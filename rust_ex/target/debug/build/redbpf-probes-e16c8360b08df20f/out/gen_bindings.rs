mod gen_bindings {
    #![allow(non_camel_case_types)]
    #![allow(non_upper_case_globals)]
    #![allow(non_snake_case)]
    #![allow(unused_unsafe)]
    #![allow(clippy::all)]
    /* automatically generated by rust-bindgen 0.59.2 */

    #[repr(C)]
    #[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct __BindgenBitfieldUnit<Storage> {
        storage: Storage,
    }
    impl<Storage> __BindgenBitfieldUnit<Storage> {
        #[inline]
        pub const fn new(storage: Storage) -> Self {
            Self { storage }
        }
    }
    impl<Storage> __BindgenBitfieldUnit<Storage>
    where
        Storage: AsRef<[u8]> + AsMut<[u8]>,
    {
        #[inline]
        pub fn get_bit(&self, index: usize) -> bool {
            debug_assert!(index / 8 < self.storage.as_ref().len());
            let byte_index = index / 8;
            let byte = self.storage.as_ref()[byte_index];
            let bit_index = if cfg!(target_endian = "big") {
                7 - (index % 8)
            } else {
                index % 8
            };
            let mask = 1 << bit_index;
            byte & mask == mask
        }
        #[inline]
        pub fn set_bit(&mut self, index: usize, val: bool) {
            debug_assert!(index / 8 < self.storage.as_ref().len());
            let byte_index = index / 8;
            let byte = &mut self.storage.as_mut()[byte_index];
            let bit_index = if cfg!(target_endian = "big") {
                7 - (index % 8)
            } else {
                index % 8
            };
            let mask = 1 << bit_index;
            if val {
                *byte |= mask;
            } else {
                *byte &= !mask;
            }
        }
        #[inline]
        pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
            debug_assert!(bit_width <= 64);
            debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
            debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
            let mut val = 0;
            for i in 0..(bit_width as usize) {
                if self.get_bit(i + bit_offset) {
                    let index = if cfg!(target_endian = "big") {
                        bit_width as usize - 1 - i
                    } else {
                        i
                    };
                    val |= 1 << index;
                }
            }
            val
        }
        #[inline]
        pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
            debug_assert!(bit_width <= 64);
            debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
            debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
            for i in 0..(bit_width as usize) {
                let mask = 1 << i;
                let val_bit_is_set = val & mask == mask;
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                self.set_bit(index + bit_offset, val_bit_is_set);
            }
        }
    }
    #[repr(C)]
    #[derive(Default)]
    pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
    impl<T> __IncompleteArrayField<T> {
        #[inline]
        pub const fn new() -> Self {
            __IncompleteArrayField(::core::marker::PhantomData, [])
        }
        #[inline]
        pub fn as_ptr(&self) -> *const T {
            self as *const _ as *const T
        }
        #[inline]
        pub fn as_mut_ptr(&mut self) -> *mut T {
            self as *mut _ as *mut T
        }
        #[inline]
        pub unsafe fn as_slice(&self, len: usize) -> &[T] {
            ::core::slice::from_raw_parts(self.as_ptr(), len)
        }
        #[inline]
        pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
            ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
        }
    }
    impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
        fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            fmt.write_str("__IncompleteArrayField")
        }
    }
    #[repr(C)]
    pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
    impl<T> __BindgenUnionField<T> {
        #[inline]
        pub const fn new() -> Self {
            __BindgenUnionField(::core::marker::PhantomData)
        }
        #[inline]
        pub unsafe fn as_ref(&self) -> &T {
            ::core::mem::transmute(self)
        }
        #[inline]
        pub unsafe fn as_mut(&mut self) -> &mut T {
            ::core::mem::transmute(self)
        }
    }
    impl<T> ::core::default::Default for __BindgenUnionField<T> {
        #[inline]
        fn default() -> Self {
            Self::new()
        }
    }
    impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
        #[inline]
        fn clone(&self) -> Self {
            Self::new()
        }
    }
    impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
    impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
        fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            fmt.write_str("__BindgenUnionField")
        }
    }
    impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
        fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
    }
    impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
        fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
            true
        }
    }
    impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
    pub const BPF_LD: u32 = 0;
    pub const BPF_LDX: u32 = 1;
    pub const BPF_ST: u32 = 2;
    pub const BPF_STX: u32 = 3;
    pub const BPF_ALU: u32 = 4;
    pub const BPF_JMP: u32 = 5;
    pub const BPF_RET: u32 = 6;
    pub const BPF_MISC: u32 = 7;
    pub const BPF_W: u32 = 0;
    pub const BPF_H: u32 = 8;
    pub const BPF_B: u32 = 16;
    pub const BPF_IMM: u32 = 0;
    pub const BPF_ABS: u32 = 32;
    pub const BPF_IND: u32 = 64;
    pub const BPF_MEM: u32 = 96;
    pub const BPF_LEN: u32 = 128;
    pub const BPF_MSH: u32 = 160;
    pub const BPF_ADD: u32 = 0;
    pub const BPF_SUB: u32 = 16;
    pub const BPF_MUL: u32 = 32;
    pub const BPF_DIV: u32 = 48;
    pub const BPF_OR: u32 = 64;
    pub const BPF_AND: u32 = 80;
    pub const BPF_LSH: u32 = 96;
    pub const BPF_RSH: u32 = 112;
    pub const BPF_NEG: u32 = 128;
    pub const BPF_MOD: u32 = 144;
    pub const BPF_XOR: u32 = 160;
    pub const BPF_JA: u32 = 0;
    pub const BPF_JEQ: u32 = 16;
    pub const BPF_JGT: u32 = 32;
    pub const BPF_JGE: u32 = 48;
    pub const BPF_JSET: u32 = 64;
    pub const BPF_K: u32 = 0;
    pub const BPF_X: u32 = 8;
    pub const BPF_MAXINSNS: u32 = 4096;
    pub const BPF_JMP32: u32 = 6;
    pub const BPF_ALU64: u32 = 7;
    pub const BPF_DW: u32 = 24;
    pub const BPF_ATOMIC: u32 = 192;
    pub const BPF_XADD: u32 = 192;
    pub const BPF_MOV: u32 = 176;
    pub const BPF_ARSH: u32 = 192;
    pub const BPF_END: u32 = 208;
    pub const BPF_TO_LE: u32 = 0;
    pub const BPF_TO_BE: u32 = 8;
    pub const BPF_FROM_LE: u32 = 0;
    pub const BPF_FROM_BE: u32 = 8;
    pub const BPF_JNE: u32 = 80;
    pub const BPF_JLT: u32 = 160;
    pub const BPF_JLE: u32 = 176;
    pub const BPF_JSGT: u32 = 96;
    pub const BPF_JSGE: u32 = 112;
    pub const BPF_JSLT: u32 = 192;
    pub const BPF_JSLE: u32 = 208;
    pub const BPF_CALL: u32 = 128;
    pub const BPF_EXIT: u32 = 144;
    pub const BPF_FETCH: u32 = 1;
    pub const BPF_XCHG: u32 = 225;
    pub const BPF_CMPXCHG: u32 = 241;
    pub const BPF_F_ALLOW_OVERRIDE: u32 = 1;
    pub const BPF_F_ALLOW_MULTI: u32 = 2;
    pub const BPF_F_REPLACE: u32 = 4;
    pub const BPF_F_STRICT_ALIGNMENT: u32 = 1;
    pub const BPF_F_ANY_ALIGNMENT: u32 = 2;
    pub const BPF_F_TEST_RND_HI32: u32 = 4;
    pub const BPF_F_TEST_STATE_FREQ: u32 = 8;
    pub const BPF_F_SLEEPABLE: u32 = 16;
    pub const BPF_F_XDP_HAS_FRAGS: u32 = 32;
    pub const BPF_F_XDP_DEV_BOUND_ONLY: u32 = 64;
    pub const BPF_F_KPROBE_MULTI_RETURN: u32 = 1;
    pub const BPF_PSEUDO_MAP_FD: u32 = 1;
    pub const BPF_PSEUDO_MAP_IDX: u32 = 5;
    pub const BPF_PSEUDO_MAP_VALUE: u32 = 2;
    pub const BPF_PSEUDO_MAP_IDX_VALUE: u32 = 6;
    pub const BPF_PSEUDO_BTF_ID: u32 = 3;
    pub const BPF_PSEUDO_FUNC: u32 = 4;
    pub const BPF_PSEUDO_CALL: u32 = 1;
    pub const BPF_PSEUDO_KFUNC_CALL: u32 = 2;
    pub const BPF_F_QUERY_EFFECTIVE: u32 = 1;
    pub const BPF_F_TEST_RUN_ON_CPU: u32 = 1;
    pub const BPF_F_TEST_XDP_LIVE_FRAMES: u32 = 2;
    pub const BPF_BUILD_ID_SIZE: u32 = 20;
    pub const BPF_OBJ_NAME_LEN: u32 = 16;
    pub const BPF_TAG_SIZE: u32 = 8;
    pub const IPPROTO_HOPOPTS: u32 = 0;
    pub const IPPROTO_ROUTING: u32 = 43;
    pub const IPPROTO_FRAGMENT: u32 = 44;
    pub const IPPROTO_ICMPV6: u32 = 58;
    pub const IPPROTO_NONE: u32 = 59;
    pub const IPPROTO_DSTOPTS: u32 = 60;
    pub const IPPROTO_MH: u32 = 135;
    pub const SOCK_IOC_TYPE: u32 = 137;
    pub const SOCK_SNDBUF_LOCK: u32 = 1;
    pub const SOCK_RCVBUF_LOCK: u32 = 2;
    pub const SOCK_BUF_LOCK_MASK: u32 = 3;
    pub const SOCK_TXREHASH_DEFAULT: u32 = 255;
    pub const SOCK_TXREHASH_DISABLED: u32 = 0;
    pub const SOCK_TXREHASH_ENABLED: u32 = 1;
    pub const AF_UNSPEC: u32 = 0;
    pub const AF_UNIX: u32 = 1;
    pub const AF_LOCAL: u32 = 1;
    pub const AF_INET: u32 = 2;
    pub const AF_AX25: u32 = 3;
    pub const AF_IPX: u32 = 4;
    pub const AF_APPLETALK: u32 = 5;
    pub const AF_NETROM: u32 = 6;
    pub const AF_BRIDGE: u32 = 7;
    pub const AF_ATMPVC: u32 = 8;
    pub const AF_X25: u32 = 9;
    pub const AF_INET6: u32 = 10;
    pub const AF_ROSE: u32 = 11;
    pub const AF_DECnet: u32 = 12;
    pub const AF_NETBEUI: u32 = 13;
    pub const AF_SECURITY: u32 = 14;
    pub const AF_KEY: u32 = 15;
    pub const AF_NETLINK: u32 = 16;
    pub const AF_ROUTE: u32 = 16;
    pub const AF_PACKET: u32 = 17;
    pub const AF_ASH: u32 = 18;
    pub const AF_ECONET: u32 = 19;
    pub const AF_ATMSVC: u32 = 20;
    pub const AF_RDS: u32 = 21;
    pub const AF_SNA: u32 = 22;
    pub const AF_IRDA: u32 = 23;
    pub const AF_PPPOX: u32 = 24;
    pub const AF_WANPIPE: u32 = 25;
    pub const AF_LLC: u32 = 26;
    pub const AF_IB: u32 = 27;
    pub const AF_MPLS: u32 = 28;
    pub const AF_CAN: u32 = 29;
    pub const AF_TIPC: u32 = 30;
    pub const AF_BLUETOOTH: u32 = 31;
    pub const AF_IUCV: u32 = 32;
    pub const AF_RXRPC: u32 = 33;
    pub const AF_ISDN: u32 = 34;
    pub const AF_PHONET: u32 = 35;
    pub const AF_IEEE802154: u32 = 36;
    pub const AF_CAIF: u32 = 37;
    pub const AF_ALG: u32 = 38;
    pub const AF_NFC: u32 = 39;
    pub const AF_VSOCK: u32 = 40;
    pub const AF_KCM: u32 = 41;
    pub const AF_QIPCRTR: u32 = 42;
    pub const AF_SMC: u32 = 43;
    pub const AF_XDP: u32 = 44;
    pub const AF_MCTP: u32 = 45;
    pub const AF_MAX: u32 = 46;
    pub const ETH_ALEN: u32 = 6;
    pub const ETH_TLEN: u32 = 2;
    pub const ETH_HLEN: u32 = 14;
    pub const ETH_ZLEN: u32 = 60;
    pub const ETH_DATA_LEN: u32 = 1500;
    pub const ETH_FRAME_LEN: u32 = 1514;
    pub const ETH_FCS_LEN: u32 = 4;
    pub const ETH_MIN_MTU: u32 = 68;
    pub const ETH_MAX_MTU: u32 = 65535;
    pub const ETH_P_LOOP: u32 = 96;
    pub const ETH_P_PUP: u32 = 512;
    pub const ETH_P_PUPAT: u32 = 513;
    pub const ETH_P_TSN: u32 = 8944;
    pub const ETH_P_ERSPAN2: u32 = 8939;
    pub const ETH_P_IP: u32 = 2048;
    pub const ETH_P_X25: u32 = 2053;
    pub const ETH_P_ARP: u32 = 2054;
    pub const ETH_P_BPQ: u32 = 2303;
    pub const ETH_P_IEEEPUP: u32 = 2560;
    pub const ETH_P_IEEEPUPAT: u32 = 2561;
    pub const ETH_P_BATMAN: u32 = 17157;
    pub const ETH_P_DEC: u32 = 24576;
    pub const ETH_P_DNA_DL: u32 = 24577;
    pub const ETH_P_DNA_RC: u32 = 24578;
    pub const ETH_P_DNA_RT: u32 = 24579;
    pub const ETH_P_LAT: u32 = 24580;
    pub const ETH_P_DIAG: u32 = 24581;
    pub const ETH_P_CUST: u32 = 24582;
    pub const ETH_P_SCA: u32 = 24583;
    pub const ETH_P_TEB: u32 = 25944;
    pub const ETH_P_RARP: u32 = 32821;
    pub const ETH_P_ATALK: u32 = 32923;
    pub const ETH_P_AARP: u32 = 33011;
    pub const ETH_P_8021Q: u32 = 33024;
    pub const ETH_P_ERSPAN: u32 = 35006;
    pub const ETH_P_IPX: u32 = 33079;
    pub const ETH_P_IPV6: u32 = 34525;
    pub const ETH_P_PAUSE: u32 = 34824;
    pub const ETH_P_SLOW: u32 = 34825;
    pub const ETH_P_WCCP: u32 = 34878;
    pub const ETH_P_MPLS_UC: u32 = 34887;
    pub const ETH_P_MPLS_MC: u32 = 34888;
    pub const ETH_P_ATMMPOA: u32 = 34892;
    pub const ETH_P_PPP_DISC: u32 = 34915;
    pub const ETH_P_PPP_SES: u32 = 34916;
    pub const ETH_P_LINK_CTL: u32 = 34924;
    pub const ETH_P_ATMFATE: u32 = 34948;
    pub const ETH_P_PAE: u32 = 34958;
    pub const ETH_P_PROFINET: u32 = 34962;
    pub const ETH_P_REALTEK: u32 = 34969;
    pub const ETH_P_AOE: u32 = 34978;
    pub const ETH_P_ETHERCAT: u32 = 34980;
    pub const ETH_P_8021AD: u32 = 34984;
    pub const ETH_P_802_EX1: u32 = 34997;
    pub const ETH_P_PREAUTH: u32 = 35015;
    pub const ETH_P_TIPC: u32 = 35018;
    pub const ETH_P_LLDP: u32 = 35020;
    pub const ETH_P_MRP: u32 = 35043;
    pub const ETH_P_MACSEC: u32 = 35045;
    pub const ETH_P_8021AH: u32 = 35047;
    pub const ETH_P_MVRP: u32 = 35061;
    pub const ETH_P_1588: u32 = 35063;
    pub const ETH_P_NCSI: u32 = 35064;
    pub const ETH_P_PRP: u32 = 35067;
    pub const ETH_P_CFM: u32 = 35074;
    pub const ETH_P_FCOE: u32 = 35078;
    pub const ETH_P_IBOE: u32 = 35093;
    pub const ETH_P_TDLS: u32 = 35085;
    pub const ETH_P_FIP: u32 = 35092;
    pub const ETH_P_80221: u32 = 35095;
    pub const ETH_P_HSR: u32 = 35119;
    pub const ETH_P_NSH: u32 = 35151;
    pub const ETH_P_LOOPBACK: u32 = 36864;
    pub const ETH_P_QINQ1: u32 = 37120;
    pub const ETH_P_QINQ2: u32 = 37376;
    pub const ETH_P_QINQ3: u32 = 37632;
    pub const ETH_P_EDSA: u32 = 56026;
    pub const ETH_P_DSA_8021Q: u32 = 56027;
    pub const ETH_P_DSA_A5PSW: u32 = 57345;
    pub const ETH_P_IFE: u32 = 60734;
    pub const ETH_P_AF_IUCV: u32 = 64507;
    pub const ETH_P_802_3_MIN: u32 = 1536;
    pub const ETH_P_802_3: u32 = 1;
    pub const ETH_P_AX25: u32 = 2;
    pub const ETH_P_ALL: u32 = 3;
    pub const ETH_P_802_2: u32 = 4;
    pub const ETH_P_SNAP: u32 = 5;
    pub const ETH_P_DDCMP: u32 = 6;
    pub const ETH_P_WAN_PPP: u32 = 7;
    pub const ETH_P_PPP_MP: u32 = 8;
    pub const ETH_P_LOCALTALK: u32 = 9;
    pub const ETH_P_CAN: u32 = 12;
    pub const ETH_P_CANFD: u32 = 13;
    pub const ETH_P_CANXL: u32 = 14;
    pub const ETH_P_PPPTALK: u32 = 16;
    pub const ETH_P_TR_802_2: u32 = 17;
    pub const ETH_P_MOBITEX: u32 = 21;
    pub const ETH_P_CONTROL: u32 = 22;
    pub const ETH_P_IRDA: u32 = 23;
    pub const ETH_P_ECONET: u32 = 24;
    pub const ETH_P_HDLC: u32 = 25;
    pub const ETH_P_ARCNET: u32 = 26;
    pub const ETH_P_DSA: u32 = 27;
    pub const ETH_P_TRAILER: u32 = 28;
    pub const ETH_P_PHONET: u32 = 245;
    pub const ETH_P_IEEE802154: u32 = 246;
    pub const ETH_P_CAIF: u32 = 247;
    pub const ETH_P_XDSA: u32 = 248;
    pub const ETH_P_MAP: u32 = 249;
    pub const ETH_P_MCTP: u32 = 250;
    pub const SOCK_NOSPACE: u32 = 2;
    pub const SOCK_PASSCRED: u32 = 3;
    pub const SOCK_PASSSEC: u32 = 4;
    pub const SOCK_SUPPORT_ZC: u32 = 5;
    pub const SOCK_CUSTOM_SOCKOPT: u32 = 6;
    pub const SOCK_PASSPIDFD: u32 = 7;
    pub const SOCK_TYPE_MASK: u32 = 15;
    pub const SOCK_CLOEXEC: u32 = 524288;
    pub const SOCK_NONBLOCK: u32 = 2048;
    pub const BPF_FS_MAGIC: u32 = 3405662737;
    pub const SOCK_DESTROY_TIME: u32 = 2500;
    pub const SOCK_BINDADDR_LOCK: u32 = 4;
    pub const SOCK_BINDPORT_LOCK: u32 = 8;
    pub type __s8 = ::cty::c_schar;
    pub type __u8 = ::cty::c_uchar;
    pub type __s16 = ::cty::c_short;
    pub type __u16 = ::cty::c_ushort;
    pub type __s32 = ::cty::c_int;
    pub type __u32 = ::cty::c_uint;
    pub type __s64 = ::cty::c_longlong;
    pub type __u64 = ::cty::c_ulonglong;
    pub type s8 = __s8;
    pub type _cargo_bpf_u8 = __u8;
    pub type s16 = __s16;
    pub type _cargo_bpf_u16 = __u16;
    pub type s32 = __s32;
    pub type _cargo_bpf_u32 = __u32;
    pub type s64 = __s64;
    pub type _cargo_bpf_u64 = __u64;
    pub type __kernel_long_t = ::cty::c_long;
    pub type __kernel_ulong_t = ::cty::c_ulong;
    pub type __kernel_pid_t = ::cty::c_int;
    pub type __kernel_uid32_t = ::cty::c_uint;
    pub type __kernel_gid32_t = ::cty::c_uint;
    pub type __kernel_size_t = __kernel_ulong_t;
    pub type __kernel_ssize_t = __kernel_long_t;
    pub type __kernel_loff_t = ::cty::c_longlong;
    pub type __kernel_time64_t = ::cty::c_longlong;
    pub type __kernel_clock_t = __kernel_long_t;
    pub type __kernel_timer_t = ::cty::c_int;
    pub type __kernel_clockid_t = ::cty::c_int;
    pub type __be16 = __u16;
    pub type __be32 = __u32;
    pub type __be64 = __u64;
    pub type __sum16 = __u16;
    pub type __wsum = __u32;
    pub type __poll_t = ::cty::c_uint;
    pub type __kernel_dev_t = _cargo_bpf_u32;
    pub type dev_t = __kernel_dev_t;
    pub type umode_t = ::cty::c_ushort;
    pub type pid_t = __kernel_pid_t;
    pub type clockid_t = __kernel_clockid_t;
    pub type bool_ = bool;
    pub type uid_t = __kernel_uid32_t;
    pub type gid_t = __kernel_gid32_t;
    pub type loff_t = __kernel_loff_t;
    pub type size_t = __kernel_size_t;
    pub type ssize_t = __kernel_ssize_t;
    #[doc = " The type used for indexing onto a disc or disc partition."]
    #[doc = ""]
    #[doc = " Linux always considers sectors to be 512 bytes long independently"]
    #[doc = " of the devices real block size."]
    #[doc = ""]
    #[doc = " blkcnt_t is the type of the inode's block count."]
    pub type sector_t = _cargo_bpf_u64;
    pub type blkcnt_t = _cargo_bpf_u64;
    pub type dma_addr_t = _cargo_bpf_u64;
    pub type gfp_t = ::cty::c_uint;
    pub type slab_flags_t = ::cty::c_uint;
    pub type fmode_t = ::cty::c_uint;
    pub type phys_addr_t = _cargo_bpf_u64;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct atomic_t {
        pub counter: ::cty::c_int,
    }
    #[test]
    fn bindgen_test_layout_atomic_t() {
        assert_eq!(
            ::core::mem::size_of::<atomic_t>(),
            4usize,
            concat!("Size of: ", stringify!(atomic_t))
        );
        assert_eq!(
            ::core::mem::align_of::<atomic_t>(),
            4usize,
            concat!("Alignment of ", stringify!(atomic_t))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<atomic_t>())).counter as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(atomic_t),
                "::",
                stringify!(counter)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct atomic64_t {
        pub counter: s64,
    }
    #[test]
    fn bindgen_test_layout_atomic64_t() {
        assert_eq!(
            ::core::mem::size_of::<atomic64_t>(),
            8usize,
            concat!("Size of: ", stringify!(atomic64_t))
        );
        assert_eq!(
            ::core::mem::align_of::<atomic64_t>(),
            8usize,
            concat!("Alignment of ", stringify!(atomic64_t))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<atomic64_t>())).counter as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(atomic64_t),
                "::",
                stringify!(counter)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct rcuref_t {
        pub refcnt: atomic_t,
    }
    #[test]
    fn bindgen_test_layout_rcuref_t() {
        assert_eq!(
            ::core::mem::size_of::<rcuref_t>(),
            4usize,
            concat!("Size of: ", stringify!(rcuref_t))
        );
        assert_eq!(
            ::core::mem::align_of::<rcuref_t>(),
            4usize,
            concat!("Alignment of ", stringify!(rcuref_t))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rcuref_t>())).refcnt as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcuref_t),
                "::",
                stringify!(refcnt)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct list_head {
        pub next: *mut list_head,
        pub prev: *mut list_head,
    }
    #[test]
    fn bindgen_test_layout_list_head() {
        assert_eq!(
            ::core::mem::size_of::<list_head>(),
            16usize,
            concat!("Size of: ", stringify!(list_head))
        );
        assert_eq!(
            ::core::mem::align_of::<list_head>(),
            8usize,
            concat!("Alignment of ", stringify!(list_head))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<list_head>())).next as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(list_head),
                "::",
                stringify!(next)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<list_head>())).prev as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(list_head),
                "::",
                stringify!(prev)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct hlist_head {
        pub first: *mut hlist_node,
    }
    #[test]
    fn bindgen_test_layout_hlist_head() {
        assert_eq!(
            ::core::mem::size_of::<hlist_head>(),
            8usize,
            concat!("Size of: ", stringify!(hlist_head))
        );
        assert_eq!(
            ::core::mem::align_of::<hlist_head>(),
            8usize,
            concat!("Alignment of ", stringify!(hlist_head))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<hlist_head>())).first as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(hlist_head),
                "::",
                stringify!(first)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct hlist_node {
        pub next: *mut hlist_node,
        pub pprev: *mut *mut hlist_node,
    }
    #[test]
    fn bindgen_test_layout_hlist_node() {
        assert_eq!(
            ::core::mem::size_of::<hlist_node>(),
            16usize,
            concat!("Size of: ", stringify!(hlist_node))
        );
        assert_eq!(
            ::core::mem::align_of::<hlist_node>(),
            8usize,
            concat!("Alignment of ", stringify!(hlist_node))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<hlist_node>())).next as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(hlist_node),
                "::",
                stringify!(next)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<hlist_node>())).pprev as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(hlist_node),
                "::",
                stringify!(pprev)
            )
        );
    }
    #[doc = " struct callback_head - callback structure for use with RCU and task_work"]
    #[doc = " @next: next update requests in a list"]
    #[doc = " @func: actual update function to call after the grace period."]
    #[doc = ""]
    #[doc = " The struct is aligned to size of pointer. On most architectures it happens"]
    #[doc = " naturally due ABI requirements, but some architectures (like CRIS) have"]
    #[doc = " weird ABI and we need to ask it explicitly."]
    #[doc = ""]
    #[doc = " The alignment is required to guarantee that bit 0 of @next will be"]
    #[doc = " clear under normal conditions -- as long as we use call_rcu() or"]
    #[doc = " call_srcu() to queue the callback."]
    #[doc = ""]
    #[doc = " This guarantee is important for few reasons:"]
    #[doc = "  - future call_rcu_lazy() will make use of lower bits in the pointer;"]
    #[doc = "  - the structure shares storage space in struct page with @compound_head,"]
    #[doc = "    which encode PageTail() in bit 0. The guarantee is needed to avoid"]
    #[doc = "    false-positive PageTail()."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct callback_head {
        pub next: *mut callback_head,
        pub func: ::core::option::Option<unsafe extern "C" fn(head: *mut callback_head)>,
    }
    #[test]
    fn bindgen_test_layout_callback_head() {
        assert_eq!(
            ::core::mem::size_of::<callback_head>(),
            16usize,
            concat!("Size of: ", stringify!(callback_head))
        );
        assert_eq!(
            ::core::mem::align_of::<callback_head>(),
            8usize,
            concat!("Alignment of ", stringify!(callback_head))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<callback_head>())).next as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(callback_head),
                "::",
                stringify!(next)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<callback_head>())).func as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(callback_head),
                "::",
                stringify!(func)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct file_system_type {
        pub name: *const ::cty::c_char,
        pub fs_flags: ::cty::c_int,
        pub init_fs_context:
            ::core::option::Option<unsafe extern "C" fn(arg1: *mut fs_context) -> ::cty::c_int>,
        pub parameters: *const fs_parameter_spec,
        pub mount: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file_system_type,
                arg2: ::cty::c_int,
                arg3: *const ::cty::c_char,
                arg4: *mut ::cty::c_void,
            ) -> *mut dentry,
        >,
        pub kill_sb: ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block)>,
        pub owner: *mut module,
        pub next: *mut file_system_type,
        pub fs_supers: hlist_head,
        pub s_lock_key: lock_class_key,
        pub s_umount_key: lock_class_key,
        pub s_vfs_rename_key: lock_class_key,
        pub s_writers_key: [lock_class_key; 3usize],
        pub i_lock_key: lock_class_key,
        pub i_mutex_key: lock_class_key,
        pub invalidate_lock_key: lock_class_key,
        pub i_mutex_dir_key: lock_class_key,
    }
    #[test]
    fn bindgen_test_layout_file_system_type() {
        assert_eq!(
            ::core::mem::size_of::<file_system_type>(),
            72usize,
            concat!("Size of: ", stringify!(file_system_type))
        );
        assert_eq!(
            ::core::mem::align_of::<file_system_type>(),
            8usize,
            concat!("Alignment of ", stringify!(file_system_type))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file_system_type>())).name as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(file_system_type),
                "::",
                stringify!(name)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file_system_type>())).fs_flags as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(file_system_type),
                "::",
                stringify!(fs_flags)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<file_system_type>())).init_fs_context as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(file_system_type),
                "::",
                stringify!(init_fs_context)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<file_system_type>())).parameters as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(file_system_type),
                "::",
                stringify!(parameters)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file_system_type>())).mount as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(file_system_type),
                "::",
                stringify!(mount)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file_system_type>())).kill_sb as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(file_system_type),
                "::",
                stringify!(kill_sb)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file_system_type>())).owner as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(file_system_type),
                "::",
                stringify!(owner)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file_system_type>())).next as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(file_system_type),
                "::",
                stringify!(next)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file_system_type>())).fs_supers as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(file_system_type),
                "::",
                stringify!(fs_supers)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<file_system_type>())).s_lock_key as *const _ as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(file_system_type),
                "::",
                stringify!(s_lock_key)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<file_system_type>())).s_umount_key as *const _ as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(file_system_type),
                "::",
                stringify!(s_umount_key)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<file_system_type>())).s_vfs_rename_key as *const _ as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(file_system_type),
                "::",
                stringify!(s_vfs_rename_key)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<file_system_type>())).s_writers_key as *const _ as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(file_system_type),
                "::",
                stringify!(s_writers_key)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<file_system_type>())).i_lock_key as *const _ as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(file_system_type),
                "::",
                stringify!(i_lock_key)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<file_system_type>())).i_mutex_key as *const _ as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(file_system_type),
                "::",
                stringify!(i_mutex_key)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<file_system_type>())).invalidate_lock_key as *const _
                    as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(file_system_type),
                "::",
                stringify!(invalidate_lock_key)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<file_system_type>())).i_mutex_dir_key as *const _ as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(file_system_type),
                "::",
                stringify!(i_mutex_dir_key)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct pt_regs {
        pub r15: ::cty::c_ulong,
        pub r14: ::cty::c_ulong,
        pub r13: ::cty::c_ulong,
        pub r12: ::cty::c_ulong,
        pub bp: ::cty::c_ulong,
        pub bx: ::cty::c_ulong,
        pub r11: ::cty::c_ulong,
        pub r10: ::cty::c_ulong,
        pub r9: ::cty::c_ulong,
        pub r8: ::cty::c_ulong,
        pub ax: ::cty::c_ulong,
        pub cx: ::cty::c_ulong,
        pub dx: ::cty::c_ulong,
        pub si: ::cty::c_ulong,
        pub di: ::cty::c_ulong,
        pub orig_ax: ::cty::c_ulong,
        pub ip: ::cty::c_ulong,
        pub cs: ::cty::c_ulong,
        pub flags: ::cty::c_ulong,
        pub sp: ::cty::c_ulong,
        pub ss: ::cty::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_pt_regs() {
        assert_eq!(
            ::core::mem::size_of::<pt_regs>(),
            168usize,
            concat!("Size of: ", stringify!(pt_regs))
        );
        assert_eq!(
            ::core::mem::align_of::<pt_regs>(),
            8usize,
            concat!("Alignment of ", stringify!(pt_regs))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pt_regs>())).r15 as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pt_regs),
                "::",
                stringify!(r15)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pt_regs>())).r14 as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(pt_regs),
                "::",
                stringify!(r14)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pt_regs>())).r13 as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(pt_regs),
                "::",
                stringify!(r13)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pt_regs>())).r12 as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(pt_regs),
                "::",
                stringify!(r12)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pt_regs>())).bp as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(pt_regs),
                "::",
                stringify!(bp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pt_regs>())).bx as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(pt_regs),
                "::",
                stringify!(bx)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pt_regs>())).r11 as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(pt_regs),
                "::",
                stringify!(r11)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pt_regs>())).r10 as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(pt_regs),
                "::",
                stringify!(r10)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pt_regs>())).r9 as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(pt_regs),
                "::",
                stringify!(r9)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pt_regs>())).r8 as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(pt_regs),
                "::",
                stringify!(r8)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pt_regs>())).ax as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(pt_regs),
                "::",
                stringify!(ax)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pt_regs>())).cx as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(pt_regs),
                "::",
                stringify!(cx)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pt_regs>())).dx as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(pt_regs),
                "::",
                stringify!(dx)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pt_regs>())).si as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(pt_regs),
                "::",
                stringify!(si)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pt_regs>())).di as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(pt_regs),
                "::",
                stringify!(di)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pt_regs>())).orig_ax as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(pt_regs),
                "::",
                stringify!(orig_ax)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pt_regs>())).ip as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(pt_regs),
                "::",
                stringify!(ip)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pt_regs>())).cs as *const _ as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(pt_regs),
                "::",
                stringify!(cs)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pt_regs>())).flags as *const _ as usize },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(pt_regs),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pt_regs>())).sp as *const _ as usize },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(pt_regs),
                "::",
                stringify!(sp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pt_regs>())).ss as *const _ as usize },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(pt_regs),
                "::",
                stringify!(ss)
            )
        );
    }
    #[repr(C, packed)]
    #[derive(Debug, Copy, Clone)]
    pub struct desc_struct {
        pub limit0: _cargo_bpf_u16,
        pub base0: _cargo_bpf_u16,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    }
    #[test]
    fn bindgen_test_layout_desc_struct() {
        assert_eq!(
            ::core::mem::size_of::<desc_struct>(),
            8usize,
            concat!("Size of: ", stringify!(desc_struct))
        );
        assert_eq!(
            ::core::mem::align_of::<desc_struct>(),
            1usize,
            concat!("Alignment of ", stringify!(desc_struct))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<desc_struct>())).limit0 as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(desc_struct),
                "::",
                stringify!(limit0)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<desc_struct>())).base0 as *const _ as usize },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(desc_struct),
                "::",
                stringify!(base0)
            )
        );
    }
    impl desc_struct {
        #[inline]
        pub fn base1(&self) -> _cargo_bpf_u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u16) }
        }
        #[inline]
        pub fn set_base1(&mut self, val: _cargo_bpf_u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 8u8, val as u64)
            }
        }
        #[inline]
        pub fn type_(&self) -> _cargo_bpf_u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u16) }
        }
        #[inline]
        pub fn set_type(&mut self, val: _cargo_bpf_u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(8usize, 4u8, val as u64)
            }
        }
        #[inline]
        pub fn s(&self) -> _cargo_bpf_u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_s(&mut self, val: _cargo_bpf_u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(12usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn dpl(&self) -> _cargo_bpf_u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 2u8) as u16) }
        }
        #[inline]
        pub fn set_dpl(&mut self, val: _cargo_bpf_u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(13usize, 2u8, val as u64)
            }
        }
        #[inline]
        pub fn p(&self) -> _cargo_bpf_u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_p(&mut self, val: _cargo_bpf_u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(15usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn limit1(&self) -> _cargo_bpf_u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u16) }
        }
        #[inline]
        pub fn set_limit1(&mut self, val: _cargo_bpf_u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(16usize, 4u8, val as u64)
            }
        }
        #[inline]
        pub fn avl(&self) -> _cargo_bpf_u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_avl(&mut self, val: _cargo_bpf_u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(20usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn l(&self) -> _cargo_bpf_u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_l(&mut self, val: _cargo_bpf_u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(21usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn d(&self) -> _cargo_bpf_u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_d(&mut self, val: _cargo_bpf_u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(22usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn g(&self) -> _cargo_bpf_u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_g(&mut self, val: _cargo_bpf_u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(23usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn base2(&self) -> _cargo_bpf_u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u16) }
        }
        #[inline]
        pub fn set_base2(&mut self, val: _cargo_bpf_u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(24usize, 8u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            base1: _cargo_bpf_u16,
            type_: _cargo_bpf_u16,
            s: _cargo_bpf_u16,
            dpl: _cargo_bpf_u16,
            p: _cargo_bpf_u16,
            limit1: _cargo_bpf_u16,
            avl: _cargo_bpf_u16,
            l: _cargo_bpf_u16,
            d: _cargo_bpf_u16,
            g: _cargo_bpf_u16,
            base2: _cargo_bpf_u16,
        ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 8u8, {
                let base1: u16 = unsafe { ::core::mem::transmute(base1) };
                base1 as u64
            });
            __bindgen_bitfield_unit.set(8usize, 4u8, {
                let type_: u16 = unsafe { ::core::mem::transmute(type_) };
                type_ as u64
            });
            __bindgen_bitfield_unit.set(12usize, 1u8, {
                let s: u16 = unsafe { ::core::mem::transmute(s) };
                s as u64
            });
            __bindgen_bitfield_unit.set(13usize, 2u8, {
                let dpl: u16 = unsafe { ::core::mem::transmute(dpl) };
                dpl as u64
            });
            __bindgen_bitfield_unit.set(15usize, 1u8, {
                let p: u16 = unsafe { ::core::mem::transmute(p) };
                p as u64
            });
            __bindgen_bitfield_unit.set(16usize, 4u8, {
                let limit1: u16 = unsafe { ::core::mem::transmute(limit1) };
                limit1 as u64
            });
            __bindgen_bitfield_unit.set(20usize, 1u8, {
                let avl: u16 = unsafe { ::core::mem::transmute(avl) };
                avl as u64
            });
            __bindgen_bitfield_unit.set(21usize, 1u8, {
                let l: u16 = unsafe { ::core::mem::transmute(l) };
                l as u64
            });
            __bindgen_bitfield_unit.set(22usize, 1u8, {
                let d: u16 = unsafe { ::core::mem::transmute(d) };
                d as u64
            });
            __bindgen_bitfield_unit.set(23usize, 1u8, {
                let g: u16 = unsafe { ::core::mem::transmute(g) };
                g as u64
            });
            __bindgen_bitfield_unit.set(24usize, 8u8, {
                let base2: u16 = unsafe { ::core::mem::transmute(base2) };
                base2 as u64
            });
            __bindgen_bitfield_unit
        }
    }
    pub type pteval_t = ::cty::c_ulong;
    pub type pmdval_t = ::cty::c_ulong;
    pub type pudval_t = ::cty::c_ulong;
    pub type pgdval_t = ::cty::c_ulong;
    pub type pgprotval_t = ::cty::c_ulong;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct pte_t {
        pub pte: pteval_t,
    }
    #[test]
    fn bindgen_test_layout_pte_t() {
        assert_eq!(
            ::core::mem::size_of::<pte_t>(),
            8usize,
            concat!("Size of: ", stringify!(pte_t))
        );
        assert_eq!(
            ::core::mem::align_of::<pte_t>(),
            8usize,
            concat!("Alignment of ", stringify!(pte_t))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pte_t>())).pte as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pte_t),
                "::",
                stringify!(pte)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct pmd_t {
        pub pmd: pmdval_t,
    }
    #[test]
    fn bindgen_test_layout_pmd_t() {
        assert_eq!(
            ::core::mem::size_of::<pmd_t>(),
            8usize,
            concat!("Size of: ", stringify!(pmd_t))
        );
        assert_eq!(
            ::core::mem::align_of::<pmd_t>(),
            8usize,
            concat!("Alignment of ", stringify!(pmd_t))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pmd_t>())).pmd as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pmd_t),
                "::",
                stringify!(pmd)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct pgprot {
        pub pgprot: pgprotval_t,
    }
    #[test]
    fn bindgen_test_layout_pgprot() {
        assert_eq!(
            ::core::mem::size_of::<pgprot>(),
            8usize,
            concat!("Size of: ", stringify!(pgprot))
        );
        assert_eq!(
            ::core::mem::align_of::<pgprot>(),
            8usize,
            concat!("Alignment of ", stringify!(pgprot))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pgprot>())).pgprot as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pgprot),
                "::",
                stringify!(pgprot)
            )
        );
    }
    pub type pgprot_t = pgprot;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct pgd_t {
        pub pgd: pgdval_t,
    }
    #[test]
    fn bindgen_test_layout_pgd_t() {
        assert_eq!(
            ::core::mem::size_of::<pgd_t>(),
            8usize,
            concat!("Size of: ", stringify!(pgd_t))
        );
        assert_eq!(
            ::core::mem::align_of::<pgd_t>(),
            8usize,
            concat!("Alignment of ", stringify!(pgd_t))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pgd_t>())).pgd as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pgd_t),
                "::",
                stringify!(pgd)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct pud_t {
        pub pud: pudval_t,
    }
    #[test]
    fn bindgen_test_layout_pud_t() {
        assert_eq!(
            ::core::mem::size_of::<pud_t>(),
            8usize,
            concat!("Size of: ", stringify!(pud_t))
        );
        assert_eq!(
            ::core::mem::align_of::<pud_t>(),
            8usize,
            concat!("Alignment of ", stringify!(pud_t))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pud_t>())).pud as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pud_t),
                "::",
                stringify!(pud)
            )
        );
    }
    pub type pgtable_t = *mut page;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct static_key {
        pub enabled: atomic_t,
        pub __bindgen_anon_1: static_key__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union static_key__bindgen_ty_1 {
        pub type_: ::cty::c_ulong,
        pub entries: *mut jump_entry,
        pub next: *mut static_key_mod,
    }
    #[test]
    fn bindgen_test_layout_static_key__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<static_key__bindgen_ty_1>(),
            8usize,
            concat!("Size of: ", stringify!(static_key__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<static_key__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(static_key__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<static_key__bindgen_ty_1>())).type_ as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(static_key__bindgen_ty_1),
                "::",
                stringify!(type_)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<static_key__bindgen_ty_1>())).entries as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(static_key__bindgen_ty_1),
                "::",
                stringify!(entries)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<static_key__bindgen_ty_1>())).next as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(static_key__bindgen_ty_1),
                "::",
                stringify!(next)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_static_key() {
        assert_eq!(
            ::core::mem::size_of::<static_key>(),
            16usize,
            concat!("Size of: ", stringify!(static_key))
        );
        assert_eq!(
            ::core::mem::align_of::<static_key>(),
            8usize,
            concat!("Alignment of ", stringify!(static_key))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<static_key>())).enabled as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(static_key),
                "::",
                stringify!(enabled)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct jump_entry {
        pub code: s32,
        pub target: s32,
        pub key: ::cty::c_long,
    }
    #[test]
    fn bindgen_test_layout_jump_entry() {
        assert_eq!(
            ::core::mem::size_of::<jump_entry>(),
            16usize,
            concat!("Size of: ", stringify!(jump_entry))
        );
        assert_eq!(
            ::core::mem::align_of::<jump_entry>(),
            8usize,
            concat!("Alignment of ", stringify!(jump_entry))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<jump_entry>())).code as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(jump_entry),
                "::",
                stringify!(code)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<jump_entry>())).target as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(jump_entry),
                "::",
                stringify!(target)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<jump_entry>())).key as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(jump_entry),
                "::",
                stringify!(key)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct static_key_true {
        pub key: static_key,
    }
    #[test]
    fn bindgen_test_layout_static_key_true() {
        assert_eq!(
            ::core::mem::size_of::<static_key_true>(),
            16usize,
            concat!("Size of: ", stringify!(static_key_true))
        );
        assert_eq!(
            ::core::mem::align_of::<static_key_true>(),
            8usize,
            concat!("Alignment of ", stringify!(static_key_true))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<static_key_true>())).key as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(static_key_true),
                "::",
                stringify!(key)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct static_key_false {
        pub key: static_key,
    }
    #[test]
    fn bindgen_test_layout_static_key_false() {
        assert_eq!(
            ::core::mem::size_of::<static_key_false>(),
            16usize,
            concat!("Size of: ", stringify!(static_key_false))
        );
        assert_eq!(
            ::core::mem::align_of::<static_key_false>(),
            8usize,
            concat!("Alignment of ", stringify!(static_key_false))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<static_key_false>())).key as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(static_key_false),
                "::",
                stringify!(key)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct qspinlock {
        pub __bindgen_anon_1: qspinlock__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union qspinlock__bindgen_ty_1 {
        pub val: atomic_t,
        pub __bindgen_anon_1: qspinlock__bindgen_ty_1__bindgen_ty_1,
        pub __bindgen_anon_2: qspinlock__bindgen_ty_1__bindgen_ty_2,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct qspinlock__bindgen_ty_1__bindgen_ty_1 {
        pub locked: _cargo_bpf_u8,
        pub pending: _cargo_bpf_u8,
    }
    #[test]
    fn bindgen_test_layout_qspinlock__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<qspinlock__bindgen_ty_1__bindgen_ty_1>(),
            2usize,
            concat!(
                "Size of: ",
                stringify!(qspinlock__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<qspinlock__bindgen_ty_1__bindgen_ty_1>(),
            1usize,
            concat!(
                "Alignment of ",
                stringify!(qspinlock__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<qspinlock__bindgen_ty_1__bindgen_ty_1>())).locked
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(qspinlock__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(locked)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<qspinlock__bindgen_ty_1__bindgen_ty_1>())).pending
                    as *const _ as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(qspinlock__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(pending)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct qspinlock__bindgen_ty_1__bindgen_ty_2 {
        pub locked_pending: _cargo_bpf_u16,
        pub tail: _cargo_bpf_u16,
    }
    #[test]
    fn bindgen_test_layout_qspinlock__bindgen_ty_1__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<qspinlock__bindgen_ty_1__bindgen_ty_2>(),
            4usize,
            concat!(
                "Size of: ",
                stringify!(qspinlock__bindgen_ty_1__bindgen_ty_2)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<qspinlock__bindgen_ty_1__bindgen_ty_2>(),
            2usize,
            concat!(
                "Alignment of ",
                stringify!(qspinlock__bindgen_ty_1__bindgen_ty_2)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<qspinlock__bindgen_ty_1__bindgen_ty_2>())).locked_pending
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(qspinlock__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(locked_pending)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<qspinlock__bindgen_ty_1__bindgen_ty_2>())).tail as *const _
                    as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(qspinlock__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(tail)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_qspinlock__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<qspinlock__bindgen_ty_1>(),
            4usize,
            concat!("Size of: ", stringify!(qspinlock__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<qspinlock__bindgen_ty_1>(),
            4usize,
            concat!("Alignment of ", stringify!(qspinlock__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<qspinlock__bindgen_ty_1>())).val as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(qspinlock__bindgen_ty_1),
                "::",
                stringify!(val)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_qspinlock() {
        assert_eq!(
            ::core::mem::size_of::<qspinlock>(),
            4usize,
            concat!("Size of: ", stringify!(qspinlock))
        );
        assert_eq!(
            ::core::mem::align_of::<qspinlock>(),
            4usize,
            concat!("Alignment of ", stringify!(qspinlock))
        );
    }
    pub type arch_spinlock_t = qspinlock;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct qrwlock {
        pub __bindgen_anon_1: qrwlock__bindgen_ty_1,
        pub wait_lock: arch_spinlock_t,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union qrwlock__bindgen_ty_1 {
        pub cnts: atomic_t,
        pub __bindgen_anon_1: qrwlock__bindgen_ty_1__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct qrwlock__bindgen_ty_1__bindgen_ty_1 {
        pub wlocked: _cargo_bpf_u8,
        pub __lstate: [_cargo_bpf_u8; 3usize],
    }
    #[test]
    fn bindgen_test_layout_qrwlock__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<qrwlock__bindgen_ty_1__bindgen_ty_1>(),
            4usize,
            concat!("Size of: ", stringify!(qrwlock__bindgen_ty_1__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<qrwlock__bindgen_ty_1__bindgen_ty_1>(),
            1usize,
            concat!(
                "Alignment of ",
                stringify!(qrwlock__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<qrwlock__bindgen_ty_1__bindgen_ty_1>())).wlocked as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(qrwlock__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(wlocked)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<qrwlock__bindgen_ty_1__bindgen_ty_1>())).__lstate
                    as *const _ as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(qrwlock__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(__lstate)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_qrwlock__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<qrwlock__bindgen_ty_1>(),
            4usize,
            concat!("Size of: ", stringify!(qrwlock__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<qrwlock__bindgen_ty_1>(),
            4usize,
            concat!("Alignment of ", stringify!(qrwlock__bindgen_ty_1))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<qrwlock__bindgen_ty_1>())).cnts as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(qrwlock__bindgen_ty_1),
                "::",
                stringify!(cnts)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_qrwlock() {
        assert_eq!(
            ::core::mem::size_of::<qrwlock>(),
            8usize,
            concat!("Size of: ", stringify!(qrwlock))
        );
        assert_eq!(
            ::core::mem::align_of::<qrwlock>(),
            4usize,
            concat!("Alignment of ", stringify!(qrwlock))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<qrwlock>())).wait_lock as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(qrwlock),
                "::",
                stringify!(wait_lock)
            )
        );
    }
    pub type arch_rwlock_t = qrwlock;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct lock_class_key {}
    #[test]
    fn bindgen_test_layout_lock_class_key() {
        assert_eq!(
            ::core::mem::size_of::<lock_class_key>(),
            0usize,
            concat!("Size of: ", stringify!(lock_class_key))
        );
        assert_eq!(
            ::core::mem::align_of::<lock_class_key>(),
            1usize,
            concat!("Alignment of ", stringify!(lock_class_key))
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct lockdep_map {}
    #[test]
    fn bindgen_test_layout_lockdep_map() {
        assert_eq!(
            ::core::mem::size_of::<lockdep_map>(),
            0usize,
            concat!("Size of: ", stringify!(lockdep_map))
        );
        assert_eq!(
            ::core::mem::align_of::<lockdep_map>(),
            1usize,
            concat!("Alignment of ", stringify!(lockdep_map))
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct raw_spinlock {
        pub raw_lock: arch_spinlock_t,
    }
    #[test]
    fn bindgen_test_layout_raw_spinlock() {
        assert_eq!(
            ::core::mem::size_of::<raw_spinlock>(),
            4usize,
            concat!("Size of: ", stringify!(raw_spinlock))
        );
        assert_eq!(
            ::core::mem::align_of::<raw_spinlock>(),
            4usize,
            concat!("Alignment of ", stringify!(raw_spinlock))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<raw_spinlock>())).raw_lock as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(raw_spinlock),
                "::",
                stringify!(raw_lock)
            )
        );
    }
    pub type raw_spinlock_t = raw_spinlock;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct ratelimit_state {
        pub lock: raw_spinlock_t,
        pub interval: ::cty::c_int,
        pub burst: ::cty::c_int,
        pub printed: ::cty::c_int,
        pub missed: ::cty::c_int,
        pub begin: ::cty::c_ulong,
        pub flags: ::cty::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_ratelimit_state() {
        assert_eq!(
            ::core::mem::size_of::<ratelimit_state>(),
            40usize,
            concat!("Size of: ", stringify!(ratelimit_state))
        );
        assert_eq!(
            ::core::mem::align_of::<ratelimit_state>(),
            8usize,
            concat!("Alignment of ", stringify!(ratelimit_state))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ratelimit_state>())).lock as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ratelimit_state),
                "::",
                stringify!(lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ratelimit_state>())).interval as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(ratelimit_state),
                "::",
                stringify!(interval)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ratelimit_state>())).burst as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ratelimit_state),
                "::",
                stringify!(burst)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ratelimit_state>())).printed as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(ratelimit_state),
                "::",
                stringify!(printed)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ratelimit_state>())).missed as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ratelimit_state),
                "::",
                stringify!(missed)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ratelimit_state>())).begin as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(ratelimit_state),
                "::",
                stringify!(begin)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ratelimit_state>())).flags as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(ratelimit_state),
                "::",
                stringify!(flags)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct _ddebug {
        pub modname: *const ::cty::c_char,
        pub function: *const ::cty::c_char,
        pub filename: *const ::cty::c_char,
        pub format: *const ::cty::c_char,
        pub _bitfield_align_1: [u32; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
        pub key: _ddebug__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union _ddebug__bindgen_ty_1 {
        pub dd_key_true: static_key_true,
        pub dd_key_false: static_key_false,
    }
    #[test]
    fn bindgen_test_layout__ddebug__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<_ddebug__bindgen_ty_1>(),
            16usize,
            concat!("Size of: ", stringify!(_ddebug__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<_ddebug__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(_ddebug__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<_ddebug__bindgen_ty_1>())).dd_key_true as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_ddebug__bindgen_ty_1),
                "::",
                stringify!(dd_key_true)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<_ddebug__bindgen_ty_1>())).dd_key_false as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_ddebug__bindgen_ty_1),
                "::",
                stringify!(dd_key_false)
            )
        );
    }
    #[test]
    fn bindgen_test_layout__ddebug() {
        assert_eq!(
            ::core::mem::size_of::<_ddebug>(),
            56usize,
            concat!("Size of: ", stringify!(_ddebug))
        );
        assert_eq!(
            ::core::mem::align_of::<_ddebug>(),
            8usize,
            concat!("Alignment of ", stringify!(_ddebug))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<_ddebug>())).modname as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_ddebug),
                "::",
                stringify!(modname)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<_ddebug>())).function as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_ddebug),
                "::",
                stringify!(function)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<_ddebug>())).filename as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_ddebug),
                "::",
                stringify!(filename)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<_ddebug>())).format as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_ddebug),
                "::",
                stringify!(format)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<_ddebug>())).key as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_ddebug),
                "::",
                stringify!(key)
            )
        );
    }
    impl _ddebug {
        #[inline]
        pub fn lineno(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 18u8) as u32) }
        }
        #[inline]
        pub fn set_lineno(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 18u8, val as u64)
            }
        }
        #[inline]
        pub fn class_id(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 6u8) as u32) }
        }
        #[inline]
        pub fn set_class_id(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(18usize, 6u8, val as u64)
            }
        }
        #[inline]
        pub fn flags(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
        }
        #[inline]
        pub fn set_flags(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(24usize, 8u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            lineno: ::cty::c_uint,
            class_id: ::cty::c_uint,
            flags: ::cty::c_uint,
        ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 18u8, {
                let lineno: u32 = unsafe { ::core::mem::transmute(lineno) };
                lineno as u64
            });
            __bindgen_bitfield_unit.set(18usize, 6u8, {
                let class_id: u32 = unsafe { ::core::mem::transmute(class_id) };
                class_id as u64
            });
            __bindgen_bitfield_unit.set(24usize, 8u8, {
                let flags: u32 = unsafe { ::core::mem::transmute(flags) };
                flags as u64
            });
            __bindgen_bitfield_unit
        }
    }
    pub const class_map_type_DD_CLASS_TYPE_DISJOINT_BITS: class_map_type = 0;
    #[doc = " DD_CLASS_TYPE_DISJOINT_BITS: classes are independent, one per bit."]
    #[doc = " expecting hex input. Built for drm.debug, basis for other types."]
    pub const class_map_type_DD_CLASS_TYPE_LEVEL_NUM: class_map_type = 1;
    #[doc = " DD_CLASS_TYPE_LEVEL_NUM: input is numeric level, 0-N."]
    #[doc = " N turns on just bits N-1 .. 0, so N=0 turns all bits off."]
    pub const class_map_type_DD_CLASS_TYPE_DISJOINT_NAMES: class_map_type = 2;
    #[doc = " DD_CLASS_TYPE_DISJOINT_NAMES: input is a CSV of [+-]CLASS_NAMES,"]
    #[doc = " classes are independent, like _DISJOINT_BITS."]
    pub const class_map_type_DD_CLASS_TYPE_LEVEL_NAMES: class_map_type = 3;
    pub type class_map_type = ::cty::c_uint;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ddebug_class_map {
        pub link: list_head,
        pub mod_: *mut module,
        pub mod_name: *const ::cty::c_char,
        pub class_names: *mut *const ::cty::c_char,
        pub length: ::cty::c_int,
        pub base: ::cty::c_int,
        pub map_type: class_map_type,
    }
    #[test]
    fn bindgen_test_layout_ddebug_class_map() {
        assert_eq!(
            ::core::mem::size_of::<ddebug_class_map>(),
            56usize,
            concat!("Size of: ", stringify!(ddebug_class_map))
        );
        assert_eq!(
            ::core::mem::align_of::<ddebug_class_map>(),
            8usize,
            concat!("Alignment of ", stringify!(ddebug_class_map))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ddebug_class_map>())).link as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ddebug_class_map),
                "::",
                stringify!(link)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ddebug_class_map>())).mod_ as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ddebug_class_map),
                "::",
                stringify!(mod_)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ddebug_class_map>())).mod_name as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(ddebug_class_map),
                "::",
                stringify!(mod_name)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ddebug_class_map>())).class_names as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(ddebug_class_map),
                "::",
                stringify!(class_names)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ddebug_class_map>())).length as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(ddebug_class_map),
                "::",
                stringify!(length)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ddebug_class_map>())).base as *const _ as usize },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(ddebug_class_map),
                "::",
                stringify!(base)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ddebug_class_map>())).map_type as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(ddebug_class_map),
                "::",
                stringify!(map_type)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _ddebug_info {
        pub descs: *mut _ddebug,
        pub classes: *mut ddebug_class_map,
        pub num_descs: ::cty::c_uint,
        pub num_classes: ::cty::c_uint,
    }
    #[test]
    fn bindgen_test_layout__ddebug_info() {
        assert_eq!(
            ::core::mem::size_of::<_ddebug_info>(),
            24usize,
            concat!("Size of: ", stringify!(_ddebug_info))
        );
        assert_eq!(
            ::core::mem::align_of::<_ddebug_info>(),
            8usize,
            concat!("Alignment of ", stringify!(_ddebug_info))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<_ddebug_info>())).descs as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_ddebug_info),
                "::",
                stringify!(descs)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<_ddebug_info>())).classes as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_ddebug_info),
                "::",
                stringify!(classes)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<_ddebug_info>())).num_descs as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_ddebug_info),
                "::",
                stringify!(num_descs)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<_ddebug_info>())).num_classes as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(_ddebug_info),
                "::",
                stringify!(num_classes)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct kernel_param_ops {
        pub flags: ::cty::c_uint,
        pub set: ::core::option::Option<
            unsafe extern "C" fn(
                val: *const ::cty::c_char,
                kp: *const kernel_param,
            ) -> ::cty::c_int,
        >,
        pub get: ::core::option::Option<
            unsafe extern "C" fn(
                buffer: *mut ::cty::c_char,
                kp: *const kernel_param,
            ) -> ::cty::c_int,
        >,
        pub free: ::core::option::Option<unsafe extern "C" fn(arg: *mut ::cty::c_void)>,
    }
    #[test]
    fn bindgen_test_layout_kernel_param_ops() {
        assert_eq!(
            ::core::mem::size_of::<kernel_param_ops>(),
            32usize,
            concat!("Size of: ", stringify!(kernel_param_ops))
        );
        assert_eq!(
            ::core::mem::align_of::<kernel_param_ops>(),
            8usize,
            concat!("Alignment of ", stringify!(kernel_param_ops))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kernel_param_ops>())).flags as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(kernel_param_ops),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kernel_param_ops>())).set as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(kernel_param_ops),
                "::",
                stringify!(set)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kernel_param_ops>())).get as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(kernel_param_ops),
                "::",
                stringify!(get)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kernel_param_ops>())).free as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(kernel_param_ops),
                "::",
                stringify!(free)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct file_operations {
        pub owner: *mut module,
        pub llseek: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut file, arg2: loff_t, arg3: ::cty::c_int) -> loff_t,
        >,
        pub read: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                arg2: *mut ::cty::c_char,
                arg3: size_t,
                arg4: *mut loff_t,
            ) -> ssize_t,
        >,
        pub write: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                arg2: *const ::cty::c_char,
                arg3: size_t,
                arg4: *mut loff_t,
            ) -> ssize_t,
        >,
        pub read_iter: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut kiocb, arg2: *mut iov_iter) -> ssize_t,
        >,
        pub write_iter: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut kiocb, arg2: *mut iov_iter) -> ssize_t,
        >,
        pub iopoll: ::core::option::Option<
            unsafe extern "C" fn(
                kiocb: *mut kiocb,
                arg1: *mut io_comp_batch,
                flags: ::cty::c_uint,
            ) -> ::cty::c_int,
        >,
        pub iterate_shared: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut file, arg2: *mut dir_context) -> ::cty::c_int,
        >,
        pub poll: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut file, arg2: *mut poll_table_struct) -> __poll_t,
        >,
        pub unlocked_ioctl: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                arg2: ::cty::c_uint,
                arg3: ::cty::c_ulong,
            ) -> ::cty::c_long,
        >,
        pub compat_ioctl: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                arg2: ::cty::c_uint,
                arg3: ::cty::c_ulong,
            ) -> ::cty::c_long,
        >,
        pub mmap: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut file, arg2: *mut vm_area_struct) -> ::cty::c_int,
        >,
        pub mmap_supported_flags: ::cty::c_ulong,
        pub open: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut inode, arg2: *mut file) -> ::cty::c_int,
        >,
        pub flush: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut file, id: fl_owner_t) -> ::cty::c_int,
        >,
        pub release: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut inode, arg2: *mut file) -> ::cty::c_int,
        >,
        pub fsync: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                arg2: loff_t,
                arg3: loff_t,
                datasync: ::cty::c_int,
            ) -> ::cty::c_int,
        >,
        pub fasync: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: ::cty::c_int,
                arg2: *mut file,
                arg3: ::cty::c_int,
            ) -> ::cty::c_int,
        >,
        pub lock: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                arg2: ::cty::c_int,
                arg3: *mut file_lock,
            ) -> ::cty::c_int,
        >,
        pub get_unmapped_area: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                arg2: ::cty::c_ulong,
                arg3: ::cty::c_ulong,
                arg4: ::cty::c_ulong,
                arg5: ::cty::c_ulong,
            ) -> ::cty::c_ulong,
        >,
        pub check_flags:
            ::core::option::Option<unsafe extern "C" fn(arg1: ::cty::c_int) -> ::cty::c_int>,
        pub flock: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                arg2: ::cty::c_int,
                arg3: *mut file_lock,
            ) -> ::cty::c_int,
        >,
        pub splice_write: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut pipe_inode_info,
                arg2: *mut file,
                arg3: *mut loff_t,
                arg4: size_t,
                arg5: ::cty::c_uint,
            ) -> ssize_t,
        >,
        pub splice_read: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                arg2: *mut loff_t,
                arg3: *mut pipe_inode_info,
                arg4: size_t,
                arg5: ::cty::c_uint,
            ) -> ssize_t,
        >,
        pub splice_eof: ::core::option::Option<unsafe extern "C" fn(file: *mut file)>,
        pub setlease: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                arg2: ::cty::c_long,
                arg3: *mut *mut file_lock,
                arg4: *mut *mut ::cty::c_void,
            ) -> ::cty::c_int,
        >,
        pub fallocate: ::core::option::Option<
            unsafe extern "C" fn(
                file: *mut file,
                mode: ::cty::c_int,
                offset: loff_t,
                len: loff_t,
            ) -> ::cty::c_long,
        >,
        pub show_fdinfo:
            ::core::option::Option<unsafe extern "C" fn(m: *mut seq_file, f: *mut file)>,
        pub copy_file_range: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                arg2: loff_t,
                arg3: *mut file,
                arg4: loff_t,
                arg5: size_t,
                arg6: ::cty::c_uint,
            ) -> ssize_t,
        >,
        pub remap_file_range: ::core::option::Option<
            unsafe extern "C" fn(
                file_in: *mut file,
                pos_in: loff_t,
                file_out: *mut file,
                pos_out: loff_t,
                len: loff_t,
                remap_flags: ::cty::c_uint,
            ) -> loff_t,
        >,
        pub fadvise: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                arg2: loff_t,
                arg3: loff_t,
                arg4: ::cty::c_int,
            ) -> ::cty::c_int,
        >,
        pub uring_cmd: ::core::option::Option<
            unsafe extern "C" fn(
                ioucmd: *mut io_uring_cmd,
                issue_flags: ::cty::c_uint,
            ) -> ::cty::c_int,
        >,
        pub uring_cmd_iopoll: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut io_uring_cmd,
                arg2: *mut io_comp_batch,
                poll_flags: ::cty::c_uint,
            ) -> ::cty::c_int,
        >,
    }
    #[test]
    fn bindgen_test_layout_file_operations() {
        assert_eq!(
            ::core::mem::size_of::<file_operations>(),
            264usize,
            concat!("Size of: ", stringify!(file_operations))
        );
        assert_eq!(
            ::core::mem::align_of::<file_operations>(),
            8usize,
            concat!("Alignment of ", stringify!(file_operations))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file_operations>())).owner as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(file_operations),
                "::",
                stringify!(owner)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file_operations>())).llseek as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(file_operations),
                "::",
                stringify!(llseek)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file_operations>())).read as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(file_operations),
                "::",
                stringify!(read)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file_operations>())).write as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(file_operations),
                "::",
                stringify!(write)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file_operations>())).read_iter as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(file_operations),
                "::",
                stringify!(read_iter)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file_operations>())).write_iter as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(file_operations),
                "::",
                stringify!(write_iter)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file_operations>())).iopoll as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(file_operations),
                "::",
                stringify!(iopoll)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<file_operations>())).iterate_shared as *const _ as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(file_operations),
                "::",
                stringify!(iterate_shared)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file_operations>())).poll as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(file_operations),
                "::",
                stringify!(poll)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<file_operations>())).unlocked_ioctl as *const _ as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(file_operations),
                "::",
                stringify!(unlocked_ioctl)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<file_operations>())).compat_ioctl as *const _ as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(file_operations),
                "::",
                stringify!(compat_ioctl)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file_operations>())).mmap as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(file_operations),
                "::",
                stringify!(mmap)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<file_operations>())).mmap_supported_flags as *const _
                    as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(file_operations),
                "::",
                stringify!(mmap_supported_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file_operations>())).open as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(file_operations),
                "::",
                stringify!(open)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file_operations>())).flush as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(file_operations),
                "::",
                stringify!(flush)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file_operations>())).release as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(file_operations),
                "::",
                stringify!(release)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file_operations>())).fsync as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(file_operations),
                "::",
                stringify!(fsync)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file_operations>())).fasync as *const _ as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(file_operations),
                "::",
                stringify!(fasync)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file_operations>())).lock as *const _ as usize },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(file_operations),
                "::",
                stringify!(lock)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<file_operations>())).get_unmapped_area as *const _ as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(file_operations),
                "::",
                stringify!(get_unmapped_area)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<file_operations>())).check_flags as *const _ as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(file_operations),
                "::",
                stringify!(check_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file_operations>())).flock as *const _ as usize },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(file_operations),
                "::",
                stringify!(flock)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<file_operations>())).splice_write as *const _ as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(file_operations),
                "::",
                stringify!(splice_write)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<file_operations>())).splice_read as *const _ as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(file_operations),
                "::",
                stringify!(splice_read)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file_operations>())).splice_eof as *const _ as usize },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(file_operations),
                "::",
                stringify!(splice_eof)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file_operations>())).setlease as *const _ as usize },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(file_operations),
                "::",
                stringify!(setlease)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file_operations>())).fallocate as *const _ as usize },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(file_operations),
                "::",
                stringify!(fallocate)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<file_operations>())).show_fdinfo as *const _ as usize
            },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(file_operations),
                "::",
                stringify!(show_fdinfo)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<file_operations>())).copy_file_range as *const _ as usize
            },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(file_operations),
                "::",
                stringify!(copy_file_range)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<file_operations>())).remap_file_range as *const _ as usize
            },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(file_operations),
                "::",
                stringify!(remap_file_range)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file_operations>())).fadvise as *const _ as usize },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(file_operations),
                "::",
                stringify!(fadvise)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file_operations>())).uring_cmd as *const _ as usize },
            248usize,
            concat!(
                "Offset of field: ",
                stringify!(file_operations),
                "::",
                stringify!(uring_cmd)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<file_operations>())).uring_cmd_iopoll as *const _ as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(file_operations),
                "::",
                stringify!(uring_cmd_iopoll)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct static_call_site {
        pub addr: s32,
        pub key: s32,
    }
    #[test]
    fn bindgen_test_layout_static_call_site() {
        assert_eq!(
            ::core::mem::size_of::<static_call_site>(),
            8usize,
            concat!("Size of: ", stringify!(static_call_site))
        );
        assert_eq!(
            ::core::mem::align_of::<static_call_site>(),
            4usize,
            concat!("Alignment of ", stringify!(static_call_site))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<static_call_site>())).addr as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(static_call_site),
                "::",
                stringify!(addr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<static_call_site>())).key as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(static_call_site),
                "::",
                stringify!(key)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct static_call_key {
        pub func: *mut ::cty::c_void,
        pub __bindgen_anon_1: static_call_key__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union static_call_key__bindgen_ty_1 {
        pub type_: ::cty::c_ulong,
        pub mods: *mut static_call_mod,
        pub sites: *mut static_call_site,
    }
    #[test]
    fn bindgen_test_layout_static_call_key__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<static_call_key__bindgen_ty_1>(),
            8usize,
            concat!("Size of: ", stringify!(static_call_key__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<static_call_key__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(static_call_key__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<static_call_key__bindgen_ty_1>())).type_ as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(static_call_key__bindgen_ty_1),
                "::",
                stringify!(type_)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<static_call_key__bindgen_ty_1>())).mods as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(static_call_key__bindgen_ty_1),
                "::",
                stringify!(mods)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<static_call_key__bindgen_ty_1>())).sites as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(static_call_key__bindgen_ty_1),
                "::",
                stringify!(sites)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_static_call_key() {
        assert_eq!(
            ::core::mem::size_of::<static_call_key>(),
            16usize,
            concat!("Size of: ", stringify!(static_call_key))
        );
        assert_eq!(
            ::core::mem::align_of::<static_call_key>(),
            8usize,
            concat!("Alignment of ", stringify!(static_call_key))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<static_call_key>())).func as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(static_call_key),
                "::",
                stringify!(func)
            )
        );
    }
    #[repr(C)]
    #[repr(align(64))]
    #[derive(Debug)]
    pub struct cacheline_padding {
        pub x: __IncompleteArrayField<::cty::c_char>,
    }
    #[test]
    fn bindgen_test_layout_cacheline_padding() {
        assert_eq!(
            ::core::mem::size_of::<cacheline_padding>(),
            0usize,
            concat!("Size of: ", stringify!(cacheline_padding))
        );
        assert_eq!(
            ::core::mem::align_of::<cacheline_padding>(),
            64usize,
            concat!("Alignment of ", stringify!(cacheline_padding))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cacheline_padding>())).x as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cacheline_padding),
                "::",
                stringify!(x)
            )
        );
    }
    pub const BPF_REG_0: ::cty::c_uint = 0;
    pub const BPF_REG_1: ::cty::c_uint = 1;
    pub const BPF_REG_2: ::cty::c_uint = 2;
    pub const BPF_REG_3: ::cty::c_uint = 3;
    pub const BPF_REG_4: ::cty::c_uint = 4;
    pub const BPF_REG_5: ::cty::c_uint = 5;
    pub const BPF_REG_6: ::cty::c_uint = 6;
    pub const BPF_REG_7: ::cty::c_uint = 7;
    pub const BPF_REG_8: ::cty::c_uint = 8;
    pub const BPF_REG_9: ::cty::c_uint = 9;
    pub const BPF_REG_10: ::cty::c_uint = 10;
    pub const __MAX_BPF_REG: ::cty::c_uint = 11;
    pub type _bindgen_ty_5 = ::cty::c_uint;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_insn {
        pub code: __u8,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
        pub off: __s16,
        pub imm: __s32,
    }
    #[test]
    fn bindgen_test_layout_bpf_insn() {
        assert_eq!(
            ::core::mem::size_of::<bpf_insn>(),
            8usize,
            concat!("Size of: ", stringify!(bpf_insn))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_insn>(),
            4usize,
            concat!("Alignment of ", stringify!(bpf_insn))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_insn>())).code as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_insn),
                "::",
                stringify!(code)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_insn>())).off as *const _ as usize },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_insn),
                "::",
                stringify!(off)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_insn>())).imm as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_insn),
                "::",
                stringify!(imm)
            )
        );
    }
    impl bpf_insn {
        #[inline]
        pub fn dst_reg(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
        }
        #[inline]
        pub fn set_dst_reg(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 4u8, val as u64)
            }
        }
        #[inline]
        pub fn src_reg(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
        }
        #[inline]
        pub fn set_src_reg(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(4usize, 4u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(dst_reg: __u8, src_reg: __u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 4u8, {
                let dst_reg: u8 = unsafe { ::core::mem::transmute(dst_reg) };
                dst_reg as u64
            });
            __bindgen_bitfield_unit.set(4usize, 4u8, {
                let src_reg: u8 = unsafe { ::core::mem::transmute(src_reg) };
                src_reg as u64
            });
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct bpf_lpm_trie_key {
        pub prefixlen: __u32,
        pub data: __IncompleteArrayField<__u8>,
    }
    #[test]
    fn bindgen_test_layout_bpf_lpm_trie_key() {
        assert_eq!(
            ::core::mem::size_of::<bpf_lpm_trie_key>(),
            4usize,
            concat!("Size of: ", stringify!(bpf_lpm_trie_key))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_lpm_trie_key>(),
            4usize,
            concat!("Alignment of ", stringify!(bpf_lpm_trie_key))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_lpm_trie_key>())).prefixlen as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_lpm_trie_key),
                "::",
                stringify!(prefixlen)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_lpm_trie_key>())).data as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_lpm_trie_key),
                "::",
                stringify!(data)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_cgroup_storage_key {
        pub cgroup_inode_id: __u64,
        pub attach_type: __u32,
    }
    #[test]
    fn bindgen_test_layout_bpf_cgroup_storage_key() {
        assert_eq!(
            ::core::mem::size_of::<bpf_cgroup_storage_key>(),
            16usize,
            concat!("Size of: ", stringify!(bpf_cgroup_storage_key))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_cgroup_storage_key>(),
            8usize,
            concat!("Alignment of ", stringify!(bpf_cgroup_storage_key))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_cgroup_storage_key>())).cgroup_inode_id as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_cgroup_storage_key),
                "::",
                stringify!(cgroup_inode_id)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_cgroup_storage_key>())).attach_type as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_cgroup_storage_key),
                "::",
                stringify!(attach_type)
            )
        );
    }
    pub const bpf_cgroup_iter_order_BPF_CGROUP_ITER_ORDER_UNSPEC: bpf_cgroup_iter_order = 0;
    pub const bpf_cgroup_iter_order_BPF_CGROUP_ITER_SELF_ONLY: bpf_cgroup_iter_order = 1;
    pub const bpf_cgroup_iter_order_BPF_CGROUP_ITER_DESCENDANTS_PRE: bpf_cgroup_iter_order = 2;
    pub const bpf_cgroup_iter_order_BPF_CGROUP_ITER_DESCENDANTS_POST: bpf_cgroup_iter_order = 3;
    pub const bpf_cgroup_iter_order_BPF_CGROUP_ITER_ANCESTORS_UP: bpf_cgroup_iter_order = 4;
    pub type bpf_cgroup_iter_order = ::cty::c_uint;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union bpf_iter_link_info {
        pub map: bpf_iter_link_info__bindgen_ty_1,
        pub cgroup: bpf_iter_link_info__bindgen_ty_2,
        pub task: bpf_iter_link_info__bindgen_ty_3,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_iter_link_info__bindgen_ty_1 {
        pub map_fd: __u32,
    }
    #[test]
    fn bindgen_test_layout_bpf_iter_link_info__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<bpf_iter_link_info__bindgen_ty_1>(),
            4usize,
            concat!("Size of: ", stringify!(bpf_iter_link_info__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_iter_link_info__bindgen_ty_1>(),
            4usize,
            concat!(
                "Alignment of ",
                stringify!(bpf_iter_link_info__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_iter_link_info__bindgen_ty_1>())).map_fd as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_iter_link_info__bindgen_ty_1),
                "::",
                stringify!(map_fd)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_iter_link_info__bindgen_ty_2 {
        pub order: bpf_cgroup_iter_order,
        pub cgroup_fd: __u32,
        pub cgroup_id: __u64,
    }
    #[test]
    fn bindgen_test_layout_bpf_iter_link_info__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<bpf_iter_link_info__bindgen_ty_2>(),
            16usize,
            concat!("Size of: ", stringify!(bpf_iter_link_info__bindgen_ty_2))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_iter_link_info__bindgen_ty_2>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(bpf_iter_link_info__bindgen_ty_2)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_iter_link_info__bindgen_ty_2>())).order as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_iter_link_info__bindgen_ty_2),
                "::",
                stringify!(order)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_iter_link_info__bindgen_ty_2>())).cgroup_fd as *const _
                    as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_iter_link_info__bindgen_ty_2),
                "::",
                stringify!(cgroup_fd)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_iter_link_info__bindgen_ty_2>())).cgroup_id as *const _
                    as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_iter_link_info__bindgen_ty_2),
                "::",
                stringify!(cgroup_id)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_iter_link_info__bindgen_ty_3 {
        pub tid: __u32,
        pub pid: __u32,
        pub pid_fd: __u32,
    }
    #[test]
    fn bindgen_test_layout_bpf_iter_link_info__bindgen_ty_3() {
        assert_eq!(
            ::core::mem::size_of::<bpf_iter_link_info__bindgen_ty_3>(),
            12usize,
            concat!("Size of: ", stringify!(bpf_iter_link_info__bindgen_ty_3))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_iter_link_info__bindgen_ty_3>(),
            4usize,
            concat!(
                "Alignment of ",
                stringify!(bpf_iter_link_info__bindgen_ty_3)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_iter_link_info__bindgen_ty_3>())).tid as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_iter_link_info__bindgen_ty_3),
                "::",
                stringify!(tid)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_iter_link_info__bindgen_ty_3>())).pid as *const _
                    as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_iter_link_info__bindgen_ty_3),
                "::",
                stringify!(pid)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_iter_link_info__bindgen_ty_3>())).pid_fd as *const _
                    as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_iter_link_info__bindgen_ty_3),
                "::",
                stringify!(pid_fd)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_bpf_iter_link_info() {
        assert_eq!(
            ::core::mem::size_of::<bpf_iter_link_info>(),
            16usize,
            concat!("Size of: ", stringify!(bpf_iter_link_info))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_iter_link_info>(),
            8usize,
            concat!("Alignment of ", stringify!(bpf_iter_link_info))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_iter_link_info>())).map as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_iter_link_info),
                "::",
                stringify!(map)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_iter_link_info>())).cgroup as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_iter_link_info),
                "::",
                stringify!(cgroup)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_iter_link_info>())).task as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_iter_link_info),
                "::",
                stringify!(task)
            )
        );
    }
    pub const bpf_cmd_BPF_MAP_CREATE: bpf_cmd = 0;
    pub const bpf_cmd_BPF_MAP_LOOKUP_ELEM: bpf_cmd = 1;
    pub const bpf_cmd_BPF_MAP_UPDATE_ELEM: bpf_cmd = 2;
    pub const bpf_cmd_BPF_MAP_DELETE_ELEM: bpf_cmd = 3;
    pub const bpf_cmd_BPF_MAP_GET_NEXT_KEY: bpf_cmd = 4;
    pub const bpf_cmd_BPF_PROG_LOAD: bpf_cmd = 5;
    pub const bpf_cmd_BPF_OBJ_PIN: bpf_cmd = 6;
    pub const bpf_cmd_BPF_OBJ_GET: bpf_cmd = 7;
    pub const bpf_cmd_BPF_PROG_ATTACH: bpf_cmd = 8;
    pub const bpf_cmd_BPF_PROG_DETACH: bpf_cmd = 9;
    pub const bpf_cmd_BPF_PROG_TEST_RUN: bpf_cmd = 10;
    pub const bpf_cmd_BPF_PROG_RUN: bpf_cmd = 10;
    pub const bpf_cmd_BPF_PROG_GET_NEXT_ID: bpf_cmd = 11;
    pub const bpf_cmd_BPF_MAP_GET_NEXT_ID: bpf_cmd = 12;
    pub const bpf_cmd_BPF_PROG_GET_FD_BY_ID: bpf_cmd = 13;
    pub const bpf_cmd_BPF_MAP_GET_FD_BY_ID: bpf_cmd = 14;
    pub const bpf_cmd_BPF_OBJ_GET_INFO_BY_FD: bpf_cmd = 15;
    pub const bpf_cmd_BPF_PROG_QUERY: bpf_cmd = 16;
    pub const bpf_cmd_BPF_RAW_TRACEPOINT_OPEN: bpf_cmd = 17;
    pub const bpf_cmd_BPF_BTF_LOAD: bpf_cmd = 18;
    pub const bpf_cmd_BPF_BTF_GET_FD_BY_ID: bpf_cmd = 19;
    pub const bpf_cmd_BPF_TASK_FD_QUERY: bpf_cmd = 20;
    pub const bpf_cmd_BPF_MAP_LOOKUP_AND_DELETE_ELEM: bpf_cmd = 21;
    pub const bpf_cmd_BPF_MAP_FREEZE: bpf_cmd = 22;
    pub const bpf_cmd_BPF_BTF_GET_NEXT_ID: bpf_cmd = 23;
    pub const bpf_cmd_BPF_MAP_LOOKUP_BATCH: bpf_cmd = 24;
    pub const bpf_cmd_BPF_MAP_LOOKUP_AND_DELETE_BATCH: bpf_cmd = 25;
    pub const bpf_cmd_BPF_MAP_UPDATE_BATCH: bpf_cmd = 26;
    pub const bpf_cmd_BPF_MAP_DELETE_BATCH: bpf_cmd = 27;
    pub const bpf_cmd_BPF_LINK_CREATE: bpf_cmd = 28;
    pub const bpf_cmd_BPF_LINK_UPDATE: bpf_cmd = 29;
    pub const bpf_cmd_BPF_LINK_GET_FD_BY_ID: bpf_cmd = 30;
    pub const bpf_cmd_BPF_LINK_GET_NEXT_ID: bpf_cmd = 31;
    pub const bpf_cmd_BPF_ENABLE_STATS: bpf_cmd = 32;
    pub const bpf_cmd_BPF_ITER_CREATE: bpf_cmd = 33;
    pub const bpf_cmd_BPF_LINK_DETACH: bpf_cmd = 34;
    pub const bpf_cmd_BPF_PROG_BIND_MAP: bpf_cmd = 35;
    #[doc = " DOC: eBPF Syscall Preamble"]
    #[doc = ""]
    #[doc = " The operation to be performed by the **bpf**\\ () system call is determined"]
    #[doc = " by the *cmd* argument. Each operation takes an accompanying argument,"]
    #[doc = " provided via *attr*, which is a pointer to a union of type *bpf_attr* (see"]
    #[doc = " below). The size argument is the size of the union pointed to by *attr*."]
    #[doc = " DOC: eBPF Syscall Commands"]
    #[doc = ""]
    #[doc = " BPF_MAP_CREATE"]
    #[doc = "\tDescription"]
    #[doc = "\t\tCreate a map and return a file descriptor that refers to the"]
    #[doc = "\t\tmap. The close-on-exec file descriptor flag (see **fcntl**\\ (2))"]
    #[doc = "\t\tis automatically enabled for the new file descriptor."]
    #[doc = ""]
    #[doc = "\t\tApplying **close**\\ (2) to the file descriptor returned by"]
    #[doc = "\t\t**BPF_MAP_CREATE** will delete the map (but see NOTES)."]
    #[doc = ""]
    #[doc = "\tReturn"]
    #[doc = "\t\tA new file descriptor (a nonnegative integer), or -1 if an"]
    #[doc = "\t\terror occurred (in which case, *errno* is set appropriately)."]
    #[doc = ""]
    #[doc = " BPF_MAP_LOOKUP_ELEM"]
    #[doc = "\tDescription"]
    #[doc = "\t\tLook up an element with a given *key* in the map referred to"]
    #[doc = "\t\tby the file descriptor *map_fd*."]
    #[doc = ""]
    #[doc = "\t\tThe *flags* argument may be specified as one of the"]
    #[doc = "\t\tfollowing:"]
    #[doc = ""]
    #[doc = "\t\t**BPF_F_LOCK**"]
    #[doc = "\t\t\tLook up the value of a spin-locked map without"]
    #[doc = "\t\t\treturning the lock. This must be specified if the"]
    #[doc = "\t\t\telements contain a spinlock."]
    #[doc = ""]
    #[doc = "\tReturn"]
    #[doc = "\t\tReturns zero on success. On error, -1 is returned and *errno*"]
    #[doc = "\t\tis set appropriately."]
    #[doc = ""]
    #[doc = " BPF_MAP_UPDATE_ELEM"]
    #[doc = "\tDescription"]
    #[doc = "\t\tCreate or update an element (key/value pair) in a specified map."]
    #[doc = ""]
    #[doc = "\t\tThe *flags* argument should be specified as one of the"]
    #[doc = "\t\tfollowing:"]
    #[doc = ""]
    #[doc = "\t\t**BPF_ANY**"]
    #[doc = "\t\t\tCreate a new element or update an existing element."]
    #[doc = "\t\t**BPF_NOEXIST**"]
    #[doc = "\t\t\tCreate a new element only if it did not exist."]
    #[doc = "\t\t**BPF_EXIST**"]
    #[doc = "\t\t\tUpdate an existing element."]
    #[doc = "\t\t**BPF_F_LOCK**"]
    #[doc = "\t\t\tUpdate a spin_lock-ed map element."]
    #[doc = ""]
    #[doc = "\tReturn"]
    #[doc = "\t\tReturns zero on success. On error, -1 is returned and *errno*"]
    #[doc = "\t\tis set appropriately."]
    #[doc = ""]
    #[doc = "\t\tMay set *errno* to **EINVAL**, **EPERM**, **ENOMEM**,"]
    #[doc = "\t\t**E2BIG**, **EEXIST**, or **ENOENT**."]
    #[doc = ""]
    #[doc = "\t\t**E2BIG**"]
    #[doc = "\t\t\tThe number of elements in the map reached the"]
    #[doc = "\t\t\t*max_entries* limit specified at map creation time."]
    #[doc = "\t\t**EEXIST**"]
    #[doc = "\t\t\tIf *flags* specifies **BPF_NOEXIST** and the element"]
    #[doc = "\t\t\twith *key* already exists in the map."]
    #[doc = "\t\t**ENOENT**"]
    #[doc = "\t\t\tIf *flags* specifies **BPF_EXIST** and the element with"]
    #[doc = "\t\t\t*key* does not exist in the map."]
    #[doc = ""]
    #[doc = " BPF_MAP_DELETE_ELEM"]
    #[doc = "\tDescription"]
    #[doc = "\t\tLook up and delete an element by key in a specified map."]
    #[doc = ""]
    #[doc = "\tReturn"]
    #[doc = "\t\tReturns zero on success. On error, -1 is returned and *errno*"]
    #[doc = "\t\tis set appropriately."]
    #[doc = ""]
    #[doc = " BPF_MAP_GET_NEXT_KEY"]
    #[doc = "\tDescription"]
    #[doc = "\t\tLook up an element by key in a specified map and return the key"]
    #[doc = "\t\tof the next element. Can be used to iterate over all elements"]
    #[doc = "\t\tin the map."]
    #[doc = ""]
    #[doc = "\tReturn"]
    #[doc = "\t\tReturns zero on success. On error, -1 is returned and *errno*"]
    #[doc = "\t\tis set appropriately."]
    #[doc = ""]
    #[doc = "\t\tThe following cases can be used to iterate over all elements of"]
    #[doc = "\t\tthe map:"]
    #[doc = ""]
    #[doc = "\t\t* If *key* is not found, the operation returns zero and sets"]
    #[doc = "\t\t  the *next_key* pointer to the key of the first element."]
    #[doc = "\t\t* If *key* is found, the operation returns zero and sets the"]
    #[doc = "\t\t  *next_key* pointer to the key of the next element."]
    #[doc = "\t\t* If *key* is the last element, returns -1 and *errno* is set"]
    #[doc = "\t\t  to **ENOENT**."]
    #[doc = ""]
    #[doc = "\t\tMay set *errno* to **ENOMEM**, **EFAULT**, **EPERM**, or"]
    #[doc = "\t\t**EINVAL** on error."]
    #[doc = ""]
    #[doc = " BPF_PROG_LOAD"]
    #[doc = "\tDescription"]
    #[doc = "\t\tVerify and load an eBPF program, returning a new file"]
    #[doc = "\t\tdescriptor associated with the program."]
    #[doc = ""]
    #[doc = "\t\tApplying **close**\\ (2) to the file descriptor returned by"]
    #[doc = "\t\t**BPF_PROG_LOAD** will unload the eBPF program (but see NOTES)."]
    #[doc = ""]
    #[doc = "\t\tThe close-on-exec file descriptor flag (see **fcntl**\\ (2)) is"]
    #[doc = "\t\tautomatically enabled for the new file descriptor."]
    #[doc = ""]
    #[doc = "\tReturn"]
    #[doc = "\t\tA new file descriptor (a nonnegative integer), or -1 if an"]
    #[doc = "\t\terror occurred (in which case, *errno* is set appropriately)."]
    #[doc = ""]
    #[doc = " BPF_OBJ_PIN"]
    #[doc = "\tDescription"]
    #[doc = "\t\tPin an eBPF program or map referred by the specified *bpf_fd*"]
    #[doc = "\t\tto the provided *pathname* on the filesystem."]
    #[doc = ""]
    #[doc = "\t\tThe *pathname* argument must not contain a dot (\".\")."]
    #[doc = ""]
    #[doc = "\t\tOn success, *pathname* retains a reference to the eBPF object,"]
    #[doc = "\t\tpreventing deallocation of the object when the original"]
    #[doc = "\t\t*bpf_fd* is closed. This allow the eBPF object to live beyond"]
    #[doc = "\t\t**close**\\ (\\ *bpf_fd*\\ ), and hence the lifetime of the parent"]
    #[doc = "\t\tprocess."]
    #[doc = ""]
    #[doc = "\t\tApplying **unlink**\\ (2) or similar calls to the *pathname*"]
    #[doc = "\t\tunpins the object from the filesystem, removing the reference."]
    #[doc = "\t\tIf no other file descriptors or filesystem nodes refer to the"]
    #[doc = "\t\tsame object, it will be deallocated (see NOTES)."]
    #[doc = ""]
    #[doc = "\t\tThe filesystem type for the parent directory of *pathname* must"]
    #[doc = "\t\tbe **BPF_FS_MAGIC**."]
    #[doc = ""]
    #[doc = "\tReturn"]
    #[doc = "\t\tReturns zero on success. On error, -1 is returned and *errno*"]
    #[doc = "\t\tis set appropriately."]
    #[doc = ""]
    #[doc = " BPF_OBJ_GET"]
    #[doc = "\tDescription"]
    #[doc = "\t\tOpen a file descriptor for the eBPF object pinned to the"]
    #[doc = "\t\tspecified *pathname*."]
    #[doc = ""]
    #[doc = "\tReturn"]
    #[doc = "\t\tA new file descriptor (a nonnegative integer), or -1 if an"]
    #[doc = "\t\terror occurred (in which case, *errno* is set appropriately)."]
    #[doc = ""]
    #[doc = " BPF_PROG_ATTACH"]
    #[doc = "\tDescription"]
    #[doc = "\t\tAttach an eBPF program to a *target_fd* at the specified"]
    #[doc = "\t\t*attach_type* hook."]
    #[doc = ""]
    #[doc = "\t\tThe *attach_type* specifies the eBPF attachment point to"]
    #[doc = "\t\tattach the program to, and must be one of *bpf_attach_type*"]
    #[doc = "\t\t(see below)."]
    #[doc = ""]
    #[doc = "\t\tThe *attach_bpf_fd* must be a valid file descriptor for a"]
    #[doc = "\t\tloaded eBPF program of a cgroup, flow dissector, LIRC, sockmap"]
    #[doc = "\t\tor sock_ops type corresponding to the specified *attach_type*."]
    #[doc = ""]
    #[doc = "\t\tThe *target_fd* must be a valid file descriptor for a kernel"]
    #[doc = "\t\tobject which depends on the attach type of *attach_bpf_fd*:"]
    #[doc = ""]
    #[doc = "\t\t**BPF_PROG_TYPE_CGROUP_DEVICE**,"]
    #[doc = "\t\t**BPF_PROG_TYPE_CGROUP_SKB**,"]
    #[doc = "\t\t**BPF_PROG_TYPE_CGROUP_SOCK**,"]
    #[doc = "\t\t**BPF_PROG_TYPE_CGROUP_SOCK_ADDR**,"]
    #[doc = "\t\t**BPF_PROG_TYPE_CGROUP_SOCKOPT**,"]
    #[doc = "\t\t**BPF_PROG_TYPE_CGROUP_SYSCTL**,"]
    #[doc = "\t\t**BPF_PROG_TYPE_SOCK_OPS**"]
    #[doc = ""]
    #[doc = "\t\t\tControl Group v2 hierarchy with the eBPF controller"]
    #[doc = "\t\t\tenabled. Requires the kernel to be compiled with"]
    #[doc = "\t\t\t**CONFIG_CGROUP_BPF**."]
    #[doc = ""]
    #[doc = "\t\t**BPF_PROG_TYPE_FLOW_DISSECTOR**"]
    #[doc = ""]
    #[doc = "\t\t\tNetwork namespace (eg /proc/self/ns/net)."]
    #[doc = ""]
    #[doc = "\t\t**BPF_PROG_TYPE_LIRC_MODE2**"]
    #[doc = ""]
    #[doc = "\t\t\tLIRC device path (eg /dev/lircN). Requires the kernel"]
    #[doc = "\t\t\tto be compiled with **CONFIG_BPF_LIRC_MODE2**."]
    #[doc = ""]
    #[doc = "\t\t**BPF_PROG_TYPE_SK_SKB**,"]
    #[doc = "\t\t**BPF_PROG_TYPE_SK_MSG**"]
    #[doc = ""]
    #[doc = "\t\t\teBPF map of socket type (eg **BPF_MAP_TYPE_SOCKHASH**)."]
    #[doc = ""]
    #[doc = "\tReturn"]
    #[doc = "\t\tReturns zero on success. On error, -1 is returned and *errno*"]
    #[doc = "\t\tis set appropriately."]
    #[doc = ""]
    #[doc = " BPF_PROG_DETACH"]
    #[doc = "\tDescription"]
    #[doc = "\t\tDetach the eBPF program associated with the *target_fd* at the"]
    #[doc = "\t\thook specified by *attach_type*. The program must have been"]
    #[doc = "\t\tpreviously attached using **BPF_PROG_ATTACH**."]
    #[doc = ""]
    #[doc = "\tReturn"]
    #[doc = "\t\tReturns zero on success. On error, -1 is returned and *errno*"]
    #[doc = "\t\tis set appropriately."]
    #[doc = ""]
    #[doc = " BPF_PROG_TEST_RUN"]
    #[doc = "\tDescription"]
    #[doc = "\t\tRun the eBPF program associated with the *prog_fd* a *repeat*"]
    #[doc = "\t\tnumber of times against a provided program context *ctx_in* and"]
    #[doc = "\t\tdata *data_in*, and return the modified program context"]
    #[doc = "\t\t*ctx_out*, *data_out* (for example, packet data), result of the"]
    #[doc = "\t\texecution *retval*, and *duration* of the test run."]
    #[doc = ""]
    #[doc = "\t\tThe sizes of the buffers provided as input and output"]
    #[doc = "\t\tparameters *ctx_in*, *ctx_out*, *data_in*, and *data_out* must"]
    #[doc = "\t\tbe provided in the corresponding variables *ctx_size_in*,"]
    #[doc = "\t\t*ctx_size_out*, *data_size_in*, and/or *data_size_out*. If any"]
    #[doc = "\t\tof these parameters are not provided (ie set to NULL), the"]
    #[doc = "\t\tcorresponding size field must be zero."]
    #[doc = ""]
    #[doc = "\t\tSome program types have particular requirements:"]
    #[doc = ""]
    #[doc = "\t\t**BPF_PROG_TYPE_SK_LOOKUP**"]
    #[doc = "\t\t\t*data_in* and *data_out* must be NULL."]
    #[doc = ""]
    #[doc = "\t\t**BPF_PROG_TYPE_RAW_TRACEPOINT**,"]
    #[doc = "\t\t**BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE**"]
    #[doc = ""]
    #[doc = "\t\t\t*ctx_out*, *data_in* and *data_out* must be NULL."]
    #[doc = "\t\t\t*repeat* must be zero."]
    #[doc = ""]
    #[doc = "\t\tBPF_PROG_RUN is an alias for BPF_PROG_TEST_RUN."]
    #[doc = ""]
    #[doc = "\tReturn"]
    #[doc = "\t\tReturns zero on success. On error, -1 is returned and *errno*"]
    #[doc = "\t\tis set appropriately."]
    #[doc = ""]
    #[doc = "\t\t**ENOSPC**"]
    #[doc = "\t\t\tEither *data_size_out* or *ctx_size_out* is too small."]
    #[doc = "\t\t**ENOTSUPP**"]
    #[doc = "\t\t\tThis command is not supported by the program type of"]
    #[doc = "\t\t\tthe program referred to by *prog_fd*."]
    #[doc = ""]
    #[doc = " BPF_PROG_GET_NEXT_ID"]
    #[doc = "\tDescription"]
    #[doc = "\t\tFetch the next eBPF program currently loaded into the kernel."]
    #[doc = ""]
    #[doc = "\t\tLooks for the eBPF program with an id greater than *start_id*"]
    #[doc = "\t\tand updates *next_id* on success. If no other eBPF programs"]
    #[doc = "\t\tremain with ids higher than *start_id*, returns -1 and sets"]
    #[doc = "\t\t*errno* to **ENOENT**."]
    #[doc = ""]
    #[doc = "\tReturn"]
    #[doc = "\t\tReturns zero on success. On error, or when no id remains, -1"]
    #[doc = "\t\tis returned and *errno* is set appropriately."]
    #[doc = ""]
    #[doc = " BPF_MAP_GET_NEXT_ID"]
    #[doc = "\tDescription"]
    #[doc = "\t\tFetch the next eBPF map currently loaded into the kernel."]
    #[doc = ""]
    #[doc = "\t\tLooks for the eBPF map with an id greater than *start_id*"]
    #[doc = "\t\tand updates *next_id* on success. If no other eBPF maps"]
    #[doc = "\t\tremain with ids higher than *start_id*, returns -1 and sets"]
    #[doc = "\t\t*errno* to **ENOENT**."]
    #[doc = ""]
    #[doc = "\tReturn"]
    #[doc = "\t\tReturns zero on success. On error, or when no id remains, -1"]
    #[doc = "\t\tis returned and *errno* is set appropriately."]
    #[doc = ""]
    #[doc = " BPF_PROG_GET_FD_BY_ID"]
    #[doc = "\tDescription"]
    #[doc = "\t\tOpen a file descriptor for the eBPF program corresponding to"]
    #[doc = "\t\t*prog_id*."]
    #[doc = ""]
    #[doc = "\tReturn"]
    #[doc = "\t\tA new file descriptor (a nonnegative integer), or -1 if an"]
    #[doc = "\t\terror occurred (in which case, *errno* is set appropriately)."]
    #[doc = ""]
    #[doc = " BPF_MAP_GET_FD_BY_ID"]
    #[doc = "\tDescription"]
    #[doc = "\t\tOpen a file descriptor for the eBPF map corresponding to"]
    #[doc = "\t\t*map_id*."]
    #[doc = ""]
    #[doc = "\tReturn"]
    #[doc = "\t\tA new file descriptor (a nonnegative integer), or -1 if an"]
    #[doc = "\t\terror occurred (in which case, *errno* is set appropriately)."]
    #[doc = ""]
    #[doc = " BPF_OBJ_GET_INFO_BY_FD"]
    #[doc = "\tDescription"]
    #[doc = "\t\tObtain information about the eBPF object corresponding to"]
    #[doc = "\t\t*bpf_fd*."]
    #[doc = ""]
    #[doc = "\t\tPopulates up to *info_len* bytes of *info*, which will be in"]
    #[doc = "\t\tone of the following formats depending on the eBPF object type"]
    #[doc = "\t\tof *bpf_fd*:"]
    #[doc = ""]
    #[doc = "\t\t* **struct bpf_prog_info**"]
    #[doc = "\t\t* **struct bpf_map_info**"]
    #[doc = "\t\t* **struct bpf_btf_info**"]
    #[doc = "\t\t* **struct bpf_link_info**"]
    #[doc = ""]
    #[doc = "\tReturn"]
    #[doc = "\t\tReturns zero on success. On error, -1 is returned and *errno*"]
    #[doc = "\t\tis set appropriately."]
    #[doc = ""]
    #[doc = " BPF_PROG_QUERY"]
    #[doc = "\tDescription"]
    #[doc = "\t\tObtain information about eBPF programs associated with the"]
    #[doc = "\t\tspecified *attach_type* hook."]
    #[doc = ""]
    #[doc = "\t\tThe *target_fd* must be a valid file descriptor for a kernel"]
    #[doc = "\t\tobject which depends on the attach type of *attach_bpf_fd*:"]
    #[doc = ""]
    #[doc = "\t\t**BPF_PROG_TYPE_CGROUP_DEVICE**,"]
    #[doc = "\t\t**BPF_PROG_TYPE_CGROUP_SKB**,"]
    #[doc = "\t\t**BPF_PROG_TYPE_CGROUP_SOCK**,"]
    #[doc = "\t\t**BPF_PROG_TYPE_CGROUP_SOCK_ADDR**,"]
    #[doc = "\t\t**BPF_PROG_TYPE_CGROUP_SOCKOPT**,"]
    #[doc = "\t\t**BPF_PROG_TYPE_CGROUP_SYSCTL**,"]
    #[doc = "\t\t**BPF_PROG_TYPE_SOCK_OPS**"]
    #[doc = ""]
    #[doc = "\t\t\tControl Group v2 hierarchy with the eBPF controller"]
    #[doc = "\t\t\tenabled. Requires the kernel to be compiled with"]
    #[doc = "\t\t\t**CONFIG_CGROUP_BPF**."]
    #[doc = ""]
    #[doc = "\t\t**BPF_PROG_TYPE_FLOW_DISSECTOR**"]
    #[doc = ""]
    #[doc = "\t\t\tNetwork namespace (eg /proc/self/ns/net)."]
    #[doc = ""]
    #[doc = "\t\t**BPF_PROG_TYPE_LIRC_MODE2**"]
    #[doc = ""]
    #[doc = "\t\t\tLIRC device path (eg /dev/lircN). Requires the kernel"]
    #[doc = "\t\t\tto be compiled with **CONFIG_BPF_LIRC_MODE2**."]
    #[doc = ""]
    #[doc = "\t\t**BPF_PROG_QUERY** always fetches the number of programs"]
    #[doc = "\t\tattached and the *attach_flags* which were used to attach those"]
    #[doc = "\t\tprograms. Additionally, if *prog_ids* is nonzero and the number"]
    #[doc = "\t\tof attached programs is less than *prog_cnt*, populates"]
    #[doc = "\t\t*prog_ids* with the eBPF program ids of the programs attached"]
    #[doc = "\t\tat *target_fd*."]
    #[doc = ""]
    #[doc = "\t\tThe following flags may alter the result:"]
    #[doc = ""]
    #[doc = "\t\t**BPF_F_QUERY_EFFECTIVE**"]
    #[doc = "\t\t\tOnly return information regarding programs which are"]
    #[doc = "\t\t\tcurrently effective at the specified *target_fd*."]
    #[doc = ""]
    #[doc = "\tReturn"]
    #[doc = "\t\tReturns zero on success. On error, -1 is returned and *errno*"]
    #[doc = "\t\tis set appropriately."]
    #[doc = ""]
    #[doc = " BPF_RAW_TRACEPOINT_OPEN"]
    #[doc = "\tDescription"]
    #[doc = "\t\tAttach an eBPF program to a tracepoint *name* to access kernel"]
    #[doc = "\t\tinternal arguments of the tracepoint in their raw form."]
    #[doc = ""]
    #[doc = "\t\tThe *prog_fd* must be a valid file descriptor associated with"]
    #[doc = "\t\ta loaded eBPF program of type **BPF_PROG_TYPE_RAW_TRACEPOINT**."]
    #[doc = ""]
    #[doc = "\t\tNo ABI guarantees are made about the content of tracepoint"]
    #[doc = "\t\targuments exposed to the corresponding eBPF program."]
    #[doc = ""]
    #[doc = "\t\tApplying **close**\\ (2) to the file descriptor returned by"]
    #[doc = "\t\t**BPF_RAW_TRACEPOINT_OPEN** will delete the map (but see NOTES)."]
    #[doc = ""]
    #[doc = "\tReturn"]
    #[doc = "\t\tA new file descriptor (a nonnegative integer), or -1 if an"]
    #[doc = "\t\terror occurred (in which case, *errno* is set appropriately)."]
    #[doc = ""]
    #[doc = " BPF_BTF_LOAD"]
    #[doc = "\tDescription"]
    #[doc = "\t\tVerify and load BPF Type Format (BTF) metadata into the kernel,"]
    #[doc = "\t\treturning a new file descriptor associated with the metadata."]
    #[doc = "\t\tBTF is described in more detail at"]
    #[doc = "\t\thttps://www.kernel.org/doc/html/latest/bpf/btf.html."]
    #[doc = ""]
    #[doc = "\t\tThe *btf* parameter must point to valid memory providing"]
    #[doc = "\t\t*btf_size* bytes of BTF binary metadata."]
    #[doc = ""]
    #[doc = "\t\tThe returned file descriptor can be passed to other **bpf**\\ ()"]
    #[doc = "\t\tsubcommands such as **BPF_PROG_LOAD** or **BPF_MAP_CREATE** to"]
    #[doc = "\t\tassociate the BTF with those objects."]
    #[doc = ""]
    #[doc = "\t\tSimilar to **BPF_PROG_LOAD**, **BPF_BTF_LOAD** has optional"]
    #[doc = "\t\tparameters to specify a *btf_log_buf*, *btf_log_size* and"]
    #[doc = "\t\t*btf_log_level* which allow the kernel to return freeform log"]
    #[doc = "\t\toutput regarding the BTF verification process."]
    #[doc = ""]
    #[doc = "\tReturn"]
    #[doc = "\t\tA new file descriptor (a nonnegative integer), or -1 if an"]
    #[doc = "\t\terror occurred (in which case, *errno* is set appropriately)."]
    #[doc = ""]
    #[doc = " BPF_BTF_GET_FD_BY_ID"]
    #[doc = "\tDescription"]
    #[doc = "\t\tOpen a file descriptor for the BPF Type Format (BTF)"]
    #[doc = "\t\tcorresponding to *btf_id*."]
    #[doc = ""]
    #[doc = "\tReturn"]
    #[doc = "\t\tA new file descriptor (a nonnegative integer), or -1 if an"]
    #[doc = "\t\terror occurred (in which case, *errno* is set appropriately)."]
    #[doc = ""]
    #[doc = " BPF_TASK_FD_QUERY"]
    #[doc = "\tDescription"]
    #[doc = "\t\tObtain information about eBPF programs associated with the"]
    #[doc = "\t\ttarget process identified by *pid* and *fd*."]
    #[doc = ""]
    #[doc = "\t\tIf the *pid* and *fd* are associated with a tracepoint, kprobe"]
    #[doc = "\t\tor uprobe perf event, then the *prog_id* and *fd_type* will"]
    #[doc = "\t\tbe populated with the eBPF program id and file descriptor type"]
    #[doc = "\t\tof type **bpf_task_fd_type**. If associated with a kprobe or"]
    #[doc = "\t\tuprobe, the  *probe_offset* and *probe_addr* will also be"]
    #[doc = "\t\tpopulated. Optionally, if *buf* is provided, then up to"]
    #[doc = "\t\t*buf_len* bytes of *buf* will be populated with the name of"]
    #[doc = "\t\tthe tracepoint, kprobe or uprobe."]
    #[doc = ""]
    #[doc = "\t\tThe resulting *prog_id* may be introspected in deeper detail"]
    #[doc = "\t\tusing **BPF_PROG_GET_FD_BY_ID** and **BPF_OBJ_GET_INFO_BY_FD**."]
    #[doc = ""]
    #[doc = "\tReturn"]
    #[doc = "\t\tReturns zero on success. On error, -1 is returned and *errno*"]
    #[doc = "\t\tis set appropriately."]
    #[doc = ""]
    #[doc = " BPF_MAP_LOOKUP_AND_DELETE_ELEM"]
    #[doc = "\tDescription"]
    #[doc = "\t\tLook up an element with the given *key* in the map referred to"]
    #[doc = "\t\tby the file descriptor *fd*, and if found, delete the element."]
    #[doc = ""]
    #[doc = "\t\tFor **BPF_MAP_TYPE_QUEUE** and **BPF_MAP_TYPE_STACK** map"]
    #[doc = "\t\ttypes, the *flags* argument needs to be set to 0, but for other"]
    #[doc = "\t\tmap types, it may be specified as:"]
    #[doc = ""]
    #[doc = "\t\t**BPF_F_LOCK**"]
    #[doc = "\t\t\tLook up and delete the value of a spin-locked map"]
    #[doc = "\t\t\twithout returning the lock. This must be specified if"]
    #[doc = "\t\t\tthe elements contain a spinlock."]
    #[doc = ""]
    #[doc = "\t\tThe **BPF_MAP_TYPE_QUEUE** and **BPF_MAP_TYPE_STACK** map types"]
    #[doc = "\t\timplement this command as a \"pop\" operation, deleting the top"]
    #[doc = "\t\telement rather than one corresponding to *key*."]
    #[doc = "\t\tThe *key* and *key_len* parameters should be zeroed when"]
    #[doc = "\t\tissuing this operation for these map types."]
    #[doc = ""]
    #[doc = "\t\tThis command is only valid for the following map types:"]
    #[doc = "\t\t* **BPF_MAP_TYPE_QUEUE**"]
    #[doc = "\t\t* **BPF_MAP_TYPE_STACK**"]
    #[doc = "\t\t* **BPF_MAP_TYPE_HASH**"]
    #[doc = "\t\t* **BPF_MAP_TYPE_PERCPU_HASH**"]
    #[doc = "\t\t* **BPF_MAP_TYPE_LRU_HASH**"]
    #[doc = "\t\t* **BPF_MAP_TYPE_LRU_PERCPU_HASH**"]
    #[doc = ""]
    #[doc = "\tReturn"]
    #[doc = "\t\tReturns zero on success. On error, -1 is returned and *errno*"]
    #[doc = "\t\tis set appropriately."]
    #[doc = ""]
    #[doc = " BPF_MAP_FREEZE"]
    #[doc = "\tDescription"]
    #[doc = "\t\tFreeze the permissions of the specified map."]
    #[doc = ""]
    #[doc = "\t\tWrite permissions may be frozen by passing zero *flags*."]
    #[doc = "\t\tUpon success, no future syscall invocations may alter the"]
    #[doc = "\t\tmap state of *map_fd*. Write operations from eBPF programs"]
    #[doc = "\t\tare still possible for a frozen map."]
    #[doc = ""]
    #[doc = "\t\tNot supported for maps of type **BPF_MAP_TYPE_STRUCT_OPS**."]
    #[doc = ""]
    #[doc = "\tReturn"]
    #[doc = "\t\tReturns zero on success. On error, -1 is returned and *errno*"]
    #[doc = "\t\tis set appropriately."]
    #[doc = ""]
    #[doc = " BPF_BTF_GET_NEXT_ID"]
    #[doc = "\tDescription"]
    #[doc = "\t\tFetch the next BPF Type Format (BTF) object currently loaded"]
    #[doc = "\t\tinto the kernel."]
    #[doc = ""]
    #[doc = "\t\tLooks for the BTF object with an id greater than *start_id*"]
    #[doc = "\t\tand updates *next_id* on success. If no other BTF objects"]
    #[doc = "\t\tremain with ids higher than *start_id*, returns -1 and sets"]
    #[doc = "\t\t*errno* to **ENOENT**."]
    #[doc = ""]
    #[doc = "\tReturn"]
    #[doc = "\t\tReturns zero on success. On error, or when no id remains, -1"]
    #[doc = "\t\tis returned and *errno* is set appropriately."]
    #[doc = ""]
    #[doc = " BPF_MAP_LOOKUP_BATCH"]
    #[doc = "\tDescription"]
    #[doc = "\t\tIterate and fetch multiple elements in a map."]
    #[doc = ""]
    #[doc = "\t\tTwo opaque values are used to manage batch operations,"]
    #[doc = "\t\t*in_batch* and *out_batch*. Initially, *in_batch* must be set"]
    #[doc = "\t\tto NULL to begin the batched operation. After each subsequent"]
    #[doc = "\t\t**BPF_MAP_LOOKUP_BATCH**, the caller should pass the resultant"]
    #[doc = "\t\t*out_batch* as the *in_batch* for the next operation to"]
    #[doc = "\t\tcontinue iteration from the current point."]
    #[doc = ""]
    #[doc = "\t\tThe *keys* and *values* are output parameters which must point"]
    #[doc = "\t\tto memory large enough to hold *count* items based on the key"]
    #[doc = "\t\tand value size of the map *map_fd*. The *keys* buffer must be"]
    #[doc = "\t\tof *key_size* * *count*. The *values* buffer must be of"]
    #[doc = "\t\t*value_size* * *count*."]
    #[doc = ""]
    #[doc = "\t\tThe *elem_flags* argument may be specified as one of the"]
    #[doc = "\t\tfollowing:"]
    #[doc = ""]
    #[doc = "\t\t**BPF_F_LOCK**"]
    #[doc = "\t\t\tLook up the value of a spin-locked map without"]
    #[doc = "\t\t\treturning the lock. This must be specified if the"]
    #[doc = "\t\t\telements contain a spinlock."]
    #[doc = ""]
    #[doc = "\t\tOn success, *count* elements from the map are copied into the"]
    #[doc = "\t\tuser buffer, with the keys copied into *keys* and the values"]
    #[doc = "\t\tcopied into the corresponding indices in *values*."]
    #[doc = ""]
    #[doc = "\t\tIf an error is returned and *errno* is not **EFAULT**, *count*"]
    #[doc = "\t\tis set to the number of successfully processed elements."]
    #[doc = ""]
    #[doc = "\tReturn"]
    #[doc = "\t\tReturns zero on success. On error, -1 is returned and *errno*"]
    #[doc = "\t\tis set appropriately."]
    #[doc = ""]
    #[doc = "\t\tMay set *errno* to **ENOSPC** to indicate that *keys* or"]
    #[doc = "\t\t*values* is too small to dump an entire bucket during"]
    #[doc = "\t\titeration of a hash-based map type."]
    #[doc = ""]
    #[doc = " BPF_MAP_LOOKUP_AND_DELETE_BATCH"]
    #[doc = "\tDescription"]
    #[doc = "\t\tIterate and delete all elements in a map."]
    #[doc = ""]
    #[doc = "\t\tThis operation has the same behavior as"]
    #[doc = "\t\t**BPF_MAP_LOOKUP_BATCH** with two exceptions:"]
    #[doc = ""]
    #[doc = "\t\t* Every element that is successfully returned is also deleted"]
    #[doc = "\t\t  from the map. This is at least *count* elements. Note that"]
    #[doc = "\t\t  *count* is both an input and an output parameter."]
    #[doc = "\t\t* Upon returning with *errno* set to **EFAULT**, up to"]
    #[doc = "\t\t  *count* elements may be deleted without returning the keys"]
    #[doc = "\t\t  and values of the deleted elements."]
    #[doc = ""]
    #[doc = "\tReturn"]
    #[doc = "\t\tReturns zero on success. On error, -1 is returned and *errno*"]
    #[doc = "\t\tis set appropriately."]
    #[doc = ""]
    #[doc = " BPF_MAP_UPDATE_BATCH"]
    #[doc = "\tDescription"]
    #[doc = "\t\tUpdate multiple elements in a map by *key*."]
    #[doc = ""]
    #[doc = "\t\tThe *keys* and *values* are input parameters which must point"]
    #[doc = "\t\tto memory large enough to hold *count* items based on the key"]
    #[doc = "\t\tand value size of the map *map_fd*. The *keys* buffer must be"]
    #[doc = "\t\tof *key_size* * *count*. The *values* buffer must be of"]
    #[doc = "\t\t*value_size* * *count*."]
    #[doc = ""]
    #[doc = "\t\tEach element specified in *keys* is sequentially updated to the"]
    #[doc = "\t\tvalue in the corresponding index in *values*. The *in_batch*"]
    #[doc = "\t\tand *out_batch* parameters are ignored and should be zeroed."]
    #[doc = ""]
    #[doc = "\t\tThe *elem_flags* argument should be specified as one of the"]
    #[doc = "\t\tfollowing:"]
    #[doc = ""]
    #[doc = "\t\t**BPF_ANY**"]
    #[doc = "\t\t\tCreate new elements or update a existing elements."]
    #[doc = "\t\t**BPF_NOEXIST**"]
    #[doc = "\t\t\tCreate new elements only if they do not exist."]
    #[doc = "\t\t**BPF_EXIST**"]
    #[doc = "\t\t\tUpdate existing elements."]
    #[doc = "\t\t**BPF_F_LOCK**"]
    #[doc = "\t\t\tUpdate spin_lock-ed map elements. This must be"]
    #[doc = "\t\t\tspecified if the map value contains a spinlock."]
    #[doc = ""]
    #[doc = "\t\tOn success, *count* elements from the map are updated."]
    #[doc = ""]
    #[doc = "\t\tIf an error is returned and *errno* is not **EFAULT**, *count*"]
    #[doc = "\t\tis set to the number of successfully processed elements."]
    #[doc = ""]
    #[doc = "\tReturn"]
    #[doc = "\t\tReturns zero on success. On error, -1 is returned and *errno*"]
    #[doc = "\t\tis set appropriately."]
    #[doc = ""]
    #[doc = "\t\tMay set *errno* to **EINVAL**, **EPERM**, **ENOMEM**, or"]
    #[doc = "\t\t**E2BIG**. **E2BIG** indicates that the number of elements in"]
    #[doc = "\t\tthe map reached the *max_entries* limit specified at map"]
    #[doc = "\t\tcreation time."]
    #[doc = ""]
    #[doc = "\t\tMay set *errno* to one of the following error codes under"]
    #[doc = "\t\tspecific circumstances:"]
    #[doc = ""]
    #[doc = "\t\t**EEXIST**"]
    #[doc = "\t\t\tIf *flags* specifies **BPF_NOEXIST** and the element"]
    #[doc = "\t\t\twith *key* already exists in the map."]
    #[doc = "\t\t**ENOENT**"]
    #[doc = "\t\t\tIf *flags* specifies **BPF_EXIST** and the element with"]
    #[doc = "\t\t\t*key* does not exist in the map."]
    #[doc = ""]
    #[doc = " BPF_MAP_DELETE_BATCH"]
    #[doc = "\tDescription"]
    #[doc = "\t\tDelete multiple elements in a map by *key*."]
    #[doc = ""]
    #[doc = "\t\tThe *keys* parameter is an input parameter which must point"]
    #[doc = "\t\tto memory large enough to hold *count* items based on the key"]
    #[doc = "\t\tsize of the map *map_fd*, that is, *key_size* * *count*."]
    #[doc = ""]
    #[doc = "\t\tEach element specified in *keys* is sequentially deleted. The"]
    #[doc = "\t\t*in_batch*, *out_batch*, and *values* parameters are ignored"]
    #[doc = "\t\tand should be zeroed."]
    #[doc = ""]
    #[doc = "\t\tThe *elem_flags* argument may be specified as one of the"]
    #[doc = "\t\tfollowing:"]
    #[doc = ""]
    #[doc = "\t\t**BPF_F_LOCK**"]
    #[doc = "\t\t\tLook up the value of a spin-locked map without"]
    #[doc = "\t\t\treturning the lock. This must be specified if the"]
    #[doc = "\t\t\telements contain a spinlock."]
    #[doc = ""]
    #[doc = "\t\tOn success, *count* elements from the map are updated."]
    #[doc = ""]
    #[doc = "\t\tIf an error is returned and *errno* is not **EFAULT**, *count*"]
    #[doc = "\t\tis set to the number of successfully processed elements. If"]
    #[doc = "\t\t*errno* is **EFAULT**, up to *count* elements may be been"]
    #[doc = "\t\tdeleted."]
    #[doc = ""]
    #[doc = "\tReturn"]
    #[doc = "\t\tReturns zero on success. On error, -1 is returned and *errno*"]
    #[doc = "\t\tis set appropriately."]
    #[doc = ""]
    #[doc = " BPF_LINK_CREATE"]
    #[doc = "\tDescription"]
    #[doc = "\t\tAttach an eBPF program to a *target_fd* at the specified"]
    #[doc = "\t\t*attach_type* hook and return a file descriptor handle for"]
    #[doc = "\t\tmanaging the link."]
    #[doc = ""]
    #[doc = "\tReturn"]
    #[doc = "\t\tA new file descriptor (a nonnegative integer), or -1 if an"]
    #[doc = "\t\terror occurred (in which case, *errno* is set appropriately)."]
    #[doc = ""]
    #[doc = " BPF_LINK_UPDATE"]
    #[doc = "\tDescription"]
    #[doc = "\t\tUpdate the eBPF program in the specified *link_fd* to"]
    #[doc = "\t\t*new_prog_fd*."]
    #[doc = ""]
    #[doc = "\tReturn"]
    #[doc = "\t\tReturns zero on success. On error, -1 is returned and *errno*"]
    #[doc = "\t\tis set appropriately."]
    #[doc = ""]
    #[doc = " BPF_LINK_GET_FD_BY_ID"]
    #[doc = "\tDescription"]
    #[doc = "\t\tOpen a file descriptor for the eBPF Link corresponding to"]
    #[doc = "\t\t*link_id*."]
    #[doc = ""]
    #[doc = "\tReturn"]
    #[doc = "\t\tA new file descriptor (a nonnegative integer), or -1 if an"]
    #[doc = "\t\terror occurred (in which case, *errno* is set appropriately)."]
    #[doc = ""]
    #[doc = " BPF_LINK_GET_NEXT_ID"]
    #[doc = "\tDescription"]
    #[doc = "\t\tFetch the next eBPF link currently loaded into the kernel."]
    #[doc = ""]
    #[doc = "\t\tLooks for the eBPF link with an id greater than *start_id*"]
    #[doc = "\t\tand updates *next_id* on success. If no other eBPF links"]
    #[doc = "\t\tremain with ids higher than *start_id*, returns -1 and sets"]
    #[doc = "\t\t*errno* to **ENOENT**."]
    #[doc = ""]
    #[doc = "\tReturn"]
    #[doc = "\t\tReturns zero on success. On error, or when no id remains, -1"]
    #[doc = "\t\tis returned and *errno* is set appropriately."]
    #[doc = ""]
    #[doc = " BPF_ENABLE_STATS"]
    #[doc = "\tDescription"]
    #[doc = "\t\tEnable eBPF runtime statistics gathering."]
    #[doc = ""]
    #[doc = "\t\tRuntime statistics gathering for the eBPF runtime is disabled"]
    #[doc = "\t\tby default to minimize the corresponding performance overhead."]
    #[doc = "\t\tThis command enables statistics globally."]
    #[doc = ""]
    #[doc = "\t\tMultiple programs may independently enable statistics."]
    #[doc = "\t\tAfter gathering the desired statistics, eBPF runtime statistics"]
    #[doc = "\t\tmay be disabled again by calling **close**\\ (2) for the file"]
    #[doc = "\t\tdescriptor returned by this function. Statistics will only be"]
    #[doc = "\t\tdisabled system-wide when all outstanding file descriptors"]
    #[doc = "\t\treturned by prior calls for this subcommand are closed."]
    #[doc = ""]
    #[doc = "\tReturn"]
    #[doc = "\t\tA new file descriptor (a nonnegative integer), or -1 if an"]
    #[doc = "\t\terror occurred (in which case, *errno* is set appropriately)."]
    #[doc = ""]
    #[doc = " BPF_ITER_CREATE"]
    #[doc = "\tDescription"]
    #[doc = "\t\tCreate an iterator on top of the specified *link_fd* (as"]
    #[doc = "\t\tpreviously created using **BPF_LINK_CREATE**) and return a"]
    #[doc = "\t\tfile descriptor that can be used to trigger the iteration."]
    #[doc = ""]
    #[doc = "\t\tIf the resulting file descriptor is pinned to the filesystem"]
    #[doc = "\t\tusing  **BPF_OBJ_PIN**, then subsequent **read**\\ (2) syscalls"]
    #[doc = "\t\tfor that path will trigger the iterator to read kernel state"]
    #[doc = "\t\tusing the eBPF program attached to *link_fd*."]
    #[doc = ""]
    #[doc = "\tReturn"]
    #[doc = "\t\tA new file descriptor (a nonnegative integer), or -1 if an"]
    #[doc = "\t\terror occurred (in which case, *errno* is set appropriately)."]
    #[doc = ""]
    #[doc = " BPF_LINK_DETACH"]
    #[doc = "\tDescription"]
    #[doc = "\t\tForcefully detach the specified *link_fd* from its"]
    #[doc = "\t\tcorresponding attachment point."]
    #[doc = ""]
    #[doc = "\tReturn"]
    #[doc = "\t\tReturns zero on success. On error, -1 is returned and *errno*"]
    #[doc = "\t\tis set appropriately."]
    #[doc = ""]
    #[doc = " BPF_PROG_BIND_MAP"]
    #[doc = "\tDescription"]
    #[doc = "\t\tBind a map to the lifetime of an eBPF program."]
    #[doc = ""]
    #[doc = "\t\tThe map identified by *map_fd* is bound to the program"]
    #[doc = "\t\tidentified by *prog_fd* and only released when *prog_fd* is"]
    #[doc = "\t\treleased. This may be used in cases where metadata should be"]
    #[doc = "\t\tassociated with a program which otherwise does not contain any"]
    #[doc = "\t\treferences to the map (for example, embedded in the eBPF"]
    #[doc = "\t\tprogram instructions)."]
    #[doc = ""]
    #[doc = "\tReturn"]
    #[doc = "\t\tReturns zero on success. On error, -1 is returned and *errno*"]
    #[doc = "\t\tis set appropriately."]
    #[doc = ""]
    #[doc = " NOTES"]
    #[doc = "\teBPF objects (maps and programs) can be shared between processes."]
    #[doc = ""]
    #[doc = "\t* After **fork**\\ (2), the child inherits file descriptors"]
    #[doc = "\t  referring to the same eBPF objects."]
    #[doc = "\t* File descriptors referring to eBPF objects can be transferred over"]
    #[doc = "\t  **unix**\\ (7) domain sockets."]
    #[doc = "\t* File descriptors referring to eBPF objects can be duplicated in the"]
    #[doc = "\t  usual way, using **dup**\\ (2) and similar calls."]
    #[doc = "\t* File descriptors referring to eBPF objects can be pinned to the"]
    #[doc = "\t  filesystem using the **BPF_OBJ_PIN** command of **bpf**\\ (2)."]
    #[doc = ""]
    #[doc = "\tAn eBPF object is deallocated only after all file descriptors referring"]
    #[doc = "\tto the object have been closed and no references remain pinned to the"]
    #[doc = "\tfilesystem or attached (for example, bound to a program or device)."]
    pub type bpf_cmd = ::cty::c_uint;
    pub const bpf_map_type_BPF_MAP_TYPE_UNSPEC: bpf_map_type = 0;
    pub const bpf_map_type_BPF_MAP_TYPE_HASH: bpf_map_type = 1;
    pub const bpf_map_type_BPF_MAP_TYPE_ARRAY: bpf_map_type = 2;
    pub const bpf_map_type_BPF_MAP_TYPE_PROG_ARRAY: bpf_map_type = 3;
    pub const bpf_map_type_BPF_MAP_TYPE_PERF_EVENT_ARRAY: bpf_map_type = 4;
    pub const bpf_map_type_BPF_MAP_TYPE_PERCPU_HASH: bpf_map_type = 5;
    pub const bpf_map_type_BPF_MAP_TYPE_PERCPU_ARRAY: bpf_map_type = 6;
    pub const bpf_map_type_BPF_MAP_TYPE_STACK_TRACE: bpf_map_type = 7;
    pub const bpf_map_type_BPF_MAP_TYPE_CGROUP_ARRAY: bpf_map_type = 8;
    pub const bpf_map_type_BPF_MAP_TYPE_LRU_HASH: bpf_map_type = 9;
    pub const bpf_map_type_BPF_MAP_TYPE_LRU_PERCPU_HASH: bpf_map_type = 10;
    pub const bpf_map_type_BPF_MAP_TYPE_LPM_TRIE: bpf_map_type = 11;
    pub const bpf_map_type_BPF_MAP_TYPE_ARRAY_OF_MAPS: bpf_map_type = 12;
    pub const bpf_map_type_BPF_MAP_TYPE_HASH_OF_MAPS: bpf_map_type = 13;
    pub const bpf_map_type_BPF_MAP_TYPE_DEVMAP: bpf_map_type = 14;
    pub const bpf_map_type_BPF_MAP_TYPE_SOCKMAP: bpf_map_type = 15;
    pub const bpf_map_type_BPF_MAP_TYPE_CPUMAP: bpf_map_type = 16;
    pub const bpf_map_type_BPF_MAP_TYPE_XSKMAP: bpf_map_type = 17;
    pub const bpf_map_type_BPF_MAP_TYPE_SOCKHASH: bpf_map_type = 18;
    pub const bpf_map_type_BPF_MAP_TYPE_CGROUP_STORAGE_DEPRECATED: bpf_map_type = 19;
    pub const bpf_map_type_BPF_MAP_TYPE_CGROUP_STORAGE: bpf_map_type = 19;
    pub const bpf_map_type_BPF_MAP_TYPE_REUSEPORT_SOCKARRAY: bpf_map_type = 20;
    pub const bpf_map_type_BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE: bpf_map_type = 21;
    pub const bpf_map_type_BPF_MAP_TYPE_QUEUE: bpf_map_type = 22;
    pub const bpf_map_type_BPF_MAP_TYPE_STACK: bpf_map_type = 23;
    pub const bpf_map_type_BPF_MAP_TYPE_SK_STORAGE: bpf_map_type = 24;
    pub const bpf_map_type_BPF_MAP_TYPE_DEVMAP_HASH: bpf_map_type = 25;
    pub const bpf_map_type_BPF_MAP_TYPE_STRUCT_OPS: bpf_map_type = 26;
    pub const bpf_map_type_BPF_MAP_TYPE_RINGBUF: bpf_map_type = 27;
    pub const bpf_map_type_BPF_MAP_TYPE_INODE_STORAGE: bpf_map_type = 28;
    pub const bpf_map_type_BPF_MAP_TYPE_TASK_STORAGE: bpf_map_type = 29;
    pub const bpf_map_type_BPF_MAP_TYPE_BLOOM_FILTER: bpf_map_type = 30;
    pub const bpf_map_type_BPF_MAP_TYPE_USER_RINGBUF: bpf_map_type = 31;
    pub const bpf_map_type_BPF_MAP_TYPE_CGRP_STORAGE: bpf_map_type = 32;
    pub type bpf_map_type = ::cty::c_uint;
    pub const bpf_prog_type_BPF_PROG_TYPE_UNSPEC: bpf_prog_type = 0;
    pub const bpf_prog_type_BPF_PROG_TYPE_SOCKET_FILTER: bpf_prog_type = 1;
    pub const bpf_prog_type_BPF_PROG_TYPE_KPROBE: bpf_prog_type = 2;
    pub const bpf_prog_type_BPF_PROG_TYPE_SCHED_CLS: bpf_prog_type = 3;
    pub const bpf_prog_type_BPF_PROG_TYPE_SCHED_ACT: bpf_prog_type = 4;
    pub const bpf_prog_type_BPF_PROG_TYPE_TRACEPOINT: bpf_prog_type = 5;
    pub const bpf_prog_type_BPF_PROG_TYPE_XDP: bpf_prog_type = 6;
    pub const bpf_prog_type_BPF_PROG_TYPE_PERF_EVENT: bpf_prog_type = 7;
    pub const bpf_prog_type_BPF_PROG_TYPE_CGROUP_SKB: bpf_prog_type = 8;
    pub const bpf_prog_type_BPF_PROG_TYPE_CGROUP_SOCK: bpf_prog_type = 9;
    pub const bpf_prog_type_BPF_PROG_TYPE_LWT_IN: bpf_prog_type = 10;
    pub const bpf_prog_type_BPF_PROG_TYPE_LWT_OUT: bpf_prog_type = 11;
    pub const bpf_prog_type_BPF_PROG_TYPE_LWT_XMIT: bpf_prog_type = 12;
    pub const bpf_prog_type_BPF_PROG_TYPE_SOCK_OPS: bpf_prog_type = 13;
    pub const bpf_prog_type_BPF_PROG_TYPE_SK_SKB: bpf_prog_type = 14;
    pub const bpf_prog_type_BPF_PROG_TYPE_CGROUP_DEVICE: bpf_prog_type = 15;
    pub const bpf_prog_type_BPF_PROG_TYPE_SK_MSG: bpf_prog_type = 16;
    pub const bpf_prog_type_BPF_PROG_TYPE_RAW_TRACEPOINT: bpf_prog_type = 17;
    pub const bpf_prog_type_BPF_PROG_TYPE_CGROUP_SOCK_ADDR: bpf_prog_type = 18;
    pub const bpf_prog_type_BPF_PROG_TYPE_LWT_SEG6LOCAL: bpf_prog_type = 19;
    pub const bpf_prog_type_BPF_PROG_TYPE_LIRC_MODE2: bpf_prog_type = 20;
    pub const bpf_prog_type_BPF_PROG_TYPE_SK_REUSEPORT: bpf_prog_type = 21;
    pub const bpf_prog_type_BPF_PROG_TYPE_FLOW_DISSECTOR: bpf_prog_type = 22;
    pub const bpf_prog_type_BPF_PROG_TYPE_CGROUP_SYSCTL: bpf_prog_type = 23;
    pub const bpf_prog_type_BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE: bpf_prog_type = 24;
    pub const bpf_prog_type_BPF_PROG_TYPE_CGROUP_SOCKOPT: bpf_prog_type = 25;
    pub const bpf_prog_type_BPF_PROG_TYPE_TRACING: bpf_prog_type = 26;
    pub const bpf_prog_type_BPF_PROG_TYPE_STRUCT_OPS: bpf_prog_type = 27;
    pub const bpf_prog_type_BPF_PROG_TYPE_EXT: bpf_prog_type = 28;
    pub const bpf_prog_type_BPF_PROG_TYPE_LSM: bpf_prog_type = 29;
    pub const bpf_prog_type_BPF_PROG_TYPE_SK_LOOKUP: bpf_prog_type = 30;
    pub const bpf_prog_type_BPF_PROG_TYPE_SYSCALL: bpf_prog_type = 31;
    pub const bpf_prog_type_BPF_PROG_TYPE_NETFILTER: bpf_prog_type = 32;
    pub type bpf_prog_type = ::cty::c_uint;
    pub const bpf_attach_type_BPF_CGROUP_INET_INGRESS: bpf_attach_type = 0;
    pub const bpf_attach_type_BPF_CGROUP_INET_EGRESS: bpf_attach_type = 1;
    pub const bpf_attach_type_BPF_CGROUP_INET_SOCK_CREATE: bpf_attach_type = 2;
    pub const bpf_attach_type_BPF_CGROUP_SOCK_OPS: bpf_attach_type = 3;
    pub const bpf_attach_type_BPF_SK_SKB_STREAM_PARSER: bpf_attach_type = 4;
    pub const bpf_attach_type_BPF_SK_SKB_STREAM_VERDICT: bpf_attach_type = 5;
    pub const bpf_attach_type_BPF_CGROUP_DEVICE: bpf_attach_type = 6;
    pub const bpf_attach_type_BPF_SK_MSG_VERDICT: bpf_attach_type = 7;
    pub const bpf_attach_type_BPF_CGROUP_INET4_BIND: bpf_attach_type = 8;
    pub const bpf_attach_type_BPF_CGROUP_INET6_BIND: bpf_attach_type = 9;
    pub const bpf_attach_type_BPF_CGROUP_INET4_CONNECT: bpf_attach_type = 10;
    pub const bpf_attach_type_BPF_CGROUP_INET6_CONNECT: bpf_attach_type = 11;
    pub const bpf_attach_type_BPF_CGROUP_INET4_POST_BIND: bpf_attach_type = 12;
    pub const bpf_attach_type_BPF_CGROUP_INET6_POST_BIND: bpf_attach_type = 13;
    pub const bpf_attach_type_BPF_CGROUP_UDP4_SENDMSG: bpf_attach_type = 14;
    pub const bpf_attach_type_BPF_CGROUP_UDP6_SENDMSG: bpf_attach_type = 15;
    pub const bpf_attach_type_BPF_LIRC_MODE2: bpf_attach_type = 16;
    pub const bpf_attach_type_BPF_FLOW_DISSECTOR: bpf_attach_type = 17;
    pub const bpf_attach_type_BPF_CGROUP_SYSCTL: bpf_attach_type = 18;
    pub const bpf_attach_type_BPF_CGROUP_UDP4_RECVMSG: bpf_attach_type = 19;
    pub const bpf_attach_type_BPF_CGROUP_UDP6_RECVMSG: bpf_attach_type = 20;
    pub const bpf_attach_type_BPF_CGROUP_GETSOCKOPT: bpf_attach_type = 21;
    pub const bpf_attach_type_BPF_CGROUP_SETSOCKOPT: bpf_attach_type = 22;
    pub const bpf_attach_type_BPF_TRACE_RAW_TP: bpf_attach_type = 23;
    pub const bpf_attach_type_BPF_TRACE_FENTRY: bpf_attach_type = 24;
    pub const bpf_attach_type_BPF_TRACE_FEXIT: bpf_attach_type = 25;
    pub const bpf_attach_type_BPF_MODIFY_RETURN: bpf_attach_type = 26;
    pub const bpf_attach_type_BPF_LSM_MAC: bpf_attach_type = 27;
    pub const bpf_attach_type_BPF_TRACE_ITER: bpf_attach_type = 28;
    pub const bpf_attach_type_BPF_CGROUP_INET4_GETPEERNAME: bpf_attach_type = 29;
    pub const bpf_attach_type_BPF_CGROUP_INET6_GETPEERNAME: bpf_attach_type = 30;
    pub const bpf_attach_type_BPF_CGROUP_INET4_GETSOCKNAME: bpf_attach_type = 31;
    pub const bpf_attach_type_BPF_CGROUP_INET6_GETSOCKNAME: bpf_attach_type = 32;
    pub const bpf_attach_type_BPF_XDP_DEVMAP: bpf_attach_type = 33;
    pub const bpf_attach_type_BPF_CGROUP_INET_SOCK_RELEASE: bpf_attach_type = 34;
    pub const bpf_attach_type_BPF_XDP_CPUMAP: bpf_attach_type = 35;
    pub const bpf_attach_type_BPF_SK_LOOKUP: bpf_attach_type = 36;
    pub const bpf_attach_type_BPF_XDP: bpf_attach_type = 37;
    pub const bpf_attach_type_BPF_SK_SKB_VERDICT: bpf_attach_type = 38;
    pub const bpf_attach_type_BPF_SK_REUSEPORT_SELECT: bpf_attach_type = 39;
    pub const bpf_attach_type_BPF_SK_REUSEPORT_SELECT_OR_MIGRATE: bpf_attach_type = 40;
    pub const bpf_attach_type_BPF_PERF_EVENT: bpf_attach_type = 41;
    pub const bpf_attach_type_BPF_TRACE_KPROBE_MULTI: bpf_attach_type = 42;
    pub const bpf_attach_type_BPF_LSM_CGROUP: bpf_attach_type = 43;
    pub const bpf_attach_type_BPF_STRUCT_OPS: bpf_attach_type = 44;
    pub const bpf_attach_type_BPF_NETFILTER: bpf_attach_type = 45;
    pub const bpf_attach_type___MAX_BPF_ATTACH_TYPE: bpf_attach_type = 46;
    pub type bpf_attach_type = ::cty::c_uint;
    pub const bpf_link_type_BPF_LINK_TYPE_UNSPEC: bpf_link_type = 0;
    pub const bpf_link_type_BPF_LINK_TYPE_RAW_TRACEPOINT: bpf_link_type = 1;
    pub const bpf_link_type_BPF_LINK_TYPE_TRACING: bpf_link_type = 2;
    pub const bpf_link_type_BPF_LINK_TYPE_CGROUP: bpf_link_type = 3;
    pub const bpf_link_type_BPF_LINK_TYPE_ITER: bpf_link_type = 4;
    pub const bpf_link_type_BPF_LINK_TYPE_NETNS: bpf_link_type = 5;
    pub const bpf_link_type_BPF_LINK_TYPE_XDP: bpf_link_type = 6;
    pub const bpf_link_type_BPF_LINK_TYPE_PERF_EVENT: bpf_link_type = 7;
    pub const bpf_link_type_BPF_LINK_TYPE_KPROBE_MULTI: bpf_link_type = 8;
    pub const bpf_link_type_BPF_LINK_TYPE_STRUCT_OPS: bpf_link_type = 9;
    pub const bpf_link_type_BPF_LINK_TYPE_NETFILTER: bpf_link_type = 10;
    pub const bpf_link_type_MAX_BPF_LINK_TYPE: bpf_link_type = 11;
    pub type bpf_link_type = ::cty::c_uint;
    pub const BPF_ANY: ::cty::c_uint = 0;
    pub const BPF_NOEXIST: ::cty::c_uint = 1;
    pub const BPF_EXIST: ::cty::c_uint = 2;
    pub const BPF_F_LOCK: ::cty::c_uint = 4;
    pub type _bindgen_ty_6 = ::cty::c_uint;
    pub const BPF_F_NO_PREALLOC: ::cty::c_uint = 1;
    pub const BPF_F_NO_COMMON_LRU: ::cty::c_uint = 2;
    pub const BPF_F_NUMA_NODE: ::cty::c_uint = 4;
    pub const BPF_F_RDONLY: ::cty::c_uint = 8;
    pub const BPF_F_WRONLY: ::cty::c_uint = 16;
    pub const BPF_F_STACK_BUILD_ID: ::cty::c_uint = 32;
    pub const BPF_F_ZERO_SEED: ::cty::c_uint = 64;
    pub const BPF_F_RDONLY_PROG: ::cty::c_uint = 128;
    pub const BPF_F_WRONLY_PROG: ::cty::c_uint = 256;
    pub const BPF_F_CLONE: ::cty::c_uint = 512;
    pub const BPF_F_MMAPABLE: ::cty::c_uint = 1024;
    pub const BPF_F_PRESERVE_ELEMS: ::cty::c_uint = 2048;
    pub const BPF_F_INNER_MAP: ::cty::c_uint = 4096;
    pub const BPF_F_LINK: ::cty::c_uint = 8192;
    pub const BPF_F_PATH_FD: ::cty::c_uint = 16384;
    pub type _bindgen_ty_7 = ::cty::c_uint;
    pub const bpf_stats_type_BPF_STATS_RUN_TIME: bpf_stats_type = 0;
    pub type bpf_stats_type = ::cty::c_uint;
    pub const bpf_stack_build_id_status_BPF_STACK_BUILD_ID_EMPTY: bpf_stack_build_id_status = 0;
    pub const bpf_stack_build_id_status_BPF_STACK_BUILD_ID_VALID: bpf_stack_build_id_status = 1;
    pub const bpf_stack_build_id_status_BPF_STACK_BUILD_ID_IP: bpf_stack_build_id_status = 2;
    pub type bpf_stack_build_id_status = ::cty::c_uint;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct bpf_stack_build_id {
        pub status: __s32,
        pub build_id: [::cty::c_uchar; 20usize],
        pub __bindgen_anon_1: bpf_stack_build_id__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union bpf_stack_build_id__bindgen_ty_1 {
        pub offset: __u64,
        pub ip: __u64,
    }
    #[test]
    fn bindgen_test_layout_bpf_stack_build_id__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<bpf_stack_build_id__bindgen_ty_1>(),
            8usize,
            concat!("Size of: ", stringify!(bpf_stack_build_id__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_stack_build_id__bindgen_ty_1>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(bpf_stack_build_id__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_stack_build_id__bindgen_ty_1>())).offset as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_stack_build_id__bindgen_ty_1),
                "::",
                stringify!(offset)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_stack_build_id__bindgen_ty_1>())).ip as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_stack_build_id__bindgen_ty_1),
                "::",
                stringify!(ip)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_bpf_stack_build_id() {
        assert_eq!(
            ::core::mem::size_of::<bpf_stack_build_id>(),
            32usize,
            concat!("Size of: ", stringify!(bpf_stack_build_id))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_stack_build_id>(),
            8usize,
            concat!("Alignment of ", stringify!(bpf_stack_build_id))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_stack_build_id>())).status as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_stack_build_id),
                "::",
                stringify!(status)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_stack_build_id>())).build_id as *const _ as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_stack_build_id),
                "::",
                stringify!(build_id)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union bpf_attr {
        pub __bindgen_anon_1: bpf_attr__bindgen_ty_1,
        pub __bindgen_anon_2: bpf_attr__bindgen_ty_2,
        pub batch: bpf_attr__bindgen_ty_3,
        pub __bindgen_anon_3: bpf_attr__bindgen_ty_4,
        pub __bindgen_anon_4: bpf_attr__bindgen_ty_5,
        pub __bindgen_anon_5: bpf_attr__bindgen_ty_6,
        pub test: bpf_attr__bindgen_ty_7,
        pub __bindgen_anon_6: bpf_attr__bindgen_ty_8,
        pub info: bpf_attr__bindgen_ty_9,
        pub query: bpf_attr__bindgen_ty_10,
        pub raw_tracepoint: bpf_attr__bindgen_ty_11,
        pub __bindgen_anon_7: bpf_attr__bindgen_ty_12,
        pub task_fd_query: bpf_attr__bindgen_ty_13,
        pub link_create: bpf_attr__bindgen_ty_14,
        pub link_update: bpf_attr__bindgen_ty_15,
        pub link_detach: bpf_attr__bindgen_ty_16,
        pub enable_stats: bpf_attr__bindgen_ty_17,
        pub iter_create: bpf_attr__bindgen_ty_18,
        pub prog_bind_map: bpf_attr__bindgen_ty_19,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_attr__bindgen_ty_1 {
        pub map_type: __u32,
        pub key_size: __u32,
        pub value_size: __u32,
        pub max_entries: __u32,
        pub map_flags: __u32,
        pub inner_map_fd: __u32,
        pub numa_node: __u32,
        pub map_name: [::cty::c_char; 16usize],
        pub map_ifindex: __u32,
        pub btf_fd: __u32,
        pub btf_key_type_id: __u32,
        pub btf_value_type_id: __u32,
        pub btf_vmlinux_value_type_id: __u32,
        pub map_extra: __u64,
    }
    #[test]
    fn bindgen_test_layout_bpf_attr__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<bpf_attr__bindgen_ty_1>(),
            72usize,
            concat!("Size of: ", stringify!(bpf_attr__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_attr__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(bpf_attr__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_1>())).map_type as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_1),
                "::",
                stringify!(map_type)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_1>())).key_size as *const _ as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_1),
                "::",
                stringify!(key_size)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_1>())).value_size as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_1),
                "::",
                stringify!(value_size)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_1>())).max_entries as *const _ as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_1),
                "::",
                stringify!(max_entries)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_1>())).map_flags as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_1),
                "::",
                stringify!(map_flags)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_1>())).inner_map_fd as *const _
                    as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_1),
                "::",
                stringify!(inner_map_fd)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_1>())).numa_node as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_1),
                "::",
                stringify!(numa_node)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_1>())).map_name as *const _ as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_1),
                "::",
                stringify!(map_name)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_1>())).map_ifindex as *const _ as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_1),
                "::",
                stringify!(map_ifindex)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_1>())).btf_fd as *const _ as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_1),
                "::",
                stringify!(btf_fd)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_1>())).btf_key_type_id as *const _
                    as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_1),
                "::",
                stringify!(btf_key_type_id)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_1>())).btf_value_type_id as *const _
                    as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_1),
                "::",
                stringify!(btf_value_type_id)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_1>())).btf_vmlinux_value_type_id
                    as *const _ as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_1),
                "::",
                stringify!(btf_vmlinux_value_type_id)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_1>())).map_extra as *const _ as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_1),
                "::",
                stringify!(map_extra)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct bpf_attr__bindgen_ty_2 {
        pub map_fd: __u32,
        pub key: __u64,
        pub __bindgen_anon_1: bpf_attr__bindgen_ty_2__bindgen_ty_1,
        pub flags: __u64,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union bpf_attr__bindgen_ty_2__bindgen_ty_1 {
        pub value: __u64,
        pub next_key: __u64,
    }
    #[test]
    fn bindgen_test_layout_bpf_attr__bindgen_ty_2__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<bpf_attr__bindgen_ty_2__bindgen_ty_1>(),
            8usize,
            concat!(
                "Size of: ",
                stringify!(bpf_attr__bindgen_ty_2__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_attr__bindgen_ty_2__bindgen_ty_1>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(bpf_attr__bindgen_ty_2__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_2__bindgen_ty_1>())).value as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_2__bindgen_ty_1),
                "::",
                stringify!(value)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_2__bindgen_ty_1>())).next_key
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_2__bindgen_ty_1),
                "::",
                stringify!(next_key)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_bpf_attr__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<bpf_attr__bindgen_ty_2>(),
            32usize,
            concat!("Size of: ", stringify!(bpf_attr__bindgen_ty_2))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_attr__bindgen_ty_2>(),
            8usize,
            concat!("Alignment of ", stringify!(bpf_attr__bindgen_ty_2))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_2>())).map_fd as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_2),
                "::",
                stringify!(map_fd)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_attr__bindgen_ty_2>())).key as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_2),
                "::",
                stringify!(key)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_2>())).flags as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_2),
                "::",
                stringify!(flags)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_attr__bindgen_ty_3 {
        pub in_batch: __u64,
        pub out_batch: __u64,
        pub keys: __u64,
        pub values: __u64,
        pub count: __u32,
        pub map_fd: __u32,
        pub elem_flags: __u64,
        pub flags: __u64,
    }
    #[test]
    fn bindgen_test_layout_bpf_attr__bindgen_ty_3() {
        assert_eq!(
            ::core::mem::size_of::<bpf_attr__bindgen_ty_3>(),
            56usize,
            concat!("Size of: ", stringify!(bpf_attr__bindgen_ty_3))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_attr__bindgen_ty_3>(),
            8usize,
            concat!("Alignment of ", stringify!(bpf_attr__bindgen_ty_3))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_3>())).in_batch as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_3),
                "::",
                stringify!(in_batch)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_3>())).out_batch as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_3),
                "::",
                stringify!(out_batch)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_3>())).keys as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_3),
                "::",
                stringify!(keys)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_3>())).values as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_3),
                "::",
                stringify!(values)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_3>())).count as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_3),
                "::",
                stringify!(count)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_3>())).map_fd as *const _ as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_3),
                "::",
                stringify!(map_fd)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_3>())).elem_flags as *const _ as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_3),
                "::",
                stringify!(elem_flags)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_3>())).flags as *const _ as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_3),
                "::",
                stringify!(flags)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct bpf_attr__bindgen_ty_4 {
        pub prog_type: __u32,
        pub insn_cnt: __u32,
        pub insns: __u64,
        pub license: __u64,
        pub log_level: __u32,
        pub log_size: __u32,
        pub log_buf: __u64,
        pub kern_version: __u32,
        pub prog_flags: __u32,
        pub prog_name: [::cty::c_char; 16usize],
        pub prog_ifindex: __u32,
        pub expected_attach_type: __u32,
        pub prog_btf_fd: __u32,
        pub func_info_rec_size: __u32,
        pub func_info: __u64,
        pub func_info_cnt: __u32,
        pub line_info_rec_size: __u32,
        pub line_info: __u64,
        pub line_info_cnt: __u32,
        pub attach_btf_id: __u32,
        pub __bindgen_anon_1: bpf_attr__bindgen_ty_4__bindgen_ty_1,
        pub core_relo_cnt: __u32,
        pub fd_array: __u64,
        pub core_relos: __u64,
        pub core_relo_rec_size: __u32,
        pub log_true_size: __u32,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union bpf_attr__bindgen_ty_4__bindgen_ty_1 {
        pub attach_prog_fd: __u32,
        pub attach_btf_obj_fd: __u32,
    }
    #[test]
    fn bindgen_test_layout_bpf_attr__bindgen_ty_4__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<bpf_attr__bindgen_ty_4__bindgen_ty_1>(),
            4usize,
            concat!(
                "Size of: ",
                stringify!(bpf_attr__bindgen_ty_4__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_attr__bindgen_ty_4__bindgen_ty_1>(),
            4usize,
            concat!(
                "Alignment of ",
                stringify!(bpf_attr__bindgen_ty_4__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_4__bindgen_ty_1>())).attach_prog_fd
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_4__bindgen_ty_1),
                "::",
                stringify!(attach_prog_fd)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_4__bindgen_ty_1>())).attach_btf_obj_fd
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_4__bindgen_ty_1),
                "::",
                stringify!(attach_btf_obj_fd)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_bpf_attr__bindgen_ty_4() {
        assert_eq!(
            ::core::mem::size_of::<bpf_attr__bindgen_ty_4>(),
            144usize,
            concat!("Size of: ", stringify!(bpf_attr__bindgen_ty_4))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_attr__bindgen_ty_4>(),
            8usize,
            concat!("Alignment of ", stringify!(bpf_attr__bindgen_ty_4))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_4>())).prog_type as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_4),
                "::",
                stringify!(prog_type)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_4>())).insn_cnt as *const _ as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_4),
                "::",
                stringify!(insn_cnt)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_4>())).insns as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_4),
                "::",
                stringify!(insns)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_4>())).license as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_4),
                "::",
                stringify!(license)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_4>())).log_level as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_4),
                "::",
                stringify!(log_level)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_4>())).log_size as *const _ as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_4),
                "::",
                stringify!(log_size)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_4>())).log_buf as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_4),
                "::",
                stringify!(log_buf)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_4>())).kern_version as *const _
                    as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_4),
                "::",
                stringify!(kern_version)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_4>())).prog_flags as *const _ as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_4),
                "::",
                stringify!(prog_flags)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_4>())).prog_name as *const _ as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_4),
                "::",
                stringify!(prog_name)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_4>())).prog_ifindex as *const _
                    as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_4),
                "::",
                stringify!(prog_ifindex)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_4>())).expected_attach_type as *const _
                    as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_4),
                "::",
                stringify!(expected_attach_type)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_4>())).prog_btf_fd as *const _ as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_4),
                "::",
                stringify!(prog_btf_fd)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_4>())).func_info_rec_size as *const _
                    as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_4),
                "::",
                stringify!(func_info_rec_size)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_4>())).func_info as *const _ as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_4),
                "::",
                stringify!(func_info)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_4>())).func_info_cnt as *const _
                    as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_4),
                "::",
                stringify!(func_info_cnt)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_4>())).line_info_rec_size as *const _
                    as usize
            },
            92usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_4),
                "::",
                stringify!(line_info_rec_size)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_4>())).line_info as *const _ as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_4),
                "::",
                stringify!(line_info)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_4>())).line_info_cnt as *const _
                    as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_4),
                "::",
                stringify!(line_info_cnt)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_4>())).attach_btf_id as *const _
                    as usize
            },
            108usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_4),
                "::",
                stringify!(attach_btf_id)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_4>())).core_relo_cnt as *const _
                    as usize
            },
            116usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_4),
                "::",
                stringify!(core_relo_cnt)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_4>())).fd_array as *const _ as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_4),
                "::",
                stringify!(fd_array)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_4>())).core_relos as *const _ as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_4),
                "::",
                stringify!(core_relos)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_4>())).core_relo_rec_size as *const _
                    as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_4),
                "::",
                stringify!(core_relo_rec_size)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_4>())).log_true_size as *const _
                    as usize
            },
            140usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_4),
                "::",
                stringify!(log_true_size)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_attr__bindgen_ty_5 {
        pub pathname: __u64,
        pub bpf_fd: __u32,
        pub file_flags: __u32,
        pub path_fd: __s32,
    }
    #[test]
    fn bindgen_test_layout_bpf_attr__bindgen_ty_5() {
        assert_eq!(
            ::core::mem::size_of::<bpf_attr__bindgen_ty_5>(),
            24usize,
            concat!("Size of: ", stringify!(bpf_attr__bindgen_ty_5))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_attr__bindgen_ty_5>(),
            8usize,
            concat!("Alignment of ", stringify!(bpf_attr__bindgen_ty_5))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_5>())).pathname as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_5),
                "::",
                stringify!(pathname)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_5>())).bpf_fd as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_5),
                "::",
                stringify!(bpf_fd)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_5>())).file_flags as *const _ as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_5),
                "::",
                stringify!(file_flags)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_5>())).path_fd as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_5),
                "::",
                stringify!(path_fd)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_attr__bindgen_ty_6 {
        pub target_fd: __u32,
        pub attach_bpf_fd: __u32,
        pub attach_type: __u32,
        pub attach_flags: __u32,
        pub replace_bpf_fd: __u32,
    }
    #[test]
    fn bindgen_test_layout_bpf_attr__bindgen_ty_6() {
        assert_eq!(
            ::core::mem::size_of::<bpf_attr__bindgen_ty_6>(),
            20usize,
            concat!("Size of: ", stringify!(bpf_attr__bindgen_ty_6))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_attr__bindgen_ty_6>(),
            4usize,
            concat!("Alignment of ", stringify!(bpf_attr__bindgen_ty_6))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_6>())).target_fd as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_6),
                "::",
                stringify!(target_fd)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_6>())).attach_bpf_fd as *const _
                    as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_6),
                "::",
                stringify!(attach_bpf_fd)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_6>())).attach_type as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_6),
                "::",
                stringify!(attach_type)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_6>())).attach_flags as *const _
                    as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_6),
                "::",
                stringify!(attach_flags)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_6>())).replace_bpf_fd as *const _
                    as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_6),
                "::",
                stringify!(replace_bpf_fd)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_attr__bindgen_ty_7 {
        pub prog_fd: __u32,
        pub retval: __u32,
        pub data_size_in: __u32,
        pub data_size_out: __u32,
        pub data_in: __u64,
        pub data_out: __u64,
        pub repeat: __u32,
        pub duration: __u32,
        pub ctx_size_in: __u32,
        pub ctx_size_out: __u32,
        pub ctx_in: __u64,
        pub ctx_out: __u64,
        pub flags: __u32,
        pub cpu: __u32,
        pub batch_size: __u32,
    }
    #[test]
    fn bindgen_test_layout_bpf_attr__bindgen_ty_7() {
        assert_eq!(
            ::core::mem::size_of::<bpf_attr__bindgen_ty_7>(),
            80usize,
            concat!("Size of: ", stringify!(bpf_attr__bindgen_ty_7))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_attr__bindgen_ty_7>(),
            8usize,
            concat!("Alignment of ", stringify!(bpf_attr__bindgen_ty_7))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_7>())).prog_fd as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_7),
                "::",
                stringify!(prog_fd)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_7>())).retval as *const _ as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_7),
                "::",
                stringify!(retval)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_7>())).data_size_in as *const _
                    as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_7),
                "::",
                stringify!(data_size_in)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_7>())).data_size_out as *const _
                    as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_7),
                "::",
                stringify!(data_size_out)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_7>())).data_in as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_7),
                "::",
                stringify!(data_in)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_7>())).data_out as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_7),
                "::",
                stringify!(data_out)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_7>())).repeat as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_7),
                "::",
                stringify!(repeat)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_7>())).duration as *const _ as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_7),
                "::",
                stringify!(duration)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_7>())).ctx_size_in as *const _ as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_7),
                "::",
                stringify!(ctx_size_in)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_7>())).ctx_size_out as *const _
                    as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_7),
                "::",
                stringify!(ctx_size_out)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_7>())).ctx_in as *const _ as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_7),
                "::",
                stringify!(ctx_in)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_7>())).ctx_out as *const _ as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_7),
                "::",
                stringify!(ctx_out)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_7>())).flags as *const _ as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_7),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_attr__bindgen_ty_7>())).cpu as *const _ as usize },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_7),
                "::",
                stringify!(cpu)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_7>())).batch_size as *const _ as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_7),
                "::",
                stringify!(batch_size)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct bpf_attr__bindgen_ty_8 {
        pub __bindgen_anon_1: bpf_attr__bindgen_ty_8__bindgen_ty_1,
        pub next_id: __u32,
        pub open_flags: __u32,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union bpf_attr__bindgen_ty_8__bindgen_ty_1 {
        pub start_id: __u32,
        pub prog_id: __u32,
        pub map_id: __u32,
        pub btf_id: __u32,
        pub link_id: __u32,
    }
    #[test]
    fn bindgen_test_layout_bpf_attr__bindgen_ty_8__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<bpf_attr__bindgen_ty_8__bindgen_ty_1>(),
            4usize,
            concat!(
                "Size of: ",
                stringify!(bpf_attr__bindgen_ty_8__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_attr__bindgen_ty_8__bindgen_ty_1>(),
            4usize,
            concat!(
                "Alignment of ",
                stringify!(bpf_attr__bindgen_ty_8__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_8__bindgen_ty_1>())).start_id
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_8__bindgen_ty_1),
                "::",
                stringify!(start_id)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_8__bindgen_ty_1>())).prog_id
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_8__bindgen_ty_1),
                "::",
                stringify!(prog_id)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_8__bindgen_ty_1>())).map_id as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_8__bindgen_ty_1),
                "::",
                stringify!(map_id)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_8__bindgen_ty_1>())).btf_id as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_8__bindgen_ty_1),
                "::",
                stringify!(btf_id)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_8__bindgen_ty_1>())).link_id
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_8__bindgen_ty_1),
                "::",
                stringify!(link_id)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_bpf_attr__bindgen_ty_8() {
        assert_eq!(
            ::core::mem::size_of::<bpf_attr__bindgen_ty_8>(),
            12usize,
            concat!("Size of: ", stringify!(bpf_attr__bindgen_ty_8))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_attr__bindgen_ty_8>(),
            4usize,
            concat!("Alignment of ", stringify!(bpf_attr__bindgen_ty_8))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_8>())).next_id as *const _ as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_8),
                "::",
                stringify!(next_id)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_8>())).open_flags as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_8),
                "::",
                stringify!(open_flags)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_attr__bindgen_ty_9 {
        pub bpf_fd: __u32,
        pub info_len: __u32,
        pub info: __u64,
    }
    #[test]
    fn bindgen_test_layout_bpf_attr__bindgen_ty_9() {
        assert_eq!(
            ::core::mem::size_of::<bpf_attr__bindgen_ty_9>(),
            16usize,
            concat!("Size of: ", stringify!(bpf_attr__bindgen_ty_9))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_attr__bindgen_ty_9>(),
            8usize,
            concat!("Alignment of ", stringify!(bpf_attr__bindgen_ty_9))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_9>())).bpf_fd as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_9),
                "::",
                stringify!(bpf_fd)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_9>())).info_len as *const _ as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_9),
                "::",
                stringify!(info_len)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_9>())).info as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_9),
                "::",
                stringify!(info)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_attr__bindgen_ty_10 {
        pub target_fd: __u32,
        pub attach_type: __u32,
        pub query_flags: __u32,
        pub attach_flags: __u32,
        pub prog_ids: __u64,
        pub prog_cnt: __u32,
        pub prog_attach_flags: __u64,
    }
    #[test]
    fn bindgen_test_layout_bpf_attr__bindgen_ty_10() {
        assert_eq!(
            ::core::mem::size_of::<bpf_attr__bindgen_ty_10>(),
            40usize,
            concat!("Size of: ", stringify!(bpf_attr__bindgen_ty_10))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_attr__bindgen_ty_10>(),
            8usize,
            concat!("Alignment of ", stringify!(bpf_attr__bindgen_ty_10))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_10>())).target_fd as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_10),
                "::",
                stringify!(target_fd)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_10>())).attach_type as *const _
                    as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_10),
                "::",
                stringify!(attach_type)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_10>())).query_flags as *const _
                    as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_10),
                "::",
                stringify!(query_flags)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_10>())).attach_flags as *const _
                    as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_10),
                "::",
                stringify!(attach_flags)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_10>())).prog_ids as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_10),
                "::",
                stringify!(prog_ids)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_10>())).prog_cnt as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_10),
                "::",
                stringify!(prog_cnt)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_10>())).prog_attach_flags as *const _
                    as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_10),
                "::",
                stringify!(prog_attach_flags)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_attr__bindgen_ty_11 {
        pub name: __u64,
        pub prog_fd: __u32,
    }
    #[test]
    fn bindgen_test_layout_bpf_attr__bindgen_ty_11() {
        assert_eq!(
            ::core::mem::size_of::<bpf_attr__bindgen_ty_11>(),
            16usize,
            concat!("Size of: ", stringify!(bpf_attr__bindgen_ty_11))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_attr__bindgen_ty_11>(),
            8usize,
            concat!("Alignment of ", stringify!(bpf_attr__bindgen_ty_11))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_11>())).name as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_11),
                "::",
                stringify!(name)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_11>())).prog_fd as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_11),
                "::",
                stringify!(prog_fd)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_attr__bindgen_ty_12 {
        pub btf: __u64,
        pub btf_log_buf: __u64,
        pub btf_size: __u32,
        pub btf_log_size: __u32,
        pub btf_log_level: __u32,
        pub btf_log_true_size: __u32,
    }
    #[test]
    fn bindgen_test_layout_bpf_attr__bindgen_ty_12() {
        assert_eq!(
            ::core::mem::size_of::<bpf_attr__bindgen_ty_12>(),
            32usize,
            concat!("Size of: ", stringify!(bpf_attr__bindgen_ty_12))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_attr__bindgen_ty_12>(),
            8usize,
            concat!("Alignment of ", stringify!(bpf_attr__bindgen_ty_12))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_12>())).btf as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_12),
                "::",
                stringify!(btf)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_12>())).btf_log_buf as *const _
                    as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_12),
                "::",
                stringify!(btf_log_buf)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_12>())).btf_size as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_12),
                "::",
                stringify!(btf_size)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_12>())).btf_log_size as *const _
                    as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_12),
                "::",
                stringify!(btf_log_size)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_12>())).btf_log_level as *const _
                    as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_12),
                "::",
                stringify!(btf_log_level)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_12>())).btf_log_true_size as *const _
                    as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_12),
                "::",
                stringify!(btf_log_true_size)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_attr__bindgen_ty_13 {
        pub pid: __u32,
        pub fd: __u32,
        pub flags: __u32,
        pub buf_len: __u32,
        pub buf: __u64,
        pub prog_id: __u32,
        pub fd_type: __u32,
        pub probe_offset: __u64,
        pub probe_addr: __u64,
    }
    #[test]
    fn bindgen_test_layout_bpf_attr__bindgen_ty_13() {
        assert_eq!(
            ::core::mem::size_of::<bpf_attr__bindgen_ty_13>(),
            48usize,
            concat!("Size of: ", stringify!(bpf_attr__bindgen_ty_13))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_attr__bindgen_ty_13>(),
            8usize,
            concat!("Alignment of ", stringify!(bpf_attr__bindgen_ty_13))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_13>())).pid as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_13),
                "::",
                stringify!(pid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_attr__bindgen_ty_13>())).fd as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_13),
                "::",
                stringify!(fd)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_13>())).flags as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_13),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_13>())).buf_len as *const _ as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_13),
                "::",
                stringify!(buf_len)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_13>())).buf as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_13),
                "::",
                stringify!(buf)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_13>())).prog_id as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_13),
                "::",
                stringify!(prog_id)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_13>())).fd_type as *const _ as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_13),
                "::",
                stringify!(fd_type)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_13>())).probe_offset as *const _
                    as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_13),
                "::",
                stringify!(probe_offset)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_13>())).probe_addr as *const _ as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_13),
                "::",
                stringify!(probe_addr)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct bpf_attr__bindgen_ty_14 {
        pub __bindgen_anon_1: bpf_attr__bindgen_ty_14__bindgen_ty_1,
        pub __bindgen_anon_2: bpf_attr__bindgen_ty_14__bindgen_ty_2,
        pub attach_type: __u32,
        pub flags: __u32,
        pub __bindgen_anon_3: bpf_attr__bindgen_ty_14__bindgen_ty_3,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union bpf_attr__bindgen_ty_14__bindgen_ty_1 {
        pub prog_fd: __u32,
        pub map_fd: __u32,
    }
    #[test]
    fn bindgen_test_layout_bpf_attr__bindgen_ty_14__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<bpf_attr__bindgen_ty_14__bindgen_ty_1>(),
            4usize,
            concat!(
                "Size of: ",
                stringify!(bpf_attr__bindgen_ty_14__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_attr__bindgen_ty_14__bindgen_ty_1>(),
            4usize,
            concat!(
                "Alignment of ",
                stringify!(bpf_attr__bindgen_ty_14__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_14__bindgen_ty_1>())).prog_fd
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_14__bindgen_ty_1),
                "::",
                stringify!(prog_fd)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_14__bindgen_ty_1>())).map_fd
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_14__bindgen_ty_1),
                "::",
                stringify!(map_fd)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union bpf_attr__bindgen_ty_14__bindgen_ty_2 {
        pub target_fd: __u32,
        pub target_ifindex: __u32,
    }
    #[test]
    fn bindgen_test_layout_bpf_attr__bindgen_ty_14__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<bpf_attr__bindgen_ty_14__bindgen_ty_2>(),
            4usize,
            concat!(
                "Size of: ",
                stringify!(bpf_attr__bindgen_ty_14__bindgen_ty_2)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_attr__bindgen_ty_14__bindgen_ty_2>(),
            4usize,
            concat!(
                "Alignment of ",
                stringify!(bpf_attr__bindgen_ty_14__bindgen_ty_2)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_14__bindgen_ty_2>())).target_fd
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_14__bindgen_ty_2),
                "::",
                stringify!(target_fd)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_14__bindgen_ty_2>())).target_ifindex
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_14__bindgen_ty_2),
                "::",
                stringify!(target_ifindex)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union bpf_attr__bindgen_ty_14__bindgen_ty_3 {
        pub target_btf_id: __u32,
        pub __bindgen_anon_1: bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_1,
        pub perf_event: bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_2,
        pub kprobe_multi: bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_3,
        pub tracing: bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_4,
        pub netfilter: bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_5,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_1 {
        pub iter_info: __u64,
        pub iter_info_len: __u32,
    }
    #[test]
    fn bindgen_test_layout_bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_1>(),
            16usize,
            concat!(
                "Size of: ",
                stringify!(bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_1>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_1>()))
                    .iter_info as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_1),
                "::",
                stringify!(iter_info)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_1>()))
                    .iter_info_len as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_1),
                "::",
                stringify!(iter_info_len)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_2 {
        pub bpf_cookie: __u64,
    }
    #[test]
    fn bindgen_test_layout_bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_2>(),
            8usize,
            concat!(
                "Size of: ",
                stringify!(bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_2)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_2>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_2)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_2>()))
                    .bpf_cookie as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_2),
                "::",
                stringify!(bpf_cookie)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_3 {
        pub flags: __u32,
        pub cnt: __u32,
        pub syms: __u64,
        pub addrs: __u64,
        pub cookies: __u64,
    }
    #[test]
    fn bindgen_test_layout_bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_3() {
        assert_eq!(
            ::core::mem::size_of::<bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_3>(),
            32usize,
            concat!(
                "Size of: ",
                stringify!(bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_3)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_3>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_3)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_3>()))
                    .flags as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_3),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_3>())).cnt
                    as *const _ as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_3),
                "::",
                stringify!(cnt)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_3>()))
                    .syms as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_3),
                "::",
                stringify!(syms)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_3>()))
                    .addrs as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_3),
                "::",
                stringify!(addrs)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_3>()))
                    .cookies as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_3),
                "::",
                stringify!(cookies)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_4 {
        pub target_btf_id: __u32,
        pub cookie: __u64,
    }
    #[test]
    fn bindgen_test_layout_bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_4() {
        assert_eq!(
            ::core::mem::size_of::<bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_4>(),
            16usize,
            concat!(
                "Size of: ",
                stringify!(bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_4)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_4>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_4)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_4>()))
                    .target_btf_id as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_4),
                "::",
                stringify!(target_btf_id)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_4>()))
                    .cookie as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_4),
                "::",
                stringify!(cookie)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_5 {
        pub pf: __u32,
        pub hooknum: __u32,
        pub priority: __s32,
        pub flags: __u32,
    }
    #[test]
    fn bindgen_test_layout_bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_5() {
        assert_eq!(
            ::core::mem::size_of::<bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_5>(),
            16usize,
            concat!(
                "Size of: ",
                stringify!(bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_5)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_5>(),
            4usize,
            concat!(
                "Alignment of ",
                stringify!(bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_5)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_5>())).pf
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_5),
                "::",
                stringify!(pf)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_5>()))
                    .hooknum as *const _ as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_5),
                "::",
                stringify!(hooknum)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_5>()))
                    .priority as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_5),
                "::",
                stringify!(priority)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_5>()))
                    .flags as *const _ as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_14__bindgen_ty_3__bindgen_ty_5),
                "::",
                stringify!(flags)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_bpf_attr__bindgen_ty_14__bindgen_ty_3() {
        assert_eq!(
            ::core::mem::size_of::<bpf_attr__bindgen_ty_14__bindgen_ty_3>(),
            32usize,
            concat!(
                "Size of: ",
                stringify!(bpf_attr__bindgen_ty_14__bindgen_ty_3)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_attr__bindgen_ty_14__bindgen_ty_3>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(bpf_attr__bindgen_ty_14__bindgen_ty_3)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_14__bindgen_ty_3>())).target_btf_id
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_14__bindgen_ty_3),
                "::",
                stringify!(target_btf_id)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_14__bindgen_ty_3>())).perf_event
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_14__bindgen_ty_3),
                "::",
                stringify!(perf_event)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_14__bindgen_ty_3>())).kprobe_multi
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_14__bindgen_ty_3),
                "::",
                stringify!(kprobe_multi)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_14__bindgen_ty_3>())).tracing
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_14__bindgen_ty_3),
                "::",
                stringify!(tracing)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_14__bindgen_ty_3>())).netfilter
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_14__bindgen_ty_3),
                "::",
                stringify!(netfilter)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_bpf_attr__bindgen_ty_14() {
        assert_eq!(
            ::core::mem::size_of::<bpf_attr__bindgen_ty_14>(),
            48usize,
            concat!("Size of: ", stringify!(bpf_attr__bindgen_ty_14))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_attr__bindgen_ty_14>(),
            8usize,
            concat!("Alignment of ", stringify!(bpf_attr__bindgen_ty_14))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_14>())).attach_type as *const _
                    as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_14),
                "::",
                stringify!(attach_type)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_14>())).flags as *const _ as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_14),
                "::",
                stringify!(flags)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct bpf_attr__bindgen_ty_15 {
        pub link_fd: __u32,
        pub __bindgen_anon_1: bpf_attr__bindgen_ty_15__bindgen_ty_1,
        pub flags: __u32,
        pub __bindgen_anon_2: bpf_attr__bindgen_ty_15__bindgen_ty_2,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union bpf_attr__bindgen_ty_15__bindgen_ty_1 {
        pub new_prog_fd: __u32,
        pub new_map_fd: __u32,
    }
    #[test]
    fn bindgen_test_layout_bpf_attr__bindgen_ty_15__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<bpf_attr__bindgen_ty_15__bindgen_ty_1>(),
            4usize,
            concat!(
                "Size of: ",
                stringify!(bpf_attr__bindgen_ty_15__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_attr__bindgen_ty_15__bindgen_ty_1>(),
            4usize,
            concat!(
                "Alignment of ",
                stringify!(bpf_attr__bindgen_ty_15__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_15__bindgen_ty_1>())).new_prog_fd
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_15__bindgen_ty_1),
                "::",
                stringify!(new_prog_fd)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_15__bindgen_ty_1>())).new_map_fd
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_15__bindgen_ty_1),
                "::",
                stringify!(new_map_fd)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union bpf_attr__bindgen_ty_15__bindgen_ty_2 {
        pub old_prog_fd: __u32,
        pub old_map_fd: __u32,
    }
    #[test]
    fn bindgen_test_layout_bpf_attr__bindgen_ty_15__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<bpf_attr__bindgen_ty_15__bindgen_ty_2>(),
            4usize,
            concat!(
                "Size of: ",
                stringify!(bpf_attr__bindgen_ty_15__bindgen_ty_2)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_attr__bindgen_ty_15__bindgen_ty_2>(),
            4usize,
            concat!(
                "Alignment of ",
                stringify!(bpf_attr__bindgen_ty_15__bindgen_ty_2)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_15__bindgen_ty_2>())).old_prog_fd
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_15__bindgen_ty_2),
                "::",
                stringify!(old_prog_fd)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_15__bindgen_ty_2>())).old_map_fd
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_15__bindgen_ty_2),
                "::",
                stringify!(old_map_fd)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_bpf_attr__bindgen_ty_15() {
        assert_eq!(
            ::core::mem::size_of::<bpf_attr__bindgen_ty_15>(),
            16usize,
            concat!("Size of: ", stringify!(bpf_attr__bindgen_ty_15))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_attr__bindgen_ty_15>(),
            4usize,
            concat!("Alignment of ", stringify!(bpf_attr__bindgen_ty_15))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_15>())).link_fd as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_15),
                "::",
                stringify!(link_fd)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_15>())).flags as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_15),
                "::",
                stringify!(flags)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_attr__bindgen_ty_16 {
        pub link_fd: __u32,
    }
    #[test]
    fn bindgen_test_layout_bpf_attr__bindgen_ty_16() {
        assert_eq!(
            ::core::mem::size_of::<bpf_attr__bindgen_ty_16>(),
            4usize,
            concat!("Size of: ", stringify!(bpf_attr__bindgen_ty_16))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_attr__bindgen_ty_16>(),
            4usize,
            concat!("Alignment of ", stringify!(bpf_attr__bindgen_ty_16))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_16>())).link_fd as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_16),
                "::",
                stringify!(link_fd)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_attr__bindgen_ty_17 {
        pub type_: __u32,
    }
    #[test]
    fn bindgen_test_layout_bpf_attr__bindgen_ty_17() {
        assert_eq!(
            ::core::mem::size_of::<bpf_attr__bindgen_ty_17>(),
            4usize,
            concat!("Size of: ", stringify!(bpf_attr__bindgen_ty_17))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_attr__bindgen_ty_17>(),
            4usize,
            concat!("Alignment of ", stringify!(bpf_attr__bindgen_ty_17))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_17>())).type_ as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_17),
                "::",
                stringify!(type_)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_attr__bindgen_ty_18 {
        pub link_fd: __u32,
        pub flags: __u32,
    }
    #[test]
    fn bindgen_test_layout_bpf_attr__bindgen_ty_18() {
        assert_eq!(
            ::core::mem::size_of::<bpf_attr__bindgen_ty_18>(),
            8usize,
            concat!("Size of: ", stringify!(bpf_attr__bindgen_ty_18))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_attr__bindgen_ty_18>(),
            4usize,
            concat!("Alignment of ", stringify!(bpf_attr__bindgen_ty_18))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_18>())).link_fd as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_18),
                "::",
                stringify!(link_fd)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_18>())).flags as *const _ as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_18),
                "::",
                stringify!(flags)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_attr__bindgen_ty_19 {
        pub prog_fd: __u32,
        pub map_fd: __u32,
        pub flags: __u32,
    }
    #[test]
    fn bindgen_test_layout_bpf_attr__bindgen_ty_19() {
        assert_eq!(
            ::core::mem::size_of::<bpf_attr__bindgen_ty_19>(),
            12usize,
            concat!("Size of: ", stringify!(bpf_attr__bindgen_ty_19))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_attr__bindgen_ty_19>(),
            4usize,
            concat!("Alignment of ", stringify!(bpf_attr__bindgen_ty_19))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_19>())).prog_fd as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_19),
                "::",
                stringify!(prog_fd)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_19>())).map_fd as *const _ as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_19),
                "::",
                stringify!(map_fd)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_attr__bindgen_ty_19>())).flags as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr__bindgen_ty_19),
                "::",
                stringify!(flags)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_bpf_attr() {
        assert_eq!(
            ::core::mem::size_of::<bpf_attr>(),
            144usize,
            concat!("Size of: ", stringify!(bpf_attr))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_attr>(),
            8usize,
            concat!("Alignment of ", stringify!(bpf_attr))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_attr>())).batch as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr),
                "::",
                stringify!(batch)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_attr>())).test as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr),
                "::",
                stringify!(test)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_attr>())).info as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr),
                "::",
                stringify!(info)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_attr>())).query as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr),
                "::",
                stringify!(query)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_attr>())).raw_tracepoint as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr),
                "::",
                stringify!(raw_tracepoint)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_attr>())).task_fd_query as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr),
                "::",
                stringify!(task_fd_query)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_attr>())).link_create as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr),
                "::",
                stringify!(link_create)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_attr>())).link_update as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr),
                "::",
                stringify!(link_update)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_attr>())).link_detach as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr),
                "::",
                stringify!(link_detach)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_attr>())).enable_stats as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr),
                "::",
                stringify!(enable_stats)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_attr>())).iter_create as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr),
                "::",
                stringify!(iter_create)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_attr>())).prog_bind_map as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_attr),
                "::",
                stringify!(prog_bind_map)
            )
        );
    }
    pub const bpf_func_id_BPF_FUNC_unspec: bpf_func_id = 0;
    pub const bpf_func_id_BPF_FUNC_map_lookup_elem: bpf_func_id = 1;
    pub const bpf_func_id_BPF_FUNC_map_update_elem: bpf_func_id = 2;
    pub const bpf_func_id_BPF_FUNC_map_delete_elem: bpf_func_id = 3;
    pub const bpf_func_id_BPF_FUNC_probe_read: bpf_func_id = 4;
    pub const bpf_func_id_BPF_FUNC_ktime_get_ns: bpf_func_id = 5;
    pub const bpf_func_id_BPF_FUNC_trace_printk: bpf_func_id = 6;
    pub const bpf_func_id_BPF_FUNC_get_prandom_u32: bpf_func_id = 7;
    pub const bpf_func_id_BPF_FUNC_get_smp_processor_id: bpf_func_id = 8;
    pub const bpf_func_id_BPF_FUNC_skb_store_bytes: bpf_func_id = 9;
    pub const bpf_func_id_BPF_FUNC_l3_csum_replace: bpf_func_id = 10;
    pub const bpf_func_id_BPF_FUNC_l4_csum_replace: bpf_func_id = 11;
    pub const bpf_func_id_BPF_FUNC_tail_call: bpf_func_id = 12;
    pub const bpf_func_id_BPF_FUNC_clone_redirect: bpf_func_id = 13;
    pub const bpf_func_id_BPF_FUNC_get_current_pid_tgid: bpf_func_id = 14;
    pub const bpf_func_id_BPF_FUNC_get_current_uid_gid: bpf_func_id = 15;
    pub const bpf_func_id_BPF_FUNC_get_current_comm: bpf_func_id = 16;
    pub const bpf_func_id_BPF_FUNC_get_cgroup_classid: bpf_func_id = 17;
    pub const bpf_func_id_BPF_FUNC_skb_vlan_push: bpf_func_id = 18;
    pub const bpf_func_id_BPF_FUNC_skb_vlan_pop: bpf_func_id = 19;
    pub const bpf_func_id_BPF_FUNC_skb_get_tunnel_key: bpf_func_id = 20;
    pub const bpf_func_id_BPF_FUNC_skb_set_tunnel_key: bpf_func_id = 21;
    pub const bpf_func_id_BPF_FUNC_perf_event_read: bpf_func_id = 22;
    pub const bpf_func_id_BPF_FUNC_redirect: bpf_func_id = 23;
    pub const bpf_func_id_BPF_FUNC_get_route_realm: bpf_func_id = 24;
    pub const bpf_func_id_BPF_FUNC_perf_event_output: bpf_func_id = 25;
    pub const bpf_func_id_BPF_FUNC_skb_load_bytes: bpf_func_id = 26;
    pub const bpf_func_id_BPF_FUNC_get_stackid: bpf_func_id = 27;
    pub const bpf_func_id_BPF_FUNC_csum_diff: bpf_func_id = 28;
    pub const bpf_func_id_BPF_FUNC_skb_get_tunnel_opt: bpf_func_id = 29;
    pub const bpf_func_id_BPF_FUNC_skb_set_tunnel_opt: bpf_func_id = 30;
    pub const bpf_func_id_BPF_FUNC_skb_change_proto: bpf_func_id = 31;
    pub const bpf_func_id_BPF_FUNC_skb_change_type: bpf_func_id = 32;
    pub const bpf_func_id_BPF_FUNC_skb_under_cgroup: bpf_func_id = 33;
    pub const bpf_func_id_BPF_FUNC_get_hash_recalc: bpf_func_id = 34;
    pub const bpf_func_id_BPF_FUNC_get_current_task: bpf_func_id = 35;
    pub const bpf_func_id_BPF_FUNC_probe_write_user: bpf_func_id = 36;
    pub const bpf_func_id_BPF_FUNC_current_task_under_cgroup: bpf_func_id = 37;
    pub const bpf_func_id_BPF_FUNC_skb_change_tail: bpf_func_id = 38;
    pub const bpf_func_id_BPF_FUNC_skb_pull_data: bpf_func_id = 39;
    pub const bpf_func_id_BPF_FUNC_csum_update: bpf_func_id = 40;
    pub const bpf_func_id_BPF_FUNC_set_hash_invalid: bpf_func_id = 41;
    pub const bpf_func_id_BPF_FUNC_get_numa_node_id: bpf_func_id = 42;
    pub const bpf_func_id_BPF_FUNC_skb_change_head: bpf_func_id = 43;
    pub const bpf_func_id_BPF_FUNC_xdp_adjust_head: bpf_func_id = 44;
    pub const bpf_func_id_BPF_FUNC_probe_read_str: bpf_func_id = 45;
    pub const bpf_func_id_BPF_FUNC_get_socket_cookie: bpf_func_id = 46;
    pub const bpf_func_id_BPF_FUNC_get_socket_uid: bpf_func_id = 47;
    pub const bpf_func_id_BPF_FUNC_set_hash: bpf_func_id = 48;
    pub const bpf_func_id_BPF_FUNC_setsockopt: bpf_func_id = 49;
    pub const bpf_func_id_BPF_FUNC_skb_adjust_room: bpf_func_id = 50;
    pub const bpf_func_id_BPF_FUNC_redirect_map: bpf_func_id = 51;
    pub const bpf_func_id_BPF_FUNC_sk_redirect_map: bpf_func_id = 52;
    pub const bpf_func_id_BPF_FUNC_sock_map_update: bpf_func_id = 53;
    pub const bpf_func_id_BPF_FUNC_xdp_adjust_meta: bpf_func_id = 54;
    pub const bpf_func_id_BPF_FUNC_perf_event_read_value: bpf_func_id = 55;
    pub const bpf_func_id_BPF_FUNC_perf_prog_read_value: bpf_func_id = 56;
    pub const bpf_func_id_BPF_FUNC_getsockopt: bpf_func_id = 57;
    pub const bpf_func_id_BPF_FUNC_override_return: bpf_func_id = 58;
    pub const bpf_func_id_BPF_FUNC_sock_ops_cb_flags_set: bpf_func_id = 59;
    pub const bpf_func_id_BPF_FUNC_msg_redirect_map: bpf_func_id = 60;
    pub const bpf_func_id_BPF_FUNC_msg_apply_bytes: bpf_func_id = 61;
    pub const bpf_func_id_BPF_FUNC_msg_cork_bytes: bpf_func_id = 62;
    pub const bpf_func_id_BPF_FUNC_msg_pull_data: bpf_func_id = 63;
    pub const bpf_func_id_BPF_FUNC_bind: bpf_func_id = 64;
    pub const bpf_func_id_BPF_FUNC_xdp_adjust_tail: bpf_func_id = 65;
    pub const bpf_func_id_BPF_FUNC_skb_get_xfrm_state: bpf_func_id = 66;
    pub const bpf_func_id_BPF_FUNC_get_stack: bpf_func_id = 67;
    pub const bpf_func_id_BPF_FUNC_skb_load_bytes_relative: bpf_func_id = 68;
    pub const bpf_func_id_BPF_FUNC_fib_lookup: bpf_func_id = 69;
    pub const bpf_func_id_BPF_FUNC_sock_hash_update: bpf_func_id = 70;
    pub const bpf_func_id_BPF_FUNC_msg_redirect_hash: bpf_func_id = 71;
    pub const bpf_func_id_BPF_FUNC_sk_redirect_hash: bpf_func_id = 72;
    pub const bpf_func_id_BPF_FUNC_lwt_push_encap: bpf_func_id = 73;
    pub const bpf_func_id_BPF_FUNC_lwt_seg6_store_bytes: bpf_func_id = 74;
    pub const bpf_func_id_BPF_FUNC_lwt_seg6_adjust_srh: bpf_func_id = 75;
    pub const bpf_func_id_BPF_FUNC_lwt_seg6_action: bpf_func_id = 76;
    pub const bpf_func_id_BPF_FUNC_rc_repeat: bpf_func_id = 77;
    pub const bpf_func_id_BPF_FUNC_rc_keydown: bpf_func_id = 78;
    pub const bpf_func_id_BPF_FUNC_skb_cgroup_id: bpf_func_id = 79;
    pub const bpf_func_id_BPF_FUNC_get_current_cgroup_id: bpf_func_id = 80;
    pub const bpf_func_id_BPF_FUNC_get_local_storage: bpf_func_id = 81;
    pub const bpf_func_id_BPF_FUNC_sk_select_reuseport: bpf_func_id = 82;
    pub const bpf_func_id_BPF_FUNC_skb_ancestor_cgroup_id: bpf_func_id = 83;
    pub const bpf_func_id_BPF_FUNC_sk_lookup_tcp: bpf_func_id = 84;
    pub const bpf_func_id_BPF_FUNC_sk_lookup_udp: bpf_func_id = 85;
    pub const bpf_func_id_BPF_FUNC_sk_release: bpf_func_id = 86;
    pub const bpf_func_id_BPF_FUNC_map_push_elem: bpf_func_id = 87;
    pub const bpf_func_id_BPF_FUNC_map_pop_elem: bpf_func_id = 88;
    pub const bpf_func_id_BPF_FUNC_map_peek_elem: bpf_func_id = 89;
    pub const bpf_func_id_BPF_FUNC_msg_push_data: bpf_func_id = 90;
    pub const bpf_func_id_BPF_FUNC_msg_pop_data: bpf_func_id = 91;
    pub const bpf_func_id_BPF_FUNC_rc_pointer_rel: bpf_func_id = 92;
    pub const bpf_func_id_BPF_FUNC_spin_lock: bpf_func_id = 93;
    pub const bpf_func_id_BPF_FUNC_spin_unlock: bpf_func_id = 94;
    pub const bpf_func_id_BPF_FUNC_sk_fullsock: bpf_func_id = 95;
    pub const bpf_func_id_BPF_FUNC_tcp_sock: bpf_func_id = 96;
    pub const bpf_func_id_BPF_FUNC_skb_ecn_set_ce: bpf_func_id = 97;
    pub const bpf_func_id_BPF_FUNC_get_listener_sock: bpf_func_id = 98;
    pub const bpf_func_id_BPF_FUNC_skc_lookup_tcp: bpf_func_id = 99;
    pub const bpf_func_id_BPF_FUNC_tcp_check_syncookie: bpf_func_id = 100;
    pub const bpf_func_id_BPF_FUNC_sysctl_get_name: bpf_func_id = 101;
    pub const bpf_func_id_BPF_FUNC_sysctl_get_current_value: bpf_func_id = 102;
    pub const bpf_func_id_BPF_FUNC_sysctl_get_new_value: bpf_func_id = 103;
    pub const bpf_func_id_BPF_FUNC_sysctl_set_new_value: bpf_func_id = 104;
    pub const bpf_func_id_BPF_FUNC_strtol: bpf_func_id = 105;
    pub const bpf_func_id_BPF_FUNC_strtoul: bpf_func_id = 106;
    pub const bpf_func_id_BPF_FUNC_sk_storage_get: bpf_func_id = 107;
    pub const bpf_func_id_BPF_FUNC_sk_storage_delete: bpf_func_id = 108;
    pub const bpf_func_id_BPF_FUNC_send_signal: bpf_func_id = 109;
    pub const bpf_func_id_BPF_FUNC_tcp_gen_syncookie: bpf_func_id = 110;
    pub const bpf_func_id_BPF_FUNC_skb_output: bpf_func_id = 111;
    pub const bpf_func_id_BPF_FUNC_probe_read_user: bpf_func_id = 112;
    pub const bpf_func_id_BPF_FUNC_probe_read_kernel: bpf_func_id = 113;
    pub const bpf_func_id_BPF_FUNC_probe_read_user_str: bpf_func_id = 114;
    pub const bpf_func_id_BPF_FUNC_probe_read_kernel_str: bpf_func_id = 115;
    pub const bpf_func_id_BPF_FUNC_tcp_send_ack: bpf_func_id = 116;
    pub const bpf_func_id_BPF_FUNC_send_signal_thread: bpf_func_id = 117;
    pub const bpf_func_id_BPF_FUNC_jiffies64: bpf_func_id = 118;
    pub const bpf_func_id_BPF_FUNC_read_branch_records: bpf_func_id = 119;
    pub const bpf_func_id_BPF_FUNC_get_ns_current_pid_tgid: bpf_func_id = 120;
    pub const bpf_func_id_BPF_FUNC_xdp_output: bpf_func_id = 121;
    pub const bpf_func_id_BPF_FUNC_get_netns_cookie: bpf_func_id = 122;
    pub const bpf_func_id_BPF_FUNC_get_current_ancestor_cgroup_id: bpf_func_id = 123;
    pub const bpf_func_id_BPF_FUNC_sk_assign: bpf_func_id = 124;
    pub const bpf_func_id_BPF_FUNC_ktime_get_boot_ns: bpf_func_id = 125;
    pub const bpf_func_id_BPF_FUNC_seq_printf: bpf_func_id = 126;
    pub const bpf_func_id_BPF_FUNC_seq_write: bpf_func_id = 127;
    pub const bpf_func_id_BPF_FUNC_sk_cgroup_id: bpf_func_id = 128;
    pub const bpf_func_id_BPF_FUNC_sk_ancestor_cgroup_id: bpf_func_id = 129;
    pub const bpf_func_id_BPF_FUNC_ringbuf_output: bpf_func_id = 130;
    pub const bpf_func_id_BPF_FUNC_ringbuf_reserve: bpf_func_id = 131;
    pub const bpf_func_id_BPF_FUNC_ringbuf_submit: bpf_func_id = 132;
    pub const bpf_func_id_BPF_FUNC_ringbuf_discard: bpf_func_id = 133;
    pub const bpf_func_id_BPF_FUNC_ringbuf_query: bpf_func_id = 134;
    pub const bpf_func_id_BPF_FUNC_csum_level: bpf_func_id = 135;
    pub const bpf_func_id_BPF_FUNC_skc_to_tcp6_sock: bpf_func_id = 136;
    pub const bpf_func_id_BPF_FUNC_skc_to_tcp_sock: bpf_func_id = 137;
    pub const bpf_func_id_BPF_FUNC_skc_to_tcp_timewait_sock: bpf_func_id = 138;
    pub const bpf_func_id_BPF_FUNC_skc_to_tcp_request_sock: bpf_func_id = 139;
    pub const bpf_func_id_BPF_FUNC_skc_to_udp6_sock: bpf_func_id = 140;
    pub const bpf_func_id_BPF_FUNC_get_task_stack: bpf_func_id = 141;
    pub const bpf_func_id_BPF_FUNC_load_hdr_opt: bpf_func_id = 142;
    pub const bpf_func_id_BPF_FUNC_store_hdr_opt: bpf_func_id = 143;
    pub const bpf_func_id_BPF_FUNC_reserve_hdr_opt: bpf_func_id = 144;
    pub const bpf_func_id_BPF_FUNC_inode_storage_get: bpf_func_id = 145;
    pub const bpf_func_id_BPF_FUNC_inode_storage_delete: bpf_func_id = 146;
    pub const bpf_func_id_BPF_FUNC_d_path: bpf_func_id = 147;
    pub const bpf_func_id_BPF_FUNC_copy_from_user: bpf_func_id = 148;
    pub const bpf_func_id_BPF_FUNC_snprintf_btf: bpf_func_id = 149;
    pub const bpf_func_id_BPF_FUNC_seq_printf_btf: bpf_func_id = 150;
    pub const bpf_func_id_BPF_FUNC_skb_cgroup_classid: bpf_func_id = 151;
    pub const bpf_func_id_BPF_FUNC_redirect_neigh: bpf_func_id = 152;
    pub const bpf_func_id_BPF_FUNC_per_cpu_ptr: bpf_func_id = 153;
    pub const bpf_func_id_BPF_FUNC_this_cpu_ptr: bpf_func_id = 154;
    pub const bpf_func_id_BPF_FUNC_redirect_peer: bpf_func_id = 155;
    pub const bpf_func_id_BPF_FUNC_task_storage_get: bpf_func_id = 156;
    pub const bpf_func_id_BPF_FUNC_task_storage_delete: bpf_func_id = 157;
    pub const bpf_func_id_BPF_FUNC_get_current_task_btf: bpf_func_id = 158;
    pub const bpf_func_id_BPF_FUNC_bprm_opts_set: bpf_func_id = 159;
    pub const bpf_func_id_BPF_FUNC_ktime_get_coarse_ns: bpf_func_id = 160;
    pub const bpf_func_id_BPF_FUNC_ima_inode_hash: bpf_func_id = 161;
    pub const bpf_func_id_BPF_FUNC_sock_from_file: bpf_func_id = 162;
    pub const bpf_func_id_BPF_FUNC_check_mtu: bpf_func_id = 163;
    pub const bpf_func_id_BPF_FUNC_for_each_map_elem: bpf_func_id = 164;
    pub const bpf_func_id_BPF_FUNC_snprintf: bpf_func_id = 165;
    pub const bpf_func_id_BPF_FUNC_sys_bpf: bpf_func_id = 166;
    pub const bpf_func_id_BPF_FUNC_btf_find_by_name_kind: bpf_func_id = 167;
    pub const bpf_func_id_BPF_FUNC_sys_close: bpf_func_id = 168;
    pub const bpf_func_id_BPF_FUNC_timer_init: bpf_func_id = 169;
    pub const bpf_func_id_BPF_FUNC_timer_set_callback: bpf_func_id = 170;
    pub const bpf_func_id_BPF_FUNC_timer_start: bpf_func_id = 171;
    pub const bpf_func_id_BPF_FUNC_timer_cancel: bpf_func_id = 172;
    pub const bpf_func_id_BPF_FUNC_get_func_ip: bpf_func_id = 173;
    pub const bpf_func_id_BPF_FUNC_get_attach_cookie: bpf_func_id = 174;
    pub const bpf_func_id_BPF_FUNC_task_pt_regs: bpf_func_id = 175;
    pub const bpf_func_id_BPF_FUNC_get_branch_snapshot: bpf_func_id = 176;
    pub const bpf_func_id_BPF_FUNC_trace_vprintk: bpf_func_id = 177;
    pub const bpf_func_id_BPF_FUNC_skc_to_unix_sock: bpf_func_id = 178;
    pub const bpf_func_id_BPF_FUNC_kallsyms_lookup_name: bpf_func_id = 179;
    pub const bpf_func_id_BPF_FUNC_find_vma: bpf_func_id = 180;
    pub const bpf_func_id_BPF_FUNC_loop: bpf_func_id = 181;
    pub const bpf_func_id_BPF_FUNC_strncmp: bpf_func_id = 182;
    pub const bpf_func_id_BPF_FUNC_get_func_arg: bpf_func_id = 183;
    pub const bpf_func_id_BPF_FUNC_get_func_ret: bpf_func_id = 184;
    pub const bpf_func_id_BPF_FUNC_get_func_arg_cnt: bpf_func_id = 185;
    pub const bpf_func_id_BPF_FUNC_get_retval: bpf_func_id = 186;
    pub const bpf_func_id_BPF_FUNC_set_retval: bpf_func_id = 187;
    pub const bpf_func_id_BPF_FUNC_xdp_get_buff_len: bpf_func_id = 188;
    pub const bpf_func_id_BPF_FUNC_xdp_load_bytes: bpf_func_id = 189;
    pub const bpf_func_id_BPF_FUNC_xdp_store_bytes: bpf_func_id = 190;
    pub const bpf_func_id_BPF_FUNC_copy_from_user_task: bpf_func_id = 191;
    pub const bpf_func_id_BPF_FUNC_skb_set_tstamp: bpf_func_id = 192;
    pub const bpf_func_id_BPF_FUNC_ima_file_hash: bpf_func_id = 193;
    pub const bpf_func_id_BPF_FUNC_kptr_xchg: bpf_func_id = 194;
    pub const bpf_func_id_BPF_FUNC_map_lookup_percpu_elem: bpf_func_id = 195;
    pub const bpf_func_id_BPF_FUNC_skc_to_mptcp_sock: bpf_func_id = 196;
    pub const bpf_func_id_BPF_FUNC_dynptr_from_mem: bpf_func_id = 197;
    pub const bpf_func_id_BPF_FUNC_ringbuf_reserve_dynptr: bpf_func_id = 198;
    pub const bpf_func_id_BPF_FUNC_ringbuf_submit_dynptr: bpf_func_id = 199;
    pub const bpf_func_id_BPF_FUNC_ringbuf_discard_dynptr: bpf_func_id = 200;
    pub const bpf_func_id_BPF_FUNC_dynptr_read: bpf_func_id = 201;
    pub const bpf_func_id_BPF_FUNC_dynptr_write: bpf_func_id = 202;
    pub const bpf_func_id_BPF_FUNC_dynptr_data: bpf_func_id = 203;
    pub const bpf_func_id_BPF_FUNC_tcp_raw_gen_syncookie_ipv4: bpf_func_id = 204;
    pub const bpf_func_id_BPF_FUNC_tcp_raw_gen_syncookie_ipv6: bpf_func_id = 205;
    pub const bpf_func_id_BPF_FUNC_tcp_raw_check_syncookie_ipv4: bpf_func_id = 206;
    pub const bpf_func_id_BPF_FUNC_tcp_raw_check_syncookie_ipv6: bpf_func_id = 207;
    pub const bpf_func_id_BPF_FUNC_ktime_get_tai_ns: bpf_func_id = 208;
    pub const bpf_func_id_BPF_FUNC_user_ringbuf_drain: bpf_func_id = 209;
    pub const bpf_func_id_BPF_FUNC_cgrp_storage_get: bpf_func_id = 210;
    pub const bpf_func_id_BPF_FUNC_cgrp_storage_delete: bpf_func_id = 211;
    pub const bpf_func_id___BPF_FUNC_MAX_ID: bpf_func_id = 212;
    pub type bpf_func_id = ::cty::c_uint;
    pub const BPF_F_RECOMPUTE_CSUM: ::cty::c_uint = 1;
    pub const BPF_F_INVALIDATE_HASH: ::cty::c_uint = 2;
    pub type _bindgen_ty_8 = ::cty::c_uint;
    pub const BPF_F_HDR_FIELD_MASK: ::cty::c_uint = 15;
    pub type _bindgen_ty_9 = ::cty::c_uint;
    pub const BPF_F_PSEUDO_HDR: ::cty::c_uint = 16;
    pub const BPF_F_MARK_MANGLED_0: ::cty::c_uint = 32;
    pub const BPF_F_MARK_ENFORCE: ::cty::c_uint = 64;
    pub type _bindgen_ty_10 = ::cty::c_uint;
    pub const BPF_F_INGRESS: ::cty::c_uint = 1;
    pub type _bindgen_ty_11 = ::cty::c_uint;
    pub const BPF_F_TUNINFO_IPV6: ::cty::c_uint = 1;
    pub type _bindgen_ty_12 = ::cty::c_uint;
    pub const BPF_F_SKIP_FIELD_MASK: ::cty::c_uint = 255;
    pub const BPF_F_USER_STACK: ::cty::c_uint = 256;
    pub const BPF_F_FAST_STACK_CMP: ::cty::c_uint = 512;
    pub const BPF_F_REUSE_STACKID: ::cty::c_uint = 1024;
    pub const BPF_F_USER_BUILD_ID: ::cty::c_uint = 2048;
    pub type _bindgen_ty_13 = ::cty::c_uint;
    pub const BPF_F_ZERO_CSUM_TX: ::cty::c_uint = 2;
    pub const BPF_F_DONT_FRAGMENT: ::cty::c_uint = 4;
    pub const BPF_F_SEQ_NUMBER: ::cty::c_uint = 8;
    pub const BPF_F_NO_TUNNEL_KEY: ::cty::c_uint = 16;
    pub type _bindgen_ty_14 = ::cty::c_uint;
    pub const BPF_F_TUNINFO_FLAGS: ::cty::c_uint = 16;
    pub type _bindgen_ty_15 = ::cty::c_uint;
    pub const BPF_F_INDEX_MASK: ::cty::c_ulong = 4294967295;
    pub const BPF_F_CURRENT_CPU: ::cty::c_ulong = 4294967295;
    pub const BPF_F_CTXLEN_MASK: ::cty::c_ulong = 4503595332403200;
    pub type _bindgen_ty_16 = ::cty::c_ulong;
    pub const BPF_F_CURRENT_NETNS: ::cty::c_int = -1;
    pub type _bindgen_ty_17 = ::cty::c_int;
    pub const BPF_CSUM_LEVEL_QUERY: ::cty::c_uint = 0;
    pub const BPF_CSUM_LEVEL_INC: ::cty::c_uint = 1;
    pub const BPF_CSUM_LEVEL_DEC: ::cty::c_uint = 2;
    pub const BPF_CSUM_LEVEL_RESET: ::cty::c_uint = 3;
    pub type _bindgen_ty_18 = ::cty::c_uint;
    pub const BPF_F_ADJ_ROOM_FIXED_GSO: ::cty::c_uint = 1;
    pub const BPF_F_ADJ_ROOM_ENCAP_L3_IPV4: ::cty::c_uint = 2;
    pub const BPF_F_ADJ_ROOM_ENCAP_L3_IPV6: ::cty::c_uint = 4;
    pub const BPF_F_ADJ_ROOM_ENCAP_L4_GRE: ::cty::c_uint = 8;
    pub const BPF_F_ADJ_ROOM_ENCAP_L4_UDP: ::cty::c_uint = 16;
    pub const BPF_F_ADJ_ROOM_NO_CSUM_RESET: ::cty::c_uint = 32;
    pub const BPF_F_ADJ_ROOM_ENCAP_L2_ETH: ::cty::c_uint = 64;
    pub const BPF_F_ADJ_ROOM_DECAP_L3_IPV4: ::cty::c_uint = 128;
    pub const BPF_F_ADJ_ROOM_DECAP_L3_IPV6: ::cty::c_uint = 256;
    pub type _bindgen_ty_19 = ::cty::c_uint;
    pub const BPF_ADJ_ROOM_ENCAP_L2_MASK: ::cty::c_uint = 255;
    pub const BPF_ADJ_ROOM_ENCAP_L2_SHIFT: ::cty::c_uint = 56;
    pub type _bindgen_ty_20 = ::cty::c_uint;
    pub const BPF_F_SYSCTL_BASE_NAME: ::cty::c_uint = 1;
    pub type _bindgen_ty_21 = ::cty::c_uint;
    pub const BPF_LOCAL_STORAGE_GET_F_CREATE: ::cty::c_uint = 1;
    pub const BPF_SK_STORAGE_GET_F_CREATE: ::cty::c_uint = 1;
    pub type _bindgen_ty_22 = ::cty::c_uint;
    pub const BPF_F_GET_BRANCH_RECORDS_SIZE: ::cty::c_uint = 1;
    pub type _bindgen_ty_23 = ::cty::c_uint;
    pub const BPF_RB_NO_WAKEUP: ::cty::c_uint = 1;
    pub const BPF_RB_FORCE_WAKEUP: ::cty::c_uint = 2;
    pub type _bindgen_ty_24 = ::cty::c_uint;
    pub const BPF_RB_AVAIL_DATA: ::cty::c_uint = 0;
    pub const BPF_RB_RING_SIZE: ::cty::c_uint = 1;
    pub const BPF_RB_CONS_POS: ::cty::c_uint = 2;
    pub const BPF_RB_PROD_POS: ::cty::c_uint = 3;
    pub type _bindgen_ty_25 = ::cty::c_uint;
    pub const BPF_RINGBUF_BUSY_BIT: ::cty::c_uint = 2147483648;
    pub const BPF_RINGBUF_DISCARD_BIT: ::cty::c_uint = 1073741824;
    pub const BPF_RINGBUF_HDR_SZ: ::cty::c_uint = 8;
    pub type _bindgen_ty_26 = ::cty::c_uint;
    pub const BPF_SK_LOOKUP_F_REPLACE: ::cty::c_uint = 1;
    pub const BPF_SK_LOOKUP_F_NO_REUSEPORT: ::cty::c_uint = 2;
    pub type _bindgen_ty_27 = ::cty::c_uint;
    pub const bpf_adj_room_mode_BPF_ADJ_ROOM_NET: bpf_adj_room_mode = 0;
    pub const bpf_adj_room_mode_BPF_ADJ_ROOM_MAC: bpf_adj_room_mode = 1;
    pub type bpf_adj_room_mode = ::cty::c_uint;
    pub const bpf_hdr_start_off_BPF_HDR_START_MAC: bpf_hdr_start_off = 0;
    pub const bpf_hdr_start_off_BPF_HDR_START_NET: bpf_hdr_start_off = 1;
    pub type bpf_hdr_start_off = ::cty::c_uint;
    pub const bpf_lwt_encap_mode_BPF_LWT_ENCAP_SEG6: bpf_lwt_encap_mode = 0;
    pub const bpf_lwt_encap_mode_BPF_LWT_ENCAP_SEG6_INLINE: bpf_lwt_encap_mode = 1;
    pub const bpf_lwt_encap_mode_BPF_LWT_ENCAP_IP: bpf_lwt_encap_mode = 2;
    pub type bpf_lwt_encap_mode = ::cty::c_uint;
    pub const BPF_F_BPRM_SECUREEXEC: ::cty::c_uint = 1;
    pub type _bindgen_ty_28 = ::cty::c_uint;
    pub const BPF_F_BROADCAST: ::cty::c_uint = 8;
    pub const BPF_F_EXCLUDE_INGRESS: ::cty::c_uint = 16;
    pub type _bindgen_ty_29 = ::cty::c_uint;
    pub const BPF_SKB_TSTAMP_UNSPEC: ::cty::c_uint = 0;
    pub const BPF_SKB_TSTAMP_DELIVERY_MONO: ::cty::c_uint = 1;
    pub type _bindgen_ty_30 = ::cty::c_uint;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct __sk_buff {
        pub len: __u32,
        pub pkt_type: __u32,
        pub mark: __u32,
        pub queue_mapping: __u32,
        pub protocol: __u32,
        pub vlan_present: __u32,
        pub vlan_tci: __u32,
        pub vlan_proto: __u32,
        pub priority: __u32,
        pub ingress_ifindex: __u32,
        pub ifindex: __u32,
        pub tc_index: __u32,
        pub cb: [__u32; 5usize],
        pub hash: __u32,
        pub tc_classid: __u32,
        pub data: __u32,
        pub data_end: __u32,
        pub napi_id: __u32,
        pub family: __u32,
        pub remote_ip4: __u32,
        pub local_ip4: __u32,
        pub remote_ip6: [__u32; 4usize],
        pub local_ip6: [__u32; 4usize],
        pub remote_port: __u32,
        pub local_port: __u32,
        pub data_meta: __u32,
        pub __bindgen_anon_1: __sk_buff__bindgen_ty_1,
        pub tstamp: __u64,
        pub wire_len: __u32,
        pub gso_segs: __u32,
        pub __bindgen_anon_2: __sk_buff__bindgen_ty_2,
        pub gso_size: __u32,
        pub tstamp_type: __u8,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
        pub hwtstamp: __u64,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union __sk_buff__bindgen_ty_1 {
        pub flow_keys: *mut bpf_flow_keys,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    }
    #[test]
    fn bindgen_test_layout___sk_buff__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<__sk_buff__bindgen_ty_1>(),
            8usize,
            concat!("Size of: ", stringify!(__sk_buff__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<__sk_buff__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(__sk_buff__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__sk_buff__bindgen_ty_1>())).flow_keys as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sk_buff__bindgen_ty_1),
                "::",
                stringify!(flow_keys)
            )
        );
    }
    impl __sk_buff__bindgen_ty_1 {
        #[inline]
        pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> =
                Default::default();
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union __sk_buff__bindgen_ty_2 {
        pub sk: *mut bpf_sock,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    }
    #[test]
    fn bindgen_test_layout___sk_buff__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<__sk_buff__bindgen_ty_2>(),
            8usize,
            concat!("Size of: ", stringify!(__sk_buff__bindgen_ty_2))
        );
        assert_eq!(
            ::core::mem::align_of::<__sk_buff__bindgen_ty_2>(),
            8usize,
            concat!("Alignment of ", stringify!(__sk_buff__bindgen_ty_2))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__sk_buff__bindgen_ty_2>())).sk as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sk_buff__bindgen_ty_2),
                "::",
                stringify!(sk)
            )
        );
    }
    impl __sk_buff__bindgen_ty_2 {
        #[inline]
        pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> =
                Default::default();
            __bindgen_bitfield_unit
        }
    }
    #[test]
    fn bindgen_test_layout___sk_buff() {
        assert_eq!(
            ::core::mem::size_of::<__sk_buff>(),
            192usize,
            concat!("Size of: ", stringify!(__sk_buff))
        );
        assert_eq!(
            ::core::mem::align_of::<__sk_buff>(),
            8usize,
            concat!("Alignment of ", stringify!(__sk_buff))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__sk_buff>())).len as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sk_buff),
                "::",
                stringify!(len)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__sk_buff>())).pkt_type as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__sk_buff),
                "::",
                stringify!(pkt_type)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__sk_buff>())).mark as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__sk_buff),
                "::",
                stringify!(mark)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__sk_buff>())).queue_mapping as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(__sk_buff),
                "::",
                stringify!(queue_mapping)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__sk_buff>())).protocol as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__sk_buff),
                "::",
                stringify!(protocol)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__sk_buff>())).vlan_present as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(__sk_buff),
                "::",
                stringify!(vlan_present)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__sk_buff>())).vlan_tci as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(__sk_buff),
                "::",
                stringify!(vlan_tci)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__sk_buff>())).vlan_proto as *const _ as usize },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(__sk_buff),
                "::",
                stringify!(vlan_proto)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__sk_buff>())).priority as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(__sk_buff),
                "::",
                stringify!(priority)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__sk_buff>())).ingress_ifindex as *const _ as usize },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(__sk_buff),
                "::",
                stringify!(ingress_ifindex)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__sk_buff>())).ifindex as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(__sk_buff),
                "::",
                stringify!(ifindex)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__sk_buff>())).tc_index as *const _ as usize },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(__sk_buff),
                "::",
                stringify!(tc_index)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__sk_buff>())).cb as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(__sk_buff),
                "::",
                stringify!(cb)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__sk_buff>())).hash as *const _ as usize },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(__sk_buff),
                "::",
                stringify!(hash)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__sk_buff>())).tc_classid as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(__sk_buff),
                "::",
                stringify!(tc_classid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__sk_buff>())).data as *const _ as usize },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(__sk_buff),
                "::",
                stringify!(data)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__sk_buff>())).data_end as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(__sk_buff),
                "::",
                stringify!(data_end)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__sk_buff>())).napi_id as *const _ as usize },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(__sk_buff),
                "::",
                stringify!(napi_id)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__sk_buff>())).family as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(__sk_buff),
                "::",
                stringify!(family)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__sk_buff>())).remote_ip4 as *const _ as usize },
            92usize,
            concat!(
                "Offset of field: ",
                stringify!(__sk_buff),
                "::",
                stringify!(remote_ip4)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__sk_buff>())).local_ip4 as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(__sk_buff),
                "::",
                stringify!(local_ip4)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__sk_buff>())).remote_ip6 as *const _ as usize },
            100usize,
            concat!(
                "Offset of field: ",
                stringify!(__sk_buff),
                "::",
                stringify!(remote_ip6)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__sk_buff>())).local_ip6 as *const _ as usize },
            116usize,
            concat!(
                "Offset of field: ",
                stringify!(__sk_buff),
                "::",
                stringify!(local_ip6)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__sk_buff>())).remote_port as *const _ as usize },
            132usize,
            concat!(
                "Offset of field: ",
                stringify!(__sk_buff),
                "::",
                stringify!(remote_port)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__sk_buff>())).local_port as *const _ as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(__sk_buff),
                "::",
                stringify!(local_port)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__sk_buff>())).data_meta as *const _ as usize },
            140usize,
            concat!(
                "Offset of field: ",
                stringify!(__sk_buff),
                "::",
                stringify!(data_meta)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__sk_buff>())).tstamp as *const _ as usize },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(__sk_buff),
                "::",
                stringify!(tstamp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__sk_buff>())).wire_len as *const _ as usize },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(__sk_buff),
                "::",
                stringify!(wire_len)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__sk_buff>())).gso_segs as *const _ as usize },
            164usize,
            concat!(
                "Offset of field: ",
                stringify!(__sk_buff),
                "::",
                stringify!(gso_segs)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__sk_buff>())).gso_size as *const _ as usize },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(__sk_buff),
                "::",
                stringify!(gso_size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__sk_buff>())).tstamp_type as *const _ as usize },
            180usize,
            concat!(
                "Offset of field: ",
                stringify!(__sk_buff),
                "::",
                stringify!(tstamp_type)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__sk_buff>())).hwtstamp as *const _ as usize },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(__sk_buff),
                "::",
                stringify!(hwtstamp)
            )
        );
    }
    impl __sk_buff {
        #[inline]
        pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 3usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> =
                Default::default();
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct bpf_tunnel_key {
        pub tunnel_id: __u32,
        pub __bindgen_anon_1: bpf_tunnel_key__bindgen_ty_1,
        pub tunnel_tos: __u8,
        pub tunnel_ttl: __u8,
        pub __bindgen_anon_2: bpf_tunnel_key__bindgen_ty_2,
        pub tunnel_label: __u32,
        pub __bindgen_anon_3: bpf_tunnel_key__bindgen_ty_3,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union bpf_tunnel_key__bindgen_ty_1 {
        pub remote_ipv4: __u32,
        pub remote_ipv6: [__u32; 4usize],
    }
    #[test]
    fn bindgen_test_layout_bpf_tunnel_key__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<bpf_tunnel_key__bindgen_ty_1>(),
            16usize,
            concat!("Size of: ", stringify!(bpf_tunnel_key__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_tunnel_key__bindgen_ty_1>(),
            4usize,
            concat!("Alignment of ", stringify!(bpf_tunnel_key__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_tunnel_key__bindgen_ty_1>())).remote_ipv4 as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_tunnel_key__bindgen_ty_1),
                "::",
                stringify!(remote_ipv4)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_tunnel_key__bindgen_ty_1>())).remote_ipv6 as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_tunnel_key__bindgen_ty_1),
                "::",
                stringify!(remote_ipv6)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union bpf_tunnel_key__bindgen_ty_2 {
        pub tunnel_ext: __u16,
        pub tunnel_flags: __be16,
    }
    #[test]
    fn bindgen_test_layout_bpf_tunnel_key__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<bpf_tunnel_key__bindgen_ty_2>(),
            2usize,
            concat!("Size of: ", stringify!(bpf_tunnel_key__bindgen_ty_2))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_tunnel_key__bindgen_ty_2>(),
            2usize,
            concat!("Alignment of ", stringify!(bpf_tunnel_key__bindgen_ty_2))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_tunnel_key__bindgen_ty_2>())).tunnel_ext as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_tunnel_key__bindgen_ty_2),
                "::",
                stringify!(tunnel_ext)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_tunnel_key__bindgen_ty_2>())).tunnel_flags as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_tunnel_key__bindgen_ty_2),
                "::",
                stringify!(tunnel_flags)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union bpf_tunnel_key__bindgen_ty_3 {
        pub local_ipv4: __u32,
        pub local_ipv6: [__u32; 4usize],
    }
    #[test]
    fn bindgen_test_layout_bpf_tunnel_key__bindgen_ty_3() {
        assert_eq!(
            ::core::mem::size_of::<bpf_tunnel_key__bindgen_ty_3>(),
            16usize,
            concat!("Size of: ", stringify!(bpf_tunnel_key__bindgen_ty_3))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_tunnel_key__bindgen_ty_3>(),
            4usize,
            concat!("Alignment of ", stringify!(bpf_tunnel_key__bindgen_ty_3))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_tunnel_key__bindgen_ty_3>())).local_ipv4 as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_tunnel_key__bindgen_ty_3),
                "::",
                stringify!(local_ipv4)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_tunnel_key__bindgen_ty_3>())).local_ipv6 as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_tunnel_key__bindgen_ty_3),
                "::",
                stringify!(local_ipv6)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_bpf_tunnel_key() {
        assert_eq!(
            ::core::mem::size_of::<bpf_tunnel_key>(),
            44usize,
            concat!("Size of: ", stringify!(bpf_tunnel_key))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_tunnel_key>(),
            4usize,
            concat!("Alignment of ", stringify!(bpf_tunnel_key))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_tunnel_key>())).tunnel_id as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_tunnel_key),
                "::",
                stringify!(tunnel_id)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_tunnel_key>())).tunnel_tos as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_tunnel_key),
                "::",
                stringify!(tunnel_tos)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_tunnel_key>())).tunnel_ttl as *const _ as usize },
            21usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_tunnel_key),
                "::",
                stringify!(tunnel_ttl)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_tunnel_key>())).tunnel_label as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_tunnel_key),
                "::",
                stringify!(tunnel_label)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct bpf_xfrm_state {
        pub reqid: __u32,
        pub spi: __u32,
        pub family: __u16,
        pub ext: __u16,
        pub __bindgen_anon_1: bpf_xfrm_state__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union bpf_xfrm_state__bindgen_ty_1 {
        pub remote_ipv4: __u32,
        pub remote_ipv6: [__u32; 4usize],
    }
    #[test]
    fn bindgen_test_layout_bpf_xfrm_state__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<bpf_xfrm_state__bindgen_ty_1>(),
            16usize,
            concat!("Size of: ", stringify!(bpf_xfrm_state__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_xfrm_state__bindgen_ty_1>(),
            4usize,
            concat!("Alignment of ", stringify!(bpf_xfrm_state__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_xfrm_state__bindgen_ty_1>())).remote_ipv4 as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_xfrm_state__bindgen_ty_1),
                "::",
                stringify!(remote_ipv4)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_xfrm_state__bindgen_ty_1>())).remote_ipv6 as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_xfrm_state__bindgen_ty_1),
                "::",
                stringify!(remote_ipv6)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_bpf_xfrm_state() {
        assert_eq!(
            ::core::mem::size_of::<bpf_xfrm_state>(),
            28usize,
            concat!("Size of: ", stringify!(bpf_xfrm_state))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_xfrm_state>(),
            4usize,
            concat!("Alignment of ", stringify!(bpf_xfrm_state))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_xfrm_state>())).reqid as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_xfrm_state),
                "::",
                stringify!(reqid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_xfrm_state>())).spi as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_xfrm_state),
                "::",
                stringify!(spi)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_xfrm_state>())).family as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_xfrm_state),
                "::",
                stringify!(family)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_xfrm_state>())).ext as *const _ as usize },
            10usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_xfrm_state),
                "::",
                stringify!(ext)
            )
        );
    }
    pub const bpf_ret_code_BPF_OK: bpf_ret_code = 0;
    pub const bpf_ret_code_BPF_DROP: bpf_ret_code = 2;
    pub const bpf_ret_code_BPF_REDIRECT: bpf_ret_code = 7;
    pub const bpf_ret_code_BPF_LWT_REROUTE: bpf_ret_code = 128;
    pub const bpf_ret_code_BPF_FLOW_DISSECTOR_CONTINUE: bpf_ret_code = 129;
    pub type bpf_ret_code = ::cty::c_uint;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_sock {
        pub bound_dev_if: __u32,
        pub family: __u32,
        pub type_: __u32,
        pub protocol: __u32,
        pub mark: __u32,
        pub priority: __u32,
        pub src_ip4: __u32,
        pub src_ip6: [__u32; 4usize],
        pub src_port: __u32,
        pub dst_port: __be16,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
        pub dst_ip4: __u32,
        pub dst_ip6: [__u32; 4usize],
        pub state: __u32,
        pub rx_queue_mapping: __s32,
    }
    #[test]
    fn bindgen_test_layout_bpf_sock() {
        assert_eq!(
            ::core::mem::size_of::<bpf_sock>(),
            80usize,
            concat!("Size of: ", stringify!(bpf_sock))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_sock>(),
            4usize,
            concat!("Alignment of ", stringify!(bpf_sock))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock>())).bound_dev_if as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock),
                "::",
                stringify!(bound_dev_if)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock>())).family as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock),
                "::",
                stringify!(family)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock>())).type_ as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock),
                "::",
                stringify!(type_)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock>())).protocol as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock),
                "::",
                stringify!(protocol)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock>())).mark as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock),
                "::",
                stringify!(mark)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock>())).priority as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock),
                "::",
                stringify!(priority)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock>())).src_ip4 as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock),
                "::",
                stringify!(src_ip4)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock>())).src_ip6 as *const _ as usize },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock),
                "::",
                stringify!(src_ip6)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock>())).src_port as *const _ as usize },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock),
                "::",
                stringify!(src_port)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock>())).dst_port as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock),
                "::",
                stringify!(dst_port)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock>())).dst_ip4 as *const _ as usize },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock),
                "::",
                stringify!(dst_ip4)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock>())).dst_ip6 as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock),
                "::",
                stringify!(dst_ip6)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock>())).state as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock),
                "::",
                stringify!(state)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock>())).rx_queue_mapping as *const _ as usize },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock),
                "::",
                stringify!(rx_queue_mapping)
            )
        );
    }
    impl bpf_sock {
        #[inline]
        pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 2usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> =
                Default::default();
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_tcp_sock {
        pub snd_cwnd: __u32,
        pub srtt_us: __u32,
        pub rtt_min: __u32,
        pub snd_ssthresh: __u32,
        pub rcv_nxt: __u32,
        pub snd_nxt: __u32,
        pub snd_una: __u32,
        pub mss_cache: __u32,
        pub ecn_flags: __u32,
        pub rate_delivered: __u32,
        pub rate_interval_us: __u32,
        pub packets_out: __u32,
        pub retrans_out: __u32,
        pub total_retrans: __u32,
        pub segs_in: __u32,
        pub data_segs_in: __u32,
        pub segs_out: __u32,
        pub data_segs_out: __u32,
        pub lost_out: __u32,
        pub sacked_out: __u32,
        pub bytes_received: __u64,
        pub bytes_acked: __u64,
        pub dsack_dups: __u32,
        pub delivered: __u32,
        pub delivered_ce: __u32,
        pub icsk_retransmits: __u32,
    }
    #[test]
    fn bindgen_test_layout_bpf_tcp_sock() {
        assert_eq!(
            ::core::mem::size_of::<bpf_tcp_sock>(),
            112usize,
            concat!("Size of: ", stringify!(bpf_tcp_sock))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_tcp_sock>(),
            8usize,
            concat!("Alignment of ", stringify!(bpf_tcp_sock))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_tcp_sock>())).snd_cwnd as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_tcp_sock),
                "::",
                stringify!(snd_cwnd)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_tcp_sock>())).srtt_us as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_tcp_sock),
                "::",
                stringify!(srtt_us)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_tcp_sock>())).rtt_min as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_tcp_sock),
                "::",
                stringify!(rtt_min)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_tcp_sock>())).snd_ssthresh as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_tcp_sock),
                "::",
                stringify!(snd_ssthresh)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_tcp_sock>())).rcv_nxt as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_tcp_sock),
                "::",
                stringify!(rcv_nxt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_tcp_sock>())).snd_nxt as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_tcp_sock),
                "::",
                stringify!(snd_nxt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_tcp_sock>())).snd_una as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_tcp_sock),
                "::",
                stringify!(snd_una)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_tcp_sock>())).mss_cache as *const _ as usize },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_tcp_sock),
                "::",
                stringify!(mss_cache)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_tcp_sock>())).ecn_flags as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_tcp_sock),
                "::",
                stringify!(ecn_flags)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_tcp_sock>())).rate_delivered as *const _ as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_tcp_sock),
                "::",
                stringify!(rate_delivered)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_tcp_sock>())).rate_interval_us as *const _ as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_tcp_sock),
                "::",
                stringify!(rate_interval_us)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_tcp_sock>())).packets_out as *const _ as usize },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_tcp_sock),
                "::",
                stringify!(packets_out)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_tcp_sock>())).retrans_out as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_tcp_sock),
                "::",
                stringify!(retrans_out)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_tcp_sock>())).total_retrans as *const _ as usize },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_tcp_sock),
                "::",
                stringify!(total_retrans)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_tcp_sock>())).segs_in as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_tcp_sock),
                "::",
                stringify!(segs_in)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_tcp_sock>())).data_segs_in as *const _ as usize },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_tcp_sock),
                "::",
                stringify!(data_segs_in)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_tcp_sock>())).segs_out as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_tcp_sock),
                "::",
                stringify!(segs_out)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_tcp_sock>())).data_segs_out as *const _ as usize },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_tcp_sock),
                "::",
                stringify!(data_segs_out)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_tcp_sock>())).lost_out as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_tcp_sock),
                "::",
                stringify!(lost_out)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_tcp_sock>())).sacked_out as *const _ as usize },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_tcp_sock),
                "::",
                stringify!(sacked_out)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_tcp_sock>())).bytes_received as *const _ as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_tcp_sock),
                "::",
                stringify!(bytes_received)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_tcp_sock>())).bytes_acked as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_tcp_sock),
                "::",
                stringify!(bytes_acked)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_tcp_sock>())).dsack_dups as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_tcp_sock),
                "::",
                stringify!(dsack_dups)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_tcp_sock>())).delivered as *const _ as usize },
            100usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_tcp_sock),
                "::",
                stringify!(delivered)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_tcp_sock>())).delivered_ce as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_tcp_sock),
                "::",
                stringify!(delivered_ce)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_tcp_sock>())).icsk_retransmits as *const _ as usize
            },
            108usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_tcp_sock),
                "::",
                stringify!(icsk_retransmits)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct bpf_sock_tuple {
        pub __bindgen_anon_1: bpf_sock_tuple__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union bpf_sock_tuple__bindgen_ty_1 {
        pub ipv4: bpf_sock_tuple__bindgen_ty_1__bindgen_ty_1,
        pub ipv6: bpf_sock_tuple__bindgen_ty_1__bindgen_ty_2,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_sock_tuple__bindgen_ty_1__bindgen_ty_1 {
        pub saddr: __be32,
        pub daddr: __be32,
        pub sport: __be16,
        pub dport: __be16,
    }
    #[test]
    fn bindgen_test_layout_bpf_sock_tuple__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<bpf_sock_tuple__bindgen_ty_1__bindgen_ty_1>(),
            12usize,
            concat!(
                "Size of: ",
                stringify!(bpf_sock_tuple__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_sock_tuple__bindgen_ty_1__bindgen_ty_1>(),
            4usize,
            concat!(
                "Alignment of ",
                stringify!(bpf_sock_tuple__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_sock_tuple__bindgen_ty_1__bindgen_ty_1>())).saddr
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_tuple__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(saddr)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_sock_tuple__bindgen_ty_1__bindgen_ty_1>())).daddr
                    as *const _ as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_tuple__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(daddr)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_sock_tuple__bindgen_ty_1__bindgen_ty_1>())).sport
                    as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_tuple__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(sport)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_sock_tuple__bindgen_ty_1__bindgen_ty_1>())).dport
                    as *const _ as usize
            },
            10usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_tuple__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(dport)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_sock_tuple__bindgen_ty_1__bindgen_ty_2 {
        pub saddr: [__be32; 4usize],
        pub daddr: [__be32; 4usize],
        pub sport: __be16,
        pub dport: __be16,
    }
    #[test]
    fn bindgen_test_layout_bpf_sock_tuple__bindgen_ty_1__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<bpf_sock_tuple__bindgen_ty_1__bindgen_ty_2>(),
            36usize,
            concat!(
                "Size of: ",
                stringify!(bpf_sock_tuple__bindgen_ty_1__bindgen_ty_2)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_sock_tuple__bindgen_ty_1__bindgen_ty_2>(),
            4usize,
            concat!(
                "Alignment of ",
                stringify!(bpf_sock_tuple__bindgen_ty_1__bindgen_ty_2)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_sock_tuple__bindgen_ty_1__bindgen_ty_2>())).saddr
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_tuple__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(saddr)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_sock_tuple__bindgen_ty_1__bindgen_ty_2>())).daddr
                    as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_tuple__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(daddr)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_sock_tuple__bindgen_ty_1__bindgen_ty_2>())).sport
                    as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_tuple__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(sport)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_sock_tuple__bindgen_ty_1__bindgen_ty_2>())).dport
                    as *const _ as usize
            },
            34usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_tuple__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(dport)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_bpf_sock_tuple__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<bpf_sock_tuple__bindgen_ty_1>(),
            36usize,
            concat!("Size of: ", stringify!(bpf_sock_tuple__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_sock_tuple__bindgen_ty_1>(),
            4usize,
            concat!("Alignment of ", stringify!(bpf_sock_tuple__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_sock_tuple__bindgen_ty_1>())).ipv4 as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_tuple__bindgen_ty_1),
                "::",
                stringify!(ipv4)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_sock_tuple__bindgen_ty_1>())).ipv6 as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_tuple__bindgen_ty_1),
                "::",
                stringify!(ipv6)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_bpf_sock_tuple() {
        assert_eq!(
            ::core::mem::size_of::<bpf_sock_tuple>(),
            36usize,
            concat!("Size of: ", stringify!(bpf_sock_tuple))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_sock_tuple>(),
            4usize,
            concat!("Alignment of ", stringify!(bpf_sock_tuple))
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_xdp_sock {
        pub queue_id: __u32,
    }
    #[test]
    fn bindgen_test_layout_bpf_xdp_sock() {
        assert_eq!(
            ::core::mem::size_of::<bpf_xdp_sock>(),
            4usize,
            concat!("Size of: ", stringify!(bpf_xdp_sock))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_xdp_sock>(),
            4usize,
            concat!("Alignment of ", stringify!(bpf_xdp_sock))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_xdp_sock>())).queue_id as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_xdp_sock),
                "::",
                stringify!(queue_id)
            )
        );
    }
    pub const xdp_action_XDP_ABORTED: xdp_action = 0;
    pub const xdp_action_XDP_DROP: xdp_action = 1;
    pub const xdp_action_XDP_PASS: xdp_action = 2;
    pub const xdp_action_XDP_TX: xdp_action = 3;
    pub const xdp_action_XDP_REDIRECT: xdp_action = 4;
    pub type xdp_action = ::cty::c_uint;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct xdp_md {
        pub data: __u32,
        pub data_end: __u32,
        pub data_meta: __u32,
        pub ingress_ifindex: __u32,
        pub rx_queue_index: __u32,
        pub egress_ifindex: __u32,
    }
    #[test]
    fn bindgen_test_layout_xdp_md() {
        assert_eq!(
            ::core::mem::size_of::<xdp_md>(),
            24usize,
            concat!("Size of: ", stringify!(xdp_md))
        );
        assert_eq!(
            ::core::mem::align_of::<xdp_md>(),
            4usize,
            concat!("Alignment of ", stringify!(xdp_md))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xdp_md>())).data as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(xdp_md),
                "::",
                stringify!(data)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xdp_md>())).data_end as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(xdp_md),
                "::",
                stringify!(data_end)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xdp_md>())).data_meta as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(xdp_md),
                "::",
                stringify!(data_meta)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xdp_md>())).ingress_ifindex as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(xdp_md),
                "::",
                stringify!(ingress_ifindex)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xdp_md>())).rx_queue_index as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(xdp_md),
                "::",
                stringify!(rx_queue_index)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xdp_md>())).egress_ifindex as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(xdp_md),
                "::",
                stringify!(egress_ifindex)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct bpf_devmap_val {
        pub ifindex: __u32,
        pub bpf_prog: bpf_devmap_val__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union bpf_devmap_val__bindgen_ty_1 {
        pub fd: ::cty::c_int,
        pub id: __u32,
    }
    #[test]
    fn bindgen_test_layout_bpf_devmap_val__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<bpf_devmap_val__bindgen_ty_1>(),
            4usize,
            concat!("Size of: ", stringify!(bpf_devmap_val__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_devmap_val__bindgen_ty_1>(),
            4usize,
            concat!("Alignment of ", stringify!(bpf_devmap_val__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_devmap_val__bindgen_ty_1>())).fd as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_devmap_val__bindgen_ty_1),
                "::",
                stringify!(fd)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_devmap_val__bindgen_ty_1>())).id as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_devmap_val__bindgen_ty_1),
                "::",
                stringify!(id)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_bpf_devmap_val() {
        assert_eq!(
            ::core::mem::size_of::<bpf_devmap_val>(),
            8usize,
            concat!("Size of: ", stringify!(bpf_devmap_val))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_devmap_val>(),
            4usize,
            concat!("Alignment of ", stringify!(bpf_devmap_val))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_devmap_val>())).ifindex as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_devmap_val),
                "::",
                stringify!(ifindex)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_devmap_val>())).bpf_prog as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_devmap_val),
                "::",
                stringify!(bpf_prog)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct bpf_cpumap_val {
        pub qsize: __u32,
        pub bpf_prog: bpf_cpumap_val__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union bpf_cpumap_val__bindgen_ty_1 {
        pub fd: ::cty::c_int,
        pub id: __u32,
    }
    #[test]
    fn bindgen_test_layout_bpf_cpumap_val__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<bpf_cpumap_val__bindgen_ty_1>(),
            4usize,
            concat!("Size of: ", stringify!(bpf_cpumap_val__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_cpumap_val__bindgen_ty_1>(),
            4usize,
            concat!("Alignment of ", stringify!(bpf_cpumap_val__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_cpumap_val__bindgen_ty_1>())).fd as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_cpumap_val__bindgen_ty_1),
                "::",
                stringify!(fd)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_cpumap_val__bindgen_ty_1>())).id as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_cpumap_val__bindgen_ty_1),
                "::",
                stringify!(id)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_bpf_cpumap_val() {
        assert_eq!(
            ::core::mem::size_of::<bpf_cpumap_val>(),
            8usize,
            concat!("Size of: ", stringify!(bpf_cpumap_val))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_cpumap_val>(),
            4usize,
            concat!("Alignment of ", stringify!(bpf_cpumap_val))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_cpumap_val>())).qsize as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_cpumap_val),
                "::",
                stringify!(qsize)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_cpumap_val>())).bpf_prog as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_cpumap_val),
                "::",
                stringify!(bpf_prog)
            )
        );
    }
    pub const sk_action_SK_DROP: sk_action = 0;
    pub const sk_action_SK_PASS: sk_action = 1;
    pub type sk_action = ::cty::c_uint;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct sk_msg_md {
        pub __bindgen_anon_1: sk_msg_md__bindgen_ty_1,
        pub __bindgen_anon_2: sk_msg_md__bindgen_ty_2,
        pub family: __u32,
        pub remote_ip4: __u32,
        pub local_ip4: __u32,
        pub remote_ip6: [__u32; 4usize],
        pub local_ip6: [__u32; 4usize],
        pub remote_port: __u32,
        pub local_port: __u32,
        pub size: __u32,
        pub __bindgen_anon_3: sk_msg_md__bindgen_ty_3,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union sk_msg_md__bindgen_ty_1 {
        pub data: *mut ::cty::c_void,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    }
    #[test]
    fn bindgen_test_layout_sk_msg_md__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<sk_msg_md__bindgen_ty_1>(),
            8usize,
            concat!("Size of: ", stringify!(sk_msg_md__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<sk_msg_md__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(sk_msg_md__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_msg_md__bindgen_ty_1>())).data as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_msg_md__bindgen_ty_1),
                "::",
                stringify!(data)
            )
        );
    }
    impl sk_msg_md__bindgen_ty_1 {
        #[inline]
        pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> =
                Default::default();
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union sk_msg_md__bindgen_ty_2 {
        pub data_end: *mut ::cty::c_void,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    }
    #[test]
    fn bindgen_test_layout_sk_msg_md__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<sk_msg_md__bindgen_ty_2>(),
            8usize,
            concat!("Size of: ", stringify!(sk_msg_md__bindgen_ty_2))
        );
        assert_eq!(
            ::core::mem::align_of::<sk_msg_md__bindgen_ty_2>(),
            8usize,
            concat!("Alignment of ", stringify!(sk_msg_md__bindgen_ty_2))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_msg_md__bindgen_ty_2>())).data_end as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_msg_md__bindgen_ty_2),
                "::",
                stringify!(data_end)
            )
        );
    }
    impl sk_msg_md__bindgen_ty_2 {
        #[inline]
        pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> =
                Default::default();
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union sk_msg_md__bindgen_ty_3 {
        pub sk: *mut bpf_sock,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    }
    #[test]
    fn bindgen_test_layout_sk_msg_md__bindgen_ty_3() {
        assert_eq!(
            ::core::mem::size_of::<sk_msg_md__bindgen_ty_3>(),
            8usize,
            concat!("Size of: ", stringify!(sk_msg_md__bindgen_ty_3))
        );
        assert_eq!(
            ::core::mem::align_of::<sk_msg_md__bindgen_ty_3>(),
            8usize,
            concat!("Alignment of ", stringify!(sk_msg_md__bindgen_ty_3))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sk_msg_md__bindgen_ty_3>())).sk as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_msg_md__bindgen_ty_3),
                "::",
                stringify!(sk)
            )
        );
    }
    impl sk_msg_md__bindgen_ty_3 {
        #[inline]
        pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> =
                Default::default();
            __bindgen_bitfield_unit
        }
    }
    #[test]
    fn bindgen_test_layout_sk_msg_md() {
        assert_eq!(
            ::core::mem::size_of::<sk_msg_md>(),
            80usize,
            concat!("Size of: ", stringify!(sk_msg_md))
        );
        assert_eq!(
            ::core::mem::align_of::<sk_msg_md>(),
            8usize,
            concat!("Alignment of ", stringify!(sk_msg_md))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sk_msg_md>())).family as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_msg_md),
                "::",
                stringify!(family)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sk_msg_md>())).remote_ip4 as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_msg_md),
                "::",
                stringify!(remote_ip4)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sk_msg_md>())).local_ip4 as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_msg_md),
                "::",
                stringify!(local_ip4)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sk_msg_md>())).remote_ip6 as *const _ as usize },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_msg_md),
                "::",
                stringify!(remote_ip6)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sk_msg_md>())).local_ip6 as *const _ as usize },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_msg_md),
                "::",
                stringify!(local_ip6)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sk_msg_md>())).remote_port as *const _ as usize },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_msg_md),
                "::",
                stringify!(remote_port)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sk_msg_md>())).local_port as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_msg_md),
                "::",
                stringify!(local_port)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sk_msg_md>())).size as *const _ as usize },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_msg_md),
                "::",
                stringify!(size)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct sk_reuseport_md {
        pub __bindgen_anon_1: sk_reuseport_md__bindgen_ty_1,
        pub __bindgen_anon_2: sk_reuseport_md__bindgen_ty_2,
        pub len: __u32,
        pub eth_protocol: __u32,
        pub ip_protocol: __u32,
        pub bind_inany: __u32,
        pub hash: __u32,
        pub __bindgen_anon_3: sk_reuseport_md__bindgen_ty_3,
        pub __bindgen_anon_4: sk_reuseport_md__bindgen_ty_4,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union sk_reuseport_md__bindgen_ty_1 {
        pub data: *mut ::cty::c_void,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    }
    #[test]
    fn bindgen_test_layout_sk_reuseport_md__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<sk_reuseport_md__bindgen_ty_1>(),
            8usize,
            concat!("Size of: ", stringify!(sk_reuseport_md__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<sk_reuseport_md__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(sk_reuseport_md__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_reuseport_md__bindgen_ty_1>())).data as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_reuseport_md__bindgen_ty_1),
                "::",
                stringify!(data)
            )
        );
    }
    impl sk_reuseport_md__bindgen_ty_1 {
        #[inline]
        pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> =
                Default::default();
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union sk_reuseport_md__bindgen_ty_2 {
        pub data_end: *mut ::cty::c_void,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    }
    #[test]
    fn bindgen_test_layout_sk_reuseport_md__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<sk_reuseport_md__bindgen_ty_2>(),
            8usize,
            concat!("Size of: ", stringify!(sk_reuseport_md__bindgen_ty_2))
        );
        assert_eq!(
            ::core::mem::align_of::<sk_reuseport_md__bindgen_ty_2>(),
            8usize,
            concat!("Alignment of ", stringify!(sk_reuseport_md__bindgen_ty_2))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_reuseport_md__bindgen_ty_2>())).data_end as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_reuseport_md__bindgen_ty_2),
                "::",
                stringify!(data_end)
            )
        );
    }
    impl sk_reuseport_md__bindgen_ty_2 {
        #[inline]
        pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> =
                Default::default();
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union sk_reuseport_md__bindgen_ty_3 {
        pub sk: *mut bpf_sock,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    }
    #[test]
    fn bindgen_test_layout_sk_reuseport_md__bindgen_ty_3() {
        assert_eq!(
            ::core::mem::size_of::<sk_reuseport_md__bindgen_ty_3>(),
            8usize,
            concat!("Size of: ", stringify!(sk_reuseport_md__bindgen_ty_3))
        );
        assert_eq!(
            ::core::mem::align_of::<sk_reuseport_md__bindgen_ty_3>(),
            8usize,
            concat!("Alignment of ", stringify!(sk_reuseport_md__bindgen_ty_3))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_reuseport_md__bindgen_ty_3>())).sk as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_reuseport_md__bindgen_ty_3),
                "::",
                stringify!(sk)
            )
        );
    }
    impl sk_reuseport_md__bindgen_ty_3 {
        #[inline]
        pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> =
                Default::default();
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union sk_reuseport_md__bindgen_ty_4 {
        pub migrating_sk: *mut bpf_sock,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    }
    #[test]
    fn bindgen_test_layout_sk_reuseport_md__bindgen_ty_4() {
        assert_eq!(
            ::core::mem::size_of::<sk_reuseport_md__bindgen_ty_4>(),
            8usize,
            concat!("Size of: ", stringify!(sk_reuseport_md__bindgen_ty_4))
        );
        assert_eq!(
            ::core::mem::align_of::<sk_reuseport_md__bindgen_ty_4>(),
            8usize,
            concat!("Alignment of ", stringify!(sk_reuseport_md__bindgen_ty_4))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_reuseport_md__bindgen_ty_4>())).migrating_sk as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_reuseport_md__bindgen_ty_4),
                "::",
                stringify!(migrating_sk)
            )
        );
    }
    impl sk_reuseport_md__bindgen_ty_4 {
        #[inline]
        pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> =
                Default::default();
            __bindgen_bitfield_unit
        }
    }
    #[test]
    fn bindgen_test_layout_sk_reuseport_md() {
        assert_eq!(
            ::core::mem::size_of::<sk_reuseport_md>(),
            56usize,
            concat!("Size of: ", stringify!(sk_reuseport_md))
        );
        assert_eq!(
            ::core::mem::align_of::<sk_reuseport_md>(),
            8usize,
            concat!("Alignment of ", stringify!(sk_reuseport_md))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sk_reuseport_md>())).len as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_reuseport_md),
                "::",
                stringify!(len)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_reuseport_md>())).eth_protocol as *const _ as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_reuseport_md),
                "::",
                stringify!(eth_protocol)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_reuseport_md>())).ip_protocol as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_reuseport_md),
                "::",
                stringify!(ip_protocol)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sk_reuseport_md>())).bind_inany as *const _ as usize },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_reuseport_md),
                "::",
                stringify!(bind_inany)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sk_reuseport_md>())).hash as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_reuseport_md),
                "::",
                stringify!(hash)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_prog_info {
        pub type_: __u32,
        pub id: __u32,
        pub tag: [__u8; 8usize],
        pub jited_prog_len: __u32,
        pub xlated_prog_len: __u32,
        pub jited_prog_insns: __u64,
        pub xlated_prog_insns: __u64,
        pub load_time: __u64,
        pub created_by_uid: __u32,
        pub nr_map_ids: __u32,
        pub map_ids: __u64,
        pub name: [::cty::c_char; 16usize],
        pub ifindex: __u32,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
        pub netns_dev: __u64,
        pub netns_ino: __u64,
        pub nr_jited_ksyms: __u32,
        pub nr_jited_func_lens: __u32,
        pub jited_ksyms: __u64,
        pub jited_func_lens: __u64,
        pub btf_id: __u32,
        pub func_info_rec_size: __u32,
        pub func_info: __u64,
        pub nr_func_info: __u32,
        pub nr_line_info: __u32,
        pub line_info: __u64,
        pub jited_line_info: __u64,
        pub nr_jited_line_info: __u32,
        pub line_info_rec_size: __u32,
        pub jited_line_info_rec_size: __u32,
        pub nr_prog_tags: __u32,
        pub prog_tags: __u64,
        pub run_time_ns: __u64,
        pub run_cnt: __u64,
        pub recursion_misses: __u64,
        pub verified_insns: __u32,
        pub attach_btf_obj_id: __u32,
        pub attach_btf_id: __u32,
    }
    #[test]
    fn bindgen_test_layout_bpf_prog_info() {
        assert_eq!(
            ::core::mem::size_of::<bpf_prog_info>(),
            232usize,
            concat!("Size of: ", stringify!(bpf_prog_info))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_prog_info>(),
            8usize,
            concat!("Alignment of ", stringify!(bpf_prog_info))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_prog_info>())).type_ as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_prog_info),
                "::",
                stringify!(type_)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_prog_info>())).id as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_prog_info),
                "::",
                stringify!(id)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_prog_info>())).tag as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_prog_info),
                "::",
                stringify!(tag)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_prog_info>())).jited_prog_len as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_prog_info),
                "::",
                stringify!(jited_prog_len)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_prog_info>())).xlated_prog_len as *const _ as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_prog_info),
                "::",
                stringify!(xlated_prog_len)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_prog_info>())).jited_prog_insns as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_prog_info),
                "::",
                stringify!(jited_prog_insns)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_prog_info>())).xlated_prog_insns as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_prog_info),
                "::",
                stringify!(xlated_prog_insns)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_prog_info>())).load_time as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_prog_info),
                "::",
                stringify!(load_time)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_prog_info>())).created_by_uid as *const _ as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_prog_info),
                "::",
                stringify!(created_by_uid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_prog_info>())).nr_map_ids as *const _ as usize },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_prog_info),
                "::",
                stringify!(nr_map_ids)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_prog_info>())).map_ids as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_prog_info),
                "::",
                stringify!(map_ids)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_prog_info>())).name as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_prog_info),
                "::",
                stringify!(name)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_prog_info>())).ifindex as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_prog_info),
                "::",
                stringify!(ifindex)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_prog_info>())).netns_dev as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_prog_info),
                "::",
                stringify!(netns_dev)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_prog_info>())).netns_ino as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_prog_info),
                "::",
                stringify!(netns_ino)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_prog_info>())).nr_jited_ksyms as *const _ as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_prog_info),
                "::",
                stringify!(nr_jited_ksyms)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_prog_info>())).nr_jited_func_lens as *const _ as usize
            },
            108usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_prog_info),
                "::",
                stringify!(nr_jited_func_lens)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_prog_info>())).jited_ksyms as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_prog_info),
                "::",
                stringify!(jited_ksyms)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_prog_info>())).jited_func_lens as *const _ as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_prog_info),
                "::",
                stringify!(jited_func_lens)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_prog_info>())).btf_id as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_prog_info),
                "::",
                stringify!(btf_id)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_prog_info>())).func_info_rec_size as *const _ as usize
            },
            132usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_prog_info),
                "::",
                stringify!(func_info_rec_size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_prog_info>())).func_info as *const _ as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_prog_info),
                "::",
                stringify!(func_info)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_prog_info>())).nr_func_info as *const _ as usize },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_prog_info),
                "::",
                stringify!(nr_func_info)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_prog_info>())).nr_line_info as *const _ as usize },
            148usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_prog_info),
                "::",
                stringify!(nr_line_info)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_prog_info>())).line_info as *const _ as usize },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_prog_info),
                "::",
                stringify!(line_info)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_prog_info>())).jited_line_info as *const _ as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_prog_info),
                "::",
                stringify!(jited_line_info)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_prog_info>())).nr_jited_line_info as *const _ as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_prog_info),
                "::",
                stringify!(nr_jited_line_info)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_prog_info>())).line_info_rec_size as *const _ as usize
            },
            172usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_prog_info),
                "::",
                stringify!(line_info_rec_size)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_prog_info>())).jited_line_info_rec_size as *const _
                    as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_prog_info),
                "::",
                stringify!(jited_line_info_rec_size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_prog_info>())).nr_prog_tags as *const _ as usize },
            180usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_prog_info),
                "::",
                stringify!(nr_prog_tags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_prog_info>())).prog_tags as *const _ as usize },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_prog_info),
                "::",
                stringify!(prog_tags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_prog_info>())).run_time_ns as *const _ as usize },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_prog_info),
                "::",
                stringify!(run_time_ns)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_prog_info>())).run_cnt as *const _ as usize },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_prog_info),
                "::",
                stringify!(run_cnt)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_prog_info>())).recursion_misses as *const _ as usize
            },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_prog_info),
                "::",
                stringify!(recursion_misses)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_prog_info>())).verified_insns as *const _ as usize
            },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_prog_info),
                "::",
                stringify!(verified_insns)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_prog_info>())).attach_btf_obj_id as *const _ as usize
            },
            220usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_prog_info),
                "::",
                stringify!(attach_btf_obj_id)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_prog_info>())).attach_btf_id as *const _ as usize
            },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_prog_info),
                "::",
                stringify!(attach_btf_id)
            )
        );
    }
    impl bpf_prog_info {
        #[inline]
        pub fn gpl_compatible(&self) -> __u32 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_gpl_compatible(&mut self, val: __u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(gpl_compatible: __u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 1u8, {
                let gpl_compatible: u32 = unsafe { ::core::mem::transmute(gpl_compatible) };
                gpl_compatible as u64
            });
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_map_info {
        pub type_: __u32,
        pub id: __u32,
        pub key_size: __u32,
        pub value_size: __u32,
        pub max_entries: __u32,
        pub map_flags: __u32,
        pub name: [::cty::c_char; 16usize],
        pub ifindex: __u32,
        pub btf_vmlinux_value_type_id: __u32,
        pub netns_dev: __u64,
        pub netns_ino: __u64,
        pub btf_id: __u32,
        pub btf_key_type_id: __u32,
        pub btf_value_type_id: __u32,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
        pub map_extra: __u64,
    }
    #[test]
    fn bindgen_test_layout_bpf_map_info() {
        assert_eq!(
            ::core::mem::size_of::<bpf_map_info>(),
            88usize,
            concat!("Size of: ", stringify!(bpf_map_info))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_map_info>(),
            8usize,
            concat!("Alignment of ", stringify!(bpf_map_info))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_map_info>())).type_ as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_map_info),
                "::",
                stringify!(type_)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_map_info>())).id as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_map_info),
                "::",
                stringify!(id)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_map_info>())).key_size as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_map_info),
                "::",
                stringify!(key_size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_map_info>())).value_size as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_map_info),
                "::",
                stringify!(value_size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_map_info>())).max_entries as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_map_info),
                "::",
                stringify!(max_entries)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_map_info>())).map_flags as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_map_info),
                "::",
                stringify!(map_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_map_info>())).name as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_map_info),
                "::",
                stringify!(name)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_map_info>())).ifindex as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_map_info),
                "::",
                stringify!(ifindex)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_map_info>())).btf_vmlinux_value_type_id as *const _
                    as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_map_info),
                "::",
                stringify!(btf_vmlinux_value_type_id)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_map_info>())).netns_dev as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_map_info),
                "::",
                stringify!(netns_dev)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_map_info>())).netns_ino as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_map_info),
                "::",
                stringify!(netns_ino)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_map_info>())).btf_id as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_map_info),
                "::",
                stringify!(btf_id)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_map_info>())).btf_key_type_id as *const _ as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_map_info),
                "::",
                stringify!(btf_key_type_id)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_map_info>())).btf_value_type_id as *const _ as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_map_info),
                "::",
                stringify!(btf_value_type_id)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_map_info>())).map_extra as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_map_info),
                "::",
                stringify!(map_extra)
            )
        );
    }
    impl bpf_map_info {
        #[inline]
        pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> =
                Default::default();
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_btf_info {
        pub btf: __u64,
        pub btf_size: __u32,
        pub id: __u32,
        pub name: __u64,
        pub name_len: __u32,
        pub kernel_btf: __u32,
    }
    #[test]
    fn bindgen_test_layout_bpf_btf_info() {
        assert_eq!(
            ::core::mem::size_of::<bpf_btf_info>(),
            32usize,
            concat!("Size of: ", stringify!(bpf_btf_info))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_btf_info>(),
            8usize,
            concat!("Alignment of ", stringify!(bpf_btf_info))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_btf_info>())).btf as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_btf_info),
                "::",
                stringify!(btf)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_btf_info>())).btf_size as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_btf_info),
                "::",
                stringify!(btf_size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_btf_info>())).id as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_btf_info),
                "::",
                stringify!(id)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_btf_info>())).name as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_btf_info),
                "::",
                stringify!(name)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_btf_info>())).name_len as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_btf_info),
                "::",
                stringify!(name_len)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_btf_info>())).kernel_btf as *const _ as usize },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_btf_info),
                "::",
                stringify!(kernel_btf)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct bpf_link_info {
        pub type_: __u32,
        pub id: __u32,
        pub prog_id: __u32,
        pub __bindgen_anon_1: bpf_link_info__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union bpf_link_info__bindgen_ty_1 {
        pub raw_tracepoint: bpf_link_info__bindgen_ty_1__bindgen_ty_1,
        pub tracing: bpf_link_info__bindgen_ty_1__bindgen_ty_2,
        pub cgroup: bpf_link_info__bindgen_ty_1__bindgen_ty_3,
        pub iter: bpf_link_info__bindgen_ty_1__bindgen_ty_4,
        pub netns: bpf_link_info__bindgen_ty_1__bindgen_ty_5,
        pub xdp: bpf_link_info__bindgen_ty_1__bindgen_ty_6,
        pub struct_ops: bpf_link_info__bindgen_ty_1__bindgen_ty_7,
        pub netfilter: bpf_link_info__bindgen_ty_1__bindgen_ty_8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_1 {
        pub tp_name: __u64,
        pub tp_name_len: __u32,
    }
    #[test]
    fn bindgen_test_layout_bpf_link_info__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<bpf_link_info__bindgen_ty_1__bindgen_ty_1>(),
            16usize,
            concat!(
                "Size of: ",
                stringify!(bpf_link_info__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_link_info__bindgen_ty_1__bindgen_ty_1>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(bpf_link_info__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_link_info__bindgen_ty_1__bindgen_ty_1>())).tp_name
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_link_info__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(tp_name)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_link_info__bindgen_ty_1__bindgen_ty_1>())).tp_name_len
                    as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_link_info__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(tp_name_len)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_2 {
        pub attach_type: __u32,
        pub target_obj_id: __u32,
        pub target_btf_id: __u32,
    }
    #[test]
    fn bindgen_test_layout_bpf_link_info__bindgen_ty_1__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<bpf_link_info__bindgen_ty_1__bindgen_ty_2>(),
            12usize,
            concat!(
                "Size of: ",
                stringify!(bpf_link_info__bindgen_ty_1__bindgen_ty_2)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_link_info__bindgen_ty_1__bindgen_ty_2>(),
            4usize,
            concat!(
                "Alignment of ",
                stringify!(bpf_link_info__bindgen_ty_1__bindgen_ty_2)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_link_info__bindgen_ty_1__bindgen_ty_2>())).attach_type
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_link_info__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(attach_type)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_link_info__bindgen_ty_1__bindgen_ty_2>())).target_obj_id
                    as *const _ as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_link_info__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(target_obj_id)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_link_info__bindgen_ty_1__bindgen_ty_2>())).target_btf_id
                    as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_link_info__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(target_btf_id)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_3 {
        pub cgroup_id: __u64,
        pub attach_type: __u32,
    }
    #[test]
    fn bindgen_test_layout_bpf_link_info__bindgen_ty_1__bindgen_ty_3() {
        assert_eq!(
            ::core::mem::size_of::<bpf_link_info__bindgen_ty_1__bindgen_ty_3>(),
            16usize,
            concat!(
                "Size of: ",
                stringify!(bpf_link_info__bindgen_ty_1__bindgen_ty_3)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_link_info__bindgen_ty_1__bindgen_ty_3>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(bpf_link_info__bindgen_ty_1__bindgen_ty_3)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_link_info__bindgen_ty_1__bindgen_ty_3>())).cgroup_id
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_link_info__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(cgroup_id)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_link_info__bindgen_ty_1__bindgen_ty_3>())).attach_type
                    as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_link_info__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(attach_type)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_4 {
        pub target_name: __u64,
        pub target_name_len: __u32,
        pub __bindgen_anon_1: bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1,
        pub __bindgen_anon_2: bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 {
        pub map: bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1 {
        pub map_id: __u32,
    }
    #[test]
    fn bindgen_test_layout_bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<
                bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1,
            >(),
            4usize,
            concat!(
                "Size of: ",
                stringify!(bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<
                bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1,
            >(),
            4usize,
            concat!(
                "Alignment of ",
                stringify!(bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<
                    bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1,
                >()))
                .map_id as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(map_id)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1>(),
            4usize,
            concat!(
                "Size of: ",
                stringify!(bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1>(),
            4usize,
            concat!(
                "Alignment of ",
                stringify!(bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1>()))
                    .map as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1),
                "::",
                stringify!(map)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2 {
        pub cgroup: bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2__bindgen_ty_1,
        pub task: bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2__bindgen_ty_2,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2__bindgen_ty_1 {
        pub cgroup_id: __u64,
        pub order: __u32,
    }
    #[test]
    fn bindgen_test_layout_bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<
                bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2__bindgen_ty_1,
            >(),
            16usize,
            concat!(
                "Size of: ",
                stringify!(bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<
                bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2__bindgen_ty_1,
            >(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<
                    bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2__bindgen_ty_1,
                >()))
                .cgroup_id as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2__bindgen_ty_1),
                "::",
                stringify!(cgroup_id)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<
                    bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2__bindgen_ty_1,
                >()))
                .order as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2__bindgen_ty_1),
                "::",
                stringify!(order)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2__bindgen_ty_2 {
        pub tid: __u32,
        pub pid: __u32,
    }
    #[test]
    fn bindgen_test_layout_bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<
                bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2__bindgen_ty_2,
            >(),
            8usize,
            concat!(
                "Size of: ",
                stringify!(bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2__bindgen_ty_2)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<
                bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2__bindgen_ty_2,
            >(),
            4usize,
            concat!(
                "Alignment of ",
                stringify!(bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2__bindgen_ty_2)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<
                    bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2__bindgen_ty_2,
                >()))
                .tid as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2__bindgen_ty_2),
                "::",
                stringify!(tid)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<
                    bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2__bindgen_ty_2,
                >()))
                .pid as *const _ as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2__bindgen_ty_2),
                "::",
                stringify!(pid)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2>(),
            16usize,
            concat!(
                "Size of: ",
                stringify!(bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2>()))
                    .cgroup as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2),
                "::",
                stringify!(cgroup)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2>()))
                    .task as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2),
                "::",
                stringify!(task)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_bpf_link_info__bindgen_ty_1__bindgen_ty_4() {
        assert_eq!(
            ::core::mem::size_of::<bpf_link_info__bindgen_ty_1__bindgen_ty_4>(),
            32usize,
            concat!(
                "Size of: ",
                stringify!(bpf_link_info__bindgen_ty_1__bindgen_ty_4)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_link_info__bindgen_ty_1__bindgen_ty_4>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(bpf_link_info__bindgen_ty_1__bindgen_ty_4)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_link_info__bindgen_ty_1__bindgen_ty_4>())).target_name
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_link_info__bindgen_ty_1__bindgen_ty_4),
                "::",
                stringify!(target_name)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_link_info__bindgen_ty_1__bindgen_ty_4>()))
                    .target_name_len as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_link_info__bindgen_ty_1__bindgen_ty_4),
                "::",
                stringify!(target_name_len)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_5 {
        pub netns_ino: __u32,
        pub attach_type: __u32,
    }
    #[test]
    fn bindgen_test_layout_bpf_link_info__bindgen_ty_1__bindgen_ty_5() {
        assert_eq!(
            ::core::mem::size_of::<bpf_link_info__bindgen_ty_1__bindgen_ty_5>(),
            8usize,
            concat!(
                "Size of: ",
                stringify!(bpf_link_info__bindgen_ty_1__bindgen_ty_5)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_link_info__bindgen_ty_1__bindgen_ty_5>(),
            4usize,
            concat!(
                "Alignment of ",
                stringify!(bpf_link_info__bindgen_ty_1__bindgen_ty_5)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_link_info__bindgen_ty_1__bindgen_ty_5>())).netns_ino
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_link_info__bindgen_ty_1__bindgen_ty_5),
                "::",
                stringify!(netns_ino)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_link_info__bindgen_ty_1__bindgen_ty_5>())).attach_type
                    as *const _ as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_link_info__bindgen_ty_1__bindgen_ty_5),
                "::",
                stringify!(attach_type)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_6 {
        pub ifindex: __u32,
    }
    #[test]
    fn bindgen_test_layout_bpf_link_info__bindgen_ty_1__bindgen_ty_6() {
        assert_eq!(
            ::core::mem::size_of::<bpf_link_info__bindgen_ty_1__bindgen_ty_6>(),
            4usize,
            concat!(
                "Size of: ",
                stringify!(bpf_link_info__bindgen_ty_1__bindgen_ty_6)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_link_info__bindgen_ty_1__bindgen_ty_6>(),
            4usize,
            concat!(
                "Alignment of ",
                stringify!(bpf_link_info__bindgen_ty_1__bindgen_ty_6)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_link_info__bindgen_ty_1__bindgen_ty_6>())).ifindex
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_link_info__bindgen_ty_1__bindgen_ty_6),
                "::",
                stringify!(ifindex)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_7 {
        pub map_id: __u32,
    }
    #[test]
    fn bindgen_test_layout_bpf_link_info__bindgen_ty_1__bindgen_ty_7() {
        assert_eq!(
            ::core::mem::size_of::<bpf_link_info__bindgen_ty_1__bindgen_ty_7>(),
            4usize,
            concat!(
                "Size of: ",
                stringify!(bpf_link_info__bindgen_ty_1__bindgen_ty_7)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_link_info__bindgen_ty_1__bindgen_ty_7>(),
            4usize,
            concat!(
                "Alignment of ",
                stringify!(bpf_link_info__bindgen_ty_1__bindgen_ty_7)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_link_info__bindgen_ty_1__bindgen_ty_7>())).map_id
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_link_info__bindgen_ty_1__bindgen_ty_7),
                "::",
                stringify!(map_id)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_8 {
        pub pf: __u32,
        pub hooknum: __u32,
        pub priority: __s32,
        pub flags: __u32,
    }
    #[test]
    fn bindgen_test_layout_bpf_link_info__bindgen_ty_1__bindgen_ty_8() {
        assert_eq!(
            ::core::mem::size_of::<bpf_link_info__bindgen_ty_1__bindgen_ty_8>(),
            16usize,
            concat!(
                "Size of: ",
                stringify!(bpf_link_info__bindgen_ty_1__bindgen_ty_8)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_link_info__bindgen_ty_1__bindgen_ty_8>(),
            4usize,
            concat!(
                "Alignment of ",
                stringify!(bpf_link_info__bindgen_ty_1__bindgen_ty_8)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_link_info__bindgen_ty_1__bindgen_ty_8>())).pf
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_link_info__bindgen_ty_1__bindgen_ty_8),
                "::",
                stringify!(pf)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_link_info__bindgen_ty_1__bindgen_ty_8>())).hooknum
                    as *const _ as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_link_info__bindgen_ty_1__bindgen_ty_8),
                "::",
                stringify!(hooknum)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_link_info__bindgen_ty_1__bindgen_ty_8>())).priority
                    as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_link_info__bindgen_ty_1__bindgen_ty_8),
                "::",
                stringify!(priority)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_link_info__bindgen_ty_1__bindgen_ty_8>())).flags
                    as *const _ as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_link_info__bindgen_ty_1__bindgen_ty_8),
                "::",
                stringify!(flags)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_bpf_link_info__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<bpf_link_info__bindgen_ty_1>(),
            32usize,
            concat!("Size of: ", stringify!(bpf_link_info__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_link_info__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(bpf_link_info__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_link_info__bindgen_ty_1>())).raw_tracepoint as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_link_info__bindgen_ty_1),
                "::",
                stringify!(raw_tracepoint)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_link_info__bindgen_ty_1>())).tracing as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_link_info__bindgen_ty_1),
                "::",
                stringify!(tracing)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_link_info__bindgen_ty_1>())).cgroup as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_link_info__bindgen_ty_1),
                "::",
                stringify!(cgroup)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_link_info__bindgen_ty_1>())).iter as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_link_info__bindgen_ty_1),
                "::",
                stringify!(iter)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_link_info__bindgen_ty_1>())).netns as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_link_info__bindgen_ty_1),
                "::",
                stringify!(netns)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_link_info__bindgen_ty_1>())).xdp as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_link_info__bindgen_ty_1),
                "::",
                stringify!(xdp)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_link_info__bindgen_ty_1>())).struct_ops as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_link_info__bindgen_ty_1),
                "::",
                stringify!(struct_ops)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_link_info__bindgen_ty_1>())).netfilter as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_link_info__bindgen_ty_1),
                "::",
                stringify!(netfilter)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_bpf_link_info() {
        assert_eq!(
            ::core::mem::size_of::<bpf_link_info>(),
            48usize,
            concat!("Size of: ", stringify!(bpf_link_info))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_link_info>(),
            8usize,
            concat!("Alignment of ", stringify!(bpf_link_info))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_link_info>())).type_ as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_link_info),
                "::",
                stringify!(type_)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_link_info>())).id as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_link_info),
                "::",
                stringify!(id)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_link_info>())).prog_id as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_link_info),
                "::",
                stringify!(prog_id)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct bpf_sock_addr {
        pub user_family: __u32,
        pub user_ip4: __u32,
        pub user_ip6: [__u32; 4usize],
        pub user_port: __u32,
        pub family: __u32,
        pub type_: __u32,
        pub protocol: __u32,
        pub msg_src_ip4: __u32,
        pub msg_src_ip6: [__u32; 4usize],
        pub __bindgen_anon_1: bpf_sock_addr__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union bpf_sock_addr__bindgen_ty_1 {
        pub sk: *mut bpf_sock,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    }
    #[test]
    fn bindgen_test_layout_bpf_sock_addr__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<bpf_sock_addr__bindgen_ty_1>(),
            8usize,
            concat!("Size of: ", stringify!(bpf_sock_addr__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_sock_addr__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(bpf_sock_addr__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_sock_addr__bindgen_ty_1>())).sk as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_addr__bindgen_ty_1),
                "::",
                stringify!(sk)
            )
        );
    }
    impl bpf_sock_addr__bindgen_ty_1 {
        #[inline]
        pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> =
                Default::default();
            __bindgen_bitfield_unit
        }
    }
    #[test]
    fn bindgen_test_layout_bpf_sock_addr() {
        assert_eq!(
            ::core::mem::size_of::<bpf_sock_addr>(),
            72usize,
            concat!("Size of: ", stringify!(bpf_sock_addr))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_sock_addr>(),
            8usize,
            concat!("Alignment of ", stringify!(bpf_sock_addr))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock_addr>())).user_family as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_addr),
                "::",
                stringify!(user_family)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock_addr>())).user_ip4 as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_addr),
                "::",
                stringify!(user_ip4)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock_addr>())).user_ip6 as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_addr),
                "::",
                stringify!(user_ip6)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock_addr>())).user_port as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_addr),
                "::",
                stringify!(user_port)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock_addr>())).family as *const _ as usize },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_addr),
                "::",
                stringify!(family)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock_addr>())).type_ as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_addr),
                "::",
                stringify!(type_)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock_addr>())).protocol as *const _ as usize },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_addr),
                "::",
                stringify!(protocol)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock_addr>())).msg_src_ip4 as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_addr),
                "::",
                stringify!(msg_src_ip4)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock_addr>())).msg_src_ip6 as *const _ as usize },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_addr),
                "::",
                stringify!(msg_src_ip6)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct bpf_sock_ops {
        pub op: __u32,
        pub __bindgen_anon_1: bpf_sock_ops__bindgen_ty_1,
        pub family: __u32,
        pub remote_ip4: __u32,
        pub local_ip4: __u32,
        pub remote_ip6: [__u32; 4usize],
        pub local_ip6: [__u32; 4usize],
        pub remote_port: __u32,
        pub local_port: __u32,
        pub is_fullsock: __u32,
        pub snd_cwnd: __u32,
        pub srtt_us: __u32,
        pub bpf_sock_ops_cb_flags: __u32,
        pub state: __u32,
        pub rtt_min: __u32,
        pub snd_ssthresh: __u32,
        pub rcv_nxt: __u32,
        pub snd_nxt: __u32,
        pub snd_una: __u32,
        pub mss_cache: __u32,
        pub ecn_flags: __u32,
        pub rate_delivered: __u32,
        pub rate_interval_us: __u32,
        pub packets_out: __u32,
        pub retrans_out: __u32,
        pub total_retrans: __u32,
        pub segs_in: __u32,
        pub data_segs_in: __u32,
        pub segs_out: __u32,
        pub data_segs_out: __u32,
        pub lost_out: __u32,
        pub sacked_out: __u32,
        pub sk_txhash: __u32,
        pub bytes_received: __u64,
        pub bytes_acked: __u64,
        pub __bindgen_anon_2: bpf_sock_ops__bindgen_ty_2,
        pub __bindgen_anon_3: bpf_sock_ops__bindgen_ty_3,
        pub __bindgen_anon_4: bpf_sock_ops__bindgen_ty_4,
        pub skb_len: __u32,
        pub skb_tcp_flags: __u32,
        pub skb_hwtstamp: __u64,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union bpf_sock_ops__bindgen_ty_1 {
        pub args: [__u32; 4usize],
        pub reply: __u32,
        pub replylong: [__u32; 4usize],
    }
    #[test]
    fn bindgen_test_layout_bpf_sock_ops__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<bpf_sock_ops__bindgen_ty_1>(),
            16usize,
            concat!("Size of: ", stringify!(bpf_sock_ops__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_sock_ops__bindgen_ty_1>(),
            4usize,
            concat!("Alignment of ", stringify!(bpf_sock_ops__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_sock_ops__bindgen_ty_1>())).args as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_ops__bindgen_ty_1),
                "::",
                stringify!(args)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_sock_ops__bindgen_ty_1>())).reply as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_ops__bindgen_ty_1),
                "::",
                stringify!(reply)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_sock_ops__bindgen_ty_1>())).replylong as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_ops__bindgen_ty_1),
                "::",
                stringify!(replylong)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union bpf_sock_ops__bindgen_ty_2 {
        pub sk: *mut bpf_sock,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    }
    #[test]
    fn bindgen_test_layout_bpf_sock_ops__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<bpf_sock_ops__bindgen_ty_2>(),
            8usize,
            concat!("Size of: ", stringify!(bpf_sock_ops__bindgen_ty_2))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_sock_ops__bindgen_ty_2>(),
            8usize,
            concat!("Alignment of ", stringify!(bpf_sock_ops__bindgen_ty_2))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_sock_ops__bindgen_ty_2>())).sk as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_ops__bindgen_ty_2),
                "::",
                stringify!(sk)
            )
        );
    }
    impl bpf_sock_ops__bindgen_ty_2 {
        #[inline]
        pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> =
                Default::default();
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union bpf_sock_ops__bindgen_ty_3 {
        pub skb_data: *mut ::cty::c_void,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    }
    #[test]
    fn bindgen_test_layout_bpf_sock_ops__bindgen_ty_3() {
        assert_eq!(
            ::core::mem::size_of::<bpf_sock_ops__bindgen_ty_3>(),
            8usize,
            concat!("Size of: ", stringify!(bpf_sock_ops__bindgen_ty_3))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_sock_ops__bindgen_ty_3>(),
            8usize,
            concat!("Alignment of ", stringify!(bpf_sock_ops__bindgen_ty_3))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_sock_ops__bindgen_ty_3>())).skb_data as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_ops__bindgen_ty_3),
                "::",
                stringify!(skb_data)
            )
        );
    }
    impl bpf_sock_ops__bindgen_ty_3 {
        #[inline]
        pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> =
                Default::default();
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union bpf_sock_ops__bindgen_ty_4 {
        pub skb_data_end: *mut ::cty::c_void,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    }
    #[test]
    fn bindgen_test_layout_bpf_sock_ops__bindgen_ty_4() {
        assert_eq!(
            ::core::mem::size_of::<bpf_sock_ops__bindgen_ty_4>(),
            8usize,
            concat!("Size of: ", stringify!(bpf_sock_ops__bindgen_ty_4))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_sock_ops__bindgen_ty_4>(),
            8usize,
            concat!("Alignment of ", stringify!(bpf_sock_ops__bindgen_ty_4))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_sock_ops__bindgen_ty_4>())).skb_data_end as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_ops__bindgen_ty_4),
                "::",
                stringify!(skb_data_end)
            )
        );
    }
    impl bpf_sock_ops__bindgen_ty_4 {
        #[inline]
        pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> =
                Default::default();
            __bindgen_bitfield_unit
        }
    }
    #[test]
    fn bindgen_test_layout_bpf_sock_ops() {
        assert_eq!(
            ::core::mem::size_of::<bpf_sock_ops>(),
            224usize,
            concat!("Size of: ", stringify!(bpf_sock_ops))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_sock_ops>(),
            8usize,
            concat!("Alignment of ", stringify!(bpf_sock_ops))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock_ops>())).op as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_ops),
                "::",
                stringify!(op)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock_ops>())).family as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_ops),
                "::",
                stringify!(family)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock_ops>())).remote_ip4 as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_ops),
                "::",
                stringify!(remote_ip4)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock_ops>())).local_ip4 as *const _ as usize },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_ops),
                "::",
                stringify!(local_ip4)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock_ops>())).remote_ip6 as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_ops),
                "::",
                stringify!(remote_ip6)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock_ops>())).local_ip6 as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_ops),
                "::",
                stringify!(local_ip6)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock_ops>())).remote_port as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_ops),
                "::",
                stringify!(remote_port)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock_ops>())).local_port as *const _ as usize },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_ops),
                "::",
                stringify!(local_port)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock_ops>())).is_fullsock as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_ops),
                "::",
                stringify!(is_fullsock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock_ops>())).snd_cwnd as *const _ as usize },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_ops),
                "::",
                stringify!(snd_cwnd)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock_ops>())).srtt_us as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_ops),
                "::",
                stringify!(srtt_us)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_sock_ops>())).bpf_sock_ops_cb_flags as *const _ as usize
            },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_ops),
                "::",
                stringify!(bpf_sock_ops_cb_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock_ops>())).state as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_ops),
                "::",
                stringify!(state)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock_ops>())).rtt_min as *const _ as usize },
            92usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_ops),
                "::",
                stringify!(rtt_min)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock_ops>())).snd_ssthresh as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_ops),
                "::",
                stringify!(snd_ssthresh)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock_ops>())).rcv_nxt as *const _ as usize },
            100usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_ops),
                "::",
                stringify!(rcv_nxt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock_ops>())).snd_nxt as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_ops),
                "::",
                stringify!(snd_nxt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock_ops>())).snd_una as *const _ as usize },
            108usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_ops),
                "::",
                stringify!(snd_una)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock_ops>())).mss_cache as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_ops),
                "::",
                stringify!(mss_cache)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock_ops>())).ecn_flags as *const _ as usize },
            116usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_ops),
                "::",
                stringify!(ecn_flags)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_sock_ops>())).rate_delivered as *const _ as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_ops),
                "::",
                stringify!(rate_delivered)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_sock_ops>())).rate_interval_us as *const _ as usize
            },
            124usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_ops),
                "::",
                stringify!(rate_interval_us)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock_ops>())).packets_out as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_ops),
                "::",
                stringify!(packets_out)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock_ops>())).retrans_out as *const _ as usize },
            132usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_ops),
                "::",
                stringify!(retrans_out)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock_ops>())).total_retrans as *const _ as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_ops),
                "::",
                stringify!(total_retrans)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock_ops>())).segs_in as *const _ as usize },
            140usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_ops),
                "::",
                stringify!(segs_in)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock_ops>())).data_segs_in as *const _ as usize },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_ops),
                "::",
                stringify!(data_segs_in)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock_ops>())).segs_out as *const _ as usize },
            148usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_ops),
                "::",
                stringify!(segs_out)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock_ops>())).data_segs_out as *const _ as usize },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_ops),
                "::",
                stringify!(data_segs_out)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock_ops>())).lost_out as *const _ as usize },
            156usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_ops),
                "::",
                stringify!(lost_out)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock_ops>())).sacked_out as *const _ as usize },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_ops),
                "::",
                stringify!(sacked_out)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock_ops>())).sk_txhash as *const _ as usize },
            164usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_ops),
                "::",
                stringify!(sk_txhash)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_sock_ops>())).bytes_received as *const _ as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_ops),
                "::",
                stringify!(bytes_received)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock_ops>())).bytes_acked as *const _ as usize },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_ops),
                "::",
                stringify!(bytes_acked)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock_ops>())).skb_len as *const _ as usize },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_ops),
                "::",
                stringify!(skb_len)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock_ops>())).skb_tcp_flags as *const _ as usize },
            212usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_ops),
                "::",
                stringify!(skb_tcp_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sock_ops>())).skb_hwtstamp as *const _ as usize },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sock_ops),
                "::",
                stringify!(skb_hwtstamp)
            )
        );
    }
    pub const BPF_SOCK_OPS_RTO_CB_FLAG: ::cty::c_uint = 1;
    pub const BPF_SOCK_OPS_RETRANS_CB_FLAG: ::cty::c_uint = 2;
    pub const BPF_SOCK_OPS_STATE_CB_FLAG: ::cty::c_uint = 4;
    pub const BPF_SOCK_OPS_RTT_CB_FLAG: ::cty::c_uint = 8;
    pub const BPF_SOCK_OPS_PARSE_ALL_HDR_OPT_CB_FLAG: ::cty::c_uint = 16;
    pub const BPF_SOCK_OPS_PARSE_UNKNOWN_HDR_OPT_CB_FLAG: ::cty::c_uint = 32;
    pub const BPF_SOCK_OPS_WRITE_HDR_OPT_CB_FLAG: ::cty::c_uint = 64;
    pub const BPF_SOCK_OPS_ALL_CB_FLAGS: ::cty::c_uint = 127;
    pub type _bindgen_ty_31 = ::cty::c_uint;
    pub const BPF_SOCK_OPS_VOID: ::cty::c_uint = 0;
    pub const BPF_SOCK_OPS_TIMEOUT_INIT: ::cty::c_uint = 1;
    pub const BPF_SOCK_OPS_RWND_INIT: ::cty::c_uint = 2;
    pub const BPF_SOCK_OPS_TCP_CONNECT_CB: ::cty::c_uint = 3;
    pub const BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB: ::cty::c_uint = 4;
    pub const BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB: ::cty::c_uint = 5;
    pub const BPF_SOCK_OPS_NEEDS_ECN: ::cty::c_uint = 6;
    pub const BPF_SOCK_OPS_BASE_RTT: ::cty::c_uint = 7;
    pub const BPF_SOCK_OPS_RTO_CB: ::cty::c_uint = 8;
    pub const BPF_SOCK_OPS_RETRANS_CB: ::cty::c_uint = 9;
    pub const BPF_SOCK_OPS_STATE_CB: ::cty::c_uint = 10;
    pub const BPF_SOCK_OPS_TCP_LISTEN_CB: ::cty::c_uint = 11;
    pub const BPF_SOCK_OPS_RTT_CB: ::cty::c_uint = 12;
    pub const BPF_SOCK_OPS_PARSE_HDR_OPT_CB: ::cty::c_uint = 13;
    pub const BPF_SOCK_OPS_HDR_OPT_LEN_CB: ::cty::c_uint = 14;
    pub const BPF_SOCK_OPS_WRITE_HDR_OPT_CB: ::cty::c_uint = 15;
    pub type _bindgen_ty_32 = ::cty::c_uint;
    pub const BPF_TCP_ESTABLISHED: ::cty::c_uint = 1;
    pub const BPF_TCP_SYN_SENT: ::cty::c_uint = 2;
    pub const BPF_TCP_SYN_RECV: ::cty::c_uint = 3;
    pub const BPF_TCP_FIN_WAIT1: ::cty::c_uint = 4;
    pub const BPF_TCP_FIN_WAIT2: ::cty::c_uint = 5;
    pub const BPF_TCP_TIME_WAIT: ::cty::c_uint = 6;
    pub const BPF_TCP_CLOSE: ::cty::c_uint = 7;
    pub const BPF_TCP_CLOSE_WAIT: ::cty::c_uint = 8;
    pub const BPF_TCP_LAST_ACK: ::cty::c_uint = 9;
    pub const BPF_TCP_LISTEN: ::cty::c_uint = 10;
    pub const BPF_TCP_CLOSING: ::cty::c_uint = 11;
    pub const BPF_TCP_NEW_SYN_RECV: ::cty::c_uint = 12;
    pub const BPF_TCP_MAX_STATES: ::cty::c_uint = 13;
    pub type _bindgen_ty_33 = ::cty::c_uint;
    pub const BPF_LOAD_HDR_OPT_TCP_SYN: ::cty::c_uint = 1;
    pub type _bindgen_ty_35 = ::cty::c_uint;
    pub const BPF_WRITE_HDR_TCP_CURRENT_MSS: ::cty::c_uint = 1;
    pub const BPF_WRITE_HDR_TCP_SYNACK_COOKIE: ::cty::c_uint = 2;
    pub type _bindgen_ty_36 = ::cty::c_uint;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_perf_event_value {
        pub counter: __u64,
        pub enabled: __u64,
        pub running: __u64,
    }
    #[test]
    fn bindgen_test_layout_bpf_perf_event_value() {
        assert_eq!(
            ::core::mem::size_of::<bpf_perf_event_value>(),
            24usize,
            concat!("Size of: ", stringify!(bpf_perf_event_value))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_perf_event_value>(),
            8usize,
            concat!("Alignment of ", stringify!(bpf_perf_event_value))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_perf_event_value>())).counter as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_perf_event_value),
                "::",
                stringify!(counter)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_perf_event_value>())).enabled as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_perf_event_value),
                "::",
                stringify!(enabled)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_perf_event_value>())).running as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_perf_event_value),
                "::",
                stringify!(running)
            )
        );
    }
    pub const BPF_DEVCG_ACC_MKNOD: ::cty::c_uint = 1;
    pub const BPF_DEVCG_ACC_READ: ::cty::c_uint = 2;
    pub const BPF_DEVCG_ACC_WRITE: ::cty::c_uint = 4;
    pub type _bindgen_ty_37 = ::cty::c_uint;
    pub const BPF_DEVCG_DEV_BLOCK: ::cty::c_uint = 1;
    pub const BPF_DEVCG_DEV_CHAR: ::cty::c_uint = 2;
    pub type _bindgen_ty_38 = ::cty::c_uint;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_cgroup_dev_ctx {
        pub access_type: __u32,
        pub major: __u32,
        pub minor: __u32,
    }
    #[test]
    fn bindgen_test_layout_bpf_cgroup_dev_ctx() {
        assert_eq!(
            ::core::mem::size_of::<bpf_cgroup_dev_ctx>(),
            12usize,
            concat!("Size of: ", stringify!(bpf_cgroup_dev_ctx))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_cgroup_dev_ctx>(),
            4usize,
            concat!("Alignment of ", stringify!(bpf_cgroup_dev_ctx))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_cgroup_dev_ctx>())).access_type as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_cgroup_dev_ctx),
                "::",
                stringify!(access_type)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_cgroup_dev_ctx>())).major as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_cgroup_dev_ctx),
                "::",
                stringify!(major)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_cgroup_dev_ctx>())).minor as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_cgroup_dev_ctx),
                "::",
                stringify!(minor)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct bpf_raw_tracepoint_args {
        pub args: __IncompleteArrayField<__u64>,
    }
    #[test]
    fn bindgen_test_layout_bpf_raw_tracepoint_args() {
        assert_eq!(
            ::core::mem::size_of::<bpf_raw_tracepoint_args>(),
            0usize,
            concat!("Size of: ", stringify!(bpf_raw_tracepoint_args))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_raw_tracepoint_args>(),
            8usize,
            concat!("Alignment of ", stringify!(bpf_raw_tracepoint_args))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_raw_tracepoint_args>())).args as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_raw_tracepoint_args),
                "::",
                stringify!(args)
            )
        );
    }
    pub const BPF_FIB_LOOKUP_DIRECT: ::cty::c_uint = 1;
    pub const BPF_FIB_LOOKUP_OUTPUT: ::cty::c_uint = 2;
    pub const BPF_FIB_LOOKUP_SKIP_NEIGH: ::cty::c_uint = 4;
    pub const BPF_FIB_LOOKUP_TBID: ::cty::c_uint = 8;
    pub type _bindgen_ty_39 = ::cty::c_uint;
    pub const BPF_FIB_LKUP_RET_SUCCESS: ::cty::c_uint = 0;
    pub const BPF_FIB_LKUP_RET_BLACKHOLE: ::cty::c_uint = 1;
    pub const BPF_FIB_LKUP_RET_UNREACHABLE: ::cty::c_uint = 2;
    pub const BPF_FIB_LKUP_RET_PROHIBIT: ::cty::c_uint = 3;
    pub const BPF_FIB_LKUP_RET_NOT_FWDED: ::cty::c_uint = 4;
    pub const BPF_FIB_LKUP_RET_FWD_DISABLED: ::cty::c_uint = 5;
    pub const BPF_FIB_LKUP_RET_UNSUPP_LWT: ::cty::c_uint = 6;
    pub const BPF_FIB_LKUP_RET_NO_NEIGH: ::cty::c_uint = 7;
    pub const BPF_FIB_LKUP_RET_FRAG_NEEDED: ::cty::c_uint = 8;
    pub type _bindgen_ty_40 = ::cty::c_uint;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct bpf_fib_lookup {
        pub family: __u8,
        pub l4_protocol: __u8,
        pub sport: __be16,
        pub dport: __be16,
        pub __bindgen_anon_1: bpf_fib_lookup__bindgen_ty_1,
        pub ifindex: __u32,
        pub __bindgen_anon_2: bpf_fib_lookup__bindgen_ty_2,
        pub __bindgen_anon_3: bpf_fib_lookup__bindgen_ty_3,
        pub __bindgen_anon_4: bpf_fib_lookup__bindgen_ty_4,
        pub __bindgen_anon_5: bpf_fib_lookup__bindgen_ty_5,
        pub smac: [__u8; 6usize],
        pub dmac: [__u8; 6usize],
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union bpf_fib_lookup__bindgen_ty_1 {
        pub tot_len: __u16,
        pub mtu_result: __u16,
    }
    #[test]
    fn bindgen_test_layout_bpf_fib_lookup__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<bpf_fib_lookup__bindgen_ty_1>(),
            2usize,
            concat!("Size of: ", stringify!(bpf_fib_lookup__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_fib_lookup__bindgen_ty_1>(),
            2usize,
            concat!("Alignment of ", stringify!(bpf_fib_lookup__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_fib_lookup__bindgen_ty_1>())).tot_len as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_fib_lookup__bindgen_ty_1),
                "::",
                stringify!(tot_len)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_fib_lookup__bindgen_ty_1>())).mtu_result as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_fib_lookup__bindgen_ty_1),
                "::",
                stringify!(mtu_result)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union bpf_fib_lookup__bindgen_ty_2 {
        pub tos: __u8,
        pub flowinfo: __be32,
        pub rt_metric: __u32,
    }
    #[test]
    fn bindgen_test_layout_bpf_fib_lookup__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<bpf_fib_lookup__bindgen_ty_2>(),
            4usize,
            concat!("Size of: ", stringify!(bpf_fib_lookup__bindgen_ty_2))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_fib_lookup__bindgen_ty_2>(),
            4usize,
            concat!("Alignment of ", stringify!(bpf_fib_lookup__bindgen_ty_2))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_fib_lookup__bindgen_ty_2>())).tos as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_fib_lookup__bindgen_ty_2),
                "::",
                stringify!(tos)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_fib_lookup__bindgen_ty_2>())).flowinfo as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_fib_lookup__bindgen_ty_2),
                "::",
                stringify!(flowinfo)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_fib_lookup__bindgen_ty_2>())).rt_metric as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_fib_lookup__bindgen_ty_2),
                "::",
                stringify!(rt_metric)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union bpf_fib_lookup__bindgen_ty_3 {
        pub ipv4_src: __be32,
        pub ipv6_src: [__u32; 4usize],
    }
    #[test]
    fn bindgen_test_layout_bpf_fib_lookup__bindgen_ty_3() {
        assert_eq!(
            ::core::mem::size_of::<bpf_fib_lookup__bindgen_ty_3>(),
            16usize,
            concat!("Size of: ", stringify!(bpf_fib_lookup__bindgen_ty_3))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_fib_lookup__bindgen_ty_3>(),
            4usize,
            concat!("Alignment of ", stringify!(bpf_fib_lookup__bindgen_ty_3))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_fib_lookup__bindgen_ty_3>())).ipv4_src as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_fib_lookup__bindgen_ty_3),
                "::",
                stringify!(ipv4_src)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_fib_lookup__bindgen_ty_3>())).ipv6_src as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_fib_lookup__bindgen_ty_3),
                "::",
                stringify!(ipv6_src)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union bpf_fib_lookup__bindgen_ty_4 {
        pub ipv4_dst: __be32,
        pub ipv6_dst: [__u32; 4usize],
    }
    #[test]
    fn bindgen_test_layout_bpf_fib_lookup__bindgen_ty_4() {
        assert_eq!(
            ::core::mem::size_of::<bpf_fib_lookup__bindgen_ty_4>(),
            16usize,
            concat!("Size of: ", stringify!(bpf_fib_lookup__bindgen_ty_4))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_fib_lookup__bindgen_ty_4>(),
            4usize,
            concat!("Alignment of ", stringify!(bpf_fib_lookup__bindgen_ty_4))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_fib_lookup__bindgen_ty_4>())).ipv4_dst as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_fib_lookup__bindgen_ty_4),
                "::",
                stringify!(ipv4_dst)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_fib_lookup__bindgen_ty_4>())).ipv6_dst as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_fib_lookup__bindgen_ty_4),
                "::",
                stringify!(ipv6_dst)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union bpf_fib_lookup__bindgen_ty_5 {
        pub __bindgen_anon_1: bpf_fib_lookup__bindgen_ty_5__bindgen_ty_1,
        pub tbid: __u32,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_fib_lookup__bindgen_ty_5__bindgen_ty_1 {
        pub h_vlan_proto: __be16,
        pub h_vlan_TCI: __be16,
    }
    #[test]
    fn bindgen_test_layout_bpf_fib_lookup__bindgen_ty_5__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<bpf_fib_lookup__bindgen_ty_5__bindgen_ty_1>(),
            4usize,
            concat!(
                "Size of: ",
                stringify!(bpf_fib_lookup__bindgen_ty_5__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_fib_lookup__bindgen_ty_5__bindgen_ty_1>(),
            2usize,
            concat!(
                "Alignment of ",
                stringify!(bpf_fib_lookup__bindgen_ty_5__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_fib_lookup__bindgen_ty_5__bindgen_ty_1>())).h_vlan_proto
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_fib_lookup__bindgen_ty_5__bindgen_ty_1),
                "::",
                stringify!(h_vlan_proto)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_fib_lookup__bindgen_ty_5__bindgen_ty_1>())).h_vlan_TCI
                    as *const _ as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_fib_lookup__bindgen_ty_5__bindgen_ty_1),
                "::",
                stringify!(h_vlan_TCI)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_bpf_fib_lookup__bindgen_ty_5() {
        assert_eq!(
            ::core::mem::size_of::<bpf_fib_lookup__bindgen_ty_5>(),
            4usize,
            concat!("Size of: ", stringify!(bpf_fib_lookup__bindgen_ty_5))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_fib_lookup__bindgen_ty_5>(),
            4usize,
            concat!("Alignment of ", stringify!(bpf_fib_lookup__bindgen_ty_5))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_fib_lookup__bindgen_ty_5>())).tbid as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_fib_lookup__bindgen_ty_5),
                "::",
                stringify!(tbid)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_bpf_fib_lookup() {
        assert_eq!(
            ::core::mem::size_of::<bpf_fib_lookup>(),
            64usize,
            concat!("Size of: ", stringify!(bpf_fib_lookup))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_fib_lookup>(),
            4usize,
            concat!("Alignment of ", stringify!(bpf_fib_lookup))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_fib_lookup>())).family as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_fib_lookup),
                "::",
                stringify!(family)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_fib_lookup>())).l4_protocol as *const _ as usize },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_fib_lookup),
                "::",
                stringify!(l4_protocol)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_fib_lookup>())).sport as *const _ as usize },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_fib_lookup),
                "::",
                stringify!(sport)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_fib_lookup>())).dport as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_fib_lookup),
                "::",
                stringify!(dport)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_fib_lookup>())).ifindex as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_fib_lookup),
                "::",
                stringify!(ifindex)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_fib_lookup>())).smac as *const _ as usize },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_fib_lookup),
                "::",
                stringify!(smac)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_fib_lookup>())).dmac as *const _ as usize },
            58usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_fib_lookup),
                "::",
                stringify!(dmac)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct bpf_redir_neigh {
        pub nh_family: __u32,
        pub __bindgen_anon_1: bpf_redir_neigh__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union bpf_redir_neigh__bindgen_ty_1 {
        pub ipv4_nh: __be32,
        pub ipv6_nh: [__u32; 4usize],
    }
    #[test]
    fn bindgen_test_layout_bpf_redir_neigh__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<bpf_redir_neigh__bindgen_ty_1>(),
            16usize,
            concat!("Size of: ", stringify!(bpf_redir_neigh__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_redir_neigh__bindgen_ty_1>(),
            4usize,
            concat!("Alignment of ", stringify!(bpf_redir_neigh__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_redir_neigh__bindgen_ty_1>())).ipv4_nh as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_redir_neigh__bindgen_ty_1),
                "::",
                stringify!(ipv4_nh)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_redir_neigh__bindgen_ty_1>())).ipv6_nh as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_redir_neigh__bindgen_ty_1),
                "::",
                stringify!(ipv6_nh)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_bpf_redir_neigh() {
        assert_eq!(
            ::core::mem::size_of::<bpf_redir_neigh>(),
            20usize,
            concat!("Size of: ", stringify!(bpf_redir_neigh))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_redir_neigh>(),
            4usize,
            concat!("Alignment of ", stringify!(bpf_redir_neigh))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_redir_neigh>())).nh_family as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_redir_neigh),
                "::",
                stringify!(nh_family)
            )
        );
    }
    pub const bpf_check_mtu_flags_BPF_MTU_CHK_SEGS: bpf_check_mtu_flags = 1;
    pub type bpf_check_mtu_flags = ::cty::c_uint;
    pub const bpf_check_mtu_ret_BPF_MTU_CHK_RET_SUCCESS: bpf_check_mtu_ret = 0;
    pub const bpf_check_mtu_ret_BPF_MTU_CHK_RET_FRAG_NEEDED: bpf_check_mtu_ret = 1;
    pub const bpf_check_mtu_ret_BPF_MTU_CHK_RET_SEGS_TOOBIG: bpf_check_mtu_ret = 2;
    pub type bpf_check_mtu_ret = ::cty::c_uint;
    pub const bpf_task_fd_type_BPF_FD_TYPE_RAW_TRACEPOINT: bpf_task_fd_type = 0;
    pub const bpf_task_fd_type_BPF_FD_TYPE_TRACEPOINT: bpf_task_fd_type = 1;
    pub const bpf_task_fd_type_BPF_FD_TYPE_KPROBE: bpf_task_fd_type = 2;
    pub const bpf_task_fd_type_BPF_FD_TYPE_KRETPROBE: bpf_task_fd_type = 3;
    pub const bpf_task_fd_type_BPF_FD_TYPE_UPROBE: bpf_task_fd_type = 4;
    pub const bpf_task_fd_type_BPF_FD_TYPE_URETPROBE: bpf_task_fd_type = 5;
    pub type bpf_task_fd_type = ::cty::c_uint;
    pub const BPF_FLOW_DISSECTOR_F_PARSE_1ST_FRAG: ::cty::c_uint = 1;
    pub const BPF_FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL: ::cty::c_uint = 2;
    pub const BPF_FLOW_DISSECTOR_F_STOP_AT_ENCAP: ::cty::c_uint = 4;
    pub type _bindgen_ty_41 = ::cty::c_uint;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct bpf_flow_keys {
        pub nhoff: __u16,
        pub thoff: __u16,
        pub addr_proto: __u16,
        pub is_frag: __u8,
        pub is_first_frag: __u8,
        pub is_encap: __u8,
        pub ip_proto: __u8,
        pub n_proto: __be16,
        pub sport: __be16,
        pub dport: __be16,
        pub __bindgen_anon_1: bpf_flow_keys__bindgen_ty_1,
        pub flags: __u32,
        pub flow_label: __be32,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union bpf_flow_keys__bindgen_ty_1 {
        pub __bindgen_anon_1: bpf_flow_keys__bindgen_ty_1__bindgen_ty_1,
        pub __bindgen_anon_2: bpf_flow_keys__bindgen_ty_1__bindgen_ty_2,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_flow_keys__bindgen_ty_1__bindgen_ty_1 {
        pub ipv4_src: __be32,
        pub ipv4_dst: __be32,
    }
    #[test]
    fn bindgen_test_layout_bpf_flow_keys__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<bpf_flow_keys__bindgen_ty_1__bindgen_ty_1>(),
            8usize,
            concat!(
                "Size of: ",
                stringify!(bpf_flow_keys__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_flow_keys__bindgen_ty_1__bindgen_ty_1>(),
            4usize,
            concat!(
                "Alignment of ",
                stringify!(bpf_flow_keys__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_flow_keys__bindgen_ty_1__bindgen_ty_1>())).ipv4_src
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_flow_keys__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(ipv4_src)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_flow_keys__bindgen_ty_1__bindgen_ty_1>())).ipv4_dst
                    as *const _ as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_flow_keys__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(ipv4_dst)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_flow_keys__bindgen_ty_1__bindgen_ty_2 {
        pub ipv6_src: [__u32; 4usize],
        pub ipv6_dst: [__u32; 4usize],
    }
    #[test]
    fn bindgen_test_layout_bpf_flow_keys__bindgen_ty_1__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<bpf_flow_keys__bindgen_ty_1__bindgen_ty_2>(),
            32usize,
            concat!(
                "Size of: ",
                stringify!(bpf_flow_keys__bindgen_ty_1__bindgen_ty_2)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_flow_keys__bindgen_ty_1__bindgen_ty_2>(),
            4usize,
            concat!(
                "Alignment of ",
                stringify!(bpf_flow_keys__bindgen_ty_1__bindgen_ty_2)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_flow_keys__bindgen_ty_1__bindgen_ty_2>())).ipv6_src
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_flow_keys__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(ipv6_src)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_flow_keys__bindgen_ty_1__bindgen_ty_2>())).ipv6_dst
                    as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_flow_keys__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(ipv6_dst)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_bpf_flow_keys__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<bpf_flow_keys__bindgen_ty_1>(),
            32usize,
            concat!("Size of: ", stringify!(bpf_flow_keys__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_flow_keys__bindgen_ty_1>(),
            4usize,
            concat!("Alignment of ", stringify!(bpf_flow_keys__bindgen_ty_1))
        );
    }
    #[test]
    fn bindgen_test_layout_bpf_flow_keys() {
        assert_eq!(
            ::core::mem::size_of::<bpf_flow_keys>(),
            56usize,
            concat!("Size of: ", stringify!(bpf_flow_keys))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_flow_keys>(),
            4usize,
            concat!("Alignment of ", stringify!(bpf_flow_keys))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_flow_keys>())).nhoff as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_flow_keys),
                "::",
                stringify!(nhoff)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_flow_keys>())).thoff as *const _ as usize },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_flow_keys),
                "::",
                stringify!(thoff)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_flow_keys>())).addr_proto as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_flow_keys),
                "::",
                stringify!(addr_proto)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_flow_keys>())).is_frag as *const _ as usize },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_flow_keys),
                "::",
                stringify!(is_frag)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_flow_keys>())).is_first_frag as *const _ as usize
            },
            7usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_flow_keys),
                "::",
                stringify!(is_first_frag)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_flow_keys>())).is_encap as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_flow_keys),
                "::",
                stringify!(is_encap)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_flow_keys>())).ip_proto as *const _ as usize },
            9usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_flow_keys),
                "::",
                stringify!(ip_proto)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_flow_keys>())).n_proto as *const _ as usize },
            10usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_flow_keys),
                "::",
                stringify!(n_proto)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_flow_keys>())).sport as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_flow_keys),
                "::",
                stringify!(sport)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_flow_keys>())).dport as *const _ as usize },
            14usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_flow_keys),
                "::",
                stringify!(dport)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_flow_keys>())).flags as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_flow_keys),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_flow_keys>())).flow_label as *const _ as usize },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_flow_keys),
                "::",
                stringify!(flow_label)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_func_info {
        pub insn_off: __u32,
        pub type_id: __u32,
    }
    #[test]
    fn bindgen_test_layout_bpf_func_info() {
        assert_eq!(
            ::core::mem::size_of::<bpf_func_info>(),
            8usize,
            concat!("Size of: ", stringify!(bpf_func_info))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_func_info>(),
            4usize,
            concat!("Alignment of ", stringify!(bpf_func_info))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_func_info>())).insn_off as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_func_info),
                "::",
                stringify!(insn_off)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_func_info>())).type_id as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_func_info),
                "::",
                stringify!(type_id)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_line_info {
        pub insn_off: __u32,
        pub file_name_off: __u32,
        pub line_off: __u32,
        pub line_col: __u32,
    }
    #[test]
    fn bindgen_test_layout_bpf_line_info() {
        assert_eq!(
            ::core::mem::size_of::<bpf_line_info>(),
            16usize,
            concat!("Size of: ", stringify!(bpf_line_info))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_line_info>(),
            4usize,
            concat!("Alignment of ", stringify!(bpf_line_info))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_line_info>())).insn_off as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_line_info),
                "::",
                stringify!(insn_off)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_line_info>())).file_name_off as *const _ as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_line_info),
                "::",
                stringify!(file_name_off)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_line_info>())).line_off as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_line_info),
                "::",
                stringify!(line_off)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_line_info>())).line_col as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_line_info),
                "::",
                stringify!(line_col)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_spin_lock {
        pub val: __u32,
    }
    #[test]
    fn bindgen_test_layout_bpf_spin_lock() {
        assert_eq!(
            ::core::mem::size_of::<bpf_spin_lock>(),
            4usize,
            concat!("Size of: ", stringify!(bpf_spin_lock))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_spin_lock>(),
            4usize,
            concat!("Alignment of ", stringify!(bpf_spin_lock))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_spin_lock>())).val as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_spin_lock),
                "::",
                stringify!(val)
            )
        );
    }
    #[repr(C)]
    #[repr(align(8))]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_timer {
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 16usize]>,
    }
    #[test]
    fn bindgen_test_layout_bpf_timer() {
        assert_eq!(
            ::core::mem::size_of::<bpf_timer>(),
            16usize,
            concat!("Size of: ", stringify!(bpf_timer))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_timer>(),
            8usize,
            concat!("Alignment of ", stringify!(bpf_timer))
        );
    }
    impl bpf_timer {
        #[inline]
        pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 16usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> =
                Default::default();
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[repr(align(8))]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_dynptr {
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 16usize]>,
    }
    #[test]
    fn bindgen_test_layout_bpf_dynptr() {
        assert_eq!(
            ::core::mem::size_of::<bpf_dynptr>(),
            16usize,
            concat!("Size of: ", stringify!(bpf_dynptr))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_dynptr>(),
            8usize,
            concat!("Alignment of ", stringify!(bpf_dynptr))
        );
    }
    impl bpf_dynptr {
        #[inline]
        pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 16usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> =
                Default::default();
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[repr(align(8))]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_list_head {
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 16usize]>,
    }
    #[test]
    fn bindgen_test_layout_bpf_list_head() {
        assert_eq!(
            ::core::mem::size_of::<bpf_list_head>(),
            16usize,
            concat!("Size of: ", stringify!(bpf_list_head))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_list_head>(),
            8usize,
            concat!("Alignment of ", stringify!(bpf_list_head))
        );
    }
    impl bpf_list_head {
        #[inline]
        pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 16usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> =
                Default::default();
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[repr(align(8))]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_list_node {
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 16usize]>,
    }
    #[test]
    fn bindgen_test_layout_bpf_list_node() {
        assert_eq!(
            ::core::mem::size_of::<bpf_list_node>(),
            16usize,
            concat!("Size of: ", stringify!(bpf_list_node))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_list_node>(),
            8usize,
            concat!("Alignment of ", stringify!(bpf_list_node))
        );
    }
    impl bpf_list_node {
        #[inline]
        pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 16usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> =
                Default::default();
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[repr(align(8))]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_rb_root {
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 16usize]>,
    }
    #[test]
    fn bindgen_test_layout_bpf_rb_root() {
        assert_eq!(
            ::core::mem::size_of::<bpf_rb_root>(),
            16usize,
            concat!("Size of: ", stringify!(bpf_rb_root))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_rb_root>(),
            8usize,
            concat!("Alignment of ", stringify!(bpf_rb_root))
        );
    }
    impl bpf_rb_root {
        #[inline]
        pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 16usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> =
                Default::default();
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[repr(align(8))]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_rb_node {
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 24usize]>,
    }
    #[test]
    fn bindgen_test_layout_bpf_rb_node() {
        assert_eq!(
            ::core::mem::size_of::<bpf_rb_node>(),
            24usize,
            concat!("Size of: ", stringify!(bpf_rb_node))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_rb_node>(),
            8usize,
            concat!("Alignment of ", stringify!(bpf_rb_node))
        );
    }
    impl bpf_rb_node {
        #[inline]
        pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 24usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 24usize]> =
                Default::default();
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[repr(align(4))]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_refcount {
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    }
    #[test]
    fn bindgen_test_layout_bpf_refcount() {
        assert_eq!(
            ::core::mem::size_of::<bpf_refcount>(),
            4usize,
            concat!("Size of: ", stringify!(bpf_refcount))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_refcount>(),
            4usize,
            concat!("Alignment of ", stringify!(bpf_refcount))
        );
    }
    impl bpf_refcount {
        #[inline]
        pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> =
                Default::default();
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_sysctl {
        pub write: __u32,
        pub file_pos: __u32,
    }
    #[test]
    fn bindgen_test_layout_bpf_sysctl() {
        assert_eq!(
            ::core::mem::size_of::<bpf_sysctl>(),
            8usize,
            concat!("Size of: ", stringify!(bpf_sysctl))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_sysctl>(),
            4usize,
            concat!("Alignment of ", stringify!(bpf_sysctl))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sysctl>())).write as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sysctl),
                "::",
                stringify!(write)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sysctl>())).file_pos as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sysctl),
                "::",
                stringify!(file_pos)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct bpf_sockopt {
        pub __bindgen_anon_1: bpf_sockopt__bindgen_ty_1,
        pub __bindgen_anon_2: bpf_sockopt__bindgen_ty_2,
        pub __bindgen_anon_3: bpf_sockopt__bindgen_ty_3,
        pub level: __s32,
        pub optname: __s32,
        pub optlen: __s32,
        pub retval: __s32,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union bpf_sockopt__bindgen_ty_1 {
        pub sk: *mut bpf_sock,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    }
    #[test]
    fn bindgen_test_layout_bpf_sockopt__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<bpf_sockopt__bindgen_ty_1>(),
            8usize,
            concat!("Size of: ", stringify!(bpf_sockopt__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_sockopt__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(bpf_sockopt__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_sockopt__bindgen_ty_1>())).sk as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sockopt__bindgen_ty_1),
                "::",
                stringify!(sk)
            )
        );
    }
    impl bpf_sockopt__bindgen_ty_1 {
        #[inline]
        pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> =
                Default::default();
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union bpf_sockopt__bindgen_ty_2 {
        pub optval: *mut ::cty::c_void,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    }
    #[test]
    fn bindgen_test_layout_bpf_sockopt__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<bpf_sockopt__bindgen_ty_2>(),
            8usize,
            concat!("Size of: ", stringify!(bpf_sockopt__bindgen_ty_2))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_sockopt__bindgen_ty_2>(),
            8usize,
            concat!("Alignment of ", stringify!(bpf_sockopt__bindgen_ty_2))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_sockopt__bindgen_ty_2>())).optval as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sockopt__bindgen_ty_2),
                "::",
                stringify!(optval)
            )
        );
    }
    impl bpf_sockopt__bindgen_ty_2 {
        #[inline]
        pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> =
                Default::default();
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union bpf_sockopt__bindgen_ty_3 {
        pub optval_end: *mut ::cty::c_void,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    }
    #[test]
    fn bindgen_test_layout_bpf_sockopt__bindgen_ty_3() {
        assert_eq!(
            ::core::mem::size_of::<bpf_sockopt__bindgen_ty_3>(),
            8usize,
            concat!("Size of: ", stringify!(bpf_sockopt__bindgen_ty_3))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_sockopt__bindgen_ty_3>(),
            8usize,
            concat!("Alignment of ", stringify!(bpf_sockopt__bindgen_ty_3))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_sockopt__bindgen_ty_3>())).optval_end as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sockopt__bindgen_ty_3),
                "::",
                stringify!(optval_end)
            )
        );
    }
    impl bpf_sockopt__bindgen_ty_3 {
        #[inline]
        pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> =
                Default::default();
            __bindgen_bitfield_unit
        }
    }
    #[test]
    fn bindgen_test_layout_bpf_sockopt() {
        assert_eq!(
            ::core::mem::size_of::<bpf_sockopt>(),
            40usize,
            concat!("Size of: ", stringify!(bpf_sockopt))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_sockopt>(),
            8usize,
            concat!("Alignment of ", stringify!(bpf_sockopt))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sockopt>())).level as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sockopt),
                "::",
                stringify!(level)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sockopt>())).optname as *const _ as usize },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sockopt),
                "::",
                stringify!(optname)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sockopt>())).optlen as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sockopt),
                "::",
                stringify!(optlen)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sockopt>())).retval as *const _ as usize },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sockopt),
                "::",
                stringify!(retval)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_pidns_info {
        pub pid: __u32,
        pub tgid: __u32,
    }
    #[test]
    fn bindgen_test_layout_bpf_pidns_info() {
        assert_eq!(
            ::core::mem::size_of::<bpf_pidns_info>(),
            8usize,
            concat!("Size of: ", stringify!(bpf_pidns_info))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_pidns_info>(),
            4usize,
            concat!("Alignment of ", stringify!(bpf_pidns_info))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_pidns_info>())).pid as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_pidns_info),
                "::",
                stringify!(pid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_pidns_info>())).tgid as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_pidns_info),
                "::",
                stringify!(tgid)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct bpf_sk_lookup {
        pub __bindgen_anon_1: bpf_sk_lookup__bindgen_ty_1,
        pub family: __u32,
        pub protocol: __u32,
        pub remote_ip4: __u32,
        pub remote_ip6: [__u32; 4usize],
        pub remote_port: __be16,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
        pub local_ip4: __u32,
        pub local_ip6: [__u32; 4usize],
        pub local_port: __u32,
        pub ingress_ifindex: __u32,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union bpf_sk_lookup__bindgen_ty_1 {
        pub __bindgen_anon_1: bpf_sk_lookup__bindgen_ty_1__bindgen_ty_1,
        pub cookie: __u64,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union bpf_sk_lookup__bindgen_ty_1__bindgen_ty_1 {
        pub sk: *mut bpf_sock,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    }
    #[test]
    fn bindgen_test_layout_bpf_sk_lookup__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<bpf_sk_lookup__bindgen_ty_1__bindgen_ty_1>(),
            8usize,
            concat!(
                "Size of: ",
                stringify!(bpf_sk_lookup__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_sk_lookup__bindgen_ty_1__bindgen_ty_1>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(bpf_sk_lookup__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_sk_lookup__bindgen_ty_1__bindgen_ty_1>())).sk
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sk_lookup__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(sk)
            )
        );
    }
    impl bpf_sk_lookup__bindgen_ty_1__bindgen_ty_1 {
        #[inline]
        pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> =
                Default::default();
            __bindgen_bitfield_unit
        }
    }
    #[test]
    fn bindgen_test_layout_bpf_sk_lookup__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<bpf_sk_lookup__bindgen_ty_1>(),
            8usize,
            concat!("Size of: ", stringify!(bpf_sk_lookup__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_sk_lookup__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(bpf_sk_lookup__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_sk_lookup__bindgen_ty_1>())).cookie as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sk_lookup__bindgen_ty_1),
                "::",
                stringify!(cookie)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_bpf_sk_lookup() {
        assert_eq!(
            ::core::mem::size_of::<bpf_sk_lookup>(),
            72usize,
            concat!("Size of: ", stringify!(bpf_sk_lookup))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_sk_lookup>(),
            8usize,
            concat!("Alignment of ", stringify!(bpf_sk_lookup))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sk_lookup>())).family as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sk_lookup),
                "::",
                stringify!(family)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sk_lookup>())).protocol as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sk_lookup),
                "::",
                stringify!(protocol)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sk_lookup>())).remote_ip4 as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sk_lookup),
                "::",
                stringify!(remote_ip4)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sk_lookup>())).remote_ip6 as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sk_lookup),
                "::",
                stringify!(remote_ip6)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sk_lookup>())).remote_port as *const _ as usize },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sk_lookup),
                "::",
                stringify!(remote_port)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sk_lookup>())).local_ip4 as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sk_lookup),
                "::",
                stringify!(local_ip4)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sk_lookup>())).local_ip6 as *const _ as usize },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sk_lookup),
                "::",
                stringify!(local_ip6)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_sk_lookup>())).local_port as *const _ as usize },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sk_lookup),
                "::",
                stringify!(local_port)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_sk_lookup>())).ingress_ifindex as *const _ as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_sk_lookup),
                "::",
                stringify!(ingress_ifindex)
            )
        );
    }
    impl bpf_sk_lookup {
        #[inline]
        pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 2usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> =
                Default::default();
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct btf_ptr {
        pub ptr: *mut ::cty::c_void,
        pub type_id: __u32,
        pub flags: __u32,
    }
    #[test]
    fn bindgen_test_layout_btf_ptr() {
        assert_eq!(
            ::core::mem::size_of::<btf_ptr>(),
            16usize,
            concat!("Size of: ", stringify!(btf_ptr))
        );
        assert_eq!(
            ::core::mem::align_of::<btf_ptr>(),
            8usize,
            concat!("Alignment of ", stringify!(btf_ptr))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<btf_ptr>())).ptr as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(btf_ptr),
                "::",
                stringify!(ptr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<btf_ptr>())).type_id as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(btf_ptr),
                "::",
                stringify!(type_id)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<btf_ptr>())).flags as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(btf_ptr),
                "::",
                stringify!(flags)
            )
        );
    }
    pub const bpf_core_relo_kind_BPF_CORE_FIELD_BYTE_OFFSET: bpf_core_relo_kind = 0;
    pub const bpf_core_relo_kind_BPF_CORE_FIELD_BYTE_SIZE: bpf_core_relo_kind = 1;
    pub const bpf_core_relo_kind_BPF_CORE_FIELD_EXISTS: bpf_core_relo_kind = 2;
    pub const bpf_core_relo_kind_BPF_CORE_FIELD_SIGNED: bpf_core_relo_kind = 3;
    pub const bpf_core_relo_kind_BPF_CORE_FIELD_LSHIFT_U64: bpf_core_relo_kind = 4;
    pub const bpf_core_relo_kind_BPF_CORE_FIELD_RSHIFT_U64: bpf_core_relo_kind = 5;
    pub const bpf_core_relo_kind_BPF_CORE_TYPE_ID_LOCAL: bpf_core_relo_kind = 6;
    pub const bpf_core_relo_kind_BPF_CORE_TYPE_ID_TARGET: bpf_core_relo_kind = 7;
    pub const bpf_core_relo_kind_BPF_CORE_TYPE_EXISTS: bpf_core_relo_kind = 8;
    pub const bpf_core_relo_kind_BPF_CORE_TYPE_SIZE: bpf_core_relo_kind = 9;
    pub const bpf_core_relo_kind_BPF_CORE_ENUMVAL_EXISTS: bpf_core_relo_kind = 10;
    pub const bpf_core_relo_kind_BPF_CORE_ENUMVAL_VALUE: bpf_core_relo_kind = 11;
    pub const bpf_core_relo_kind_BPF_CORE_TYPE_MATCHES: bpf_core_relo_kind = 12;
    pub type bpf_core_relo_kind = ::cty::c_uint;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_core_relo {
        pub insn_off: __u32,
        pub type_id: __u32,
        pub access_str_off: __u32,
        pub kind: bpf_core_relo_kind,
    }
    #[test]
    fn bindgen_test_layout_bpf_core_relo() {
        assert_eq!(
            ::core::mem::size_of::<bpf_core_relo>(),
            16usize,
            concat!("Size of: ", stringify!(bpf_core_relo))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_core_relo>(),
            4usize,
            concat!("Alignment of ", stringify!(bpf_core_relo))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_core_relo>())).insn_off as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_core_relo),
                "::",
                stringify!(insn_off)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_core_relo>())).type_id as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_core_relo),
                "::",
                stringify!(type_id)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_core_relo>())).access_str_off as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_core_relo),
                "::",
                stringify!(access_str_off)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_core_relo>())).kind as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_core_relo),
                "::",
                stringify!(kind)
            )
        );
    }
    pub const BPF_F_TIMER_ABS: ::cty::c_uint = 1;
    pub type _bindgen_ty_43 = ::cty::c_uint;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_iter_num {
        pub __opaque: [__u64; 1usize],
    }
    #[test]
    fn bindgen_test_layout_bpf_iter_num() {
        assert_eq!(
            ::core::mem::size_of::<bpf_iter_num>(),
            8usize,
            concat!("Size of: ", stringify!(bpf_iter_num))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_iter_num>(),
            8usize,
            concat!("Alignment of ", stringify!(bpf_iter_num))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_iter_num>())).__opaque as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_iter_num),
                "::",
                stringify!(__opaque)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bug_entry {
        pub bug_addr_disp: ::cty::c_int,
        pub file_disp: ::cty::c_int,
        pub line: ::cty::c_ushort,
        pub flags: ::cty::c_ushort,
    }
    #[test]
    fn bindgen_test_layout_bug_entry() {
        assert_eq!(
            ::core::mem::size_of::<bug_entry>(),
            12usize,
            concat!("Size of: ", stringify!(bug_entry))
        );
        assert_eq!(
            ::core::mem::align_of::<bug_entry>(),
            4usize,
            concat!("Alignment of ", stringify!(bug_entry))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bug_entry>())).bug_addr_disp as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bug_entry),
                "::",
                stringify!(bug_addr_disp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bug_entry>())).file_disp as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(bug_entry),
                "::",
                stringify!(file_disp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bug_entry>())).line as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bug_entry),
                "::",
                stringify!(line)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bug_entry>())).flags as *const _ as usize },
            10usize,
            concat!(
                "Offset of field: ",
                stringify!(bug_entry),
                "::",
                stringify!(flags)
            )
        );
    }
    pub type time64_t = __s64;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct __kernel_timespec {
        pub tv_sec: __kernel_time64_t,
        pub tv_nsec: ::cty::c_longlong,
    }
    #[test]
    fn bindgen_test_layout___kernel_timespec() {
        assert_eq!(
            ::core::mem::size_of::<__kernel_timespec>(),
            16usize,
            concat!("Size of: ", stringify!(__kernel_timespec))
        );
        assert_eq!(
            ::core::mem::align_of::<__kernel_timespec>(),
            8usize,
            concat!("Alignment of ", stringify!(__kernel_timespec))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__kernel_timespec>())).tv_sec as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__kernel_timespec),
                "::",
                stringify!(tv_sec)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__kernel_timespec>())).tv_nsec as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__kernel_timespec),
                "::",
                stringify!(tv_nsec)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct timespec64 {
        pub tv_sec: time64_t,
        pub tv_nsec: ::cty::c_long,
    }
    #[test]
    fn bindgen_test_layout_timespec64() {
        assert_eq!(
            ::core::mem::size_of::<timespec64>(),
            16usize,
            concat!("Size of: ", stringify!(timespec64))
        );
        assert_eq!(
            ::core::mem::align_of::<timespec64>(),
            8usize,
            concat!("Alignment of ", stringify!(timespec64))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<timespec64>())).tv_sec as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(timespec64),
                "::",
                stringify!(tv_sec)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<timespec64>())).tv_nsec as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(timespec64),
                "::",
                stringify!(tv_nsec)
            )
        );
    }
    pub const timespec_type_TT_NONE: timespec_type = 0;
    pub const timespec_type_TT_NATIVE: timespec_type = 1;
    pub const timespec_type_TT_COMPAT: timespec_type = 2;
    pub type timespec_type = ::cty::c_uint;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct restart_block {
        pub arch_data: ::cty::c_ulong,
        pub fn_:
            ::core::option::Option<unsafe extern "C" fn(arg1: *mut restart_block) -> ::cty::c_long>,
        pub __bindgen_anon_1: restart_block__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union restart_block__bindgen_ty_1 {
        pub futex: restart_block__bindgen_ty_1__bindgen_ty_1,
        pub nanosleep: restart_block__bindgen_ty_1__bindgen_ty_2,
        pub poll: restart_block__bindgen_ty_1__bindgen_ty_3,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct restart_block__bindgen_ty_1__bindgen_ty_1 {
        pub uaddr: *mut _cargo_bpf_u32,
        pub val: _cargo_bpf_u32,
        pub flags: _cargo_bpf_u32,
        pub bitset: _cargo_bpf_u32,
        pub time: _cargo_bpf_u64,
        pub uaddr2: *mut _cargo_bpf_u32,
    }
    #[test]
    fn bindgen_test_layout_restart_block__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<restart_block__bindgen_ty_1__bindgen_ty_1>(),
            40usize,
            concat!(
                "Size of: ",
                stringify!(restart_block__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<restart_block__bindgen_ty_1__bindgen_ty_1>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(restart_block__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_1>())).uaddr
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(restart_block__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(uaddr)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_1>())).val
                    as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(restart_block__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(val)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_1>())).flags
                    as *const _ as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(restart_block__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_1>())).bitset
                    as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(restart_block__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(bitset)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_1>())).time
                    as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(restart_block__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(time)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_1>())).uaddr2
                    as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(restart_block__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(uaddr2)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct restart_block__bindgen_ty_1__bindgen_ty_2 {
        pub clockid: clockid_t,
        pub type_: timespec_type,
        pub __bindgen_anon_1: restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
        pub expires: _cargo_bpf_u64,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
        pub rmtp: *mut __kernel_timespec,
        pub compat_rmtp: *mut old_timespec32,
    }
    #[test]
    fn bindgen_test_layout_restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>(),
            8usize,
            concat!(
                "Size of: ",
                stringify!(restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>()))
                    .rmtp as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1),
                "::",
                stringify!(rmtp)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>()))
                    .compat_rmtp as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1),
                "::",
                stringify!(compat_rmtp)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_restart_block__bindgen_ty_1__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<restart_block__bindgen_ty_1__bindgen_ty_2>(),
            24usize,
            concat!(
                "Size of: ",
                stringify!(restart_block__bindgen_ty_1__bindgen_ty_2)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<restart_block__bindgen_ty_1__bindgen_ty_2>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(restart_block__bindgen_ty_1__bindgen_ty_2)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_2>())).clockid
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(restart_block__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(clockid)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_2>())).type_
                    as *const _ as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(restart_block__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(type_)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_2>())).expires
                    as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(restart_block__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(expires)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct restart_block__bindgen_ty_1__bindgen_ty_3 {
        pub ufds: *mut pollfd,
        pub nfds: ::cty::c_int,
        pub has_timeout: ::cty::c_int,
        pub tv_sec: ::cty::c_ulong,
        pub tv_nsec: ::cty::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_restart_block__bindgen_ty_1__bindgen_ty_3() {
        assert_eq!(
            ::core::mem::size_of::<restart_block__bindgen_ty_1__bindgen_ty_3>(),
            32usize,
            concat!(
                "Size of: ",
                stringify!(restart_block__bindgen_ty_1__bindgen_ty_3)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<restart_block__bindgen_ty_1__bindgen_ty_3>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(restart_block__bindgen_ty_1__bindgen_ty_3)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_3>())).ufds
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(restart_block__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(ufds)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_3>())).nfds
                    as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(restart_block__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(nfds)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_3>())).has_timeout
                    as *const _ as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(restart_block__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(has_timeout)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_3>())).tv_sec
                    as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(restart_block__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(tv_sec)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_3>())).tv_nsec
                    as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(restart_block__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(tv_nsec)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_restart_block__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<restart_block__bindgen_ty_1>(),
            40usize,
            concat!("Size of: ", stringify!(restart_block__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<restart_block__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(restart_block__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<restart_block__bindgen_ty_1>())).futex as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(restart_block__bindgen_ty_1),
                "::",
                stringify!(futex)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<restart_block__bindgen_ty_1>())).nanosleep as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(restart_block__bindgen_ty_1),
                "::",
                stringify!(nanosleep)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<restart_block__bindgen_ty_1>())).poll as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(restart_block__bindgen_ty_1),
                "::",
                stringify!(poll)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_restart_block() {
        assert_eq!(
            ::core::mem::size_of::<restart_block>(),
            56usize,
            concat!("Size of: ", stringify!(restart_block))
        );
        assert_eq!(
            ::core::mem::align_of::<restart_block>(),
            8usize,
            concat!("Alignment of ", stringify!(restart_block))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<restart_block>())).arch_data as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(restart_block),
                "::",
                stringify!(arch_data)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<restart_block>())).fn_ as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(restart_block),
                "::",
                stringify!(fn_)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct range {
        pub start: _cargo_bpf_u64,
        pub end: _cargo_bpf_u64,
    }
    #[test]
    fn bindgen_test_layout_range() {
        assert_eq!(
            ::core::mem::size_of::<range>(),
            16usize,
            concat!("Size of: ", stringify!(range))
        );
        assert_eq!(
            ::core::mem::align_of::<range>(),
            8usize,
            concat!("Alignment of ", stringify!(range))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<range>())).start as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(range),
                "::",
                stringify!(start)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<range>())).end as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(range),
                "::",
                stringify!(end)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct io_bitmap {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct math_emu_info {
        pub ___orig_eip: ::cty::c_long,
        pub regs: *mut pt_regs,
    }
    #[test]
    fn bindgen_test_layout_math_emu_info() {
        assert_eq!(
            ::core::mem::size_of::<math_emu_info>(),
            16usize,
            concat!("Size of: ", stringify!(math_emu_info))
        );
        assert_eq!(
            ::core::mem::align_of::<math_emu_info>(),
            8usize,
            concat!("Alignment of ", stringify!(math_emu_info))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<math_emu_info>())).___orig_eip as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(math_emu_info),
                "::",
                stringify!(___orig_eip)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<math_emu_info>())).regs as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(math_emu_info),
                "::",
                stringify!(regs)
            )
        );
    }
    pub type atomic_long_t = atomic64_t;
    #[doc = " struct attribute_group - data structure used to declare an attribute group."]
    #[doc = " @name:\tOptional: Attribute group name"]
    #[doc = "\t\tIf specified, the attribute group will be created in"]
    #[doc = "\t\ta new subdirectory with this name."]
    #[doc = " @is_visible:\tOptional: Function to return permissions associated with an"]
    #[doc = "\t\tattribute of the group. Will be called repeatedly for each"]
    #[doc = "\t\tnon-binary attribute in the group. Only read/write"]
    #[doc = "\t\tpermissions as well as SYSFS_PREALLOC are accepted. Must"]
    #[doc = "\t\treturn 0 if an attribute is not visible. The returned value"]
    #[doc = "\t\twill replace static permissions defined in struct attribute."]
    #[doc = " @is_bin_visible:"]
    #[doc = "\t\tOptional: Function to return permissions associated with a"]
    #[doc = "\t\tbinary attribute of the group. Will be called repeatedly"]
    #[doc = "\t\tfor each binary attribute in the group. Only read/write"]
    #[doc = "\t\tpermissions as well as SYSFS_PREALLOC are accepted. Must"]
    #[doc = "\t\treturn 0 if a binary attribute is not visible. The returned"]
    #[doc = "\t\tvalue will replace static permissions defined in"]
    #[doc = "\t\tstruct bin_attribute."]
    #[doc = " @attrs:\tPointer to NULL terminated list of attributes."]
    #[doc = " @bin_attrs:\tPointer to NULL terminated list of binary attributes."]
    #[doc = "\t\tEither attrs or bin_attrs or both must be provided."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct attribute_group {
        pub name: *const ::cty::c_char,
        pub is_visible: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut kobject,
                arg2: *mut attribute,
                arg3: ::cty::c_int,
            ) -> umode_t,
        >,
        pub is_bin_visible: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut kobject,
                arg2: *mut bin_attribute,
                arg3: ::cty::c_int,
            ) -> umode_t,
        >,
        pub attrs: *mut *mut attribute,
        pub bin_attrs: *mut *mut bin_attribute,
    }
    #[test]
    fn bindgen_test_layout_attribute_group() {
        assert_eq!(
            ::core::mem::size_of::<attribute_group>(),
            40usize,
            concat!("Size of: ", stringify!(attribute_group))
        );
        assert_eq!(
            ::core::mem::align_of::<attribute_group>(),
            8usize,
            concat!("Alignment of ", stringify!(attribute_group))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<attribute_group>())).name as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(attribute_group),
                "::",
                stringify!(name)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<attribute_group>())).is_visible as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(attribute_group),
                "::",
                stringify!(is_visible)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<attribute_group>())).is_bin_visible as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(attribute_group),
                "::",
                stringify!(is_bin_visible)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<attribute_group>())).attrs as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(attribute_group),
                "::",
                stringify!(attrs)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<attribute_group>())).bin_attrs as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(attribute_group),
                "::",
                stringify!(bin_attrs)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cpumask {
        pub bits: [::cty::c_ulong; 128usize],
    }
    #[test]
    fn bindgen_test_layout_cpumask() {
        assert_eq!(
            ::core::mem::size_of::<cpumask>(),
            1024usize,
            concat!("Size of: ", stringify!(cpumask))
        );
        assert_eq!(
            ::core::mem::align_of::<cpumask>(),
            8usize,
            concat!("Alignment of ", stringify!(cpumask))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cpumask>())).bits as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cpumask),
                "::",
                stringify!(bits)
            )
        );
    }
    pub type cpumask_t = cpumask;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct tracepoint_func {
        pub func: *mut ::cty::c_void,
        pub data: *mut ::cty::c_void,
        pub prio: ::cty::c_int,
    }
    #[test]
    fn bindgen_test_layout_tracepoint_func() {
        assert_eq!(
            ::core::mem::size_of::<tracepoint_func>(),
            24usize,
            concat!("Size of: ", stringify!(tracepoint_func))
        );
        assert_eq!(
            ::core::mem::align_of::<tracepoint_func>(),
            8usize,
            concat!("Alignment of ", stringify!(tracepoint_func))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tracepoint_func>())).func as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(tracepoint_func),
                "::",
                stringify!(func)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tracepoint_func>())).data as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(tracepoint_func),
                "::",
                stringify!(data)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tracepoint_func>())).prio as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(tracepoint_func),
                "::",
                stringify!(prio)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct tracepoint {
        pub name: *const ::cty::c_char,
        pub key: static_key,
        pub static_call_key: *mut static_call_key,
        pub static_call_tramp: *mut ::cty::c_void,
        pub iterator: *mut ::cty::c_void,
        pub probestub: *mut ::cty::c_void,
        pub regfunc: ::core::option::Option<unsafe extern "C" fn() -> ::cty::c_int>,
        pub unregfunc: ::core::option::Option<unsafe extern "C" fn()>,
        pub funcs: *mut tracepoint_func,
    }
    #[test]
    fn bindgen_test_layout_tracepoint() {
        assert_eq!(
            ::core::mem::size_of::<tracepoint>(),
            80usize,
            concat!("Size of: ", stringify!(tracepoint))
        );
        assert_eq!(
            ::core::mem::align_of::<tracepoint>(),
            8usize,
            concat!("Alignment of ", stringify!(tracepoint))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tracepoint>())).name as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(tracepoint),
                "::",
                stringify!(name)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tracepoint>())).key as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(tracepoint),
                "::",
                stringify!(key)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tracepoint>())).static_call_key as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(tracepoint),
                "::",
                stringify!(static_call_key)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<tracepoint>())).static_call_tramp as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(tracepoint),
                "::",
                stringify!(static_call_tramp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tracepoint>())).iterator as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(tracepoint),
                "::",
                stringify!(iterator)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tracepoint>())).probestub as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(tracepoint),
                "::",
                stringify!(probestub)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tracepoint>())).regfunc as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(tracepoint),
                "::",
                stringify!(regfunc)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tracepoint>())).unregfunc as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(tracepoint),
                "::",
                stringify!(unregfunc)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tracepoint>())).funcs as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(tracepoint),
                "::",
                stringify!(funcs)
            )
        );
    }
    pub type tracepoint_ptr_t = ::cty::c_int;
    #[repr(C)]
    #[repr(align(32))]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_raw_event_map {
        pub tp: *mut tracepoint,
        pub bpf_func: *mut ::cty::c_void,
        pub num_args: _cargo_bpf_u32,
        pub writable_size: _cargo_bpf_u32,
    }
    #[test]
    fn bindgen_test_layout_bpf_raw_event_map() {
        assert_eq!(
            ::core::mem::size_of::<bpf_raw_event_map>(),
            32usize,
            concat!("Size of: ", stringify!(bpf_raw_event_map))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_raw_event_map>(),
            32usize,
            concat!("Alignment of ", stringify!(bpf_raw_event_map))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_raw_event_map>())).tp as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_raw_event_map),
                "::",
                stringify!(tp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_raw_event_map>())).bpf_func as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_raw_event_map),
                "::",
                stringify!(bpf_func)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_raw_event_map>())).num_args as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_raw_event_map),
                "::",
                stringify!(num_args)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_raw_event_map>())).writable_size as *const _ as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_raw_event_map),
                "::",
                stringify!(writable_size)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct fregs_state {
        pub cwd: _cargo_bpf_u32,
        pub swd: _cargo_bpf_u32,
        pub twd: _cargo_bpf_u32,
        pub fip: _cargo_bpf_u32,
        pub fcs: _cargo_bpf_u32,
        pub foo: _cargo_bpf_u32,
        pub fos: _cargo_bpf_u32,
        pub st_space: [_cargo_bpf_u32; 20usize],
        pub status: _cargo_bpf_u32,
    }
    #[test]
    fn bindgen_test_layout_fregs_state() {
        assert_eq!(
            ::core::mem::size_of::<fregs_state>(),
            112usize,
            concat!("Size of: ", stringify!(fregs_state))
        );
        assert_eq!(
            ::core::mem::align_of::<fregs_state>(),
            4usize,
            concat!("Alignment of ", stringify!(fregs_state))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fregs_state>())).cwd as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fregs_state),
                "::",
                stringify!(cwd)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fregs_state>())).swd as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(fregs_state),
                "::",
                stringify!(swd)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fregs_state>())).twd as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fregs_state),
                "::",
                stringify!(twd)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fregs_state>())).fip as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(fregs_state),
                "::",
                stringify!(fip)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fregs_state>())).fcs as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fregs_state),
                "::",
                stringify!(fcs)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fregs_state>())).foo as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(fregs_state),
                "::",
                stringify!(foo)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fregs_state>())).fos as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(fregs_state),
                "::",
                stringify!(fos)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fregs_state>())).st_space as *const _ as usize },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(fregs_state),
                "::",
                stringify!(st_space)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fregs_state>())).status as *const _ as usize },
            108usize,
            concat!(
                "Offset of field: ",
                stringify!(fregs_state),
                "::",
                stringify!(status)
            )
        );
    }
    #[repr(C)]
    #[repr(align(16))]
    #[derive(Copy, Clone)]
    pub struct fxregs_state {
        pub cwd: _cargo_bpf_u16,
        pub swd: _cargo_bpf_u16,
        pub twd: _cargo_bpf_u16,
        pub fop: _cargo_bpf_u16,
        pub __bindgen_anon_1: fxregs_state__bindgen_ty_1,
        pub mxcsr: _cargo_bpf_u32,
        pub mxcsr_mask: _cargo_bpf_u32,
        pub st_space: [_cargo_bpf_u32; 32usize],
        pub xmm_space: [_cargo_bpf_u32; 64usize],
        pub padding: [_cargo_bpf_u32; 12usize],
        pub __bindgen_anon_2: fxregs_state__bindgen_ty_2,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union fxregs_state__bindgen_ty_1 {
        pub __bindgen_anon_1: fxregs_state__bindgen_ty_1__bindgen_ty_1,
        pub __bindgen_anon_2: fxregs_state__bindgen_ty_1__bindgen_ty_2,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct fxregs_state__bindgen_ty_1__bindgen_ty_1 {
        pub rip: _cargo_bpf_u64,
        pub rdp: _cargo_bpf_u64,
    }
    #[test]
    fn bindgen_test_layout_fxregs_state__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<fxregs_state__bindgen_ty_1__bindgen_ty_1>(),
            16usize,
            concat!(
                "Size of: ",
                stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<fxregs_state__bindgen_ty_1__bindgen_ty_1>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<fxregs_state__bindgen_ty_1__bindgen_ty_1>())).rip
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(rip)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<fxregs_state__bindgen_ty_1__bindgen_ty_1>())).rdp
                    as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(rdp)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct fxregs_state__bindgen_ty_1__bindgen_ty_2 {
        pub fip: _cargo_bpf_u32,
        pub fcs: _cargo_bpf_u32,
        pub foo: _cargo_bpf_u32,
        pub fos: _cargo_bpf_u32,
    }
    #[test]
    fn bindgen_test_layout_fxregs_state__bindgen_ty_1__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<fxregs_state__bindgen_ty_1__bindgen_ty_2>(),
            16usize,
            concat!(
                "Size of: ",
                stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_2)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<fxregs_state__bindgen_ty_1__bindgen_ty_2>(),
            4usize,
            concat!(
                "Alignment of ",
                stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_2)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<fxregs_state__bindgen_ty_1__bindgen_ty_2>())).fip
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(fip)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<fxregs_state__bindgen_ty_1__bindgen_ty_2>())).fcs
                    as *const _ as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(fcs)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<fxregs_state__bindgen_ty_1__bindgen_ty_2>())).foo
                    as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(foo)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<fxregs_state__bindgen_ty_1__bindgen_ty_2>())).fos
                    as *const _ as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(fos)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_fxregs_state__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<fxregs_state__bindgen_ty_1>(),
            16usize,
            concat!("Size of: ", stringify!(fxregs_state__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<fxregs_state__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(fxregs_state__bindgen_ty_1))
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union fxregs_state__bindgen_ty_2 {
        pub padding1: [_cargo_bpf_u32; 12usize],
        pub sw_reserved: [_cargo_bpf_u32; 12usize],
    }
    #[test]
    fn bindgen_test_layout_fxregs_state__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<fxregs_state__bindgen_ty_2>(),
            48usize,
            concat!("Size of: ", stringify!(fxregs_state__bindgen_ty_2))
        );
        assert_eq!(
            ::core::mem::align_of::<fxregs_state__bindgen_ty_2>(),
            4usize,
            concat!("Alignment of ", stringify!(fxregs_state__bindgen_ty_2))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<fxregs_state__bindgen_ty_2>())).padding1 as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fxregs_state__bindgen_ty_2),
                "::",
                stringify!(padding1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<fxregs_state__bindgen_ty_2>())).sw_reserved as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fxregs_state__bindgen_ty_2),
                "::",
                stringify!(sw_reserved)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_fxregs_state() {
        assert_eq!(
            ::core::mem::size_of::<fxregs_state>(),
            512usize,
            concat!("Size of: ", stringify!(fxregs_state))
        );
        assert_eq!(
            ::core::mem::align_of::<fxregs_state>(),
            16usize,
            concat!("Alignment of ", stringify!(fxregs_state))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fxregs_state>())).cwd as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fxregs_state),
                "::",
                stringify!(cwd)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fxregs_state>())).swd as *const _ as usize },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(fxregs_state),
                "::",
                stringify!(swd)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fxregs_state>())).twd as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(fxregs_state),
                "::",
                stringify!(twd)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fxregs_state>())).fop as *const _ as usize },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(fxregs_state),
                "::",
                stringify!(fop)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fxregs_state>())).mxcsr as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(fxregs_state),
                "::",
                stringify!(mxcsr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fxregs_state>())).mxcsr_mask as *const _ as usize },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(fxregs_state),
                "::",
                stringify!(mxcsr_mask)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fxregs_state>())).st_space as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(fxregs_state),
                "::",
                stringify!(st_space)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fxregs_state>())).xmm_space as *const _ as usize },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(fxregs_state),
                "::",
                stringify!(xmm_space)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fxregs_state>())).padding as *const _ as usize },
            416usize,
            concat!(
                "Offset of field: ",
                stringify!(fxregs_state),
                "::",
                stringify!(padding)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct swregs_state {
        pub cwd: _cargo_bpf_u32,
        pub swd: _cargo_bpf_u32,
        pub twd: _cargo_bpf_u32,
        pub fip: _cargo_bpf_u32,
        pub fcs: _cargo_bpf_u32,
        pub foo: _cargo_bpf_u32,
        pub fos: _cargo_bpf_u32,
        pub st_space: [_cargo_bpf_u32; 20usize],
        pub ftop: _cargo_bpf_u8,
        pub changed: _cargo_bpf_u8,
        pub lookahead: _cargo_bpf_u8,
        pub no_update: _cargo_bpf_u8,
        pub rm: _cargo_bpf_u8,
        pub alimit: _cargo_bpf_u8,
        pub info: *mut math_emu_info,
        pub entry_eip: _cargo_bpf_u32,
    }
    #[test]
    fn bindgen_test_layout_swregs_state() {
        assert_eq!(
            ::core::mem::size_of::<swregs_state>(),
            136usize,
            concat!("Size of: ", stringify!(swregs_state))
        );
        assert_eq!(
            ::core::mem::align_of::<swregs_state>(),
            8usize,
            concat!("Alignment of ", stringify!(swregs_state))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<swregs_state>())).cwd as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(swregs_state),
                "::",
                stringify!(cwd)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<swregs_state>())).swd as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(swregs_state),
                "::",
                stringify!(swd)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<swregs_state>())).twd as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(swregs_state),
                "::",
                stringify!(twd)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<swregs_state>())).fip as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(swregs_state),
                "::",
                stringify!(fip)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<swregs_state>())).fcs as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(swregs_state),
                "::",
                stringify!(fcs)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<swregs_state>())).foo as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(swregs_state),
                "::",
                stringify!(foo)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<swregs_state>())).fos as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(swregs_state),
                "::",
                stringify!(fos)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<swregs_state>())).st_space as *const _ as usize },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(swregs_state),
                "::",
                stringify!(st_space)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<swregs_state>())).ftop as *const _ as usize },
            108usize,
            concat!(
                "Offset of field: ",
                stringify!(swregs_state),
                "::",
                stringify!(ftop)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<swregs_state>())).changed as *const _ as usize },
            109usize,
            concat!(
                "Offset of field: ",
                stringify!(swregs_state),
                "::",
                stringify!(changed)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<swregs_state>())).lookahead as *const _ as usize },
            110usize,
            concat!(
                "Offset of field: ",
                stringify!(swregs_state),
                "::",
                stringify!(lookahead)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<swregs_state>())).no_update as *const _ as usize },
            111usize,
            concat!(
                "Offset of field: ",
                stringify!(swregs_state),
                "::",
                stringify!(no_update)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<swregs_state>())).rm as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(swregs_state),
                "::",
                stringify!(rm)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<swregs_state>())).alimit as *const _ as usize },
            113usize,
            concat!(
                "Offset of field: ",
                stringify!(swregs_state),
                "::",
                stringify!(alimit)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<swregs_state>())).info as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(swregs_state),
                "::",
                stringify!(info)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<swregs_state>())).entry_eip as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(swregs_state),
                "::",
                stringify!(entry_eip)
            )
        );
    }
    #[repr(C)]
    #[repr(align(64))]
    pub struct xregs_state {
        pub _bindgen_opaque_blob: [u8; 576usize],
    }
    #[test]
    fn bindgen_test_layout_xregs_state() {
        assert_eq!(
            ::core::mem::size_of::<xregs_state>(),
            576usize,
            concat!("Size of: ", stringify!(xregs_state))
        );
        assert_eq!(
            ::core::mem::align_of::<xregs_state>(),
            64usize,
            concat!("Alignment of ", stringify!(xregs_state))
        );
    }
    #[repr(C)]
    #[repr(align(64))]
    pub struct fpregs_state {
        pub fsave: __BindgenUnionField<fregs_state>,
        pub fxsave: __BindgenUnionField<fxregs_state>,
        pub soft: __BindgenUnionField<swregs_state>,
        pub xsave: __BindgenUnionField<xregs_state>,
        pub __padding: __BindgenUnionField<[_cargo_bpf_u8; 4096usize]>,
        pub bindgen_union_field: [u8; 4096usize],
    }
    #[test]
    fn bindgen_test_layout_fpregs_state() {
        assert_eq!(
            ::core::mem::size_of::<fpregs_state>(),
            4096usize,
            concat!("Size of: ", stringify!(fpregs_state))
        );
        assert_eq!(
            ::core::mem::align_of::<fpregs_state>(),
            64usize,
            concat!("Alignment of ", stringify!(fpregs_state))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fpregs_state>())).fsave as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fpregs_state),
                "::",
                stringify!(fsave)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fpregs_state>())).fxsave as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fpregs_state),
                "::",
                stringify!(fxsave)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fpregs_state>())).soft as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fpregs_state),
                "::",
                stringify!(soft)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fpregs_state>())).xsave as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fpregs_state),
                "::",
                stringify!(xsave)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fpregs_state>())).__padding as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fpregs_state),
                "::",
                stringify!(__padding)
            )
        );
    }
    #[repr(C)]
    #[repr(align(64))]
    pub struct fpstate {
        pub size: ::cty::c_uint,
        pub user_size: ::cty::c_uint,
        pub xfeatures: _cargo_bpf_u64,
        pub user_xfeatures: _cargo_bpf_u64,
        pub xfd: _cargo_bpf_u64,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
        pub __bindgen_padding_0: [u64; 3usize],
        pub regs: fpregs_state,
    }
    #[test]
    fn bindgen_test_layout_fpstate() {
        assert_eq!(
            ::core::mem::size_of::<fpstate>(),
            4160usize,
            concat!("Size of: ", stringify!(fpstate))
        );
        assert_eq!(
            ::core::mem::align_of::<fpstate>(),
            64usize,
            concat!("Alignment of ", stringify!(fpstate))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fpstate>())).size as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fpstate),
                "::",
                stringify!(size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fpstate>())).user_size as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(fpstate),
                "::",
                stringify!(user_size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fpstate>())).xfeatures as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fpstate),
                "::",
                stringify!(xfeatures)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fpstate>())).user_xfeatures as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fpstate),
                "::",
                stringify!(user_xfeatures)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fpstate>())).xfd as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(fpstate),
                "::",
                stringify!(xfd)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fpstate>())).regs as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(fpstate),
                "::",
                stringify!(regs)
            )
        );
    }
    impl fpstate {
        #[inline]
        pub fn is_valloc(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_is_valloc(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn is_guest(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_is_guest(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(1usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn is_confidential(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_is_confidential(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(2usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn in_use(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_in_use(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(3usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            is_valloc: ::cty::c_uint,
            is_guest: ::cty::c_uint,
            is_confidential: ::cty::c_uint,
            in_use: ::cty::c_uint,
        ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 1u8, {
                let is_valloc: u32 = unsafe { ::core::mem::transmute(is_valloc) };
                is_valloc as u64
            });
            __bindgen_bitfield_unit.set(1usize, 1u8, {
                let is_guest: u32 = unsafe { ::core::mem::transmute(is_guest) };
                is_guest as u64
            });
            __bindgen_bitfield_unit.set(2usize, 1u8, {
                let is_confidential: u32 = unsafe { ::core::mem::transmute(is_confidential) };
                is_confidential as u64
            });
            __bindgen_bitfield_unit.set(3usize, 1u8, {
                let in_use: u32 = unsafe { ::core::mem::transmute(in_use) };
                in_use as u64
            });
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct fpu_state_perm {
        pub __state_perm: _cargo_bpf_u64,
        pub __state_size: ::cty::c_uint,
        pub __user_state_size: ::cty::c_uint,
    }
    #[test]
    fn bindgen_test_layout_fpu_state_perm() {
        assert_eq!(
            ::core::mem::size_of::<fpu_state_perm>(),
            16usize,
            concat!("Size of: ", stringify!(fpu_state_perm))
        );
        assert_eq!(
            ::core::mem::align_of::<fpu_state_perm>(),
            8usize,
            concat!("Alignment of ", stringify!(fpu_state_perm))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<fpu_state_perm>())).__state_perm as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fpu_state_perm),
                "::",
                stringify!(__state_perm)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<fpu_state_perm>())).__state_size as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fpu_state_perm),
                "::",
                stringify!(__state_size)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<fpu_state_perm>())).__user_state_size as *const _ as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(fpu_state_perm),
                "::",
                stringify!(__user_state_size)
            )
        );
    }
    #[repr(C)]
    #[repr(align(64))]
    pub struct fpu {
        pub last_cpu: ::cty::c_uint,
        pub avx512_timestamp: ::cty::c_ulong,
        pub fpstate: *mut fpstate,
        pub __task_fpstate: *mut fpstate,
        pub perm: fpu_state_perm,
        pub guest_perm: fpu_state_perm,
        pub __fpstate: fpstate,
    }
    #[test]
    fn bindgen_test_layout_fpu() {
        assert_eq!(
            ::core::mem::size_of::<fpu>(),
            4224usize,
            concat!("Size of: ", stringify!(fpu))
        );
        assert_eq!(
            ::core::mem::align_of::<fpu>(),
            64usize,
            concat!("Alignment of ", stringify!(fpu))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fpu>())).last_cpu as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fpu),
                "::",
                stringify!(last_cpu)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fpu>())).avx512_timestamp as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fpu),
                "::",
                stringify!(avx512_timestamp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fpu>())).fpstate as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fpu),
                "::",
                stringify!(fpstate)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fpu>())).__task_fpstate as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(fpu),
                "::",
                stringify!(__task_fpstate)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fpu>())).perm as *const _ as usize },
            32usize,
            concat!("Offset of field: ", stringify!(fpu), "::", stringify!(perm))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fpu>())).guest_perm as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(fpu),
                "::",
                stringify!(guest_perm)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fpu>())).__fpstate as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(fpu),
                "::",
                stringify!(__fpstate)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct seq_operations {
        pub start: ::core::option::Option<
            unsafe extern "C" fn(m: *mut seq_file, pos: *mut loff_t) -> *mut ::cty::c_void,
        >,
        pub stop:
            ::core::option::Option<unsafe extern "C" fn(m: *mut seq_file, v: *mut ::cty::c_void)>,
        pub next: ::core::option::Option<
            unsafe extern "C" fn(
                m: *mut seq_file,
                v: *mut ::cty::c_void,
                pos: *mut loff_t,
            ) -> *mut ::cty::c_void,
        >,
        pub show: ::core::option::Option<
            unsafe extern "C" fn(m: *mut seq_file, v: *mut ::cty::c_void) -> ::cty::c_int,
        >,
    }
    #[test]
    fn bindgen_test_layout_seq_operations() {
        assert_eq!(
            ::core::mem::size_of::<seq_operations>(),
            32usize,
            concat!("Size of: ", stringify!(seq_operations))
        );
        assert_eq!(
            ::core::mem::align_of::<seq_operations>(),
            8usize,
            concat!("Alignment of ", stringify!(seq_operations))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<seq_operations>())).start as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(seq_operations),
                "::",
                stringify!(start)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<seq_operations>())).stop as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(seq_operations),
                "::",
                stringify!(stop)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<seq_operations>())).next as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(seq_operations),
                "::",
                stringify!(next)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<seq_operations>())).show as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(seq_operations),
                "::",
                stringify!(show)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct perf_event {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[repr(align(64))]
    pub struct thread_struct {
        pub tls_array: [desc_struct; 3usize],
        pub sp: ::cty::c_ulong,
        pub es: ::cty::c_ushort,
        pub ds: ::cty::c_ushort,
        pub fsindex: ::cty::c_ushort,
        pub gsindex: ::cty::c_ushort,
        pub fsbase: ::cty::c_ulong,
        pub gsbase: ::cty::c_ulong,
        pub ptrace_bps: [*mut perf_event; 4usize],
        pub virtual_dr6: ::cty::c_ulong,
        pub ptrace_dr7: ::cty::c_ulong,
        pub cr2: ::cty::c_ulong,
        pub trap_nr: ::cty::c_ulong,
        pub error_code: ::cty::c_ulong,
        pub io_bitmap: *mut io_bitmap,
        pub iopl_emul: ::cty::c_ulong,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
        pub pkru: _cargo_bpf_u32,
        pub __bindgen_padding_0: [u64; 5usize],
        pub fpu: fpu,
    }
    #[test]
    fn bindgen_test_layout_thread_struct() {
        assert_eq!(
            ::core::mem::size_of::<thread_struct>(),
            4416usize,
            concat!("Size of: ", stringify!(thread_struct))
        );
        assert_eq!(
            ::core::mem::align_of::<thread_struct>(),
            64usize,
            concat!("Alignment of ", stringify!(thread_struct))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<thread_struct>())).tls_array as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(thread_struct),
                "::",
                stringify!(tls_array)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<thread_struct>())).sp as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(thread_struct),
                "::",
                stringify!(sp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<thread_struct>())).es as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(thread_struct),
                "::",
                stringify!(es)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<thread_struct>())).ds as *const _ as usize },
            34usize,
            concat!(
                "Offset of field: ",
                stringify!(thread_struct),
                "::",
                stringify!(ds)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<thread_struct>())).fsindex as *const _ as usize },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(thread_struct),
                "::",
                stringify!(fsindex)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<thread_struct>())).gsindex as *const _ as usize },
            38usize,
            concat!(
                "Offset of field: ",
                stringify!(thread_struct),
                "::",
                stringify!(gsindex)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<thread_struct>())).fsbase as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(thread_struct),
                "::",
                stringify!(fsbase)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<thread_struct>())).gsbase as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(thread_struct),
                "::",
                stringify!(gsbase)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<thread_struct>())).ptrace_bps as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(thread_struct),
                "::",
                stringify!(ptrace_bps)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<thread_struct>())).virtual_dr6 as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(thread_struct),
                "::",
                stringify!(virtual_dr6)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<thread_struct>())).ptrace_dr7 as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(thread_struct),
                "::",
                stringify!(ptrace_dr7)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<thread_struct>())).cr2 as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(thread_struct),
                "::",
                stringify!(cr2)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<thread_struct>())).trap_nr as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(thread_struct),
                "::",
                stringify!(trap_nr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<thread_struct>())).error_code as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(thread_struct),
                "::",
                stringify!(error_code)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<thread_struct>())).io_bitmap as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(thread_struct),
                "::",
                stringify!(io_bitmap)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<thread_struct>())).iopl_emul as *const _ as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(thread_struct),
                "::",
                stringify!(iopl_emul)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<thread_struct>())).pkru as *const _ as usize },
            148usize,
            concat!(
                "Offset of field: ",
                stringify!(thread_struct),
                "::",
                stringify!(pkru)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<thread_struct>())).fpu as *const _ as usize },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(thread_struct),
                "::",
                stringify!(fpu)
            )
        );
    }
    impl thread_struct {
        #[inline]
        pub fn iopl_warn(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_iopl_warn(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn sig_on_uaccess_err(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_sig_on_uaccess_err(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(1usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            iopl_warn: ::cty::c_uint,
            sig_on_uaccess_err: ::cty::c_uint,
        ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 1u8, {
                let iopl_warn: u32 = unsafe { ::core::mem::transmute(iopl_warn) };
                iopl_warn as u64
            });
            __bindgen_bitfield_unit.set(1usize, 1u8, {
                let sig_on_uaccess_err: u32 = unsafe { ::core::mem::transmute(sig_on_uaccess_err) };
                sig_on_uaccess_err as u64
            });
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct thread_info {
        pub flags: ::cty::c_ulong,
        pub syscall_work: ::cty::c_ulong,
        pub status: _cargo_bpf_u32,
        pub cpu: _cargo_bpf_u32,
    }
    #[test]
    fn bindgen_test_layout_thread_info() {
        assert_eq!(
            ::core::mem::size_of::<thread_info>(),
            24usize,
            concat!("Size of: ", stringify!(thread_info))
        );
        assert_eq!(
            ::core::mem::align_of::<thread_info>(),
            8usize,
            concat!("Alignment of ", stringify!(thread_info))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<thread_info>())).flags as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(thread_info),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<thread_info>())).syscall_work as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(thread_info),
                "::",
                stringify!(syscall_work)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<thread_info>())).status as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(thread_info),
                "::",
                stringify!(status)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<thread_info>())).cpu as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(thread_info),
                "::",
                stringify!(cpu)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct llist_head {
        pub first: *mut llist_node,
    }
    #[test]
    fn bindgen_test_layout_llist_head() {
        assert_eq!(
            ::core::mem::size_of::<llist_head>(),
            8usize,
            concat!("Size of: ", stringify!(llist_head))
        );
        assert_eq!(
            ::core::mem::align_of::<llist_head>(),
            8usize,
            concat!("Alignment of ", stringify!(llist_head))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<llist_head>())).first as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(llist_head),
                "::",
                stringify!(first)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct llist_node {
        pub next: *mut llist_node,
    }
    #[test]
    fn bindgen_test_layout_llist_node() {
        assert_eq!(
            ::core::mem::size_of::<llist_node>(),
            8usize,
            concat!("Size of: ", stringify!(llist_node))
        );
        assert_eq!(
            ::core::mem::align_of::<llist_node>(),
            8usize,
            concat!("Alignment of ", stringify!(llist_node))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<llist_node>())).next as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(llist_node),
                "::",
                stringify!(next)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct __call_single_node {
        pub llist: llist_node,
        pub __bindgen_anon_1: __call_single_node__bindgen_ty_1,
        pub src: _cargo_bpf_u16,
        pub dst: _cargo_bpf_u16,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union __call_single_node__bindgen_ty_1 {
        pub u_flags: ::cty::c_uint,
        pub a_flags: atomic_t,
    }
    #[test]
    fn bindgen_test_layout___call_single_node__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<__call_single_node__bindgen_ty_1>(),
            4usize,
            concat!("Size of: ", stringify!(__call_single_node__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<__call_single_node__bindgen_ty_1>(),
            4usize,
            concat!(
                "Alignment of ",
                stringify!(__call_single_node__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__call_single_node__bindgen_ty_1>())).u_flags as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__call_single_node__bindgen_ty_1),
                "::",
                stringify!(u_flags)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__call_single_node__bindgen_ty_1>())).a_flags as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__call_single_node__bindgen_ty_1),
                "::",
                stringify!(a_flags)
            )
        );
    }
    #[test]
    fn bindgen_test_layout___call_single_node() {
        assert_eq!(
            ::core::mem::size_of::<__call_single_node>(),
            16usize,
            concat!("Size of: ", stringify!(__call_single_node))
        );
        assert_eq!(
            ::core::mem::align_of::<__call_single_node>(),
            8usize,
            concat!("Alignment of ", stringify!(__call_single_node))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__call_single_node>())).llist as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__call_single_node),
                "::",
                stringify!(llist)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__call_single_node>())).src as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(__call_single_node),
                "::",
                stringify!(src)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__call_single_node>())).dst as *const _ as usize },
            14usize,
            concat!(
                "Offset of field: ",
                stringify!(__call_single_node),
                "::",
                stringify!(dst)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct spinlock {
        pub __bindgen_anon_1: spinlock__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union spinlock__bindgen_ty_1 {
        pub rlock: raw_spinlock,
    }
    #[test]
    fn bindgen_test_layout_spinlock__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<spinlock__bindgen_ty_1>(),
            4usize,
            concat!("Size of: ", stringify!(spinlock__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<spinlock__bindgen_ty_1>(),
            4usize,
            concat!("Alignment of ", stringify!(spinlock__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<spinlock__bindgen_ty_1>())).rlock as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spinlock__bindgen_ty_1),
                "::",
                stringify!(rlock)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_spinlock() {
        assert_eq!(
            ::core::mem::size_of::<spinlock>(),
            4usize,
            concat!("Size of: ", stringify!(spinlock))
        );
        assert_eq!(
            ::core::mem::align_of::<spinlock>(),
            4usize,
            concat!("Alignment of ", stringify!(spinlock))
        );
    }
    pub type spinlock_t = spinlock;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct rwlock_t {
        pub raw_lock: arch_rwlock_t,
    }
    #[test]
    fn bindgen_test_layout_rwlock_t() {
        assert_eq!(
            ::core::mem::size_of::<rwlock_t>(),
            8usize,
            concat!("Size of: ", stringify!(rwlock_t))
        );
        assert_eq!(
            ::core::mem::align_of::<rwlock_t>(),
            4usize,
            concat!("Alignment of ", stringify!(rwlock_t))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rwlock_t>())).raw_lock as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rwlock_t),
                "::",
                stringify!(raw_lock)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct wait_queue_head {
        pub lock: spinlock_t,
        pub head: list_head,
    }
    #[test]
    fn bindgen_test_layout_wait_queue_head() {
        assert_eq!(
            ::core::mem::size_of::<wait_queue_head>(),
            24usize,
            concat!("Size of: ", stringify!(wait_queue_head))
        );
        assert_eq!(
            ::core::mem::align_of::<wait_queue_head>(),
            8usize,
            concat!("Alignment of ", stringify!(wait_queue_head))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<wait_queue_head>())).lock as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(wait_queue_head),
                "::",
                stringify!(lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<wait_queue_head>())).head as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(wait_queue_head),
                "::",
                stringify!(head)
            )
        );
    }
    pub type wait_queue_head_t = wait_queue_head;
    #[doc = " typedef refcount_t - variant of atomic_t specialized for reference counts"]
    #[doc = " @refs: atomic_t counter field"]
    #[doc = ""]
    #[doc = " The counter saturates at REFCOUNT_SATURATED and will not move once"]
    #[doc = " there. This avoids wrapping the counter and causing 'spurious'"]
    #[doc = " use-after-free bugs."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct refcount_struct {
        pub refs: atomic_t,
    }
    #[test]
    fn bindgen_test_layout_refcount_struct() {
        assert_eq!(
            ::core::mem::size_of::<refcount_struct>(),
            4usize,
            concat!("Size of: ", stringify!(refcount_struct))
        );
        assert_eq!(
            ::core::mem::align_of::<refcount_struct>(),
            4usize,
            concat!("Alignment of ", stringify!(refcount_struct))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<refcount_struct>())).refs as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(refcount_struct),
                "::",
                stringify!(refs)
            )
        );
    }
    #[doc = " typedef refcount_t - variant of atomic_t specialized for reference counts"]
    #[doc = " @refs: atomic_t counter field"]
    #[doc = ""]
    #[doc = " The counter saturates at REFCOUNT_SATURATED and will not move once"]
    #[doc = " there. This avoids wrapping the counter and causing 'spurious'"]
    #[doc = " use-after-free bugs."]
    pub type refcount_t = refcount_struct;
    pub const pid_type_PIDTYPE_PID: pid_type = 0;
    pub const pid_type_PIDTYPE_TGID: pid_type = 1;
    pub const pid_type_PIDTYPE_PGID: pid_type = 2;
    pub const pid_type_PIDTYPE_SID: pid_type = 3;
    pub const pid_type_PIDTYPE_MAX: pid_type = 4;
    pub type pid_type = ::cty::c_uint;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct upid {
        pub nr: ::cty::c_int,
        pub ns: *mut pid_namespace,
    }
    #[test]
    fn bindgen_test_layout_upid() {
        assert_eq!(
            ::core::mem::size_of::<upid>(),
            16usize,
            concat!("Size of: ", stringify!(upid))
        );
        assert_eq!(
            ::core::mem::align_of::<upid>(),
            8usize,
            concat!("Alignment of ", stringify!(upid))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<upid>())).nr as *const _ as usize },
            0usize,
            concat!("Offset of field: ", stringify!(upid), "::", stringify!(nr))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<upid>())).ns as *const _ as usize },
            8usize,
            concat!("Offset of field: ", stringify!(upid), "::", stringify!(ns))
        );
    }
    #[repr(C)]
    pub struct pid {
        pub count: refcount_t,
        pub level: ::cty::c_uint,
        pub lock: spinlock_t,
        pub tasks: [hlist_head; 4usize],
        pub inodes: hlist_head,
        pub wait_pidfd: wait_queue_head_t,
        pub rcu: callback_head,
        pub numbers: __IncompleteArrayField<upid>,
    }
    #[test]
    fn bindgen_test_layout_pid() {
        assert_eq!(
            ::core::mem::size_of::<pid>(),
            96usize,
            concat!("Size of: ", stringify!(pid))
        );
        assert_eq!(
            ::core::mem::align_of::<pid>(),
            8usize,
            concat!("Alignment of ", stringify!(pid))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pid>())).count as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pid),
                "::",
                stringify!(count)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pid>())).level as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(pid),
                "::",
                stringify!(level)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pid>())).lock as *const _ as usize },
            8usize,
            concat!("Offset of field: ", stringify!(pid), "::", stringify!(lock))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pid>())).tasks as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(pid),
                "::",
                stringify!(tasks)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pid>())).inodes as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(pid),
                "::",
                stringify!(inodes)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pid>())).wait_pidfd as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(pid),
                "::",
                stringify!(wait_pidfd)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pid>())).rcu as *const _ as usize },
            80usize,
            concat!("Offset of field: ", stringify!(pid), "::", stringify!(rcu))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pid>())).numbers as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(pid),
                "::",
                stringify!(numbers)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct pid_namespace {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct user_namespace {
        pub uid_map: uid_gid_map,
        pub gid_map: uid_gid_map,
        pub projid_map: uid_gid_map,
        pub parent: *mut user_namespace,
        pub level: ::cty::c_int,
        pub owner: kuid_t,
        pub group: kgid_t,
        pub ns: ns_common,
        pub flags: ::cty::c_ulong,
        pub parent_could_setfcap: bool_,
        pub keyring_name_list: list_head,
        pub user_keyring_register: *mut key,
        pub keyring_sem: rw_semaphore,
        pub persistent_keyring_register: *mut key,
        pub work: work_struct,
        pub set: ctl_table_set,
        pub sysctls: *mut ctl_table_header,
        pub ucounts: *mut ucounts,
        pub ucount_max: [::cty::c_long; 12usize],
        pub rlimit_max: [::cty::c_long; 4usize],
    }
    #[test]
    fn bindgen_test_layout_user_namespace() {
        assert_eq!(
            ::core::mem::size_of::<user_namespace>(),
            624usize,
            concat!("Size of: ", stringify!(user_namespace))
        );
        assert_eq!(
            ::core::mem::align_of::<user_namespace>(),
            8usize,
            concat!("Alignment of ", stringify!(user_namespace))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<user_namespace>())).uid_map as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(user_namespace),
                "::",
                stringify!(uid_map)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<user_namespace>())).gid_map as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(user_namespace),
                "::",
                stringify!(gid_map)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<user_namespace>())).projid_map as *const _ as usize },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(user_namespace),
                "::",
                stringify!(projid_map)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<user_namespace>())).parent as *const _ as usize },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(user_namespace),
                "::",
                stringify!(parent)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<user_namespace>())).level as *const _ as usize },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(user_namespace),
                "::",
                stringify!(level)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<user_namespace>())).owner as *const _ as usize },
            228usize,
            concat!(
                "Offset of field: ",
                stringify!(user_namespace),
                "::",
                stringify!(owner)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<user_namespace>())).group as *const _ as usize },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(user_namespace),
                "::",
                stringify!(group)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<user_namespace>())).ns as *const _ as usize },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(user_namespace),
                "::",
                stringify!(ns)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<user_namespace>())).flags as *const _ as usize },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(user_namespace),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<user_namespace>())).parent_could_setfcap as *const _
                    as usize
            },
            272usize,
            concat!(
                "Offset of field: ",
                stringify!(user_namespace),
                "::",
                stringify!(parent_could_setfcap)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<user_namespace>())).keyring_name_list as *const _ as usize
            },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(user_namespace),
                "::",
                stringify!(keyring_name_list)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<user_namespace>())).user_keyring_register as *const _
                    as usize
            },
            296usize,
            concat!(
                "Offset of field: ",
                stringify!(user_namespace),
                "::",
                stringify!(user_keyring_register)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<user_namespace>())).keyring_sem as *const _ as usize },
            304usize,
            concat!(
                "Offset of field: ",
                stringify!(user_namespace),
                "::",
                stringify!(keyring_sem)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<user_namespace>())).persistent_keyring_register as *const _
                    as usize
            },
            344usize,
            concat!(
                "Offset of field: ",
                stringify!(user_namespace),
                "::",
                stringify!(persistent_keyring_register)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<user_namespace>())).work as *const _ as usize },
            352usize,
            concat!(
                "Offset of field: ",
                stringify!(user_namespace),
                "::",
                stringify!(work)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<user_namespace>())).set as *const _ as usize },
            384usize,
            concat!(
                "Offset of field: ",
                stringify!(user_namespace),
                "::",
                stringify!(set)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<user_namespace>())).sysctls as *const _ as usize },
            480usize,
            concat!(
                "Offset of field: ",
                stringify!(user_namespace),
                "::",
                stringify!(sysctls)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<user_namespace>())).ucounts as *const _ as usize },
            488usize,
            concat!(
                "Offset of field: ",
                stringify!(user_namespace),
                "::",
                stringify!(ucounts)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<user_namespace>())).ucount_max as *const _ as usize },
            496usize,
            concat!(
                "Offset of field: ",
                stringify!(user_namespace),
                "::",
                stringify!(ucount_max)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<user_namespace>())).rlimit_max as *const _ as usize },
            592usize,
            concat!(
                "Offset of field: ",
                stringify!(user_namespace),
                "::",
                stringify!(rlimit_max)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct kuid_t {
        pub val: uid_t,
    }
    #[test]
    fn bindgen_test_layout_kuid_t() {
        assert_eq!(
            ::core::mem::size_of::<kuid_t>(),
            4usize,
            concat!("Size of: ", stringify!(kuid_t))
        );
        assert_eq!(
            ::core::mem::align_of::<kuid_t>(),
            4usize,
            concat!("Alignment of ", stringify!(kuid_t))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kuid_t>())).val as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(kuid_t),
                "::",
                stringify!(val)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct kgid_t {
        pub val: gid_t,
    }
    #[test]
    fn bindgen_test_layout_kgid_t() {
        assert_eq!(
            ::core::mem::size_of::<kgid_t>(),
            4usize,
            concat!("Size of: ", stringify!(kgid_t))
        );
        assert_eq!(
            ::core::mem::align_of::<kgid_t>(),
            4usize,
            concat!("Alignment of ", stringify!(kgid_t))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kgid_t>())).val as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(kgid_t),
                "::",
                stringify!(val)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct optimistic_spin_queue {
        pub tail: atomic_t,
    }
    #[test]
    fn bindgen_test_layout_optimistic_spin_queue() {
        assert_eq!(
            ::core::mem::size_of::<optimistic_spin_queue>(),
            4usize,
            concat!("Size of: ", stringify!(optimistic_spin_queue))
        );
        assert_eq!(
            ::core::mem::align_of::<optimistic_spin_queue>(),
            4usize,
            concat!("Alignment of ", stringify!(optimistic_spin_queue))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<optimistic_spin_queue>())).tail as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(optimistic_spin_queue),
                "::",
                stringify!(tail)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct mutex {
        pub owner: atomic_long_t,
        pub wait_lock: raw_spinlock_t,
        pub osq: optimistic_spin_queue,
        pub wait_list: list_head,
    }
    #[test]
    fn bindgen_test_layout_mutex() {
        assert_eq!(
            ::core::mem::size_of::<mutex>(),
            32usize,
            concat!("Size of: ", stringify!(mutex))
        );
        assert_eq!(
            ::core::mem::align_of::<mutex>(),
            8usize,
            concat!("Alignment of ", stringify!(mutex))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mutex>())).owner as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mutex),
                "::",
                stringify!(owner)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mutex>())).wait_lock as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mutex),
                "::",
                stringify!(wait_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mutex>())).osq as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(mutex),
                "::",
                stringify!(osq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mutex>())).wait_list as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(mutex),
                "::",
                stringify!(wait_list)
            )
        );
    }
    pub type old_time32_t = s32;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct old_timespec32 {
        pub tv_sec: old_time32_t,
        pub tv_nsec: s32,
    }
    #[test]
    fn bindgen_test_layout_old_timespec32() {
        assert_eq!(
            ::core::mem::size_of::<old_timespec32>(),
            8usize,
            concat!("Size of: ", stringify!(old_timespec32))
        );
        assert_eq!(
            ::core::mem::align_of::<old_timespec32>(),
            4usize,
            concat!("Alignment of ", stringify!(old_timespec32))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<old_timespec32>())).tv_sec as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(old_timespec32),
                "::",
                stringify!(tv_sec)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<old_timespec32>())).tv_nsec as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(old_timespec32),
                "::",
                stringify!(tv_nsec)
            )
        );
    }
    pub type ktime_t = s64;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct timer_list {
        pub entry: hlist_node,
        pub expires: ::cty::c_ulong,
        pub function: ::core::option::Option<unsafe extern "C" fn(arg1: *mut timer_list)>,
        pub flags: _cargo_bpf_u32,
    }
    #[test]
    fn bindgen_test_layout_timer_list() {
        assert_eq!(
            ::core::mem::size_of::<timer_list>(),
            40usize,
            concat!("Size of: ", stringify!(timer_list))
        );
        assert_eq!(
            ::core::mem::align_of::<timer_list>(),
            8usize,
            concat!("Alignment of ", stringify!(timer_list))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<timer_list>())).entry as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(timer_list),
                "::",
                stringify!(entry)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<timer_list>())).expires as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(timer_list),
                "::",
                stringify!(expires)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<timer_list>())).function as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(timer_list),
                "::",
                stringify!(function)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<timer_list>())).flags as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(timer_list),
                "::",
                stringify!(flags)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct workqueue_struct {
        _unused: [u8; 0],
    }
    pub type work_func_t = ::core::option::Option<unsafe extern "C" fn(work: *mut work_struct)>;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct work_struct {
        pub data: atomic_long_t,
        pub entry: list_head,
        pub func: work_func_t,
    }
    #[test]
    fn bindgen_test_layout_work_struct() {
        assert_eq!(
            ::core::mem::size_of::<work_struct>(),
            32usize,
            concat!("Size of: ", stringify!(work_struct))
        );
        assert_eq!(
            ::core::mem::align_of::<work_struct>(),
            8usize,
            concat!("Alignment of ", stringify!(work_struct))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<work_struct>())).data as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(work_struct),
                "::",
                stringify!(data)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<work_struct>())).entry as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(work_struct),
                "::",
                stringify!(entry)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<work_struct>())).func as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(work_struct),
                "::",
                stringify!(func)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct delayed_work {
        pub work: work_struct,
        pub timer: timer_list,
        pub wq: *mut workqueue_struct,
        pub cpu: ::cty::c_int,
    }
    #[test]
    fn bindgen_test_layout_delayed_work() {
        assert_eq!(
            ::core::mem::size_of::<delayed_work>(),
            88usize,
            concat!("Size of: ", stringify!(delayed_work))
        );
        assert_eq!(
            ::core::mem::align_of::<delayed_work>(),
            8usize,
            concat!("Alignment of ", stringify!(delayed_work))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<delayed_work>())).work as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(delayed_work),
                "::",
                stringify!(work)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<delayed_work>())).timer as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(delayed_work),
                "::",
                stringify!(timer)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<delayed_work>())).wq as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(delayed_work),
                "::",
                stringify!(wq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<delayed_work>())).cpu as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(delayed_work),
                "::",
                stringify!(cpu)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct rcu_work {
        pub work: work_struct,
        pub rcu: callback_head,
        pub wq: *mut workqueue_struct,
    }
    #[test]
    fn bindgen_test_layout_rcu_work() {
        assert_eq!(
            ::core::mem::size_of::<rcu_work>(),
            56usize,
            concat!("Size of: ", stringify!(rcu_work))
        );
        assert_eq!(
            ::core::mem::align_of::<rcu_work>(),
            8usize,
            concat!("Alignment of ", stringify!(rcu_work))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rcu_work>())).work as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcu_work),
                "::",
                stringify!(work)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rcu_work>())).rcu as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(rcu_work),
                "::",
                stringify!(rcu)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rcu_work>())).wq as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(rcu_work),
                "::",
                stringify!(wq)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct rhash_head {
        pub next: *mut rhash_head,
    }
    #[test]
    fn bindgen_test_layout_rhash_head() {
        assert_eq!(
            ::core::mem::size_of::<rhash_head>(),
            8usize,
            concat!("Size of: ", stringify!(rhash_head))
        );
        assert_eq!(
            ::core::mem::align_of::<rhash_head>(),
            8usize,
            concat!("Alignment of ", stringify!(rhash_head))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rhash_head>())).next as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rhash_head),
                "::",
                stringify!(next)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bucket_table {
        _unused: [u8; 0],
    }
    #[doc = " struct rhashtable_compare_arg - Key for the function rhashtable_compare"]
    #[doc = " @ht: Hash table"]
    #[doc = " @key: Key to compare against"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct rhashtable_compare_arg {
        pub ht: *mut rhashtable,
        pub key: *const ::cty::c_void,
    }
    #[test]
    fn bindgen_test_layout_rhashtable_compare_arg() {
        assert_eq!(
            ::core::mem::size_of::<rhashtable_compare_arg>(),
            16usize,
            concat!("Size of: ", stringify!(rhashtable_compare_arg))
        );
        assert_eq!(
            ::core::mem::align_of::<rhashtable_compare_arg>(),
            8usize,
            concat!("Alignment of ", stringify!(rhashtable_compare_arg))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rhashtable_compare_arg>())).ht as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rhashtable_compare_arg),
                "::",
                stringify!(ht)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rhashtable_compare_arg>())).key as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rhashtable_compare_arg),
                "::",
                stringify!(key)
            )
        );
    }
    pub type rht_hashfn_t = ::core::option::Option<
        unsafe extern "C" fn(
            data: *const ::cty::c_void,
            len: _cargo_bpf_u32,
            seed: _cargo_bpf_u32,
        ) -> _cargo_bpf_u32,
    >;
    pub type rht_obj_hashfn_t = ::core::option::Option<
        unsafe extern "C" fn(
            data: *const ::cty::c_void,
            len: _cargo_bpf_u32,
            seed: _cargo_bpf_u32,
        ) -> _cargo_bpf_u32,
    >;
    pub type rht_obj_cmpfn_t = ::core::option::Option<
        unsafe extern "C" fn(
            arg: *mut rhashtable_compare_arg,
            obj: *const ::cty::c_void,
        ) -> ::cty::c_int,
    >;
    #[doc = " struct rhashtable_params - Hash table construction parameters"]
    #[doc = " @nelem_hint: Hint on number of elements, should be 75% of desired size"]
    #[doc = " @key_len: Length of key"]
    #[doc = " @key_offset: Offset of key in struct to be hashed"]
    #[doc = " @head_offset: Offset of rhash_head in struct to be hashed"]
    #[doc = " @max_size: Maximum size while expanding"]
    #[doc = " @min_size: Minimum size while shrinking"]
    #[doc = " @automatic_shrinking: Enable automatic shrinking of tables"]
    #[doc = " @hashfn: Hash function (default: jhash2 if !(key_len % 4), or jhash)"]
    #[doc = " @obj_hashfn: Function to hash object"]
    #[doc = " @obj_cmpfn: Function to compare key with object"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct rhashtable_params {
        pub nelem_hint: _cargo_bpf_u16,
        pub key_len: _cargo_bpf_u16,
        pub key_offset: _cargo_bpf_u16,
        pub head_offset: _cargo_bpf_u16,
        pub max_size: ::cty::c_uint,
        pub min_size: _cargo_bpf_u16,
        pub automatic_shrinking: bool_,
        pub hashfn: rht_hashfn_t,
        pub obj_hashfn: rht_obj_hashfn_t,
        pub obj_cmpfn: rht_obj_cmpfn_t,
    }
    #[test]
    fn bindgen_test_layout_rhashtable_params() {
        assert_eq!(
            ::core::mem::size_of::<rhashtable_params>(),
            40usize,
            concat!("Size of: ", stringify!(rhashtable_params))
        );
        assert_eq!(
            ::core::mem::align_of::<rhashtable_params>(),
            8usize,
            concat!("Alignment of ", stringify!(rhashtable_params))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<rhashtable_params>())).nelem_hint as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rhashtable_params),
                "::",
                stringify!(nelem_hint)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rhashtable_params>())).key_len as *const _ as usize },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(rhashtable_params),
                "::",
                stringify!(key_len)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<rhashtable_params>())).key_offset as *const _ as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(rhashtable_params),
                "::",
                stringify!(key_offset)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<rhashtable_params>())).head_offset as *const _ as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(rhashtable_params),
                "::",
                stringify!(head_offset)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rhashtable_params>())).max_size as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rhashtable_params),
                "::",
                stringify!(max_size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rhashtable_params>())).min_size as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(rhashtable_params),
                "::",
                stringify!(min_size)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<rhashtable_params>())).automatic_shrinking as *const _
                    as usize
            },
            14usize,
            concat!(
                "Offset of field: ",
                stringify!(rhashtable_params),
                "::",
                stringify!(automatic_shrinking)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rhashtable_params>())).hashfn as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rhashtable_params),
                "::",
                stringify!(hashfn)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<rhashtable_params>())).obj_hashfn as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rhashtable_params),
                "::",
                stringify!(obj_hashfn)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<rhashtable_params>())).obj_cmpfn as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(rhashtable_params),
                "::",
                stringify!(obj_cmpfn)
            )
        );
    }
    #[doc = " struct rhashtable - Hash table handle"]
    #[doc = " @tbl: Bucket table"]
    #[doc = " @key_len: Key length for hashfn"]
    #[doc = " @max_elems: Maximum number of elements in table"]
    #[doc = " @p: Configuration parameters"]
    #[doc = " @rhlist: True if this is an rhltable"]
    #[doc = " @run_work: Deferred worker to expand/shrink asynchronously"]
    #[doc = " @mutex: Mutex to protect current/future table swapping"]
    #[doc = " @lock: Spin lock to protect walker list"]
    #[doc = " @nelems: Number of elements in table"]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct rhashtable {
        pub tbl: *mut bucket_table,
        pub key_len: ::cty::c_uint,
        pub max_elems: ::cty::c_uint,
        pub p: rhashtable_params,
        pub rhlist: bool_,
        pub run_work: work_struct,
        pub mutex: mutex,
        pub lock: spinlock_t,
        pub nelems: atomic_t,
    }
    #[test]
    fn bindgen_test_layout_rhashtable() {
        assert_eq!(
            ::core::mem::size_of::<rhashtable>(),
            136usize,
            concat!("Size of: ", stringify!(rhashtable))
        );
        assert_eq!(
            ::core::mem::align_of::<rhashtable>(),
            8usize,
            concat!("Alignment of ", stringify!(rhashtable))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rhashtable>())).tbl as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rhashtable),
                "::",
                stringify!(tbl)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rhashtable>())).key_len as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rhashtable),
                "::",
                stringify!(key_len)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rhashtable>())).max_elems as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(rhashtable),
                "::",
                stringify!(max_elems)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rhashtable>())).p as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rhashtable),
                "::",
                stringify!(p)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rhashtable>())).rhlist as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(rhashtable),
                "::",
                stringify!(rhlist)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rhashtable>())).run_work as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(rhashtable),
                "::",
                stringify!(run_work)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rhashtable>())).mutex as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(rhashtable),
                "::",
                stringify!(mutex)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rhashtable>())).lock as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(rhashtable),
                "::",
                stringify!(lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rhashtable>())).nelems as *const _ as usize },
            132usize,
            concat!(
                "Offset of field: ",
                stringify!(rhashtable),
                "::",
                stringify!(nelems)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct sem_undo_list {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct sysv_sem {
        pub undo_list: *mut sem_undo_list,
    }
    #[test]
    fn bindgen_test_layout_sysv_sem() {
        assert_eq!(
            ::core::mem::size_of::<sysv_sem>(),
            8usize,
            concat!("Size of: ", stringify!(sysv_sem))
        );
        assert_eq!(
            ::core::mem::align_of::<sysv_sem>(),
            8usize,
            concat!("Alignment of ", stringify!(sysv_sem))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sysv_sem>())).undo_list as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sysv_sem),
                "::",
                stringify!(undo_list)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct sysv_shm {
        pub shm_clist: list_head,
    }
    #[test]
    fn bindgen_test_layout_sysv_shm() {
        assert_eq!(
            ::core::mem::size_of::<sysv_shm>(),
            16usize,
            concat!("Size of: ", stringify!(sysv_shm))
        );
        assert_eq!(
            ::core::mem::align_of::<sysv_shm>(),
            8usize,
            concat!("Alignment of ", stringify!(sysv_shm))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sysv_shm>())).shm_clist as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sysv_shm),
                "::",
                stringify!(shm_clist)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct plist_node {
        pub prio: ::cty::c_int,
        pub prio_list: list_head,
        pub node_list: list_head,
    }
    #[test]
    fn bindgen_test_layout_plist_node() {
        assert_eq!(
            ::core::mem::size_of::<plist_node>(),
            40usize,
            concat!("Size of: ", stringify!(plist_node))
        );
        assert_eq!(
            ::core::mem::align_of::<plist_node>(),
            8usize,
            concat!("Alignment of ", stringify!(plist_node))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<plist_node>())).prio as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(plist_node),
                "::",
                stringify!(prio)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<plist_node>())).prio_list as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(plist_node),
                "::",
                stringify!(prio_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<plist_node>())).node_list as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(plist_node),
                "::",
                stringify!(node_list)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct rb_node {
        pub __rb_parent_color: ::cty::c_ulong,
        pub rb_right: *mut rb_node,
        pub rb_left: *mut rb_node,
    }
    #[test]
    fn bindgen_test_layout_rb_node() {
        assert_eq!(
            ::core::mem::size_of::<rb_node>(),
            24usize,
            concat!("Size of: ", stringify!(rb_node))
        );
        assert_eq!(
            ::core::mem::align_of::<rb_node>(),
            8usize,
            concat!("Alignment of ", stringify!(rb_node))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rb_node>())).__rb_parent_color as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_node),
                "::",
                stringify!(__rb_parent_color)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rb_node>())).rb_right as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_node),
                "::",
                stringify!(rb_right)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rb_node>())).rb_left as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_node),
                "::",
                stringify!(rb_left)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct rb_root {
        pub rb_node: *mut rb_node,
    }
    #[test]
    fn bindgen_test_layout_rb_root() {
        assert_eq!(
            ::core::mem::size_of::<rb_root>(),
            8usize,
            concat!("Size of: ", stringify!(rb_root))
        );
        assert_eq!(
            ::core::mem::align_of::<rb_root>(),
            8usize,
            concat!("Alignment of ", stringify!(rb_root))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rb_root>())).rb_node as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_root),
                "::",
                stringify!(rb_node)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct rb_root_cached {
        pub rb_root: rb_root,
        pub rb_leftmost: *mut rb_node,
    }
    #[test]
    fn bindgen_test_layout_rb_root_cached() {
        assert_eq!(
            ::core::mem::size_of::<rb_root_cached>(),
            16usize,
            concat!("Size of: ", stringify!(rb_root_cached))
        );
        assert_eq!(
            ::core::mem::align_of::<rb_root_cached>(),
            8usize,
            concat!("Alignment of ", stringify!(rb_root_cached))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rb_root_cached>())).rb_root as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_root_cached),
                "::",
                stringify!(rb_root)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rb_root_cached>())).rb_leftmost as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_root_cached),
                "::",
                stringify!(rb_leftmost)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct seqcount {
        pub sequence: ::cty::c_uint,
    }
    #[test]
    fn bindgen_test_layout_seqcount() {
        assert_eq!(
            ::core::mem::size_of::<seqcount>(),
            4usize,
            concat!("Size of: ", stringify!(seqcount))
        );
        assert_eq!(
            ::core::mem::align_of::<seqcount>(),
            4usize,
            concat!("Alignment of ", stringify!(seqcount))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<seqcount>())).sequence as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(seqcount),
                "::",
                stringify!(sequence)
            )
        );
    }
    pub type seqcount_t = seqcount;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct seqcount_raw_spinlock {
        pub seqcount: seqcount_t,
    }
    #[test]
    fn bindgen_test_layout_seqcount_raw_spinlock() {
        assert_eq!(
            ::core::mem::size_of::<seqcount_raw_spinlock>(),
            4usize,
            concat!("Size of: ", stringify!(seqcount_raw_spinlock))
        );
        assert_eq!(
            ::core::mem::align_of::<seqcount_raw_spinlock>(),
            4usize,
            concat!("Alignment of ", stringify!(seqcount_raw_spinlock))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<seqcount_raw_spinlock>())).seqcount as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(seqcount_raw_spinlock),
                "::",
                stringify!(seqcount)
            )
        );
    }
    pub type seqcount_raw_spinlock_t = seqcount_raw_spinlock;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct seqcount_spinlock {
        pub seqcount: seqcount_t,
    }
    #[test]
    fn bindgen_test_layout_seqcount_spinlock() {
        assert_eq!(
            ::core::mem::size_of::<seqcount_spinlock>(),
            4usize,
            concat!("Size of: ", stringify!(seqcount_spinlock))
        );
        assert_eq!(
            ::core::mem::align_of::<seqcount_spinlock>(),
            4usize,
            concat!("Alignment of ", stringify!(seqcount_spinlock))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<seqcount_spinlock>())).seqcount as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(seqcount_spinlock),
                "::",
                stringify!(seqcount)
            )
        );
    }
    pub type seqcount_spinlock_t = seqcount_spinlock;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct seqlock_t {
        pub seqcount: seqcount_spinlock_t,
        pub lock: spinlock_t,
    }
    #[test]
    fn bindgen_test_layout_seqlock_t() {
        assert_eq!(
            ::core::mem::size_of::<seqlock_t>(),
            8usize,
            concat!("Size of: ", stringify!(seqlock_t))
        );
        assert_eq!(
            ::core::mem::align_of::<seqlock_t>(),
            4usize,
            concat!("Alignment of ", stringify!(seqlock_t))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<seqlock_t>())).seqcount as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(seqlock_t),
                "::",
                stringify!(seqcount)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<seqlock_t>())).lock as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(seqlock_t),
                "::",
                stringify!(lock)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct timerqueue_node {
        pub node: rb_node,
        pub expires: ktime_t,
    }
    #[test]
    fn bindgen_test_layout_timerqueue_node() {
        assert_eq!(
            ::core::mem::size_of::<timerqueue_node>(),
            32usize,
            concat!("Size of: ", stringify!(timerqueue_node))
        );
        assert_eq!(
            ::core::mem::align_of::<timerqueue_node>(),
            8usize,
            concat!("Alignment of ", stringify!(timerqueue_node))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<timerqueue_node>())).node as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(timerqueue_node),
                "::",
                stringify!(node)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<timerqueue_node>())).expires as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(timerqueue_node),
                "::",
                stringify!(expires)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct timerqueue_head {
        pub rb_root: rb_root_cached,
    }
    #[test]
    fn bindgen_test_layout_timerqueue_head() {
        assert_eq!(
            ::core::mem::size_of::<timerqueue_head>(),
            16usize,
            concat!("Size of: ", stringify!(timerqueue_head))
        );
        assert_eq!(
            ::core::mem::align_of::<timerqueue_head>(),
            8usize,
            concat!("Alignment of ", stringify!(timerqueue_head))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<timerqueue_head>())).rb_root as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(timerqueue_head),
                "::",
                stringify!(rb_root)
            )
        );
    }
    pub const hrtimer_restart_HRTIMER_NORESTART: hrtimer_restart = 0;
    pub const hrtimer_restart_HRTIMER_RESTART: hrtimer_restart = 1;
    pub type hrtimer_restart = i32;
    #[doc = " struct hrtimer - the basic hrtimer structure"]
    #[doc = " @node:\ttimerqueue node, which also manages node.expires,"]
    #[doc = "\t\tthe absolute expiry time in the hrtimers internal"]
    #[doc = "\t\trepresentation. The time is related to the clock on"]
    #[doc = "\t\twhich the timer is based. Is setup by adding"]
    #[doc = "\t\tslack to the _softexpires value. For non range timers"]
    #[doc = "\t\tidentical to _softexpires."]
    #[doc = " @_softexpires: the absolute earliest expiry time of the hrtimer."]
    #[doc = "\t\tThe time which was given as expiry time when the timer"]
    #[doc = "\t\twas armed."]
    #[doc = " @function:\ttimer expiry callback function"]
    #[doc = " @base:\tpointer to the timer base (per cpu and per clock)"]
    #[doc = " @state:\tstate information (See bit values above)"]
    #[doc = " @is_rel:\tSet if the timer was armed relative"]
    #[doc = " @is_soft:\tSet if hrtimer will be expired in soft interrupt context."]
    #[doc = " @is_hard:\tSet if hrtimer will be expired in hard interrupt context"]
    #[doc = "\t\teven on RT."]
    #[doc = ""]
    #[doc = " The hrtimer structure must be initialized by hrtimer_init()"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct hrtimer {
        pub node: timerqueue_node,
        pub _softexpires: ktime_t,
        pub function:
            ::core::option::Option<unsafe extern "C" fn(arg1: *mut hrtimer) -> hrtimer_restart>,
        pub base: *mut hrtimer_clock_base,
        pub state: _cargo_bpf_u8,
        pub is_rel: _cargo_bpf_u8,
        pub is_soft: _cargo_bpf_u8,
        pub is_hard: _cargo_bpf_u8,
    }
    #[test]
    fn bindgen_test_layout_hrtimer() {
        assert_eq!(
            ::core::mem::size_of::<hrtimer>(),
            64usize,
            concat!("Size of: ", stringify!(hrtimer))
        );
        assert_eq!(
            ::core::mem::align_of::<hrtimer>(),
            8usize,
            concat!("Alignment of ", stringify!(hrtimer))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<hrtimer>())).node as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(hrtimer),
                "::",
                stringify!(node)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<hrtimer>()))._softexpires as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(hrtimer),
                "::",
                stringify!(_softexpires)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<hrtimer>())).function as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(hrtimer),
                "::",
                stringify!(function)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<hrtimer>())).base as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(hrtimer),
                "::",
                stringify!(base)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<hrtimer>())).state as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(hrtimer),
                "::",
                stringify!(state)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<hrtimer>())).is_rel as *const _ as usize },
            57usize,
            concat!(
                "Offset of field: ",
                stringify!(hrtimer),
                "::",
                stringify!(is_rel)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<hrtimer>())).is_soft as *const _ as usize },
            58usize,
            concat!(
                "Offset of field: ",
                stringify!(hrtimer),
                "::",
                stringify!(is_soft)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<hrtimer>())).is_hard as *const _ as usize },
            59usize,
            concat!(
                "Offset of field: ",
                stringify!(hrtimer),
                "::",
                stringify!(is_hard)
            )
        );
    }
    #[doc = " struct hrtimer_clock_base - the timer base for a specific clock"]
    #[doc = " @cpu_base:\t\tper cpu clock base"]
    #[doc = " @index:\t\tclock type index for per_cpu support when moving a"]
    #[doc = "\t\t\ttimer to a base on another cpu."]
    #[doc = " @clockid:\t\tclock id for per_cpu support"]
    #[doc = " @seq:\t\tseqcount around __run_hrtimer"]
    #[doc = " @running:\t\tpointer to the currently running hrtimer"]
    #[doc = " @active:\t\tred black tree root node for the active timers"]
    #[doc = " @get_time:\t\tfunction to retrieve the current time of the clock"]
    #[doc = " @offset:\t\toffset of this clock to the monotonic base"]
    #[repr(C)]
    #[repr(align(64))]
    #[derive(Debug, Copy, Clone)]
    pub struct hrtimer_clock_base {
        pub cpu_base: *mut hrtimer_cpu_base,
        pub index: ::cty::c_uint,
        pub clockid: clockid_t,
        pub seq: seqcount_raw_spinlock_t,
        pub running: *mut hrtimer,
        pub active: timerqueue_head,
        pub get_time: ::core::option::Option<unsafe extern "C" fn() -> ktime_t>,
        pub offset: ktime_t,
    }
    #[test]
    fn bindgen_test_layout_hrtimer_clock_base() {
        assert_eq!(
            ::core::mem::size_of::<hrtimer_clock_base>(),
            64usize,
            concat!("Size of: ", stringify!(hrtimer_clock_base))
        );
        assert_eq!(
            ::core::mem::align_of::<hrtimer_clock_base>(),
            64usize,
            concat!("Alignment of ", stringify!(hrtimer_clock_base))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<hrtimer_clock_base>())).cpu_base as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(hrtimer_clock_base),
                "::",
                stringify!(cpu_base)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<hrtimer_clock_base>())).index as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(hrtimer_clock_base),
                "::",
                stringify!(index)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<hrtimer_clock_base>())).clockid as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(hrtimer_clock_base),
                "::",
                stringify!(clockid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<hrtimer_clock_base>())).seq as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(hrtimer_clock_base),
                "::",
                stringify!(seq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<hrtimer_clock_base>())).running as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(hrtimer_clock_base),
                "::",
                stringify!(running)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<hrtimer_clock_base>())).active as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(hrtimer_clock_base),
                "::",
                stringify!(active)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<hrtimer_clock_base>())).get_time as *const _ as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(hrtimer_clock_base),
                "::",
                stringify!(get_time)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<hrtimer_clock_base>())).offset as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(hrtimer_clock_base),
                "::",
                stringify!(offset)
            )
        );
    }
    #[doc = " struct hrtimer_cpu_base - the per cpu clock bases"]
    #[doc = " @lock:\t\tlock protecting the base and associated clock bases"]
    #[doc = "\t\t\tand timers"]
    #[doc = " @cpu:\t\tcpu number"]
    #[doc = " @active_bases:\tBitfield to mark bases with active timers"]
    #[doc = " @clock_was_set_seq:\tSequence counter of clock was set events"]
    #[doc = " @hres_active:\tState of high resolution mode"]
    #[doc = " @in_hrtirq:\t\thrtimer_interrupt() is currently executing"]
    #[doc = " @hang_detected:\tThe last hrtimer interrupt detected a hang"]
    #[doc = " @softirq_activated:\tdisplays, if the softirq is raised - update of softirq"]
    #[doc = "\t\t\trelated settings is not required then."]
    #[doc = " @nr_events:\t\tTotal number of hrtimer interrupt events"]
    #[doc = " @nr_retries:\t\tTotal number of hrtimer interrupt retries"]
    #[doc = " @nr_hangs:\t\tTotal number of hrtimer interrupt hangs"]
    #[doc = " @max_hang_time:\tMaximum time spent in hrtimer_interrupt"]
    #[doc = " @softirq_expiry_lock: Lock which is taken while softirq based hrtimer are"]
    #[doc = "\t\t\t expired"]
    #[doc = " @timer_waiters:\tA hrtimer_cancel() invocation waits for the timer"]
    #[doc = "\t\t\tcallback to finish."]
    #[doc = " @expires_next:\tabsolute time of the next event, is required for remote"]
    #[doc = "\t\t\thrtimer enqueue; it is the total first expiry time (hard"]
    #[doc = "\t\t\tand soft hrtimer are taken into account)"]
    #[doc = " @next_timer:\t\tPointer to the first expiring timer"]
    #[doc = " @softirq_expires_next: Time to check, if soft queues needs also to be expired"]
    #[doc = " @softirq_next_timer: Pointer to the first expiring softirq based timer"]
    #[doc = " @clock_base:\t\tarray of clock bases for this cpu"]
    #[doc = ""]
    #[doc = " Note: next_timer is just an optimization for __remove_hrtimer()."]
    #[doc = "\t Do not dereference the pointer because it is not reliable on"]
    #[doc = "\t cross cpu removals."]
    #[repr(C)]
    #[repr(align(64))]
    #[derive(Copy, Clone)]
    pub struct hrtimer_cpu_base {
        pub lock: raw_spinlock_t,
        pub cpu: ::cty::c_uint,
        pub active_bases: ::cty::c_uint,
        pub clock_was_set_seq: ::cty::c_uint,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
        pub nr_events: ::cty::c_uint,
        pub nr_retries: ::cty::c_ushort,
        pub nr_hangs: ::cty::c_ushort,
        pub max_hang_time: ::cty::c_uint,
        pub expires_next: ktime_t,
        pub next_timer: *mut hrtimer,
        pub softirq_expires_next: ktime_t,
        pub softirq_next_timer: *mut hrtimer,
        pub clock_base: [hrtimer_clock_base; 8usize],
    }
    #[test]
    fn bindgen_test_layout_hrtimer_cpu_base() {
        assert_eq!(
            ::core::mem::size_of::<hrtimer_cpu_base>(),
            576usize,
            concat!("Size of: ", stringify!(hrtimer_cpu_base))
        );
        assert_eq!(
            ::core::mem::align_of::<hrtimer_cpu_base>(),
            64usize,
            concat!("Alignment of ", stringify!(hrtimer_cpu_base))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<hrtimer_cpu_base>())).lock as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(hrtimer_cpu_base),
                "::",
                stringify!(lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<hrtimer_cpu_base>())).cpu as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(hrtimer_cpu_base),
                "::",
                stringify!(cpu)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<hrtimer_cpu_base>())).active_bases as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(hrtimer_cpu_base),
                "::",
                stringify!(active_bases)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<hrtimer_cpu_base>())).clock_was_set_seq as *const _ as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(hrtimer_cpu_base),
                "::",
                stringify!(clock_was_set_seq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<hrtimer_cpu_base>())).nr_events as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(hrtimer_cpu_base),
                "::",
                stringify!(nr_events)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<hrtimer_cpu_base>())).nr_retries as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(hrtimer_cpu_base),
                "::",
                stringify!(nr_retries)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<hrtimer_cpu_base>())).nr_hangs as *const _ as usize },
            26usize,
            concat!(
                "Offset of field: ",
                stringify!(hrtimer_cpu_base),
                "::",
                stringify!(nr_hangs)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<hrtimer_cpu_base>())).max_hang_time as *const _ as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(hrtimer_cpu_base),
                "::",
                stringify!(max_hang_time)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<hrtimer_cpu_base>())).expires_next as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(hrtimer_cpu_base),
                "::",
                stringify!(expires_next)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<hrtimer_cpu_base>())).next_timer as *const _ as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(hrtimer_cpu_base),
                "::",
                stringify!(next_timer)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<hrtimer_cpu_base>())).softirq_expires_next as *const _
                    as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(hrtimer_cpu_base),
                "::",
                stringify!(softirq_expires_next)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<hrtimer_cpu_base>())).softirq_next_timer as *const _
                    as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(hrtimer_cpu_base),
                "::",
                stringify!(softirq_next_timer)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<hrtimer_cpu_base>())).clock_base as *const _ as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(hrtimer_cpu_base),
                "::",
                stringify!(clock_base)
            )
        );
    }
    impl hrtimer_cpu_base {
        #[inline]
        pub fn hres_active(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_hres_active(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn in_hrtirq(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_in_hrtirq(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(1usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn hang_detected(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_hang_detected(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(2usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn softirq_activated(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_softirq_activated(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(3usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            hres_active: ::cty::c_uint,
            in_hrtirq: ::cty::c_uint,
            hang_detected: ::cty::c_uint,
            softirq_activated: ::cty::c_uint,
        ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 1u8, {
                let hres_active: u32 = unsafe { ::core::mem::transmute(hres_active) };
                hres_active as u64
            });
            __bindgen_bitfield_unit.set(1usize, 1u8, {
                let in_hrtirq: u32 = unsafe { ::core::mem::transmute(in_hrtirq) };
                in_hrtirq as u64
            });
            __bindgen_bitfield_unit.set(2usize, 1u8, {
                let hang_detected: u32 = unsafe { ::core::mem::transmute(hang_detected) };
                hang_detected as u64
            });
            __bindgen_bitfield_unit.set(3usize, 1u8, {
                let softirq_activated: u32 = unsafe { ::core::mem::transmute(softirq_activated) };
                softirq_activated as u64
            });
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct seccomp_filter {
        _unused: [u8; 0],
    }
    #[doc = " struct seccomp - the state of a seccomp'ed process"]
    #[doc = ""]
    #[doc = " @mode:  indicates one of the valid values above for controlled"]
    #[doc = "         system calls available to a process."]
    #[doc = " @filter_count: number of seccomp filters"]
    #[doc = " @filter: must always point to a valid seccomp-filter or NULL as it is"]
    #[doc = "          accessed without locking during system call entry."]
    #[doc = ""]
    #[doc = "          @filter must only be accessed from the context of current as there"]
    #[doc = "          is no read locking."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct seccomp {
        pub mode: ::cty::c_int,
        pub filter_count: atomic_t,
        pub filter: *mut seccomp_filter,
    }
    #[test]
    fn bindgen_test_layout_seccomp() {
        assert_eq!(
            ::core::mem::size_of::<seccomp>(),
            16usize,
            concat!("Size of: ", stringify!(seccomp))
        );
        assert_eq!(
            ::core::mem::align_of::<seccomp>(),
            8usize,
            concat!("Alignment of ", stringify!(seccomp))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<seccomp>())).mode as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(seccomp),
                "::",
                stringify!(mode)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<seccomp>())).filter_count as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(seccomp),
                "::",
                stringify!(filter_count)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<seccomp>())).filter as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(seccomp),
                "::",
                stringify!(filter)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nodemask_t {
        pub bits: [::cty::c_ulong; 16usize],
    }
    #[test]
    fn bindgen_test_layout_nodemask_t() {
        assert_eq!(
            ::core::mem::size_of::<nodemask_t>(),
            128usize,
            concat!("Size of: ", stringify!(nodemask_t))
        );
        assert_eq!(
            ::core::mem::align_of::<nodemask_t>(),
            8usize,
            concat!("Alignment of ", stringify!(nodemask_t))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<nodemask_t>())).bits as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(nodemask_t),
                "::",
                stringify!(bits)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct rlimit {
        pub rlim_cur: __kernel_ulong_t,
        pub rlim_max: __kernel_ulong_t,
    }
    #[test]
    fn bindgen_test_layout_rlimit() {
        assert_eq!(
            ::core::mem::size_of::<rlimit>(),
            16usize,
            concat!("Size of: ", stringify!(rlimit))
        );
        assert_eq!(
            ::core::mem::align_of::<rlimit>(),
            8usize,
            concat!("Alignment of ", stringify!(rlimit))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rlimit>())).rlim_cur as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rlimit),
                "::",
                stringify!(rlim_cur)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rlimit>())).rlim_max as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rlimit),
                "::",
                stringify!(rlim_max)
            )
        );
    }
    #[doc = " struct task_cputime - collected CPU time counts"]
    #[doc = " @stime:\t\ttime spent in kernel mode, in nanoseconds"]
    #[doc = " @utime:\t\ttime spent in user mode, in nanoseconds"]
    #[doc = " @sum_exec_runtime:\ttotal time spent on the CPU, in nanoseconds"]
    #[doc = ""]
    #[doc = " This structure groups together three kinds of CPU time that are tracked for"]
    #[doc = " threads and thread groups.  Most things considering CPU time want to group"]
    #[doc = " these counts together and treat all three of them in parallel."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct task_cputime {
        pub stime: _cargo_bpf_u64,
        pub utime: _cargo_bpf_u64,
        pub sum_exec_runtime: ::cty::c_ulonglong,
    }
    #[test]
    fn bindgen_test_layout_task_cputime() {
        assert_eq!(
            ::core::mem::size_of::<task_cputime>(),
            24usize,
            concat!("Size of: ", stringify!(task_cputime))
        );
        assert_eq!(
            ::core::mem::align_of::<task_cputime>(),
            8usize,
            concat!("Alignment of ", stringify!(task_cputime))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_cputime>())).stime as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(task_cputime),
                "::",
                stringify!(stime)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_cputime>())).utime as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(task_cputime),
                "::",
                stringify!(utime)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_cputime>())).sum_exec_runtime as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(task_cputime),
                "::",
                stringify!(sum_exec_runtime)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct sigset_t {
        pub sig: [::cty::c_ulong; 1usize],
    }
    #[test]
    fn bindgen_test_layout_sigset_t() {
        assert_eq!(
            ::core::mem::size_of::<sigset_t>(),
            8usize,
            concat!("Size of: ", stringify!(sigset_t))
        );
        assert_eq!(
            ::core::mem::align_of::<sigset_t>(),
            8usize,
            concat!("Alignment of ", stringify!(sigset_t))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sigset_t>())).sig as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sigset_t),
                "::",
                stringify!(sig)
            )
        );
    }
    pub type __signalfn_t = ::core::option::Option<unsafe extern "C" fn(arg1: ::cty::c_int)>;
    pub type __sighandler_t = __signalfn_t;
    pub type __restorefn_t = ::core::option::Option<unsafe extern "C" fn()>;
    pub type __sigrestore_t = __restorefn_t;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union sigval {
        pub sival_int: ::cty::c_int,
        pub sival_ptr: *mut ::cty::c_void,
    }
    #[test]
    fn bindgen_test_layout_sigval() {
        assert_eq!(
            ::core::mem::size_of::<sigval>(),
            8usize,
            concat!("Size of: ", stringify!(sigval))
        );
        assert_eq!(
            ::core::mem::align_of::<sigval>(),
            8usize,
            concat!("Alignment of ", stringify!(sigval))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sigval>())).sival_int as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sigval),
                "::",
                stringify!(sival_int)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sigval>())).sival_ptr as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sigval),
                "::",
                stringify!(sival_ptr)
            )
        );
    }
    pub type sigval_t = sigval;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union __sifields {
        pub _kill: __sifields__bindgen_ty_1,
        pub _timer: __sifields__bindgen_ty_2,
        pub _rt: __sifields__bindgen_ty_3,
        pub _sigchld: __sifields__bindgen_ty_4,
        pub _sigfault: __sifields__bindgen_ty_5,
        pub _sigpoll: __sifields__bindgen_ty_6,
        pub _sigsys: __sifields__bindgen_ty_7,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct __sifields__bindgen_ty_1 {
        pub _pid: __kernel_pid_t,
        pub _uid: __kernel_uid32_t,
    }
    #[test]
    fn bindgen_test_layout___sifields__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<__sifields__bindgen_ty_1>(),
            8usize,
            concat!("Size of: ", stringify!(__sifields__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<__sifields__bindgen_ty_1>(),
            4usize,
            concat!("Alignment of ", stringify!(__sifields__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__sifields__bindgen_ty_1>()))._pid as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sifields__bindgen_ty_1),
                "::",
                stringify!(_pid)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__sifields__bindgen_ty_1>()))._uid as *const _ as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__sifields__bindgen_ty_1),
                "::",
                stringify!(_uid)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct __sifields__bindgen_ty_2 {
        pub _tid: __kernel_timer_t,
        pub _overrun: ::cty::c_int,
        pub _sigval: sigval_t,
        pub _sys_private: ::cty::c_int,
    }
    #[test]
    fn bindgen_test_layout___sifields__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<__sifields__bindgen_ty_2>(),
            24usize,
            concat!("Size of: ", stringify!(__sifields__bindgen_ty_2))
        );
        assert_eq!(
            ::core::mem::align_of::<__sifields__bindgen_ty_2>(),
            8usize,
            concat!("Alignment of ", stringify!(__sifields__bindgen_ty_2))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__sifields__bindgen_ty_2>()))._tid as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sifields__bindgen_ty_2),
                "::",
                stringify!(_tid)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__sifields__bindgen_ty_2>()))._overrun as *const _ as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__sifields__bindgen_ty_2),
                "::",
                stringify!(_overrun)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__sifields__bindgen_ty_2>()))._sigval as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__sifields__bindgen_ty_2),
                "::",
                stringify!(_sigval)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__sifields__bindgen_ty_2>()))._sys_private as *const _
                    as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__sifields__bindgen_ty_2),
                "::",
                stringify!(_sys_private)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct __sifields__bindgen_ty_3 {
        pub _pid: __kernel_pid_t,
        pub _uid: __kernel_uid32_t,
        pub _sigval: sigval_t,
    }
    #[test]
    fn bindgen_test_layout___sifields__bindgen_ty_3() {
        assert_eq!(
            ::core::mem::size_of::<__sifields__bindgen_ty_3>(),
            16usize,
            concat!("Size of: ", stringify!(__sifields__bindgen_ty_3))
        );
        assert_eq!(
            ::core::mem::align_of::<__sifields__bindgen_ty_3>(),
            8usize,
            concat!("Alignment of ", stringify!(__sifields__bindgen_ty_3))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__sifields__bindgen_ty_3>()))._pid as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sifields__bindgen_ty_3),
                "::",
                stringify!(_pid)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__sifields__bindgen_ty_3>()))._uid as *const _ as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__sifields__bindgen_ty_3),
                "::",
                stringify!(_uid)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__sifields__bindgen_ty_3>()))._sigval as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__sifields__bindgen_ty_3),
                "::",
                stringify!(_sigval)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct __sifields__bindgen_ty_4 {
        pub _pid: __kernel_pid_t,
        pub _uid: __kernel_uid32_t,
        pub _status: ::cty::c_int,
        pub _utime: __kernel_clock_t,
        pub _stime: __kernel_clock_t,
    }
    #[test]
    fn bindgen_test_layout___sifields__bindgen_ty_4() {
        assert_eq!(
            ::core::mem::size_of::<__sifields__bindgen_ty_4>(),
            32usize,
            concat!("Size of: ", stringify!(__sifields__bindgen_ty_4))
        );
        assert_eq!(
            ::core::mem::align_of::<__sifields__bindgen_ty_4>(),
            8usize,
            concat!("Alignment of ", stringify!(__sifields__bindgen_ty_4))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__sifields__bindgen_ty_4>()))._pid as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sifields__bindgen_ty_4),
                "::",
                stringify!(_pid)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__sifields__bindgen_ty_4>()))._uid as *const _ as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__sifields__bindgen_ty_4),
                "::",
                stringify!(_uid)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__sifields__bindgen_ty_4>()))._status as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__sifields__bindgen_ty_4),
                "::",
                stringify!(_status)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__sifields__bindgen_ty_4>()))._utime as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__sifields__bindgen_ty_4),
                "::",
                stringify!(_utime)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__sifields__bindgen_ty_4>()))._stime as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(__sifields__bindgen_ty_4),
                "::",
                stringify!(_stime)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct __sifields__bindgen_ty_5 {
        pub _addr: *mut ::cty::c_void,
        pub __bindgen_anon_1: __sifields__bindgen_ty_5__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union __sifields__bindgen_ty_5__bindgen_ty_1 {
        pub _trapno: ::cty::c_int,
        pub _addr_lsb: ::cty::c_short,
        pub _addr_bnd: __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
        pub _addr_pkey: __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2,
        pub _perf: __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
        pub _dummy_bnd: [::cty::c_char; 8usize],
        pub _lower: *mut ::cty::c_void,
        pub _upper: *mut ::cty::c_void,
    }
    #[test]
    fn bindgen_test_layout___sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>(),
            24usize,
            concat!(
                "Size of: ",
                stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>()))
                    ._dummy_bnd as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(_dummy_bnd)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>()))
                    ._lower as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(_lower)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>()))
                    ._upper as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(_upper)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2 {
        pub _dummy_pkey: [::cty::c_char; 8usize],
        pub _pkey: __u32,
    }
    #[test]
    fn bindgen_test_layout___sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2>(),
            12usize,
            concat!(
                "Size of: ",
                stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2>(),
            4usize,
            concat!(
                "Alignment of ",
                stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2>()))
                    ._dummy_pkey as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(_dummy_pkey)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2>()))
                    ._pkey as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(_pkey)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3 {
        pub _data: ::cty::c_ulong,
        pub _type: __u32,
        pub _flags: __u32,
    }
    #[test]
    fn bindgen_test_layout___sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3() {
        assert_eq!(
            ::core::mem::size_of::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3>(),
            16usize,
            concat!(
                "Size of: ",
                stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3>()))
                    ._data as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(_data)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3>()))
                    ._type as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(_type)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3>()))
                    ._flags as *const _ as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(_flags)
            )
        );
    }
    #[test]
    fn bindgen_test_layout___sifields__bindgen_ty_5__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<__sifields__bindgen_ty_5__bindgen_ty_1>(),
            24usize,
            concat!(
                "Size of: ",
                stringify!(__sifields__bindgen_ty_5__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<__sifields__bindgen_ty_5__bindgen_ty_1>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(__sifields__bindgen_ty_5__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1>()))._trapno
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sifields__bindgen_ty_5__bindgen_ty_1),
                "::",
                stringify!(_trapno)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1>()))._addr_lsb
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sifields__bindgen_ty_5__bindgen_ty_1),
                "::",
                stringify!(_addr_lsb)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1>()))._addr_bnd
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sifields__bindgen_ty_5__bindgen_ty_1),
                "::",
                stringify!(_addr_bnd)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1>()))._addr_pkey
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sifields__bindgen_ty_5__bindgen_ty_1),
                "::",
                stringify!(_addr_pkey)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1>()))._perf
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sifields__bindgen_ty_5__bindgen_ty_1),
                "::",
                stringify!(_perf)
            )
        );
    }
    #[test]
    fn bindgen_test_layout___sifields__bindgen_ty_5() {
        assert_eq!(
            ::core::mem::size_of::<__sifields__bindgen_ty_5>(),
            32usize,
            concat!("Size of: ", stringify!(__sifields__bindgen_ty_5))
        );
        assert_eq!(
            ::core::mem::align_of::<__sifields__bindgen_ty_5>(),
            8usize,
            concat!("Alignment of ", stringify!(__sifields__bindgen_ty_5))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__sifields__bindgen_ty_5>()))._addr as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sifields__bindgen_ty_5),
                "::",
                stringify!(_addr)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct __sifields__bindgen_ty_6 {
        pub _band: ::cty::c_long,
        pub _fd: ::cty::c_int,
    }
    #[test]
    fn bindgen_test_layout___sifields__bindgen_ty_6() {
        assert_eq!(
            ::core::mem::size_of::<__sifields__bindgen_ty_6>(),
            16usize,
            concat!("Size of: ", stringify!(__sifields__bindgen_ty_6))
        );
        assert_eq!(
            ::core::mem::align_of::<__sifields__bindgen_ty_6>(),
            8usize,
            concat!("Alignment of ", stringify!(__sifields__bindgen_ty_6))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__sifields__bindgen_ty_6>()))._band as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sifields__bindgen_ty_6),
                "::",
                stringify!(_band)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__sifields__bindgen_ty_6>()))._fd as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__sifields__bindgen_ty_6),
                "::",
                stringify!(_fd)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct __sifields__bindgen_ty_7 {
        pub _call_addr: *mut ::cty::c_void,
        pub _syscall: ::cty::c_int,
        pub _arch: ::cty::c_uint,
    }
    #[test]
    fn bindgen_test_layout___sifields__bindgen_ty_7() {
        assert_eq!(
            ::core::mem::size_of::<__sifields__bindgen_ty_7>(),
            16usize,
            concat!("Size of: ", stringify!(__sifields__bindgen_ty_7))
        );
        assert_eq!(
            ::core::mem::align_of::<__sifields__bindgen_ty_7>(),
            8usize,
            concat!("Alignment of ", stringify!(__sifields__bindgen_ty_7))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__sifields__bindgen_ty_7>()))._call_addr as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sifields__bindgen_ty_7),
                "::",
                stringify!(_call_addr)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__sifields__bindgen_ty_7>()))._syscall as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__sifields__bindgen_ty_7),
                "::",
                stringify!(_syscall)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<__sifields__bindgen_ty_7>()))._arch as *const _ as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(__sifields__bindgen_ty_7),
                "::",
                stringify!(_arch)
            )
        );
    }
    #[test]
    fn bindgen_test_layout___sifields() {
        assert_eq!(
            ::core::mem::size_of::<__sifields>(),
            32usize,
            concat!("Size of: ", stringify!(__sifields))
        );
        assert_eq!(
            ::core::mem::align_of::<__sifields>(),
            8usize,
            concat!("Alignment of ", stringify!(__sifields))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__sifields>()))._kill as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sifields),
                "::",
                stringify!(_kill)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__sifields>()))._timer as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sifields),
                "::",
                stringify!(_timer)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__sifields>()))._rt as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sifields),
                "::",
                stringify!(_rt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__sifields>()))._sigchld as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sifields),
                "::",
                stringify!(_sigchld)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__sifields>()))._sigfault as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sifields),
                "::",
                stringify!(_sigfault)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__sifields>()))._sigpoll as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sifields),
                "::",
                stringify!(_sigpoll)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<__sifields>()))._sigsys as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sifields),
                "::",
                stringify!(_sigsys)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct kernel_siginfo {
        pub __bindgen_anon_1: kernel_siginfo__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct kernel_siginfo__bindgen_ty_1 {
        pub si_signo: ::cty::c_int,
        pub si_errno: ::cty::c_int,
        pub si_code: ::cty::c_int,
        pub _sifields: __sifields,
    }
    #[test]
    fn bindgen_test_layout_kernel_siginfo__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<kernel_siginfo__bindgen_ty_1>(),
            48usize,
            concat!("Size of: ", stringify!(kernel_siginfo__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<kernel_siginfo__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(kernel_siginfo__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<kernel_siginfo__bindgen_ty_1>())).si_signo as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(kernel_siginfo__bindgen_ty_1),
                "::",
                stringify!(si_signo)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<kernel_siginfo__bindgen_ty_1>())).si_errno as *const _
                    as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(kernel_siginfo__bindgen_ty_1),
                "::",
                stringify!(si_errno)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<kernel_siginfo__bindgen_ty_1>())).si_code as *const _
                    as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(kernel_siginfo__bindgen_ty_1),
                "::",
                stringify!(si_code)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<kernel_siginfo__bindgen_ty_1>()))._sifields as *const _
                    as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(kernel_siginfo__bindgen_ty_1),
                "::",
                stringify!(_sifields)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_kernel_siginfo() {
        assert_eq!(
            ::core::mem::size_of::<kernel_siginfo>(),
            48usize,
            concat!("Size of: ", stringify!(kernel_siginfo))
        );
        assert_eq!(
            ::core::mem::align_of::<kernel_siginfo>(),
            8usize,
            concat!("Alignment of ", stringify!(kernel_siginfo))
        );
    }
    pub type kernel_siginfo_t = kernel_siginfo;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct sigpending {
        pub list: list_head,
        pub signal: sigset_t,
    }
    #[test]
    fn bindgen_test_layout_sigpending() {
        assert_eq!(
            ::core::mem::size_of::<sigpending>(),
            24usize,
            concat!("Size of: ", stringify!(sigpending))
        );
        assert_eq!(
            ::core::mem::align_of::<sigpending>(),
            8usize,
            concat!("Alignment of ", stringify!(sigpending))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sigpending>())).list as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sigpending),
                "::",
                stringify!(list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sigpending>())).signal as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(sigpending),
                "::",
                stringify!(signal)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct sigaction {
        pub sa_handler: __sighandler_t,
        pub sa_flags: ::cty::c_ulong,
        pub sa_restorer: __sigrestore_t,
        pub sa_mask: sigset_t,
    }
    #[test]
    fn bindgen_test_layout_sigaction() {
        assert_eq!(
            ::core::mem::size_of::<sigaction>(),
            32usize,
            concat!("Size of: ", stringify!(sigaction))
        );
        assert_eq!(
            ::core::mem::align_of::<sigaction>(),
            8usize,
            concat!("Alignment of ", stringify!(sigaction))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sigaction>())).sa_handler as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sigaction),
                "::",
                stringify!(sa_handler)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sigaction>())).sa_flags as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sigaction),
                "::",
                stringify!(sa_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sigaction>())).sa_restorer as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(sigaction),
                "::",
                stringify!(sa_restorer)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sigaction>())).sa_mask as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(sigaction),
                "::",
                stringify!(sa_mask)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct k_sigaction {
        pub sa: sigaction,
    }
    #[test]
    fn bindgen_test_layout_k_sigaction() {
        assert_eq!(
            ::core::mem::size_of::<k_sigaction>(),
            32usize,
            concat!("Size of: ", stringify!(k_sigaction))
        );
        assert_eq!(
            ::core::mem::align_of::<k_sigaction>(),
            8usize,
            concat!("Alignment of ", stringify!(k_sigaction))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<k_sigaction>())).sa as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(k_sigaction),
                "::",
                stringify!(sa)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct syscall_user_dispatch {
        pub selector: *mut ::cty::c_char,
        pub offset: ::cty::c_ulong,
        pub len: ::cty::c_ulong,
        pub on_dispatch: bool_,
    }
    #[test]
    fn bindgen_test_layout_syscall_user_dispatch() {
        assert_eq!(
            ::core::mem::size_of::<syscall_user_dispatch>(),
            32usize,
            concat!("Size of: ", stringify!(syscall_user_dispatch))
        );
        assert_eq!(
            ::core::mem::align_of::<syscall_user_dispatch>(),
            8usize,
            concat!("Alignment of ", stringify!(syscall_user_dispatch))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<syscall_user_dispatch>())).selector as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(syscall_user_dispatch),
                "::",
                stringify!(selector)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<syscall_user_dispatch>())).offset as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(syscall_user_dispatch),
                "::",
                stringify!(offset)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<syscall_user_dispatch>())).len as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(syscall_user_dispatch),
                "::",
                stringify!(len)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<syscall_user_dispatch>())).on_dispatch as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(syscall_user_dispatch),
                "::",
                stringify!(on_dispatch)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct arch_tlbflush_unmap_batch {
        pub cpumask: cpumask,
    }
    #[test]
    fn bindgen_test_layout_arch_tlbflush_unmap_batch() {
        assert_eq!(
            ::core::mem::size_of::<arch_tlbflush_unmap_batch>(),
            1024usize,
            concat!("Size of: ", stringify!(arch_tlbflush_unmap_batch))
        );
        assert_eq!(
            ::core::mem::align_of::<arch_tlbflush_unmap_batch>(),
            8usize,
            concat!("Alignment of ", stringify!(arch_tlbflush_unmap_batch))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<arch_tlbflush_unmap_batch>())).cpumask as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(arch_tlbflush_unmap_batch),
                "::",
                stringify!(cpumask)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct page_frag {
        pub page: *mut page,
        pub offset: __u32,
        pub size: __u32,
    }
    #[test]
    fn bindgen_test_layout_page_frag() {
        assert_eq!(
            ::core::mem::size_of::<page_frag>(),
            16usize,
            concat!("Size of: ", stringify!(page_frag))
        );
        assert_eq!(
            ::core::mem::align_of::<page_frag>(),
            8usize,
            concat!("Alignment of ", stringify!(page_frag))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<page_frag>())).page as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(page_frag),
                "::",
                stringify!(page)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<page_frag>())).offset as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(page_frag),
                "::",
                stringify!(offset)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<page_frag>())).size as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(page_frag),
                "::",
                stringify!(size)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct tlbflush_unmap_batch {
        pub arch: arch_tlbflush_unmap_batch,
        pub flush_required: bool_,
        pub writable: bool_,
    }
    #[test]
    fn bindgen_test_layout_tlbflush_unmap_batch() {
        assert_eq!(
            ::core::mem::size_of::<tlbflush_unmap_batch>(),
            1032usize,
            concat!("Size of: ", stringify!(tlbflush_unmap_batch))
        );
        assert_eq!(
            ::core::mem::align_of::<tlbflush_unmap_batch>(),
            8usize,
            concat!("Alignment of ", stringify!(tlbflush_unmap_batch))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tlbflush_unmap_batch>())).arch as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(tlbflush_unmap_batch),
                "::",
                stringify!(arch)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<tlbflush_unmap_batch>())).flush_required as *const _
                    as usize
            },
            1024usize,
            concat!(
                "Offset of field: ",
                stringify!(tlbflush_unmap_batch),
                "::",
                stringify!(flush_required)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<tlbflush_unmap_batch>())).writable as *const _ as usize
            },
            1025usize,
            concat!(
                "Offset of field: ",
                stringify!(tlbflush_unmap_batch),
                "::",
                stringify!(writable)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct task_io_accounting {
        pub rchar: _cargo_bpf_u64,
        pub wchar: _cargo_bpf_u64,
        pub syscr: _cargo_bpf_u64,
        pub syscw: _cargo_bpf_u64,
        pub read_bytes: _cargo_bpf_u64,
        pub write_bytes: _cargo_bpf_u64,
        pub cancelled_write_bytes: _cargo_bpf_u64,
    }
    #[test]
    fn bindgen_test_layout_task_io_accounting() {
        assert_eq!(
            ::core::mem::size_of::<task_io_accounting>(),
            56usize,
            concat!("Size of: ", stringify!(task_io_accounting))
        );
        assert_eq!(
            ::core::mem::align_of::<task_io_accounting>(),
            8usize,
            concat!("Alignment of ", stringify!(task_io_accounting))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_io_accounting>())).rchar as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(task_io_accounting),
                "::",
                stringify!(rchar)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_io_accounting>())).wchar as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(task_io_accounting),
                "::",
                stringify!(wchar)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_io_accounting>())).syscr as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(task_io_accounting),
                "::",
                stringify!(syscr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_io_accounting>())).syscw as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(task_io_accounting),
                "::",
                stringify!(syscw)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_io_accounting>())).read_bytes as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(task_io_accounting),
                "::",
                stringify!(read_bytes)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_io_accounting>())).write_bytes as *const _ as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(task_io_accounting),
                "::",
                stringify!(write_bytes)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_io_accounting>())).cancelled_write_bytes as *const _
                    as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(task_io_accounting),
                "::",
                stringify!(cancelled_write_bytes)
            )
        );
    }
    #[doc = " posix_cputimer_base - Container per posix CPU clock"]
    #[doc = " @nextevt:\t\tEarliest-expiration cache"]
    #[doc = " @tqhead:\t\ttimerqueue head for cpu_timers"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct posix_cputimer_base {
        pub nextevt: _cargo_bpf_u64,
        pub tqhead: timerqueue_head,
    }
    #[test]
    fn bindgen_test_layout_posix_cputimer_base() {
        assert_eq!(
            ::core::mem::size_of::<posix_cputimer_base>(),
            24usize,
            concat!("Size of: ", stringify!(posix_cputimer_base))
        );
        assert_eq!(
            ::core::mem::align_of::<posix_cputimer_base>(),
            8usize,
            concat!("Alignment of ", stringify!(posix_cputimer_base))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<posix_cputimer_base>())).nextevt as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(posix_cputimer_base),
                "::",
                stringify!(nextevt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<posix_cputimer_base>())).tqhead as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(posix_cputimer_base),
                "::",
                stringify!(tqhead)
            )
        );
    }
    #[doc = " posix_cputimers - Container for posix CPU timer related data"]
    #[doc = " @bases:\t\tBase container for posix CPU clocks"]
    #[doc = " @timers_active:\tTimers are queued."]
    #[doc = " @expiry_active:\tTimer expiry is active. Used for"]
    #[doc = "\t\t\tprocess wide timers to avoid multiple"]
    #[doc = "\t\t\ttask trying to handle expiry concurrently"]
    #[doc = ""]
    #[doc = " Used in task_struct and signal_struct"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct posix_cputimers {
        pub bases: [posix_cputimer_base; 3usize],
        pub timers_active: ::cty::c_uint,
        pub expiry_active: ::cty::c_uint,
    }
    #[test]
    fn bindgen_test_layout_posix_cputimers() {
        assert_eq!(
            ::core::mem::size_of::<posix_cputimers>(),
            80usize,
            concat!("Size of: ", stringify!(posix_cputimers))
        );
        assert_eq!(
            ::core::mem::align_of::<posix_cputimers>(),
            8usize,
            concat!("Alignment of ", stringify!(posix_cputimers))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<posix_cputimers>())).bases as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(posix_cputimers),
                "::",
                stringify!(bases)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<posix_cputimers>())).timers_active as *const _ as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(posix_cputimers),
                "::",
                stringify!(timers_active)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<posix_cputimers>())).expiry_active as *const _ as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(posix_cputimers),
                "::",
                stringify!(expiry_active)
            )
        );
    }
    #[doc = " posix_cputimers_work - Container for task work based posix CPU timer expiry"]
    #[doc = " @work:\tThe task work to be scheduled"]
    #[doc = " @mutex:\tMutex held around expiry in context of this task work"]
    #[doc = " @scheduled:  @work has been scheduled already, no further processing"]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct posix_cputimers_work {
        pub work: callback_head,
        pub mutex: mutex,
        pub scheduled: ::cty::c_uint,
    }
    #[test]
    fn bindgen_test_layout_posix_cputimers_work() {
        assert_eq!(
            ::core::mem::size_of::<posix_cputimers_work>(),
            56usize,
            concat!("Size of: ", stringify!(posix_cputimers_work))
        );
        assert_eq!(
            ::core::mem::align_of::<posix_cputimers_work>(),
            8usize,
            concat!("Alignment of ", stringify!(posix_cputimers_work))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<posix_cputimers_work>())).work as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(posix_cputimers_work),
                "::",
                stringify!(work)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<posix_cputimers_work>())).mutex as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(posix_cputimers_work),
                "::",
                stringify!(mutex)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<posix_cputimers_work>())).scheduled as *const _ as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(posix_cputimers_work),
                "::",
                stringify!(scheduled)
            )
        );
    }
    #[repr(C)]
    #[repr(align(32))]
    #[derive(Debug)]
    pub struct rseq {
        pub cpu_id_start: __u32,
        pub cpu_id: __u32,
        pub rseq_cs: __u64,
        pub flags: __u32,
        pub node_id: __u32,
        pub mm_cid: __u32,
        pub end: __IncompleteArrayField<::cty::c_char>,
    }
    #[test]
    fn bindgen_test_layout_rseq() {
        assert_eq!(
            ::core::mem::size_of::<rseq>(),
            32usize,
            concat!("Size of: ", stringify!(rseq))
        );
        assert_eq!(
            ::core::mem::align_of::<rseq>(),
            32usize,
            concat!("Alignment of ", stringify!(rseq))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rseq>())).cpu_id_start as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rseq),
                "::",
                stringify!(cpu_id_start)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rseq>())).cpu_id as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(rseq),
                "::",
                stringify!(cpu_id)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rseq>())).rseq_cs as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rseq),
                "::",
                stringify!(rseq_cs)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rseq>())).flags as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rseq),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rseq>())).node_id as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(rseq),
                "::",
                stringify!(node_id)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rseq>())).mm_cid as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rseq),
                "::",
                stringify!(mm_cid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rseq>())).end as *const _ as usize },
            28usize,
            concat!("Offset of field: ", stringify!(rseq), "::", stringify!(end))
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct da_monitor {
        pub monitoring: bool_,
        pub curr_state: ::cty::c_uint,
    }
    #[test]
    fn bindgen_test_layout_da_monitor() {
        assert_eq!(
            ::core::mem::size_of::<da_monitor>(),
            8usize,
            concat!("Size of: ", stringify!(da_monitor))
        );
        assert_eq!(
            ::core::mem::align_of::<da_monitor>(),
            4usize,
            concat!("Alignment of ", stringify!(da_monitor))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<da_monitor>())).monitoring as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(da_monitor),
                "::",
                stringify!(monitoring)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<da_monitor>())).curr_state as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(da_monitor),
                "::",
                stringify!(curr_state)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union rv_task_monitor {
        pub da_mon: da_monitor,
    }
    #[test]
    fn bindgen_test_layout_rv_task_monitor() {
        assert_eq!(
            ::core::mem::size_of::<rv_task_monitor>(),
            8usize,
            concat!("Size of: ", stringify!(rv_task_monitor))
        );
        assert_eq!(
            ::core::mem::align_of::<rv_task_monitor>(),
            4usize,
            concat!("Alignment of ", stringify!(rv_task_monitor))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rv_task_monitor>())).da_mon as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rv_task_monitor),
                "::",
                stringify!(da_mon)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct audit_context {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct blk_plug {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_local_storage {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_run_ctx {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct capture_control {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cfs_rq {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct fs_struct {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct futex_pi_state {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct io_uring_task {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct mempolicy {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nameidata {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct perf_event_context {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct pipe_inode_info {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct rcu_node {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct reclaim_state {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct robust_list_head {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct task_delay_info {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct task_group {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct user_event_mm {
        _unused: [u8; 0],
    }
    #[doc = " struct prev_cputime - snapshot of system and user cputime"]
    #[doc = " @utime: time spent in user mode"]
    #[doc = " @stime: time spent in system mode"]
    #[doc = " @lock: protects the above two fields"]
    #[doc = ""]
    #[doc = " Stores previous user/system time values such that we can guarantee"]
    #[doc = " monotonicity."]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct prev_cputime {
        pub utime: _cargo_bpf_u64,
        pub stime: _cargo_bpf_u64,
        pub lock: raw_spinlock_t,
    }
    #[test]
    fn bindgen_test_layout_prev_cputime() {
        assert_eq!(
            ::core::mem::size_of::<prev_cputime>(),
            24usize,
            concat!("Size of: ", stringify!(prev_cputime))
        );
        assert_eq!(
            ::core::mem::align_of::<prev_cputime>(),
            8usize,
            concat!("Alignment of ", stringify!(prev_cputime))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<prev_cputime>())).utime as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(prev_cputime),
                "::",
                stringify!(utime)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<prev_cputime>())).stime as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(prev_cputime),
                "::",
                stringify!(stime)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<prev_cputime>())).lock as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(prev_cputime),
                "::",
                stringify!(lock)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct sched_info {
        pub pcount: ::cty::c_ulong,
        pub run_delay: ::cty::c_ulonglong,
        pub last_arrival: ::cty::c_ulonglong,
        pub last_queued: ::cty::c_ulonglong,
    }
    #[test]
    fn bindgen_test_layout_sched_info() {
        assert_eq!(
            ::core::mem::size_of::<sched_info>(),
            32usize,
            concat!("Size of: ", stringify!(sched_info))
        );
        assert_eq!(
            ::core::mem::align_of::<sched_info>(),
            8usize,
            concat!("Alignment of ", stringify!(sched_info))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sched_info>())).pcount as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_info),
                "::",
                stringify!(pcount)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sched_info>())).run_delay as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_info),
                "::",
                stringify!(run_delay)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sched_info>())).last_arrival as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_info),
                "::",
                stringify!(last_arrival)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sched_info>())).last_queued as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_info),
                "::",
                stringify!(last_queued)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct load_weight {
        pub weight: ::cty::c_ulong,
        pub inv_weight: _cargo_bpf_u32,
    }
    #[test]
    fn bindgen_test_layout_load_weight() {
        assert_eq!(
            ::core::mem::size_of::<load_weight>(),
            16usize,
            concat!("Size of: ", stringify!(load_weight))
        );
        assert_eq!(
            ::core::mem::align_of::<load_weight>(),
            8usize,
            concat!("Alignment of ", stringify!(load_weight))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<load_weight>())).weight as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(load_weight),
                "::",
                stringify!(weight)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<load_weight>())).inv_weight as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(load_weight),
                "::",
                stringify!(inv_weight)
            )
        );
    }
    #[doc = " struct util_est - Estimation utilization of FAIR tasks"]
    #[doc = " @enqueued: instantaneous estimated utilization of a task/cpu"]
    #[doc = " @ewma:     the Exponential Weighted Moving Average (EWMA)"]
    #[doc = "            utilization of a task"]
    #[doc = ""]
    #[doc = " Support data structure to track an Exponential Weighted Moving Average"]
    #[doc = " (EWMA) of a FAIR task's utilization. New samples are added to the moving"]
    #[doc = " average each time a task completes an activation. Sample's weight is chosen"]
    #[doc = " so that the EWMA will be relatively insensitive to transient changes to the"]
    #[doc = " task's workload."]
    #[doc = ""]
    #[doc = " The enqueued attribute has a slightly different meaning for tasks and cpus:"]
    #[doc = " - task:   the task's util_avg at last task dequeue time"]
    #[doc = " - cfs_rq: the sum of util_est.enqueued for each RUNNABLE task on that CPU"]
    #[doc = " Thus, the util_est.enqueued of a task represents the contribution on the"]
    #[doc = " estimated utilization of the CPU where that task is currently enqueued."]
    #[doc = ""]
    #[doc = " Only for tasks we track a moving average of the past instantaneous"]
    #[doc = " estimated utilization. This allows to absorb sporadic drops in utilization"]
    #[doc = " of an otherwise almost periodic task."]
    #[doc = ""]
    #[doc = " The UTIL_AVG_UNCHANGED flag is used to synchronize util_est with util_avg"]
    #[doc = " updates. When a task is dequeued, its util_est should not be updated if its"]
    #[doc = " util_avg has not been updated in the meantime."]
    #[doc = " This information is mapped into the MSB bit of util_est.enqueued at dequeue"]
    #[doc = " time. Since max value of util_est.enqueued for a task is 1024 (PELT util_avg"]
    #[doc = " for a task) it is safe to use MSB."]
    #[repr(C)]
    #[repr(align(8))]
    #[derive(Debug, Copy, Clone)]
    pub struct util_est {
        pub enqueued: ::cty::c_uint,
        pub ewma: ::cty::c_uint,
    }
    #[test]
    fn bindgen_test_layout_util_est() {
        assert_eq!(
            ::core::mem::size_of::<util_est>(),
            8usize,
            concat!("Size of: ", stringify!(util_est))
        );
        assert_eq!(
            ::core::mem::align_of::<util_est>(),
            8usize,
            concat!("Alignment of ", stringify!(util_est))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<util_est>())).enqueued as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(util_est),
                "::",
                stringify!(enqueued)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<util_est>())).ewma as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(util_est),
                "::",
                stringify!(ewma)
            )
        );
    }
    #[repr(C)]
    #[repr(align(64))]
    #[derive(Debug, Copy, Clone)]
    pub struct sched_avg {
        pub last_update_time: _cargo_bpf_u64,
        pub load_sum: _cargo_bpf_u64,
        pub runnable_sum: _cargo_bpf_u64,
        pub util_sum: _cargo_bpf_u32,
        pub period_contrib: _cargo_bpf_u32,
        pub load_avg: ::cty::c_ulong,
        pub runnable_avg: ::cty::c_ulong,
        pub util_avg: ::cty::c_ulong,
        pub util_est: util_est,
    }
    #[test]
    fn bindgen_test_layout_sched_avg() {
        assert_eq!(
            ::core::mem::size_of::<sched_avg>(),
            64usize,
            concat!("Size of: ", stringify!(sched_avg))
        );
        assert_eq!(
            ::core::mem::align_of::<sched_avg>(),
            64usize,
            concat!("Alignment of ", stringify!(sched_avg))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sched_avg>())).last_update_time as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_avg),
                "::",
                stringify!(last_update_time)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sched_avg>())).load_sum as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_avg),
                "::",
                stringify!(load_sum)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sched_avg>())).runnable_sum as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_avg),
                "::",
                stringify!(runnable_sum)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sched_avg>())).util_sum as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_avg),
                "::",
                stringify!(util_sum)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sched_avg>())).period_contrib as *const _ as usize },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_avg),
                "::",
                stringify!(period_contrib)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sched_avg>())).load_avg as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_avg),
                "::",
                stringify!(load_avg)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sched_avg>())).runnable_avg as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_avg),
                "::",
                stringify!(runnable_avg)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sched_avg>())).util_avg as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_avg),
                "::",
                stringify!(util_avg)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sched_avg>())).util_est as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_avg),
                "::",
                stringify!(util_est)
            )
        );
    }
    #[repr(C)]
    #[repr(align(64))]
    #[derive(Debug, Copy, Clone)]
    pub struct sched_statistics {
        pub wait_start: _cargo_bpf_u64,
        pub wait_max: _cargo_bpf_u64,
        pub wait_count: _cargo_bpf_u64,
        pub wait_sum: _cargo_bpf_u64,
        pub iowait_count: _cargo_bpf_u64,
        pub iowait_sum: _cargo_bpf_u64,
        pub sleep_start: _cargo_bpf_u64,
        pub sleep_max: _cargo_bpf_u64,
        pub sum_sleep_runtime: s64,
        pub block_start: _cargo_bpf_u64,
        pub block_max: _cargo_bpf_u64,
        pub sum_block_runtime: s64,
        pub exec_max: _cargo_bpf_u64,
        pub slice_max: _cargo_bpf_u64,
        pub nr_migrations_cold: _cargo_bpf_u64,
        pub nr_failed_migrations_affine: _cargo_bpf_u64,
        pub nr_failed_migrations_running: _cargo_bpf_u64,
        pub nr_failed_migrations_hot: _cargo_bpf_u64,
        pub nr_forced_migrations: _cargo_bpf_u64,
        pub nr_wakeups: _cargo_bpf_u64,
        pub nr_wakeups_sync: _cargo_bpf_u64,
        pub nr_wakeups_migrate: _cargo_bpf_u64,
        pub nr_wakeups_local: _cargo_bpf_u64,
        pub nr_wakeups_remote: _cargo_bpf_u64,
        pub nr_wakeups_affine: _cargo_bpf_u64,
        pub nr_wakeups_affine_attempts: _cargo_bpf_u64,
        pub nr_wakeups_passive: _cargo_bpf_u64,
        pub nr_wakeups_idle: _cargo_bpf_u64,
        pub core_forceidle_sum: _cargo_bpf_u64,
    }
    #[test]
    fn bindgen_test_layout_sched_statistics() {
        assert_eq!(
            ::core::mem::size_of::<sched_statistics>(),
            256usize,
            concat!("Size of: ", stringify!(sched_statistics))
        );
        assert_eq!(
            ::core::mem::align_of::<sched_statistics>(),
            64usize,
            concat!("Alignment of ", stringify!(sched_statistics))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sched_statistics>())).wait_start as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_statistics),
                "::",
                stringify!(wait_start)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sched_statistics>())).wait_max as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_statistics),
                "::",
                stringify!(wait_max)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sched_statistics>())).wait_count as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_statistics),
                "::",
                stringify!(wait_count)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sched_statistics>())).wait_sum as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_statistics),
                "::",
                stringify!(wait_sum)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sched_statistics>())).iowait_count as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_statistics),
                "::",
                stringify!(iowait_count)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sched_statistics>())).iowait_sum as *const _ as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_statistics),
                "::",
                stringify!(iowait_sum)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sched_statistics>())).sleep_start as *const _ as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_statistics),
                "::",
                stringify!(sleep_start)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sched_statistics>())).sleep_max as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_statistics),
                "::",
                stringify!(sleep_max)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sched_statistics>())).sum_sleep_runtime as *const _ as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_statistics),
                "::",
                stringify!(sum_sleep_runtime)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sched_statistics>())).block_start as *const _ as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_statistics),
                "::",
                stringify!(block_start)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sched_statistics>())).block_max as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_statistics),
                "::",
                stringify!(block_max)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sched_statistics>())).sum_block_runtime as *const _ as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_statistics),
                "::",
                stringify!(sum_block_runtime)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sched_statistics>())).exec_max as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_statistics),
                "::",
                stringify!(exec_max)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sched_statistics>())).slice_max as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_statistics),
                "::",
                stringify!(slice_max)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sched_statistics>())).nr_migrations_cold as *const _
                    as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_statistics),
                "::",
                stringify!(nr_migrations_cold)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sched_statistics>())).nr_failed_migrations_affine
                    as *const _ as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_statistics),
                "::",
                stringify!(nr_failed_migrations_affine)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sched_statistics>())).nr_failed_migrations_running
                    as *const _ as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_statistics),
                "::",
                stringify!(nr_failed_migrations_running)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sched_statistics>())).nr_failed_migrations_hot as *const _
                    as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_statistics),
                "::",
                stringify!(nr_failed_migrations_hot)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sched_statistics>())).nr_forced_migrations as *const _
                    as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_statistics),
                "::",
                stringify!(nr_forced_migrations)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sched_statistics>())).nr_wakeups as *const _ as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_statistics),
                "::",
                stringify!(nr_wakeups)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sched_statistics>())).nr_wakeups_sync as *const _ as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_statistics),
                "::",
                stringify!(nr_wakeups_sync)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sched_statistics>())).nr_wakeups_migrate as *const _
                    as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_statistics),
                "::",
                stringify!(nr_wakeups_migrate)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sched_statistics>())).nr_wakeups_local as *const _ as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_statistics),
                "::",
                stringify!(nr_wakeups_local)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sched_statistics>())).nr_wakeups_remote as *const _ as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_statistics),
                "::",
                stringify!(nr_wakeups_remote)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sched_statistics>())).nr_wakeups_affine as *const _ as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_statistics),
                "::",
                stringify!(nr_wakeups_affine)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sched_statistics>())).nr_wakeups_affine_attempts as *const _
                    as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_statistics),
                "::",
                stringify!(nr_wakeups_affine_attempts)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sched_statistics>())).nr_wakeups_passive as *const _
                    as usize
            },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_statistics),
                "::",
                stringify!(nr_wakeups_passive)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sched_statistics>())).nr_wakeups_idle as *const _ as usize
            },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_statistics),
                "::",
                stringify!(nr_wakeups_idle)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sched_statistics>())).core_forceidle_sum as *const _
                    as usize
            },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_statistics),
                "::",
                stringify!(core_forceidle_sum)
            )
        );
    }
    #[repr(C)]
    #[repr(align(64))]
    #[derive(Debug, Copy, Clone)]
    pub struct sched_entity {
        pub load: load_weight,
        pub run_node: rb_node,
        pub group_node: list_head,
        pub on_rq: ::cty::c_uint,
        pub exec_start: _cargo_bpf_u64,
        pub sum_exec_runtime: _cargo_bpf_u64,
        pub vruntime: _cargo_bpf_u64,
        pub prev_sum_exec_runtime: _cargo_bpf_u64,
        pub nr_migrations: _cargo_bpf_u64,
        pub depth: ::cty::c_int,
        pub parent: *mut sched_entity,
        pub cfs_rq: *mut cfs_rq,
        pub my_q: *mut cfs_rq,
        pub runnable_weight: ::cty::c_ulong,
        pub __bindgen_padding_0: [u64; 6usize],
        pub avg: sched_avg,
    }
    #[test]
    fn bindgen_test_layout_sched_entity() {
        assert_eq!(
            ::core::mem::size_of::<sched_entity>(),
            256usize,
            concat!("Size of: ", stringify!(sched_entity))
        );
        assert_eq!(
            ::core::mem::align_of::<sched_entity>(),
            64usize,
            concat!("Alignment of ", stringify!(sched_entity))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sched_entity>())).load as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_entity),
                "::",
                stringify!(load)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sched_entity>())).run_node as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_entity),
                "::",
                stringify!(run_node)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sched_entity>())).group_node as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_entity),
                "::",
                stringify!(group_node)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sched_entity>())).on_rq as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_entity),
                "::",
                stringify!(on_rq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sched_entity>())).exec_start as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_entity),
                "::",
                stringify!(exec_start)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sched_entity>())).sum_exec_runtime as *const _ as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_entity),
                "::",
                stringify!(sum_exec_runtime)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sched_entity>())).vruntime as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_entity),
                "::",
                stringify!(vruntime)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sched_entity>())).prev_sum_exec_runtime as *const _ as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_entity),
                "::",
                stringify!(prev_sum_exec_runtime)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sched_entity>())).nr_migrations as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_entity),
                "::",
                stringify!(nr_migrations)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sched_entity>())).depth as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_entity),
                "::",
                stringify!(depth)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sched_entity>())).parent as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_entity),
                "::",
                stringify!(parent)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sched_entity>())).cfs_rq as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_entity),
                "::",
                stringify!(cfs_rq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sched_entity>())).my_q as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_entity),
                "::",
                stringify!(my_q)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sched_entity>())).runnable_weight as *const _ as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_entity),
                "::",
                stringify!(runnable_weight)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sched_entity>())).avg as *const _ as usize },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_entity),
                "::",
                stringify!(avg)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct sched_rt_entity {
        pub run_list: list_head,
        pub timeout: ::cty::c_ulong,
        pub watchdog_stamp: ::cty::c_ulong,
        pub time_slice: ::cty::c_uint,
        pub on_rq: ::cty::c_ushort,
        pub on_list: ::cty::c_ushort,
        pub back: *mut sched_rt_entity,
    }
    #[test]
    fn bindgen_test_layout_sched_rt_entity() {
        assert_eq!(
            ::core::mem::size_of::<sched_rt_entity>(),
            48usize,
            concat!("Size of: ", stringify!(sched_rt_entity))
        );
        assert_eq!(
            ::core::mem::align_of::<sched_rt_entity>(),
            8usize,
            concat!("Alignment of ", stringify!(sched_rt_entity))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sched_rt_entity>())).run_list as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_rt_entity),
                "::",
                stringify!(run_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sched_rt_entity>())).timeout as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_rt_entity),
                "::",
                stringify!(timeout)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sched_rt_entity>())).watchdog_stamp as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_rt_entity),
                "::",
                stringify!(watchdog_stamp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sched_rt_entity>())).time_slice as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_rt_entity),
                "::",
                stringify!(time_slice)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sched_rt_entity>())).on_rq as *const _ as usize },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_rt_entity),
                "::",
                stringify!(on_rq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sched_rt_entity>())).on_list as *const _ as usize },
            38usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_rt_entity),
                "::",
                stringify!(on_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sched_rt_entity>())).back as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_rt_entity),
                "::",
                stringify!(back)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct sched_dl_entity {
        pub rb_node: rb_node,
        pub dl_runtime: _cargo_bpf_u64,
        pub dl_deadline: _cargo_bpf_u64,
        pub dl_period: _cargo_bpf_u64,
        pub dl_bw: _cargo_bpf_u64,
        pub dl_density: _cargo_bpf_u64,
        pub runtime: s64,
        pub deadline: _cargo_bpf_u64,
        pub flags: ::cty::c_uint,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
        pub dl_timer: hrtimer,
        pub inactive_timer: hrtimer,
        pub pi_se: *mut sched_dl_entity,
    }
    #[test]
    fn bindgen_test_layout_sched_dl_entity() {
        assert_eq!(
            ::core::mem::size_of::<sched_dl_entity>(),
            224usize,
            concat!("Size of: ", stringify!(sched_dl_entity))
        );
        assert_eq!(
            ::core::mem::align_of::<sched_dl_entity>(),
            8usize,
            concat!("Alignment of ", stringify!(sched_dl_entity))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sched_dl_entity>())).rb_node as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_dl_entity),
                "::",
                stringify!(rb_node)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sched_dl_entity>())).dl_runtime as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_dl_entity),
                "::",
                stringify!(dl_runtime)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sched_dl_entity>())).dl_deadline as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_dl_entity),
                "::",
                stringify!(dl_deadline)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sched_dl_entity>())).dl_period as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_dl_entity),
                "::",
                stringify!(dl_period)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sched_dl_entity>())).dl_bw as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_dl_entity),
                "::",
                stringify!(dl_bw)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sched_dl_entity>())).dl_density as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_dl_entity),
                "::",
                stringify!(dl_density)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sched_dl_entity>())).runtime as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_dl_entity),
                "::",
                stringify!(runtime)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sched_dl_entity>())).deadline as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_dl_entity),
                "::",
                stringify!(deadline)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sched_dl_entity>())).flags as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_dl_entity),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sched_dl_entity>())).dl_timer as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_dl_entity),
                "::",
                stringify!(dl_timer)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sched_dl_entity>())).inactive_timer as *const _ as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_dl_entity),
                "::",
                stringify!(inactive_timer)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sched_dl_entity>())).pi_se as *const _ as usize },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_dl_entity),
                "::",
                stringify!(pi_se)
            )
        );
    }
    impl sched_dl_entity {
        #[inline]
        pub fn dl_throttled(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_dl_throttled(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn dl_yielded(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_dl_yielded(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(1usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn dl_non_contending(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_dl_non_contending(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(2usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn dl_overrun(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_dl_overrun(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(3usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            dl_throttled: ::cty::c_uint,
            dl_yielded: ::cty::c_uint,
            dl_non_contending: ::cty::c_uint,
            dl_overrun: ::cty::c_uint,
        ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 1u8, {
                let dl_throttled: u32 = unsafe { ::core::mem::transmute(dl_throttled) };
                dl_throttled as u64
            });
            __bindgen_bitfield_unit.set(1usize, 1u8, {
                let dl_yielded: u32 = unsafe { ::core::mem::transmute(dl_yielded) };
                dl_yielded as u64
            });
            __bindgen_bitfield_unit.set(2usize, 1u8, {
                let dl_non_contending: u32 = unsafe { ::core::mem::transmute(dl_non_contending) };
                dl_non_contending as u64
            });
            __bindgen_bitfield_unit.set(3usize, 1u8, {
                let dl_overrun: u32 = unsafe { ::core::mem::transmute(dl_overrun) };
                dl_overrun as u64
            });
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[repr(align(4))]
    #[derive(Debug, Copy, Clone)]
    pub struct uclamp_se {
        pub _bitfield_align_1: [u16; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
        pub __bindgen_padding_0: u16,
    }
    #[test]
    fn bindgen_test_layout_uclamp_se() {
        assert_eq!(
            ::core::mem::size_of::<uclamp_se>(),
            4usize,
            concat!("Size of: ", stringify!(uclamp_se))
        );
        assert_eq!(
            ::core::mem::align_of::<uclamp_se>(),
            4usize,
            concat!("Alignment of ", stringify!(uclamp_se))
        );
    }
    impl uclamp_se {
        #[inline]
        pub fn value(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 11u8) as u32) }
        }
        #[inline]
        pub fn set_value(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 11u8, val as u64)
            }
        }
        #[inline]
        pub fn bucket_id(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 3u8) as u32) }
        }
        #[inline]
        pub fn set_bucket_id(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(11usize, 3u8, val as u64)
            }
        }
        #[inline]
        pub fn active(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_active(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(14usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn user_defined(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_user_defined(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(15usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            value: ::cty::c_uint,
            bucket_id: ::cty::c_uint,
            active: ::cty::c_uint,
            user_defined: ::cty::c_uint,
        ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 11u8, {
                let value: u32 = unsafe { ::core::mem::transmute(value) };
                value as u64
            });
            __bindgen_bitfield_unit.set(11usize, 3u8, {
                let bucket_id: u32 = unsafe { ::core::mem::transmute(bucket_id) };
                bucket_id as u64
            });
            __bindgen_bitfield_unit.set(14usize, 1u8, {
                let active: u32 = unsafe { ::core::mem::transmute(active) };
                active as u64
            });
            __bindgen_bitfield_unit.set(15usize, 1u8, {
                let user_defined: u32 = unsafe { ::core::mem::transmute(user_defined) };
                user_defined as u64
            });
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union rcu_special {
        pub b: rcu_special__bindgen_ty_1,
        pub s: _cargo_bpf_u32,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct rcu_special__bindgen_ty_1 {
        pub blocked: _cargo_bpf_u8,
        pub need_qs: _cargo_bpf_u8,
        pub exp_hint: _cargo_bpf_u8,
        pub need_mb: _cargo_bpf_u8,
    }
    #[test]
    fn bindgen_test_layout_rcu_special__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<rcu_special__bindgen_ty_1>(),
            4usize,
            concat!("Size of: ", stringify!(rcu_special__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<rcu_special__bindgen_ty_1>(),
            1usize,
            concat!("Alignment of ", stringify!(rcu_special__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<rcu_special__bindgen_ty_1>())).blocked as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcu_special__bindgen_ty_1),
                "::",
                stringify!(blocked)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<rcu_special__bindgen_ty_1>())).need_qs as *const _ as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(rcu_special__bindgen_ty_1),
                "::",
                stringify!(need_qs)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<rcu_special__bindgen_ty_1>())).exp_hint as *const _ as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(rcu_special__bindgen_ty_1),
                "::",
                stringify!(exp_hint)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<rcu_special__bindgen_ty_1>())).need_mb as *const _ as usize
            },
            3usize,
            concat!(
                "Offset of field: ",
                stringify!(rcu_special__bindgen_ty_1),
                "::",
                stringify!(need_mb)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_rcu_special() {
        assert_eq!(
            ::core::mem::size_of::<rcu_special>(),
            4usize,
            concat!("Size of: ", stringify!(rcu_special))
        );
        assert_eq!(
            ::core::mem::align_of::<rcu_special>(),
            4usize,
            concat!("Alignment of ", stringify!(rcu_special))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rcu_special>())).b as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcu_special),
                "::",
                stringify!(b)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rcu_special>())).s as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcu_special),
                "::",
                stringify!(s)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct wake_q_node {
        pub next: *mut wake_q_node,
    }
    #[test]
    fn bindgen_test_layout_wake_q_node() {
        assert_eq!(
            ::core::mem::size_of::<wake_q_node>(),
            8usize,
            concat!("Size of: ", stringify!(wake_q_node))
        );
        assert_eq!(
            ::core::mem::align_of::<wake_q_node>(),
            8usize,
            concat!("Alignment of ", stringify!(wake_q_node))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<wake_q_node>())).next as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(wake_q_node),
                "::",
                stringify!(next)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct kmap_ctrl {}
    #[test]
    fn bindgen_test_layout_kmap_ctrl() {
        assert_eq!(
            ::core::mem::size_of::<kmap_ctrl>(),
            0usize,
            concat!("Size of: ", stringify!(kmap_ctrl))
        );
        assert_eq!(
            ::core::mem::align_of::<kmap_ctrl>(),
            1usize,
            concat!("Alignment of ", stringify!(kmap_ctrl))
        );
    }
    #[repr(C)]
    #[repr(align(64))]
    pub struct task_struct {
        pub thread_info: thread_info,
        pub __state: ::cty::c_uint,
        pub stack: *mut ::cty::c_void,
        pub usage: refcount_t,
        pub flags: ::cty::c_uint,
        pub ptrace: ::cty::c_uint,
        pub on_cpu: ::cty::c_int,
        pub wake_entry: __call_single_node,
        pub wakee_flips: ::cty::c_uint,
        pub wakee_flip_decay_ts: ::cty::c_ulong,
        pub last_wakee: *mut task_struct,
        pub recent_used_cpu: ::cty::c_int,
        pub wake_cpu: ::cty::c_int,
        pub on_rq: ::cty::c_int,
        pub prio: ::cty::c_int,
        pub static_prio: ::cty::c_int,
        pub normal_prio: ::cty::c_int,
        pub rt_priority: ::cty::c_uint,
        pub __bindgen_padding_0: [u64; 0usize],
        pub se: sched_entity,
        pub rt: sched_rt_entity,
        pub dl: sched_dl_entity,
        pub sched_class: *mut sched_class,
        pub core_node: rb_node,
        pub core_cookie: ::cty::c_ulong,
        pub core_occupation: ::cty::c_uint,
        pub sched_task_group: *mut task_group,
        pub uclamp_req: [uclamp_se; 2usize],
        pub uclamp: [uclamp_se; 2usize],
        pub __bindgen_padding_1: [u64; 5usize],
        pub stats: sched_statistics,
        pub preempt_notifiers: hlist_head,
        pub btrace_seq: ::cty::c_uint,
        pub policy: ::cty::c_uint,
        pub nr_cpus_allowed: ::cty::c_int,
        pub cpus_ptr: *const cpumask_t,
        pub user_cpus_ptr: *mut cpumask_t,
        pub cpus_mask: cpumask_t,
        pub migration_pending: *mut ::cty::c_void,
        pub migration_disabled: ::cty::c_ushort,
        pub migration_flags: ::cty::c_ushort,
        pub rcu_read_lock_nesting: ::cty::c_int,
        pub rcu_read_unlock_special: rcu_special,
        pub rcu_node_entry: list_head,
        pub rcu_blocked_node: *mut rcu_node,
        pub rcu_tasks_nvcsw: ::cty::c_ulong,
        pub rcu_tasks_holdout: _cargo_bpf_u8,
        pub rcu_tasks_idx: _cargo_bpf_u8,
        pub rcu_tasks_idle_cpu: ::cty::c_int,
        pub rcu_tasks_holdout_list: list_head,
        pub trc_reader_nesting: ::cty::c_int,
        pub trc_ipi_to_cpu: ::cty::c_int,
        pub trc_reader_special: rcu_special,
        pub trc_holdout_list: list_head,
        pub trc_blkd_node: list_head,
        pub trc_blkd_cpu: ::cty::c_int,
        pub sched_info: sched_info,
        pub tasks: list_head,
        pub pushable_tasks: plist_node,
        pub pushable_dl_tasks: rb_node,
        pub mm: *mut mm_struct,
        pub active_mm: *mut mm_struct,
        pub exit_state: ::cty::c_int,
        pub exit_code: ::cty::c_int,
        pub exit_signal: ::cty::c_int,
        pub pdeath_signal: ::cty::c_int,
        pub jobctl: ::cty::c_ulong,
        pub personality: ::cty::c_uint,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 6usize]>,
        pub atomic_flags: ::cty::c_ulong,
        pub restart_block: restart_block,
        pub pid: pid_t,
        pub tgid: pid_t,
        pub stack_canary: ::cty::c_ulong,
        pub real_parent: *mut task_struct,
        pub parent: *mut task_struct,
        pub children: list_head,
        pub sibling: list_head,
        pub group_leader: *mut task_struct,
        pub ptraced: list_head,
        pub ptrace_entry: list_head,
        pub thread_pid: *mut pid,
        pub pid_links: [hlist_node; 4usize],
        pub thread_group: list_head,
        pub thread_node: list_head,
        pub vfork_done: *mut completion,
        pub set_child_tid: *mut ::cty::c_int,
        pub clear_child_tid: *mut ::cty::c_int,
        pub worker_private: *mut ::cty::c_void,
        pub utime: _cargo_bpf_u64,
        pub stime: _cargo_bpf_u64,
        pub gtime: _cargo_bpf_u64,
        pub prev_cputime: prev_cputime,
        pub nvcsw: ::cty::c_ulong,
        pub nivcsw: ::cty::c_ulong,
        pub start_time: _cargo_bpf_u64,
        pub start_boottime: _cargo_bpf_u64,
        pub min_flt: ::cty::c_ulong,
        pub maj_flt: ::cty::c_ulong,
        pub posix_cputimers: posix_cputimers,
        pub posix_cputimers_work: posix_cputimers_work,
        pub ptracer_cred: *const cred,
        pub real_cred: *const cred,
        pub cred: *const cred,
        pub cached_requested_key: *mut key,
        pub comm: [::cty::c_char; 16usize],
        pub nameidata: *mut nameidata,
        pub sysvsem: sysv_sem,
        pub sysvshm: sysv_shm,
        pub last_switch_count: ::cty::c_ulong,
        pub last_switch_time: ::cty::c_ulong,
        pub fs: *mut fs_struct,
        pub files: *mut files_struct,
        pub io_uring: *mut io_uring_task,
        pub nsproxy: *mut nsproxy,
        pub signal: *mut signal_struct,
        pub sighand: *mut sighand_struct,
        pub blocked: sigset_t,
        pub real_blocked: sigset_t,
        pub saved_sigmask: sigset_t,
        pub pending: sigpending,
        pub sas_ss_sp: ::cty::c_ulong,
        pub sas_ss_size: size_t,
        pub sas_ss_flags: ::cty::c_uint,
        pub task_works: *mut callback_head,
        pub audit_context: *mut audit_context,
        pub loginuid: kuid_t,
        pub sessionid: ::cty::c_uint,
        pub seccomp: seccomp,
        pub syscall_dispatch: syscall_user_dispatch,
        pub parent_exec_id: _cargo_bpf_u64,
        pub self_exec_id: _cargo_bpf_u64,
        pub alloc_lock: spinlock_t,
        pub pi_lock: raw_spinlock_t,
        pub wake_q: wake_q_node,
        pub pi_waiters: rb_root_cached,
        pub pi_top_task: *mut task_struct,
        pub pi_blocked_on: *mut rt_mutex_waiter,
        pub in_ubsan: ::cty::c_uint,
        pub journal_info: *mut ::cty::c_void,
        pub bio_list: *mut bio_list,
        pub plug: *mut blk_plug,
        pub reclaim_state: *mut reclaim_state,
        pub io_context: *mut io_context,
        pub capture_control: *mut capture_control,
        pub ptrace_message: ::cty::c_ulong,
        pub last_siginfo: *mut kernel_siginfo_t,
        pub ioac: task_io_accounting,
        pub psi_flags: ::cty::c_uint,
        pub acct_rss_mem1: _cargo_bpf_u64,
        pub acct_vm_mem1: _cargo_bpf_u64,
        pub acct_timexpd: _cargo_bpf_u64,
        pub mems_allowed: nodemask_t,
        pub mems_allowed_seq: seqcount_spinlock_t,
        pub cpuset_mem_spread_rotor: ::cty::c_int,
        pub cpuset_slab_spread_rotor: ::cty::c_int,
        pub cgroups: *mut css_set,
        pub cg_list: list_head,
        pub closid: _cargo_bpf_u32,
        pub rmid: _cargo_bpf_u32,
        pub robust_list: *mut robust_list_head,
        pub compat_robust_list: *mut compat_robust_list_head,
        pub pi_state_list: list_head,
        pub pi_state_cache: *mut futex_pi_state,
        pub futex_exit_mutex: mutex,
        pub futex_state: ::cty::c_uint,
        pub perf_event_ctxp: *mut perf_event_context,
        pub perf_event_mutex: mutex,
        pub perf_event_list: list_head,
        pub mempolicy: *mut mempolicy,
        pub il_prev: ::cty::c_short,
        pub pref_node_fork: ::cty::c_short,
        pub numa_scan_seq: ::cty::c_int,
        pub numa_scan_period: ::cty::c_uint,
        pub numa_scan_period_max: ::cty::c_uint,
        pub numa_preferred_nid: ::cty::c_int,
        pub numa_migrate_retry: ::cty::c_ulong,
        pub node_stamp: _cargo_bpf_u64,
        pub last_task_numa_placement: _cargo_bpf_u64,
        pub last_sum_exec_runtime: _cargo_bpf_u64,
        pub numa_work: callback_head,
        pub numa_group: *mut numa_group,
        pub numa_faults: *mut ::cty::c_ulong,
        pub total_numa_faults: ::cty::c_ulong,
        pub numa_faults_locality: [::cty::c_ulong; 3usize],
        pub numa_pages_migrated: ::cty::c_ulong,
        pub rseq: *mut rseq,
        pub rseq_len: _cargo_bpf_u32,
        pub rseq_sig: _cargo_bpf_u32,
        pub rseq_event_mask: ::cty::c_ulong,
        pub mm_cid: ::cty::c_int,
        pub last_mm_cid: ::cty::c_int,
        pub migrate_from_cpu: ::cty::c_int,
        pub mm_cid_active: ::cty::c_int,
        pub cid_work: callback_head,
        pub tlb_ubc: tlbflush_unmap_batch,
        pub splice_pipe: *mut pipe_inode_info,
        pub task_frag: page_frag,
        pub delays: *mut task_delay_info,
        pub nr_dirtied: ::cty::c_int,
        pub nr_dirtied_pause: ::cty::c_int,
        pub dirty_paused_when: ::cty::c_ulong,
        pub timer_slack_ns: _cargo_bpf_u64,
        pub default_timer_slack_ns: _cargo_bpf_u64,
        pub curr_ret_stack: ::cty::c_int,
        pub curr_ret_depth: ::cty::c_int,
        pub ret_stack: *mut ftrace_ret_stack,
        pub ftrace_timestamp: ::cty::c_ulonglong,
        pub trace_overrun: atomic_t,
        pub tracing_graph_pause: atomic_t,
        pub trace_recursion: ::cty::c_ulong,
        pub memcg_in_oom: *mut mem_cgroup,
        pub memcg_oom_gfp_mask: gfp_t,
        pub memcg_oom_order: ::cty::c_int,
        pub memcg_nr_pages_over_high: ::cty::c_uint,
        pub active_memcg: *mut mem_cgroup,
        pub throttle_disk: *mut gendisk,
        pub utask: *mut uprobe_task,
        pub sequential_io: ::cty::c_uint,
        pub sequential_io_avg: ::cty::c_uint,
        pub kmap_ctrl: kmap_ctrl,
        pub rcu: callback_head,
        pub rcu_users: refcount_t,
        pub pagefault_disabled: ::cty::c_int,
        pub oom_reaper_list: *mut task_struct,
        pub oom_reaper_timer: timer_list,
        pub stack_vm_area: *mut vm_struct,
        pub stack_refcount: refcount_t,
        pub patch_state: ::cty::c_int,
        pub security: *mut ::cty::c_void,
        pub bpf_storage: *mut bpf_local_storage,
        pub bpf_ctx: *mut bpf_run_ctx,
        pub mce_vaddr: *mut ::cty::c_void,
        pub mce_kflags: __u64,
        pub mce_addr: _cargo_bpf_u64,
        pub _bitfield_align_2: [u64; 0],
        pub _bitfield_2: __BindgenBitfieldUnit<[u8; 8usize]>,
        pub mce_kill_me: callback_head,
        pub mce_count: ::cty::c_int,
        pub kretprobe_instances: llist_head,
        pub rethooks: llist_head,
        pub l1d_flush_kill: callback_head,
        pub rv: [rv_task_monitor; 1usize],
        pub user_event_mm: *mut user_event_mm,
        pub __bindgen_padding_2: [u64; 3usize],
        pub thread: thread_struct,
    }
    #[test]
    fn bindgen_test_layout_task_struct() {
        assert_eq!(
            ::core::mem::size_of::<task_struct>(),
            9792usize,
            concat!("Size of: ", stringify!(task_struct))
        );
        assert_eq!(
            ::core::mem::align_of::<task_struct>(),
            64usize,
            concat!("Alignment of ", stringify!(task_struct))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).thread_info as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(thread_info)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).__state as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(__state)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).stack as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(stack)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).usage as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(usage)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).flags as *const _ as usize },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).ptrace as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(ptrace)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).on_cpu as *const _ as usize },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(on_cpu)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).wake_entry as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(wake_entry)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).wakee_flips as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(wakee_flips)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).wakee_flip_decay_ts as *const _ as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(wakee_flip_decay_ts)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).last_wakee as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(last_wakee)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).recent_used_cpu as *const _ as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(recent_used_cpu)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).wake_cpu as *const _ as usize },
            100usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(wake_cpu)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).on_rq as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(on_rq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).prio as *const _ as usize },
            108usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(prio)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).static_prio as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(static_prio)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).normal_prio as *const _ as usize },
            116usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(normal_prio)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).rt_priority as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(rt_priority)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).se as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(se)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).rt as *const _ as usize },
            384usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(rt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).dl as *const _ as usize },
            432usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(dl)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).sched_class as *const _ as usize },
            656usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(sched_class)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).core_node as *const _ as usize },
            664usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(core_node)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).core_cookie as *const _ as usize },
            688usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(core_cookie)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).core_occupation as *const _ as usize
            },
            696usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(core_occupation)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).sched_task_group as *const _ as usize
            },
            704usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(sched_task_group)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).uclamp_req as *const _ as usize },
            712usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(uclamp_req)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).uclamp as *const _ as usize },
            720usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(uclamp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).stats as *const _ as usize },
            768usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(stats)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).preempt_notifiers as *const _ as usize
            },
            1024usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(preempt_notifiers)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).btrace_seq as *const _ as usize },
            1032usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(btrace_seq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).policy as *const _ as usize },
            1036usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(policy)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).nr_cpus_allowed as *const _ as usize
            },
            1040usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(nr_cpus_allowed)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).cpus_ptr as *const _ as usize },
            1048usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(cpus_ptr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).user_cpus_ptr as *const _ as usize },
            1056usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(user_cpus_ptr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).cpus_mask as *const _ as usize },
            1064usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(cpus_mask)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).migration_pending as *const _ as usize
            },
            2088usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(migration_pending)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).migration_disabled as *const _ as usize
            },
            2096usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(migration_disabled)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).migration_flags as *const _ as usize
            },
            2098usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(migration_flags)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).rcu_read_lock_nesting as *const _ as usize
            },
            2100usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(rcu_read_lock_nesting)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).rcu_read_unlock_special as *const _
                    as usize
            },
            2104usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(rcu_read_unlock_special)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).rcu_node_entry as *const _ as usize },
            2112usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(rcu_node_entry)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).rcu_blocked_node as *const _ as usize
            },
            2128usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(rcu_blocked_node)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).rcu_tasks_nvcsw as *const _ as usize
            },
            2136usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(rcu_tasks_nvcsw)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).rcu_tasks_holdout as *const _ as usize
            },
            2144usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(rcu_tasks_holdout)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).rcu_tasks_idx as *const _ as usize },
            2145usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(rcu_tasks_idx)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).rcu_tasks_idle_cpu as *const _ as usize
            },
            2148usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(rcu_tasks_idle_cpu)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).rcu_tasks_holdout_list as *const _ as usize
            },
            2152usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(rcu_tasks_holdout_list)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).trc_reader_nesting as *const _ as usize
            },
            2168usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(trc_reader_nesting)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).trc_ipi_to_cpu as *const _ as usize },
            2172usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(trc_ipi_to_cpu)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).trc_reader_special as *const _ as usize
            },
            2176usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(trc_reader_special)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).trc_holdout_list as *const _ as usize
            },
            2184usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(trc_holdout_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).trc_blkd_node as *const _ as usize },
            2200usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(trc_blkd_node)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).trc_blkd_cpu as *const _ as usize },
            2216usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(trc_blkd_cpu)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).sched_info as *const _ as usize },
            2224usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(sched_info)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).tasks as *const _ as usize },
            2256usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(tasks)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).pushable_tasks as *const _ as usize },
            2272usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(pushable_tasks)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).pushable_dl_tasks as *const _ as usize
            },
            2312usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(pushable_dl_tasks)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).mm as *const _ as usize },
            2336usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(mm)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).active_mm as *const _ as usize },
            2344usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(active_mm)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).exit_state as *const _ as usize },
            2352usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(exit_state)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).exit_code as *const _ as usize },
            2356usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(exit_code)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).exit_signal as *const _ as usize },
            2360usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(exit_signal)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).pdeath_signal as *const _ as usize },
            2364usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(pdeath_signal)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).jobctl as *const _ as usize },
            2368usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(jobctl)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).personality as *const _ as usize },
            2376usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(personality)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).atomic_flags as *const _ as usize },
            2392usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(atomic_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).restart_block as *const _ as usize },
            2400usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(restart_block)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).pid as *const _ as usize },
            2456usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(pid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).tgid as *const _ as usize },
            2460usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(tgid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).stack_canary as *const _ as usize },
            2464usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(stack_canary)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).real_parent as *const _ as usize },
            2472usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(real_parent)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).parent as *const _ as usize },
            2480usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(parent)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).children as *const _ as usize },
            2488usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(children)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).sibling as *const _ as usize },
            2504usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(sibling)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).group_leader as *const _ as usize },
            2520usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(group_leader)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).ptraced as *const _ as usize },
            2528usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(ptraced)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).ptrace_entry as *const _ as usize },
            2544usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(ptrace_entry)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).thread_pid as *const _ as usize },
            2560usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(thread_pid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).pid_links as *const _ as usize },
            2568usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(pid_links)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).thread_group as *const _ as usize },
            2632usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(thread_group)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).thread_node as *const _ as usize },
            2648usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(thread_node)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).vfork_done as *const _ as usize },
            2664usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(vfork_done)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).set_child_tid as *const _ as usize },
            2672usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(set_child_tid)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).clear_child_tid as *const _ as usize
            },
            2680usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(clear_child_tid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).worker_private as *const _ as usize },
            2688usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(worker_private)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).utime as *const _ as usize },
            2696usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(utime)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).stime as *const _ as usize },
            2704usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(stime)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).gtime as *const _ as usize },
            2712usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(gtime)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).prev_cputime as *const _ as usize },
            2720usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(prev_cputime)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).nvcsw as *const _ as usize },
            2744usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(nvcsw)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).nivcsw as *const _ as usize },
            2752usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(nivcsw)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).start_time as *const _ as usize },
            2760usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(start_time)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).start_boottime as *const _ as usize },
            2768usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(start_boottime)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).min_flt as *const _ as usize },
            2776usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(min_flt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).maj_flt as *const _ as usize },
            2784usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(maj_flt)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).posix_cputimers as *const _ as usize
            },
            2792usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(posix_cputimers)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).posix_cputimers_work as *const _ as usize
            },
            2872usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(posix_cputimers_work)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).ptracer_cred as *const _ as usize },
            2928usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(ptracer_cred)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).real_cred as *const _ as usize },
            2936usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(real_cred)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).cred as *const _ as usize },
            2944usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(cred)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).cached_requested_key as *const _ as usize
            },
            2952usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(cached_requested_key)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).comm as *const _ as usize },
            2960usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(comm)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).nameidata as *const _ as usize },
            2976usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(nameidata)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).sysvsem as *const _ as usize },
            2984usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(sysvsem)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).sysvshm as *const _ as usize },
            2992usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(sysvshm)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).last_switch_count as *const _ as usize
            },
            3008usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(last_switch_count)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).last_switch_time as *const _ as usize
            },
            3016usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(last_switch_time)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).fs as *const _ as usize },
            3024usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(fs)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).files as *const _ as usize },
            3032usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(files)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).io_uring as *const _ as usize },
            3040usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(io_uring)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).nsproxy as *const _ as usize },
            3048usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(nsproxy)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).signal as *const _ as usize },
            3056usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(signal)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).sighand as *const _ as usize },
            3064usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(sighand)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).blocked as *const _ as usize },
            3072usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(blocked)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).real_blocked as *const _ as usize },
            3080usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(real_blocked)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).saved_sigmask as *const _ as usize },
            3088usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(saved_sigmask)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).pending as *const _ as usize },
            3096usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(pending)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).sas_ss_sp as *const _ as usize },
            3120usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(sas_ss_sp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).sas_ss_size as *const _ as usize },
            3128usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(sas_ss_size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).sas_ss_flags as *const _ as usize },
            3136usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(sas_ss_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).task_works as *const _ as usize },
            3144usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(task_works)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).audit_context as *const _ as usize },
            3152usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(audit_context)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).loginuid as *const _ as usize },
            3160usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(loginuid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).sessionid as *const _ as usize },
            3164usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(sessionid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).seccomp as *const _ as usize },
            3168usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(seccomp)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).syscall_dispatch as *const _ as usize
            },
            3184usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(syscall_dispatch)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).parent_exec_id as *const _ as usize },
            3216usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(parent_exec_id)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).self_exec_id as *const _ as usize },
            3224usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(self_exec_id)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).alloc_lock as *const _ as usize },
            3232usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(alloc_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).pi_lock as *const _ as usize },
            3236usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(pi_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).wake_q as *const _ as usize },
            3240usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(wake_q)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).pi_waiters as *const _ as usize },
            3248usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(pi_waiters)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).pi_top_task as *const _ as usize },
            3264usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(pi_top_task)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).pi_blocked_on as *const _ as usize },
            3272usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(pi_blocked_on)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).in_ubsan as *const _ as usize },
            3280usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(in_ubsan)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).journal_info as *const _ as usize },
            3288usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(journal_info)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).bio_list as *const _ as usize },
            3296usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(bio_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).plug as *const _ as usize },
            3304usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(plug)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).reclaim_state as *const _ as usize },
            3312usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(reclaim_state)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).io_context as *const _ as usize },
            3320usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(io_context)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).capture_control as *const _ as usize
            },
            3328usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(capture_control)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).ptrace_message as *const _ as usize },
            3336usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(ptrace_message)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).last_siginfo as *const _ as usize },
            3344usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(last_siginfo)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).ioac as *const _ as usize },
            3352usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(ioac)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).psi_flags as *const _ as usize },
            3408usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(psi_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).acct_rss_mem1 as *const _ as usize },
            3416usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(acct_rss_mem1)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).acct_vm_mem1 as *const _ as usize },
            3424usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(acct_vm_mem1)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).acct_timexpd as *const _ as usize },
            3432usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(acct_timexpd)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).mems_allowed as *const _ as usize },
            3440usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(mems_allowed)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).mems_allowed_seq as *const _ as usize
            },
            3568usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(mems_allowed_seq)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).cpuset_mem_spread_rotor as *const _
                    as usize
            },
            3572usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(cpuset_mem_spread_rotor)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).cpuset_slab_spread_rotor as *const _
                    as usize
            },
            3576usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(cpuset_slab_spread_rotor)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).cgroups as *const _ as usize },
            3584usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(cgroups)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).cg_list as *const _ as usize },
            3592usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(cg_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).closid as *const _ as usize },
            3608usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(closid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).rmid as *const _ as usize },
            3612usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(rmid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).robust_list as *const _ as usize },
            3616usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(robust_list)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).compat_robust_list as *const _ as usize
            },
            3624usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(compat_robust_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).pi_state_list as *const _ as usize },
            3632usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(pi_state_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).pi_state_cache as *const _ as usize },
            3648usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(pi_state_cache)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).futex_exit_mutex as *const _ as usize
            },
            3656usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(futex_exit_mutex)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).futex_state as *const _ as usize },
            3688usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(futex_state)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).perf_event_ctxp as *const _ as usize
            },
            3696usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(perf_event_ctxp)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).perf_event_mutex as *const _ as usize
            },
            3704usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(perf_event_mutex)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).perf_event_list as *const _ as usize
            },
            3736usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(perf_event_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).mempolicy as *const _ as usize },
            3752usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(mempolicy)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).il_prev as *const _ as usize },
            3760usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(il_prev)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).pref_node_fork as *const _ as usize },
            3762usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(pref_node_fork)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).numa_scan_seq as *const _ as usize },
            3764usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(numa_scan_seq)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).numa_scan_period as *const _ as usize
            },
            3768usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(numa_scan_period)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).numa_scan_period_max as *const _ as usize
            },
            3772usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(numa_scan_period_max)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).numa_preferred_nid as *const _ as usize
            },
            3776usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(numa_preferred_nid)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).numa_migrate_retry as *const _ as usize
            },
            3784usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(numa_migrate_retry)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).node_stamp as *const _ as usize },
            3792usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(node_stamp)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).last_task_numa_placement as *const _
                    as usize
            },
            3800usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(last_task_numa_placement)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).last_sum_exec_runtime as *const _ as usize
            },
            3808usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(last_sum_exec_runtime)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).numa_work as *const _ as usize },
            3816usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(numa_work)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).numa_group as *const _ as usize },
            3832usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(numa_group)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).numa_faults as *const _ as usize },
            3840usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(numa_faults)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).total_numa_faults as *const _ as usize
            },
            3848usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(total_numa_faults)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).numa_faults_locality as *const _ as usize
            },
            3856usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(numa_faults_locality)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).numa_pages_migrated as *const _ as usize
            },
            3880usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(numa_pages_migrated)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).rseq as *const _ as usize },
            3888usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(rseq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).rseq_len as *const _ as usize },
            3896usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(rseq_len)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).rseq_sig as *const _ as usize },
            3900usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(rseq_sig)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).rseq_event_mask as *const _ as usize
            },
            3904usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(rseq_event_mask)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).mm_cid as *const _ as usize },
            3912usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(mm_cid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).last_mm_cid as *const _ as usize },
            3916usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(last_mm_cid)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).migrate_from_cpu as *const _ as usize
            },
            3920usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(migrate_from_cpu)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).mm_cid_active as *const _ as usize },
            3924usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(mm_cid_active)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).cid_work as *const _ as usize },
            3928usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(cid_work)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).tlb_ubc as *const _ as usize },
            3944usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(tlb_ubc)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).splice_pipe as *const _ as usize },
            4976usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(splice_pipe)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).task_frag as *const _ as usize },
            4984usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(task_frag)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).delays as *const _ as usize },
            5000usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(delays)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).nr_dirtied as *const _ as usize },
            5008usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(nr_dirtied)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).nr_dirtied_pause as *const _ as usize
            },
            5012usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(nr_dirtied_pause)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).dirty_paused_when as *const _ as usize
            },
            5016usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(dirty_paused_when)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).timer_slack_ns as *const _ as usize },
            5024usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(timer_slack_ns)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).default_timer_slack_ns as *const _ as usize
            },
            5032usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(default_timer_slack_ns)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).curr_ret_stack as *const _ as usize },
            5040usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(curr_ret_stack)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).curr_ret_depth as *const _ as usize },
            5044usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(curr_ret_depth)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).ret_stack as *const _ as usize },
            5048usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(ret_stack)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).ftrace_timestamp as *const _ as usize
            },
            5056usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(ftrace_timestamp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).trace_overrun as *const _ as usize },
            5064usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(trace_overrun)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).tracing_graph_pause as *const _ as usize
            },
            5068usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(tracing_graph_pause)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).trace_recursion as *const _ as usize
            },
            5072usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(trace_recursion)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).memcg_in_oom as *const _ as usize },
            5080usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(memcg_in_oom)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).memcg_oom_gfp_mask as *const _ as usize
            },
            5088usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(memcg_oom_gfp_mask)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).memcg_oom_order as *const _ as usize
            },
            5092usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(memcg_oom_order)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).memcg_nr_pages_over_high as *const _
                    as usize
            },
            5096usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(memcg_nr_pages_over_high)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).active_memcg as *const _ as usize },
            5104usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(active_memcg)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).throttle_disk as *const _ as usize },
            5112usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(throttle_disk)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).utask as *const _ as usize },
            5120usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(utask)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).sequential_io as *const _ as usize },
            5128usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(sequential_io)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).sequential_io_avg as *const _ as usize
            },
            5132usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(sequential_io_avg)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).kmap_ctrl as *const _ as usize },
            5136usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(kmap_ctrl)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).rcu as *const _ as usize },
            5136usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(rcu)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).rcu_users as *const _ as usize },
            5152usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(rcu_users)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).pagefault_disabled as *const _ as usize
            },
            5156usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(pagefault_disabled)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).oom_reaper_list as *const _ as usize
            },
            5160usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(oom_reaper_list)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).oom_reaper_timer as *const _ as usize
            },
            5168usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(oom_reaper_timer)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).stack_vm_area as *const _ as usize },
            5208usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(stack_vm_area)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).stack_refcount as *const _ as usize },
            5216usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(stack_refcount)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).patch_state as *const _ as usize },
            5220usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(patch_state)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).security as *const _ as usize },
            5224usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(security)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).bpf_storage as *const _ as usize },
            5232usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(bpf_storage)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).bpf_ctx as *const _ as usize },
            5240usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(bpf_ctx)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).mce_vaddr as *const _ as usize },
            5248usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(mce_vaddr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).mce_kflags as *const _ as usize },
            5256usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(mce_kflags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).mce_addr as *const _ as usize },
            5264usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(mce_addr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).mce_kill_me as *const _ as usize },
            5280usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(mce_kill_me)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).mce_count as *const _ as usize },
            5296usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(mce_count)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_struct>())).kretprobe_instances as *const _ as usize
            },
            5304usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(kretprobe_instances)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).rethooks as *const _ as usize },
            5312usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(rethooks)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).l1d_flush_kill as *const _ as usize },
            5320usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(l1d_flush_kill)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).rv as *const _ as usize },
            5336usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(rv)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).user_event_mm as *const _ as usize },
            5344usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(user_event_mm)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_struct>())).thread as *const _ as usize },
            5376usize,
            concat!(
                "Offset of field: ",
                stringify!(task_struct),
                "::",
                stringify!(thread)
            )
        );
    }
    impl task_struct {
        #[inline]
        pub fn sched_reset_on_fork(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_sched_reset_on_fork(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn sched_contributes_to_load(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_sched_contributes_to_load(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(1usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn sched_migrated(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_sched_migrated(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(2usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn sched_remote_wakeup(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_sched_remote_wakeup(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(32usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn in_execve(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_in_execve(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(33usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn in_iowait(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(34usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_in_iowait(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(34usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn restore_sigmask(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(35usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_restore_sigmask(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(35usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn in_user_fault(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(36usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_in_user_fault(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(36usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn in_lru_fault(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(37usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_in_lru_fault(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(37usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn no_cgroup_migration(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(38usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_no_cgroup_migration(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(38usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn frozen(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(39usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_frozen(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(39usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn use_memdelay(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(40usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_use_memdelay(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(40usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn in_memstall(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(41usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_in_memstall(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(41usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn in_eventfd(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(42usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_in_eventfd(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(42usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn pasid_activated(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(43usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_pasid_activated(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(43usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn reported_split_lock(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(44usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_reported_split_lock(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(44usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn in_thrashing(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(45usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_in_thrashing(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(45usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            sched_reset_on_fork: ::cty::c_uint,
            sched_contributes_to_load: ::cty::c_uint,
            sched_migrated: ::cty::c_uint,
            sched_remote_wakeup: ::cty::c_uint,
            in_execve: ::cty::c_uint,
            in_iowait: ::cty::c_uint,
            restore_sigmask: ::cty::c_uint,
            in_user_fault: ::cty::c_uint,
            in_lru_fault: ::cty::c_uint,
            no_cgroup_migration: ::cty::c_uint,
            frozen: ::cty::c_uint,
            use_memdelay: ::cty::c_uint,
            in_memstall: ::cty::c_uint,
            in_eventfd: ::cty::c_uint,
            pasid_activated: ::cty::c_uint,
            reported_split_lock: ::cty::c_uint,
            in_thrashing: ::cty::c_uint,
        ) -> __BindgenBitfieldUnit<[u8; 6usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 6usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 1u8, {
                let sched_reset_on_fork: u32 =
                    unsafe { ::core::mem::transmute(sched_reset_on_fork) };
                sched_reset_on_fork as u64
            });
            __bindgen_bitfield_unit.set(1usize, 1u8, {
                let sched_contributes_to_load: u32 =
                    unsafe { ::core::mem::transmute(sched_contributes_to_load) };
                sched_contributes_to_load as u64
            });
            __bindgen_bitfield_unit.set(2usize, 1u8, {
                let sched_migrated: u32 = unsafe { ::core::mem::transmute(sched_migrated) };
                sched_migrated as u64
            });
            __bindgen_bitfield_unit.set(32usize, 1u8, {
                let sched_remote_wakeup: u32 =
                    unsafe { ::core::mem::transmute(sched_remote_wakeup) };
                sched_remote_wakeup as u64
            });
            __bindgen_bitfield_unit.set(33usize, 1u8, {
                let in_execve: u32 = unsafe { ::core::mem::transmute(in_execve) };
                in_execve as u64
            });
            __bindgen_bitfield_unit.set(34usize, 1u8, {
                let in_iowait: u32 = unsafe { ::core::mem::transmute(in_iowait) };
                in_iowait as u64
            });
            __bindgen_bitfield_unit.set(35usize, 1u8, {
                let restore_sigmask: u32 = unsafe { ::core::mem::transmute(restore_sigmask) };
                restore_sigmask as u64
            });
            __bindgen_bitfield_unit.set(36usize, 1u8, {
                let in_user_fault: u32 = unsafe { ::core::mem::transmute(in_user_fault) };
                in_user_fault as u64
            });
            __bindgen_bitfield_unit.set(37usize, 1u8, {
                let in_lru_fault: u32 = unsafe { ::core::mem::transmute(in_lru_fault) };
                in_lru_fault as u64
            });
            __bindgen_bitfield_unit.set(38usize, 1u8, {
                let no_cgroup_migration: u32 =
                    unsafe { ::core::mem::transmute(no_cgroup_migration) };
                no_cgroup_migration as u64
            });
            __bindgen_bitfield_unit.set(39usize, 1u8, {
                let frozen: u32 = unsafe { ::core::mem::transmute(frozen) };
                frozen as u64
            });
            __bindgen_bitfield_unit.set(40usize, 1u8, {
                let use_memdelay: u32 = unsafe { ::core::mem::transmute(use_memdelay) };
                use_memdelay as u64
            });
            __bindgen_bitfield_unit.set(41usize, 1u8, {
                let in_memstall: u32 = unsafe { ::core::mem::transmute(in_memstall) };
                in_memstall as u64
            });
            __bindgen_bitfield_unit.set(42usize, 1u8, {
                let in_eventfd: u32 = unsafe { ::core::mem::transmute(in_eventfd) };
                in_eventfd as u64
            });
            __bindgen_bitfield_unit.set(43usize, 1u8, {
                let pasid_activated: u32 = unsafe { ::core::mem::transmute(pasid_activated) };
                pasid_activated as u64
            });
            __bindgen_bitfield_unit.set(44usize, 1u8, {
                let reported_split_lock: u32 =
                    unsafe { ::core::mem::transmute(reported_split_lock) };
                reported_split_lock as u64
            });
            __bindgen_bitfield_unit.set(45usize, 1u8, {
                let in_thrashing: u32 = unsafe { ::core::mem::transmute(in_thrashing) };
                in_thrashing as u64
            });
            __bindgen_bitfield_unit
        }
        #[inline]
        pub fn mce_ripv(&self) -> __u64 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u64) }
        }
        #[inline]
        pub fn set_mce_ripv(&mut self, val: __u64) {
            unsafe {
                let val: u64 = ::core::mem::transmute(val);
                self._bitfield_2.set(0usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn mce_whole_page(&self) -> __u64 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u64) }
        }
        #[inline]
        pub fn set_mce_whole_page(&mut self, val: __u64) {
            unsafe {
                let val: u64 = ::core::mem::transmute(val);
                self._bitfield_2.set(1usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn __mce_reserved(&self) -> __u64 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(2usize, 62u8) as u64) }
        }
        #[inline]
        pub fn set___mce_reserved(&mut self, val: __u64) {
            unsafe {
                let val: u64 = ::core::mem::transmute(val);
                self._bitfield_2.set(2usize, 62u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_2(
            mce_ripv: __u64,
            mce_whole_page: __u64,
            __mce_reserved: __u64,
        ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 1u8, {
                let mce_ripv: u64 = unsafe { ::core::mem::transmute(mce_ripv) };
                mce_ripv as u64
            });
            __bindgen_bitfield_unit.set(1usize, 1u8, {
                let mce_whole_page: u64 = unsafe { ::core::mem::transmute(mce_whole_page) };
                mce_whole_page as u64
            });
            __bindgen_bitfield_unit.set(2usize, 62u8, {
                let __mce_reserved: u64 = unsafe { ::core::mem::transmute(__mce_reserved) };
                __mce_reserved as u64
            });
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct hlist_nulls_head {
        pub first: *mut hlist_nulls_node,
    }
    #[test]
    fn bindgen_test_layout_hlist_nulls_head() {
        assert_eq!(
            ::core::mem::size_of::<hlist_nulls_head>(),
            8usize,
            concat!("Size of: ", stringify!(hlist_nulls_head))
        );
        assert_eq!(
            ::core::mem::align_of::<hlist_nulls_head>(),
            8usize,
            concat!("Alignment of ", stringify!(hlist_nulls_head))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<hlist_nulls_head>())).first as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(hlist_nulls_head),
                "::",
                stringify!(first)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct hlist_nulls_node {
        pub next: *mut hlist_nulls_node,
        pub pprev: *mut *mut hlist_nulls_node,
    }
    #[test]
    fn bindgen_test_layout_hlist_nulls_node() {
        assert_eq!(
            ::core::mem::size_of::<hlist_nulls_node>(),
            16usize,
            concat!("Size of: ", stringify!(hlist_nulls_node))
        );
        assert_eq!(
            ::core::mem::align_of::<hlist_nulls_node>(),
            8usize,
            concat!("Alignment of ", stringify!(hlist_nulls_node))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<hlist_nulls_node>())).next as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(hlist_nulls_node),
                "::",
                stringify!(next)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<hlist_nulls_node>())).pprev as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(hlist_nulls_node),
                "::",
                stringify!(pprev)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct local_t {
        pub a: atomic_long_t,
    }
    #[test]
    fn bindgen_test_layout_local_t() {
        assert_eq!(
            ::core::mem::size_of::<local_t>(),
            8usize,
            concat!("Size of: ", stringify!(local_t))
        );
        assert_eq!(
            ::core::mem::align_of::<local_t>(),
            8usize,
            concat!("Alignment of ", stringify!(local_t))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<local_t>())).a as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(local_t),
                "::",
                stringify!(a)
            )
        );
    }
    #[repr(C)]
    #[repr(align(64))]
    #[derive(Debug, Copy, Clone)]
    pub struct dql {
        pub num_queued: ::cty::c_uint,
        pub adj_limit: ::cty::c_uint,
        pub last_obj_cnt: ::cty::c_uint,
        pub __bindgen_padding_0: [u32; 13usize],
        pub limit: ::cty::c_uint,
        pub num_completed: ::cty::c_uint,
        pub prev_ovlimit: ::cty::c_uint,
        pub prev_num_queued: ::cty::c_uint,
        pub prev_last_obj_cnt: ::cty::c_uint,
        pub lowest_slack: ::cty::c_uint,
        pub slack_start_time: ::cty::c_ulong,
        pub max_limit: ::cty::c_uint,
        pub min_limit: ::cty::c_uint,
        pub slack_hold_time: ::cty::c_uint,
    }
    #[test]
    fn bindgen_test_layout_dql() {
        assert_eq!(
            ::core::mem::size_of::<dql>(),
            128usize,
            concat!("Size of: ", stringify!(dql))
        );
        assert_eq!(
            ::core::mem::align_of::<dql>(),
            64usize,
            concat!("Alignment of ", stringify!(dql))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dql>())).num_queued as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(dql),
                "::",
                stringify!(num_queued)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dql>())).adj_limit as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(dql),
                "::",
                stringify!(adj_limit)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dql>())).last_obj_cnt as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(dql),
                "::",
                stringify!(last_obj_cnt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dql>())).limit as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(dql),
                "::",
                stringify!(limit)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dql>())).num_completed as *const _ as usize },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(dql),
                "::",
                stringify!(num_completed)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dql>())).prev_ovlimit as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(dql),
                "::",
                stringify!(prev_ovlimit)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dql>())).prev_num_queued as *const _ as usize },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(dql),
                "::",
                stringify!(prev_num_queued)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dql>())).prev_last_obj_cnt as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(dql),
                "::",
                stringify!(prev_last_obj_cnt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dql>())).lowest_slack as *const _ as usize },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(dql),
                "::",
                stringify!(lowest_slack)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dql>())).slack_start_time as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(dql),
                "::",
                stringify!(slack_start_time)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dql>())).max_limit as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(dql),
                "::",
                stringify!(max_limit)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dql>())).min_limit as *const _ as usize },
            100usize,
            concat!(
                "Offset of field: ",
                stringify!(dql),
                "::",
                stringify!(min_limit)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dql>())).slack_hold_time as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(dql),
                "::",
                stringify!(slack_hold_time)
            )
        );
    }
    pub type proc_handler = ::core::option::Option<
        unsafe extern "C" fn(
            ctl: *mut ctl_table,
            write: ::cty::c_int,
            buffer: *mut ::cty::c_void,
            lenp: *mut size_t,
            ppos: *mut loff_t,
        ) -> ::cty::c_int,
    >;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct ctl_table_poll {
        pub event: atomic_t,
        pub wait: wait_queue_head_t,
    }
    #[test]
    fn bindgen_test_layout_ctl_table_poll() {
        assert_eq!(
            ::core::mem::size_of::<ctl_table_poll>(),
            32usize,
            concat!("Size of: ", stringify!(ctl_table_poll))
        );
        assert_eq!(
            ::core::mem::align_of::<ctl_table_poll>(),
            8usize,
            concat!("Alignment of ", stringify!(ctl_table_poll))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ctl_table_poll>())).event as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ctl_table_poll),
                "::",
                stringify!(event)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ctl_table_poll>())).wait as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ctl_table_poll),
                "::",
                stringify!(wait)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ctl_table {
        pub procname: *const ::cty::c_char,
        pub data: *mut ::cty::c_void,
        pub maxlen: ::cty::c_int,
        pub mode: umode_t,
        pub type_: ctl_table__bindgen_ty_1,
        pub proc_handler: proc_handler,
        pub poll: *mut ctl_table_poll,
        pub extra1: *mut ::cty::c_void,
        pub extra2: *mut ::cty::c_void,
    }
    pub const ctl_table_SYSCTL_TABLE_TYPE_DEFAULT: ::cty::c_uint = 0;
    pub const ctl_table_SYSCTL_TABLE_TYPE_PERMANENTLY_EMPTY: ::cty::c_uint = 1;
    #[doc = " enum type - Enumeration to differentiate between ctl target types"]
    #[doc = " @SYSCTL_TABLE_TYPE_DEFAULT: ctl target with no special considerations"]
    #[doc = " @SYSCTL_TABLE_TYPE_PERMANENTLY_EMPTY: Used to identify a permanently"]
    #[doc = "                                       empty directory target to serve"]
    #[doc = "                                       as mount point."]
    pub type ctl_table__bindgen_ty_1 = ::cty::c_uint;
    #[test]
    fn bindgen_test_layout_ctl_table() {
        assert_eq!(
            ::core::mem::size_of::<ctl_table>(),
            64usize,
            concat!("Size of: ", stringify!(ctl_table))
        );
        assert_eq!(
            ::core::mem::align_of::<ctl_table>(),
            8usize,
            concat!("Alignment of ", stringify!(ctl_table))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ctl_table>())).procname as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ctl_table),
                "::",
                stringify!(procname)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ctl_table>())).data as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ctl_table),
                "::",
                stringify!(data)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ctl_table>())).maxlen as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ctl_table),
                "::",
                stringify!(maxlen)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ctl_table>())).mode as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(ctl_table),
                "::",
                stringify!(mode)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ctl_table>())).type_ as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(ctl_table),
                "::",
                stringify!(type_)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ctl_table>())).proc_handler as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(ctl_table),
                "::",
                stringify!(proc_handler)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ctl_table>())).poll as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(ctl_table),
                "::",
                stringify!(poll)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ctl_table>())).extra1 as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(ctl_table),
                "::",
                stringify!(extra1)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ctl_table>())).extra2 as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(ctl_table),
                "::",
                stringify!(extra2)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ctl_node {
        pub node: rb_node,
        pub header: *mut ctl_table_header,
    }
    #[test]
    fn bindgen_test_layout_ctl_node() {
        assert_eq!(
            ::core::mem::size_of::<ctl_node>(),
            32usize,
            concat!("Size of: ", stringify!(ctl_node))
        );
        assert_eq!(
            ::core::mem::align_of::<ctl_node>(),
            8usize,
            concat!("Alignment of ", stringify!(ctl_node))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ctl_node>())).node as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ctl_node),
                "::",
                stringify!(node)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ctl_node>())).header as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(ctl_node),
                "::",
                stringify!(header)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct ctl_table_header {
        pub __bindgen_anon_1: ctl_table_header__bindgen_ty_1,
        pub unregistering: *mut completion,
        pub ctl_table_arg: *mut ctl_table,
        pub root: *mut ctl_table_root,
        pub set: *mut ctl_table_set,
        pub parent: *mut ctl_dir,
        pub node: *mut ctl_node,
        pub inodes: hlist_head,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union ctl_table_header__bindgen_ty_1 {
        pub __bindgen_anon_1: ctl_table_header__bindgen_ty_1__bindgen_ty_1,
        pub rcu: callback_head,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ctl_table_header__bindgen_ty_1__bindgen_ty_1 {
        pub ctl_table: *mut ctl_table,
        pub used: ::cty::c_int,
        pub count: ::cty::c_int,
        pub nreg: ::cty::c_int,
    }
    #[test]
    fn bindgen_test_layout_ctl_table_header__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<ctl_table_header__bindgen_ty_1__bindgen_ty_1>(),
            24usize,
            concat!(
                "Size of: ",
                stringify!(ctl_table_header__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<ctl_table_header__bindgen_ty_1__bindgen_ty_1>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(ctl_table_header__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ctl_table_header__bindgen_ty_1__bindgen_ty_1>())).ctl_table
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ctl_table_header__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(ctl_table)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ctl_table_header__bindgen_ty_1__bindgen_ty_1>())).used
                    as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ctl_table_header__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(used)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ctl_table_header__bindgen_ty_1__bindgen_ty_1>())).count
                    as *const _ as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(ctl_table_header__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(count)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ctl_table_header__bindgen_ty_1__bindgen_ty_1>())).nreg
                    as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ctl_table_header__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(nreg)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_ctl_table_header__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<ctl_table_header__bindgen_ty_1>(),
            24usize,
            concat!("Size of: ", stringify!(ctl_table_header__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<ctl_table_header__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(ctl_table_header__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ctl_table_header__bindgen_ty_1>())).rcu as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ctl_table_header__bindgen_ty_1),
                "::",
                stringify!(rcu)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_ctl_table_header() {
        assert_eq!(
            ::core::mem::size_of::<ctl_table_header>(),
            80usize,
            concat!("Size of: ", stringify!(ctl_table_header))
        );
        assert_eq!(
            ::core::mem::align_of::<ctl_table_header>(),
            8usize,
            concat!("Alignment of ", stringify!(ctl_table_header))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ctl_table_header>())).unregistering as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(ctl_table_header),
                "::",
                stringify!(unregistering)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ctl_table_header>())).ctl_table_arg as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(ctl_table_header),
                "::",
                stringify!(ctl_table_arg)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ctl_table_header>())).root as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(ctl_table_header),
                "::",
                stringify!(root)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ctl_table_header>())).set as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(ctl_table_header),
                "::",
                stringify!(set)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ctl_table_header>())).parent as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(ctl_table_header),
                "::",
                stringify!(parent)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ctl_table_header>())).node as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(ctl_table_header),
                "::",
                stringify!(node)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ctl_table_header>())).inodes as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(ctl_table_header),
                "::",
                stringify!(inodes)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct ctl_dir {
        pub header: ctl_table_header,
        pub root: rb_root,
    }
    #[test]
    fn bindgen_test_layout_ctl_dir() {
        assert_eq!(
            ::core::mem::size_of::<ctl_dir>(),
            88usize,
            concat!("Size of: ", stringify!(ctl_dir))
        );
        assert_eq!(
            ::core::mem::align_of::<ctl_dir>(),
            8usize,
            concat!("Alignment of ", stringify!(ctl_dir))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ctl_dir>())).header as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ctl_dir),
                "::",
                stringify!(header)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ctl_dir>())).root as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(ctl_dir),
                "::",
                stringify!(root)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct ctl_table_set {
        pub is_seen:
            ::core::option::Option<unsafe extern "C" fn(arg1: *mut ctl_table_set) -> ::cty::c_int>,
        pub dir: ctl_dir,
    }
    #[test]
    fn bindgen_test_layout_ctl_table_set() {
        assert_eq!(
            ::core::mem::size_of::<ctl_table_set>(),
            96usize,
            concat!("Size of: ", stringify!(ctl_table_set))
        );
        assert_eq!(
            ::core::mem::align_of::<ctl_table_set>(),
            8usize,
            concat!("Alignment of ", stringify!(ctl_table_set))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ctl_table_set>())).is_seen as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ctl_table_set),
                "::",
                stringify!(is_seen)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ctl_table_set>())).dir as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ctl_table_set),
                "::",
                stringify!(dir)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct ctl_table_root {
        pub default_set: ctl_table_set,
        pub lookup: ::core::option::Option<
            unsafe extern "C" fn(root: *mut ctl_table_root) -> *mut ctl_table_set,
        >,
        pub set_ownership: ::core::option::Option<
            unsafe extern "C" fn(
                head: *mut ctl_table_header,
                table: *mut ctl_table,
                uid: *mut kuid_t,
                gid: *mut kgid_t,
            ),
        >,
        pub permissions: ::core::option::Option<
            unsafe extern "C" fn(
                head: *mut ctl_table_header,
                table: *mut ctl_table,
            ) -> ::cty::c_int,
        >,
    }
    #[test]
    fn bindgen_test_layout_ctl_table_root() {
        assert_eq!(
            ::core::mem::size_of::<ctl_table_root>(),
            120usize,
            concat!("Size of: ", stringify!(ctl_table_root))
        );
        assert_eq!(
            ::core::mem::align_of::<ctl_table_root>(),
            8usize,
            concat!("Alignment of ", stringify!(ctl_table_root))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ctl_table_root>())).default_set as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ctl_table_root),
                "::",
                stringify!(default_set)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ctl_table_root>())).lookup as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(ctl_table_root),
                "::",
                stringify!(lookup)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ctl_table_root>())).set_ownership as *const _ as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(ctl_table_root),
                "::",
                stringify!(set_ownership)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ctl_table_root>())).permissions as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(ctl_table_root),
                "::",
                stringify!(permissions)
            )
        );
    }
    #[doc = " csum_ipv6_magic - Compute checksum of an IPv6 pseudo header."]
    #[doc = " @saddr: source address"]
    #[doc = " @daddr: destination address"]
    #[doc = " @len: length of packet"]
    #[doc = " @proto: protocol of packet"]
    #[doc = " @sum: initial sum (32bit unfolded) to be added in"]
    #[doc = ""]
    #[doc = " Computes an IPv6 pseudo header checksum. This sum is added the checksum"]
    #[doc = " into UDP/TCP packets and contains some link layer information."]
    #[doc = " Returns the unfolded 32bit checksum."]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct in6_addr {
        pub in6_u: in6_addr__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union in6_addr__bindgen_ty_1 {
        pub u6_addr8: [__u8; 16usize],
        pub u6_addr16: [__be16; 8usize],
        pub u6_addr32: [__be32; 4usize],
    }
    #[test]
    fn bindgen_test_layout_in6_addr__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<in6_addr__bindgen_ty_1>(),
            16usize,
            concat!("Size of: ", stringify!(in6_addr__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<in6_addr__bindgen_ty_1>(),
            4usize,
            concat!("Alignment of ", stringify!(in6_addr__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<in6_addr__bindgen_ty_1>())).u6_addr8 as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(in6_addr__bindgen_ty_1),
                "::",
                stringify!(u6_addr8)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<in6_addr__bindgen_ty_1>())).u6_addr16 as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(in6_addr__bindgen_ty_1),
                "::",
                stringify!(u6_addr16)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<in6_addr__bindgen_ty_1>())).u6_addr32 as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(in6_addr__bindgen_ty_1),
                "::",
                stringify!(u6_addr32)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_in6_addr() {
        assert_eq!(
            ::core::mem::size_of::<in6_addr>(),
            16usize,
            concat!("Size of: ", stringify!(in6_addr))
        );
        assert_eq!(
            ::core::mem::align_of::<in6_addr>(),
            4usize,
            concat!("Alignment of ", stringify!(in6_addr))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<in6_addr>())).in6_u as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(in6_addr),
                "::",
                stringify!(in6_u)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct flowi_tunnel {
        pub tun_id: __be64,
    }
    #[test]
    fn bindgen_test_layout_flowi_tunnel() {
        assert_eq!(
            ::core::mem::size_of::<flowi_tunnel>(),
            8usize,
            concat!("Size of: ", stringify!(flowi_tunnel))
        );
        assert_eq!(
            ::core::mem::align_of::<flowi_tunnel>(),
            8usize,
            concat!("Alignment of ", stringify!(flowi_tunnel))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<flowi_tunnel>())).tun_id as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(flowi_tunnel),
                "::",
                stringify!(tun_id)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct flowi_common {
        pub flowic_oif: ::cty::c_int,
        pub flowic_iif: ::cty::c_int,
        pub flowic_l3mdev: ::cty::c_int,
        pub flowic_mark: __u32,
        pub flowic_tos: __u8,
        pub flowic_scope: __u8,
        pub flowic_proto: __u8,
        pub flowic_flags: __u8,
        pub flowic_secid: __u32,
        pub flowic_uid: kuid_t,
        pub flowic_tun_key: flowi_tunnel,
        pub flowic_multipath_hash: __u32,
    }
    #[test]
    fn bindgen_test_layout_flowi_common() {
        assert_eq!(
            ::core::mem::size_of::<flowi_common>(),
            48usize,
            concat!("Size of: ", stringify!(flowi_common))
        );
        assert_eq!(
            ::core::mem::align_of::<flowi_common>(),
            8usize,
            concat!("Alignment of ", stringify!(flowi_common))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<flowi_common>())).flowic_oif as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(flowi_common),
                "::",
                stringify!(flowic_oif)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<flowi_common>())).flowic_iif as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(flowi_common),
                "::",
                stringify!(flowic_iif)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<flowi_common>())).flowic_l3mdev as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(flowi_common),
                "::",
                stringify!(flowic_l3mdev)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<flowi_common>())).flowic_mark as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(flowi_common),
                "::",
                stringify!(flowic_mark)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<flowi_common>())).flowic_tos as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(flowi_common),
                "::",
                stringify!(flowic_tos)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<flowi_common>())).flowic_scope as *const _ as usize },
            17usize,
            concat!(
                "Offset of field: ",
                stringify!(flowi_common),
                "::",
                stringify!(flowic_scope)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<flowi_common>())).flowic_proto as *const _ as usize },
            18usize,
            concat!(
                "Offset of field: ",
                stringify!(flowi_common),
                "::",
                stringify!(flowic_proto)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<flowi_common>())).flowic_flags as *const _ as usize },
            19usize,
            concat!(
                "Offset of field: ",
                stringify!(flowi_common),
                "::",
                stringify!(flowic_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<flowi_common>())).flowic_secid as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(flowi_common),
                "::",
                stringify!(flowic_secid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<flowi_common>())).flowic_uid as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(flowi_common),
                "::",
                stringify!(flowic_uid)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<flowi_common>())).flowic_tun_key as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(flowi_common),
                "::",
                stringify!(flowic_tun_key)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<flowi_common>())).flowic_multipath_hash as *const _ as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(flowi_common),
                "::",
                stringify!(flowic_multipath_hash)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union flowi_uli {
        pub ports: flowi_uli__bindgen_ty_1,
        pub icmpt: flowi_uli__bindgen_ty_2,
        pub gre_key: __be32,
        pub mht: flowi_uli__bindgen_ty_3,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct flowi_uli__bindgen_ty_1 {
        pub dport: __be16,
        pub sport: __be16,
    }
    #[test]
    fn bindgen_test_layout_flowi_uli__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<flowi_uli__bindgen_ty_1>(),
            4usize,
            concat!("Size of: ", stringify!(flowi_uli__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<flowi_uli__bindgen_ty_1>(),
            2usize,
            concat!("Alignment of ", stringify!(flowi_uli__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<flowi_uli__bindgen_ty_1>())).dport as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(flowi_uli__bindgen_ty_1),
                "::",
                stringify!(dport)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<flowi_uli__bindgen_ty_1>())).sport as *const _ as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(flowi_uli__bindgen_ty_1),
                "::",
                stringify!(sport)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct flowi_uli__bindgen_ty_2 {
        pub type_: __u8,
        pub code: __u8,
    }
    #[test]
    fn bindgen_test_layout_flowi_uli__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<flowi_uli__bindgen_ty_2>(),
            2usize,
            concat!("Size of: ", stringify!(flowi_uli__bindgen_ty_2))
        );
        assert_eq!(
            ::core::mem::align_of::<flowi_uli__bindgen_ty_2>(),
            1usize,
            concat!("Alignment of ", stringify!(flowi_uli__bindgen_ty_2))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<flowi_uli__bindgen_ty_2>())).type_ as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(flowi_uli__bindgen_ty_2),
                "::",
                stringify!(type_)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<flowi_uli__bindgen_ty_2>())).code as *const _ as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(flowi_uli__bindgen_ty_2),
                "::",
                stringify!(code)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct flowi_uli__bindgen_ty_3 {
        pub type_: __u8,
    }
    #[test]
    fn bindgen_test_layout_flowi_uli__bindgen_ty_3() {
        assert_eq!(
            ::core::mem::size_of::<flowi_uli__bindgen_ty_3>(),
            1usize,
            concat!("Size of: ", stringify!(flowi_uli__bindgen_ty_3))
        );
        assert_eq!(
            ::core::mem::align_of::<flowi_uli__bindgen_ty_3>(),
            1usize,
            concat!("Alignment of ", stringify!(flowi_uli__bindgen_ty_3))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<flowi_uli__bindgen_ty_3>())).type_ as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(flowi_uli__bindgen_ty_3),
                "::",
                stringify!(type_)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_flowi_uli() {
        assert_eq!(
            ::core::mem::size_of::<flowi_uli>(),
            4usize,
            concat!("Size of: ", stringify!(flowi_uli))
        );
        assert_eq!(
            ::core::mem::align_of::<flowi_uli>(),
            4usize,
            concat!("Alignment of ", stringify!(flowi_uli))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<flowi_uli>())).ports as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(flowi_uli),
                "::",
                stringify!(ports)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<flowi_uli>())).icmpt as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(flowi_uli),
                "::",
                stringify!(icmpt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<flowi_uli>())).gre_key as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(flowi_uli),
                "::",
                stringify!(gre_key)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<flowi_uli>())).mht as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(flowi_uli),
                "::",
                stringify!(mht)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct flowi4 {
        pub __fl_common: flowi_common,
        pub saddr: __be32,
        pub daddr: __be32,
        pub uli: flowi_uli,
    }
    #[test]
    fn bindgen_test_layout_flowi4() {
        assert_eq!(
            ::core::mem::size_of::<flowi4>(),
            64usize,
            concat!("Size of: ", stringify!(flowi4))
        );
        assert_eq!(
            ::core::mem::align_of::<flowi4>(),
            8usize,
            concat!("Alignment of ", stringify!(flowi4))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<flowi4>())).__fl_common as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(flowi4),
                "::",
                stringify!(__fl_common)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<flowi4>())).saddr as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(flowi4),
                "::",
                stringify!(saddr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<flowi4>())).daddr as *const _ as usize },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(flowi4),
                "::",
                stringify!(daddr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<flowi4>())).uli as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(flowi4),
                "::",
                stringify!(uli)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct flowi6 {
        pub __fl_common: flowi_common,
        pub daddr: in6_addr,
        pub saddr: in6_addr,
        pub flowlabel: __be32,
        pub uli: flowi_uli,
        pub mp_hash: __u32,
    }
    #[test]
    fn bindgen_test_layout_flowi6() {
        assert_eq!(
            ::core::mem::size_of::<flowi6>(),
            96usize,
            concat!("Size of: ", stringify!(flowi6))
        );
        assert_eq!(
            ::core::mem::align_of::<flowi6>(),
            8usize,
            concat!("Alignment of ", stringify!(flowi6))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<flowi6>())).__fl_common as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(flowi6),
                "::",
                stringify!(__fl_common)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<flowi6>())).daddr as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(flowi6),
                "::",
                stringify!(daddr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<flowi6>())).saddr as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(flowi6),
                "::",
                stringify!(saddr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<flowi6>())).flowlabel as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(flowi6),
                "::",
                stringify!(flowlabel)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<flowi6>())).uli as *const _ as usize },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(flowi6),
                "::",
                stringify!(uli)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<flowi6>())).mp_hash as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(flowi6),
                "::",
                stringify!(mp_hash)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct flowi {
        pub u: flowi__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union flowi__bindgen_ty_1 {
        pub __fl_common: flowi_common,
        pub ip4: flowi4,
        pub ip6: flowi6,
    }
    #[test]
    fn bindgen_test_layout_flowi__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<flowi__bindgen_ty_1>(),
            96usize,
            concat!("Size of: ", stringify!(flowi__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<flowi__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(flowi__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<flowi__bindgen_ty_1>())).__fl_common as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(flowi__bindgen_ty_1),
                "::",
                stringify!(__fl_common)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<flowi__bindgen_ty_1>())).ip4 as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(flowi__bindgen_ty_1),
                "::",
                stringify!(ip4)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<flowi__bindgen_ty_1>())).ip6 as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(flowi__bindgen_ty_1),
                "::",
                stringify!(ip6)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_flowi() {
        assert_eq!(
            ::core::mem::size_of::<flowi>(),
            96usize,
            concat!("Size of: ", stringify!(flowi))
        );
        assert_eq!(
            ::core::mem::align_of::<flowi>(),
            8usize,
            concat!("Alignment of ", stringify!(flowi))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<flowi>())).u as *const _ as usize },
            0usize,
            concat!("Offset of field: ", stringify!(flowi), "::", stringify!(u))
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct netns_core {
        pub sysctl_hdr: *mut ctl_table_header,
        pub sysctl_somaxconn: ::cty::c_int,
        pub sysctl_txrehash: _cargo_bpf_u8,
        pub prot_inuse: *mut prot_inuse,
        pub rps_default_mask: *mut cpumask,
    }
    #[test]
    fn bindgen_test_layout_netns_core() {
        assert_eq!(
            ::core::mem::size_of::<netns_core>(),
            32usize,
            concat!("Size of: ", stringify!(netns_core))
        );
        assert_eq!(
            ::core::mem::align_of::<netns_core>(),
            8usize,
            concat!("Alignment of ", stringify!(netns_core))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_core>())).sysctl_hdr as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_core),
                "::",
                stringify!(sysctl_hdr)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_core>())).sysctl_somaxconn as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_core),
                "::",
                stringify!(sysctl_somaxconn)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_core>())).sysctl_txrehash as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_core),
                "::",
                stringify!(sysctl_txrehash)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_core>())).prot_inuse as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_core),
                "::",
                stringify!(prot_inuse)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_core>())).rps_default_mask as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_core),
                "::",
                stringify!(rps_default_mask)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct u64_stats_sync {}
    #[test]
    fn bindgen_test_layout_u64_stats_sync() {
        assert_eq!(
            ::core::mem::size_of::<u64_stats_sync>(),
            0usize,
            concat!("Size of: ", stringify!(u64_stats_sync))
        );
        assert_eq!(
            ::core::mem::align_of::<u64_stats_sync>(),
            1usize,
            concat!("Alignment of ", stringify!(u64_stats_sync))
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct local64_t {
        pub a: local_t,
    }
    #[test]
    fn bindgen_test_layout_local64_t() {
        assert_eq!(
            ::core::mem::size_of::<local64_t>(),
            8usize,
            concat!("Size of: ", stringify!(local64_t))
        );
        assert_eq!(
            ::core::mem::align_of::<local64_t>(),
            8usize,
            concat!("Alignment of ", stringify!(local64_t))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<local64_t>())).a as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(local64_t),
                "::",
                stringify!(a)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct u64_stats_t {
        pub v: local64_t,
    }
    #[test]
    fn bindgen_test_layout_u64_stats_t() {
        assert_eq!(
            ::core::mem::size_of::<u64_stats_t>(),
            8usize,
            concat!("Size of: ", stringify!(u64_stats_t))
        );
        assert_eq!(
            ::core::mem::align_of::<u64_stats_t>(),
            8usize,
            concat!("Alignment of ", stringify!(u64_stats_t))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<u64_stats_t>())).v as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(u64_stats_t),
                "::",
                stringify!(v)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ipstats_mib {
        pub mibs: [_cargo_bpf_u64; 37usize],
        pub syncp: u64_stats_sync,
    }
    #[test]
    fn bindgen_test_layout_ipstats_mib() {
        assert_eq!(
            ::core::mem::size_of::<ipstats_mib>(),
            296usize,
            concat!("Size of: ", stringify!(ipstats_mib))
        );
        assert_eq!(
            ::core::mem::align_of::<ipstats_mib>(),
            8usize,
            concat!("Alignment of ", stringify!(ipstats_mib))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ipstats_mib>())).mibs as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ipstats_mib),
                "::",
                stringify!(mibs)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ipstats_mib>())).syncp as *const _ as usize },
            296usize,
            concat!(
                "Offset of field: ",
                stringify!(ipstats_mib),
                "::",
                stringify!(syncp)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct icmp_mib {
        pub mibs: [::cty::c_ulong; 30usize],
    }
    #[test]
    fn bindgen_test_layout_icmp_mib() {
        assert_eq!(
            ::core::mem::size_of::<icmp_mib>(),
            240usize,
            concat!("Size of: ", stringify!(icmp_mib))
        );
        assert_eq!(
            ::core::mem::align_of::<icmp_mib>(),
            8usize,
            concat!("Alignment of ", stringify!(icmp_mib))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<icmp_mib>())).mibs as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(icmp_mib),
                "::",
                stringify!(mibs)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct icmpmsg_mib {
        pub mibs: [atomic_long_t; 512usize],
    }
    #[test]
    fn bindgen_test_layout_icmpmsg_mib() {
        assert_eq!(
            ::core::mem::size_of::<icmpmsg_mib>(),
            4096usize,
            concat!("Size of: ", stringify!(icmpmsg_mib))
        );
        assert_eq!(
            ::core::mem::align_of::<icmpmsg_mib>(),
            8usize,
            concat!("Alignment of ", stringify!(icmpmsg_mib))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<icmpmsg_mib>())).mibs as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(icmpmsg_mib),
                "::",
                stringify!(mibs)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct icmpv6_mib {
        pub mibs: [::cty::c_ulong; 7usize],
    }
    #[test]
    fn bindgen_test_layout_icmpv6_mib() {
        assert_eq!(
            ::core::mem::size_of::<icmpv6_mib>(),
            56usize,
            concat!("Size of: ", stringify!(icmpv6_mib))
        );
        assert_eq!(
            ::core::mem::align_of::<icmpv6_mib>(),
            8usize,
            concat!("Alignment of ", stringify!(icmpv6_mib))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<icmpv6_mib>())).mibs as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(icmpv6_mib),
                "::",
                stringify!(mibs)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct icmpv6msg_mib {
        pub mibs: [atomic_long_t; 512usize],
    }
    #[test]
    fn bindgen_test_layout_icmpv6msg_mib() {
        assert_eq!(
            ::core::mem::size_of::<icmpv6msg_mib>(),
            4096usize,
            concat!("Size of: ", stringify!(icmpv6msg_mib))
        );
        assert_eq!(
            ::core::mem::align_of::<icmpv6msg_mib>(),
            8usize,
            concat!("Alignment of ", stringify!(icmpv6msg_mib))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<icmpv6msg_mib>())).mibs as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(icmpv6msg_mib),
                "::",
                stringify!(mibs)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct tcp_mib {
        pub mibs: [::cty::c_ulong; 16usize],
    }
    #[test]
    fn bindgen_test_layout_tcp_mib() {
        assert_eq!(
            ::core::mem::size_of::<tcp_mib>(),
            128usize,
            concat!("Size of: ", stringify!(tcp_mib))
        );
        assert_eq!(
            ::core::mem::align_of::<tcp_mib>(),
            8usize,
            concat!("Alignment of ", stringify!(tcp_mib))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_mib>())).mibs as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_mib),
                "::",
                stringify!(mibs)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct udp_mib {
        pub mibs: [::cty::c_ulong; 10usize],
    }
    #[test]
    fn bindgen_test_layout_udp_mib() {
        assert_eq!(
            ::core::mem::size_of::<udp_mib>(),
            80usize,
            concat!("Size of: ", stringify!(udp_mib))
        );
        assert_eq!(
            ::core::mem::align_of::<udp_mib>(),
            8usize,
            concat!("Alignment of ", stringify!(udp_mib))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<udp_mib>())).mibs as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(udp_mib),
                "::",
                stringify!(mibs)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct linux_mib {
        pub mibs: [::cty::c_ulong; 127usize],
    }
    #[test]
    fn bindgen_test_layout_linux_mib() {
        assert_eq!(
            ::core::mem::size_of::<linux_mib>(),
            1016usize,
            concat!("Size of: ", stringify!(linux_mib))
        );
        assert_eq!(
            ::core::mem::align_of::<linux_mib>(),
            8usize,
            concat!("Alignment of ", stringify!(linux_mib))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<linux_mib>())).mibs as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(linux_mib),
                "::",
                stringify!(mibs)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct linux_xfrm_mib {
        pub mibs: [::cty::c_ulong; 29usize],
    }
    #[test]
    fn bindgen_test_layout_linux_xfrm_mib() {
        assert_eq!(
            ::core::mem::size_of::<linux_xfrm_mib>(),
            232usize,
            concat!("Size of: ", stringify!(linux_xfrm_mib))
        );
        assert_eq!(
            ::core::mem::align_of::<linux_xfrm_mib>(),
            8usize,
            concat!("Alignment of ", stringify!(linux_xfrm_mib))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<linux_xfrm_mib>())).mibs as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(linux_xfrm_mib),
                "::",
                stringify!(mibs)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct linux_tls_mib {
        pub mibs: [::cty::c_ulong; 13usize],
    }
    #[test]
    fn bindgen_test_layout_linux_tls_mib() {
        assert_eq!(
            ::core::mem::size_of::<linux_tls_mib>(),
            104usize,
            concat!("Size of: ", stringify!(linux_tls_mib))
        );
        assert_eq!(
            ::core::mem::align_of::<linux_tls_mib>(),
            8usize,
            concat!("Alignment of ", stringify!(linux_tls_mib))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<linux_tls_mib>())).mibs as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(linux_tls_mib),
                "::",
                stringify!(mibs)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct netns_mib {
        pub ip_statistics: *mut ipstats_mib,
        pub ipv6_statistics: *mut ipstats_mib,
        pub tcp_statistics: *mut tcp_mib,
        pub net_statistics: *mut linux_mib,
        pub udp_statistics: *mut udp_mib,
        pub udp_stats_in6: *mut udp_mib,
        pub xfrm_statistics: *mut linux_xfrm_mib,
        pub tls_statistics: *mut linux_tls_mib,
        pub mptcp_statistics: *mut mptcp_mib,
        pub udplite_statistics: *mut udp_mib,
        pub udplite_stats_in6: *mut udp_mib,
        pub icmp_statistics: *mut icmp_mib,
        pub icmpmsg_statistics: *mut icmpmsg_mib,
        pub icmpv6_statistics: *mut icmpv6_mib,
        pub icmpv6msg_statistics: *mut icmpv6msg_mib,
        pub proc_net_devsnmp6: *mut proc_dir_entry,
    }
    #[test]
    fn bindgen_test_layout_netns_mib() {
        assert_eq!(
            ::core::mem::size_of::<netns_mib>(),
            128usize,
            concat!("Size of: ", stringify!(netns_mib))
        );
        assert_eq!(
            ::core::mem::align_of::<netns_mib>(),
            8usize,
            concat!("Alignment of ", stringify!(netns_mib))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_mib>())).ip_statistics as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_mib),
                "::",
                stringify!(ip_statistics)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_mib>())).ipv6_statistics as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_mib),
                "::",
                stringify!(ipv6_statistics)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_mib>())).tcp_statistics as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_mib),
                "::",
                stringify!(tcp_statistics)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_mib>())).net_statistics as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_mib),
                "::",
                stringify!(net_statistics)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_mib>())).udp_statistics as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_mib),
                "::",
                stringify!(udp_statistics)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_mib>())).udp_stats_in6 as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_mib),
                "::",
                stringify!(udp_stats_in6)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_mib>())).xfrm_statistics as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_mib),
                "::",
                stringify!(xfrm_statistics)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_mib>())).tls_statistics as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_mib),
                "::",
                stringify!(tls_statistics)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_mib>())).mptcp_statistics as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_mib),
                "::",
                stringify!(mptcp_statistics)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_mib>())).udplite_statistics as *const _ as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_mib),
                "::",
                stringify!(udplite_statistics)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_mib>())).udplite_stats_in6 as *const _ as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_mib),
                "::",
                stringify!(udplite_stats_in6)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_mib>())).icmp_statistics as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_mib),
                "::",
                stringify!(icmp_statistics)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_mib>())).icmpmsg_statistics as *const _ as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_mib),
                "::",
                stringify!(icmpmsg_statistics)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_mib>())).icmpv6_statistics as *const _ as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_mib),
                "::",
                stringify!(icmpv6_statistics)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_mib>())).icmpv6msg_statistics as *const _ as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_mib),
                "::",
                stringify!(icmpv6msg_statistics)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_mib>())).proc_net_devsnmp6 as *const _ as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_mib),
                "::",
                stringify!(proc_net_devsnmp6)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct unix_table {
        pub locks: *mut spinlock_t,
        pub buckets: *mut hlist_head,
    }
    #[test]
    fn bindgen_test_layout_unix_table() {
        assert_eq!(
            ::core::mem::size_of::<unix_table>(),
            16usize,
            concat!("Size of: ", stringify!(unix_table))
        );
        assert_eq!(
            ::core::mem::align_of::<unix_table>(),
            8usize,
            concat!("Alignment of ", stringify!(unix_table))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<unix_table>())).locks as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(unix_table),
                "::",
                stringify!(locks)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<unix_table>())).buckets as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(unix_table),
                "::",
                stringify!(buckets)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct netns_unix {
        pub table: unix_table,
        pub sysctl_max_dgram_qlen: ::cty::c_int,
        pub ctl: *mut ctl_table_header,
    }
    #[test]
    fn bindgen_test_layout_netns_unix() {
        assert_eq!(
            ::core::mem::size_of::<netns_unix>(),
            32usize,
            concat!("Size of: ", stringify!(netns_unix))
        );
        assert_eq!(
            ::core::mem::align_of::<netns_unix>(),
            8usize,
            concat!("Alignment of ", stringify!(netns_unix))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_unix>())).table as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_unix),
                "::",
                stringify!(table)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_unix>())).sysctl_max_dgram_qlen as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_unix),
                "::",
                stringify!(sysctl_max_dgram_qlen)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_unix>())).ctl as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_unix),
                "::",
                stringify!(ctl)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct netns_packet {
        pub sklist_lock: mutex,
        pub sklist: hlist_head,
    }
    #[test]
    fn bindgen_test_layout_netns_packet() {
        assert_eq!(
            ::core::mem::size_of::<netns_packet>(),
            40usize,
            concat!("Size of: ", stringify!(netns_packet))
        );
        assert_eq!(
            ::core::mem::align_of::<netns_packet>(),
            8usize,
            concat!("Alignment of ", stringify!(netns_packet))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_packet>())).sklist_lock as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_packet),
                "::",
                stringify!(sklist_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_packet>())).sklist as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_packet),
                "::",
                stringify!(sklist)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct swait_queue_head {
        pub lock: raw_spinlock_t,
        pub task_list: list_head,
    }
    #[test]
    fn bindgen_test_layout_swait_queue_head() {
        assert_eq!(
            ::core::mem::size_of::<swait_queue_head>(),
            24usize,
            concat!("Size of: ", stringify!(swait_queue_head))
        );
        assert_eq!(
            ::core::mem::align_of::<swait_queue_head>(),
            8usize,
            concat!("Alignment of ", stringify!(swait_queue_head))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<swait_queue_head>())).lock as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(swait_queue_head),
                "::",
                stringify!(lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<swait_queue_head>())).task_list as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(swait_queue_head),
                "::",
                stringify!(task_list)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct completion {
        pub done: ::cty::c_uint,
        pub wait: swait_queue_head,
    }
    #[test]
    fn bindgen_test_layout_completion() {
        assert_eq!(
            ::core::mem::size_of::<completion>(),
            32usize,
            concat!("Size of: ", stringify!(completion))
        );
        assert_eq!(
            ::core::mem::align_of::<completion>(),
            8usize,
            concat!("Alignment of ", stringify!(completion))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<completion>())).done as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(completion),
                "::",
                stringify!(done)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<completion>())).wait as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(completion),
                "::",
                stringify!(wait)
            )
        );
    }
    #[repr(C)]
    #[repr(align(64))]
    #[derive(Copy, Clone)]
    pub struct fqdir {
        pub high_thresh: ::cty::c_long,
        pub low_thresh: ::cty::c_long,
        pub timeout: ::cty::c_int,
        pub max_dist: ::cty::c_int,
        pub f: *mut inet_frags,
        pub net: *mut net,
        pub dead: bool_,
        pub __bindgen_padding_0: [u64; 2usize],
        pub rhashtable: rhashtable,
        pub __bindgen_padding_1: [u64; 7usize],
        pub mem: atomic_long_t,
        pub destroy_work: work_struct,
        pub free_list: llist_node,
    }
    #[test]
    fn bindgen_test_layout_fqdir() {
        assert_eq!(
            ::core::mem::size_of::<fqdir>(),
            320usize,
            concat!("Size of: ", stringify!(fqdir))
        );
        assert_eq!(
            ::core::mem::align_of::<fqdir>(),
            64usize,
            concat!("Alignment of ", stringify!(fqdir))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fqdir>())).high_thresh as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fqdir),
                "::",
                stringify!(high_thresh)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fqdir>())).low_thresh as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fqdir),
                "::",
                stringify!(low_thresh)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fqdir>())).timeout as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fqdir),
                "::",
                stringify!(timeout)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fqdir>())).max_dist as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(fqdir),
                "::",
                stringify!(max_dist)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fqdir>())).f as *const _ as usize },
            24usize,
            concat!("Offset of field: ", stringify!(fqdir), "::", stringify!(f))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fqdir>())).net as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(fqdir),
                "::",
                stringify!(net)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fqdir>())).dead as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(fqdir),
                "::",
                stringify!(dead)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fqdir>())).rhashtable as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(fqdir),
                "::",
                stringify!(rhashtable)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fqdir>())).mem as *const _ as usize },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(fqdir),
                "::",
                stringify!(mem)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fqdir>())).destroy_work as *const _ as usize },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(fqdir),
                "::",
                stringify!(destroy_work)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fqdir>())).free_list as *const _ as usize },
            296usize,
            concat!(
                "Offset of field: ",
                stringify!(fqdir),
                "::",
                stringify!(free_list)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct frag_v4_compare_key {
        pub saddr: __be32,
        pub daddr: __be32,
        pub user: _cargo_bpf_u32,
        pub vif: _cargo_bpf_u32,
        pub id: __be16,
        pub protocol: _cargo_bpf_u16,
    }
    #[test]
    fn bindgen_test_layout_frag_v4_compare_key() {
        assert_eq!(
            ::core::mem::size_of::<frag_v4_compare_key>(),
            20usize,
            concat!("Size of: ", stringify!(frag_v4_compare_key))
        );
        assert_eq!(
            ::core::mem::align_of::<frag_v4_compare_key>(),
            4usize,
            concat!("Alignment of ", stringify!(frag_v4_compare_key))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<frag_v4_compare_key>())).saddr as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(frag_v4_compare_key),
                "::",
                stringify!(saddr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<frag_v4_compare_key>())).daddr as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(frag_v4_compare_key),
                "::",
                stringify!(daddr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<frag_v4_compare_key>())).user as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(frag_v4_compare_key),
                "::",
                stringify!(user)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<frag_v4_compare_key>())).vif as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(frag_v4_compare_key),
                "::",
                stringify!(vif)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<frag_v4_compare_key>())).id as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(frag_v4_compare_key),
                "::",
                stringify!(id)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<frag_v4_compare_key>())).protocol as *const _ as usize
            },
            18usize,
            concat!(
                "Offset of field: ",
                stringify!(frag_v4_compare_key),
                "::",
                stringify!(protocol)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct frag_v6_compare_key {
        pub saddr: in6_addr,
        pub daddr: in6_addr,
        pub user: _cargo_bpf_u32,
        pub id: __be32,
        pub iif: _cargo_bpf_u32,
    }
    #[test]
    fn bindgen_test_layout_frag_v6_compare_key() {
        assert_eq!(
            ::core::mem::size_of::<frag_v6_compare_key>(),
            44usize,
            concat!("Size of: ", stringify!(frag_v6_compare_key))
        );
        assert_eq!(
            ::core::mem::align_of::<frag_v6_compare_key>(),
            4usize,
            concat!("Alignment of ", stringify!(frag_v6_compare_key))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<frag_v6_compare_key>())).saddr as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(frag_v6_compare_key),
                "::",
                stringify!(saddr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<frag_v6_compare_key>())).daddr as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(frag_v6_compare_key),
                "::",
                stringify!(daddr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<frag_v6_compare_key>())).user as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(frag_v6_compare_key),
                "::",
                stringify!(user)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<frag_v6_compare_key>())).id as *const _ as usize },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(frag_v6_compare_key),
                "::",
                stringify!(id)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<frag_v6_compare_key>())).iif as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(frag_v6_compare_key),
                "::",
                stringify!(iif)
            )
        );
    }
    #[doc = " struct inet_frag_queue - fragment queue"]
    #[doc = ""]
    #[doc = " @node: rhash node"]
    #[doc = " @key: keys identifying this frag."]
    #[doc = " @timer: queue expiration timer"]
    #[doc = " @lock: spinlock protecting this frag"]
    #[doc = " @refcnt: reference count of the queue"]
    #[doc = " @rb_fragments: received fragments rb-tree root"]
    #[doc = " @fragments_tail: received fragments tail"]
    #[doc = " @last_run_head: the head of the last \"run\". see ip_fragment.c"]
    #[doc = " @stamp: timestamp of the last received fragment"]
    #[doc = " @len: total length of the original datagram"]
    #[doc = " @meat: length of received fragments so far"]
    #[doc = " @mono_delivery_time: stamp has a mono delivery time (EDT)"]
    #[doc = " @flags: fragment queue flags"]
    #[doc = " @max_size: maximum received fragment size"]
    #[doc = " @fqdir: pointer to struct fqdir"]
    #[doc = " @rcu: rcu head for freeing deferall"]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct inet_frag_queue {
        pub node: rhash_head,
        pub key: inet_frag_queue__bindgen_ty_1,
        pub timer: timer_list,
        pub lock: spinlock_t,
        pub refcnt: refcount_t,
        pub rb_fragments: rb_root,
        pub fragments_tail: *mut sk_buff,
        pub last_run_head: *mut sk_buff,
        pub stamp: ktime_t,
        pub len: ::cty::c_int,
        pub meat: ::cty::c_int,
        pub mono_delivery_time: _cargo_bpf_u8,
        pub flags: __u8,
        pub max_size: _cargo_bpf_u16,
        pub fqdir: *mut fqdir,
        pub rcu: callback_head,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union inet_frag_queue__bindgen_ty_1 {
        pub v4: frag_v4_compare_key,
        pub v6: frag_v6_compare_key,
    }
    #[test]
    fn bindgen_test_layout_inet_frag_queue__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<inet_frag_queue__bindgen_ty_1>(),
            44usize,
            concat!("Size of: ", stringify!(inet_frag_queue__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<inet_frag_queue__bindgen_ty_1>(),
            4usize,
            concat!("Alignment of ", stringify!(inet_frag_queue__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_frag_queue__bindgen_ty_1>())).v4 as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_frag_queue__bindgen_ty_1),
                "::",
                stringify!(v4)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_frag_queue__bindgen_ty_1>())).v6 as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_frag_queue__bindgen_ty_1),
                "::",
                stringify!(v6)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_inet_frag_queue() {
        assert_eq!(
            ::core::mem::size_of::<inet_frag_queue>(),
            176usize,
            concat!("Size of: ", stringify!(inet_frag_queue))
        );
        assert_eq!(
            ::core::mem::align_of::<inet_frag_queue>(),
            8usize,
            concat!("Alignment of ", stringify!(inet_frag_queue))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_frag_queue>())).node as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_frag_queue),
                "::",
                stringify!(node)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_frag_queue>())).key as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_frag_queue),
                "::",
                stringify!(key)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_frag_queue>())).timer as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_frag_queue),
                "::",
                stringify!(timer)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_frag_queue>())).lock as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_frag_queue),
                "::",
                stringify!(lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_frag_queue>())).refcnt as *const _ as usize },
            100usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_frag_queue),
                "::",
                stringify!(refcnt)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_frag_queue>())).rb_fragments as *const _ as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_frag_queue),
                "::",
                stringify!(rb_fragments)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_frag_queue>())).fragments_tail as *const _ as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_frag_queue),
                "::",
                stringify!(fragments_tail)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_frag_queue>())).last_run_head as *const _ as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_frag_queue),
                "::",
                stringify!(last_run_head)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_frag_queue>())).stamp as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_frag_queue),
                "::",
                stringify!(stamp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_frag_queue>())).len as *const _ as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_frag_queue),
                "::",
                stringify!(len)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_frag_queue>())).meat as *const _ as usize },
            140usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_frag_queue),
                "::",
                stringify!(meat)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_frag_queue>())).mono_delivery_time as *const _ as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_frag_queue),
                "::",
                stringify!(mono_delivery_time)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_frag_queue>())).flags as *const _ as usize },
            145usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_frag_queue),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_frag_queue>())).max_size as *const _ as usize },
            146usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_frag_queue),
                "::",
                stringify!(max_size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_frag_queue>())).fqdir as *const _ as usize },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_frag_queue),
                "::",
                stringify!(fqdir)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_frag_queue>())).rcu as *const _ as usize },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_frag_queue),
                "::",
                stringify!(rcu)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct inet_frags {
        pub qsize: ::cty::c_uint,
        pub constructor: ::core::option::Option<
            unsafe extern "C" fn(q: *mut inet_frag_queue, arg: *const ::cty::c_void),
        >,
        pub destructor: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inet_frag_queue)>,
        pub frag_expire: ::core::option::Option<unsafe extern "C" fn(t: *mut timer_list)>,
        pub frags_cachep: *mut kmem_cache,
        pub frags_cache_name: *const ::cty::c_char,
        pub rhash_params: rhashtable_params,
        pub refcnt: refcount_t,
        pub completion: completion,
    }
    #[test]
    fn bindgen_test_layout_inet_frags() {
        assert_eq!(
            ::core::mem::size_of::<inet_frags>(),
            128usize,
            concat!("Size of: ", stringify!(inet_frags))
        );
        assert_eq!(
            ::core::mem::align_of::<inet_frags>(),
            8usize,
            concat!("Alignment of ", stringify!(inet_frags))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_frags>())).qsize as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_frags),
                "::",
                stringify!(qsize)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_frags>())).constructor as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_frags),
                "::",
                stringify!(constructor)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_frags>())).destructor as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_frags),
                "::",
                stringify!(destructor)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_frags>())).frag_expire as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_frags),
                "::",
                stringify!(frag_expire)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_frags>())).frags_cachep as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_frags),
                "::",
                stringify!(frags_cachep)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_frags>())).frags_cache_name as *const _ as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_frags),
                "::",
                stringify!(frags_cache_name)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_frags>())).rhash_params as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_frags),
                "::",
                stringify!(rhash_params)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_frags>())).refcnt as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_frags),
                "::",
                stringify!(refcnt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_frags>())).completion as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_frags),
                "::",
                stringify!(completion)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct siphash_key_t {
        pub key: [_cargo_bpf_u64; 2usize],
    }
    #[test]
    fn bindgen_test_layout_siphash_key_t() {
        assert_eq!(
            ::core::mem::size_of::<siphash_key_t>(),
            16usize,
            concat!("Size of: ", stringify!(siphash_key_t))
        );
        assert_eq!(
            ::core::mem::align_of::<siphash_key_t>(),
            8usize,
            concat!("Alignment of ", stringify!(siphash_key_t))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<siphash_key_t>())).key as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(siphash_key_t),
                "::",
                stringify!(key)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ipv4_devconf {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct fib_table {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct local_ports {
        pub lock: seqlock_t,
        pub range: [::cty::c_int; 2usize],
        pub warned: bool_,
    }
    #[test]
    fn bindgen_test_layout_local_ports() {
        assert_eq!(
            ::core::mem::size_of::<local_ports>(),
            20usize,
            concat!("Size of: ", stringify!(local_ports))
        );
        assert_eq!(
            ::core::mem::align_of::<local_ports>(),
            4usize,
            concat!("Alignment of ", stringify!(local_ports))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<local_ports>())).lock as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(local_ports),
                "::",
                stringify!(lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<local_ports>())).range as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(local_ports),
                "::",
                stringify!(range)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<local_ports>())).warned as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(local_ports),
                "::",
                stringify!(warned)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct ping_group_range {
        pub lock: seqlock_t,
        pub range: [kgid_t; 2usize],
    }
    #[test]
    fn bindgen_test_layout_ping_group_range() {
        assert_eq!(
            ::core::mem::size_of::<ping_group_range>(),
            16usize,
            concat!("Size of: ", stringify!(ping_group_range))
        );
        assert_eq!(
            ::core::mem::align_of::<ping_group_range>(),
            4usize,
            concat!("Alignment of ", stringify!(ping_group_range))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ping_group_range>())).lock as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ping_group_range),
                "::",
                stringify!(lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ping_group_range>())).range as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ping_group_range),
                "::",
                stringify!(range)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct inet_hashinfo {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[repr(align(64))]
    #[derive(Debug, Copy, Clone)]
    pub struct inet_timewait_death_row {
        pub tw_refcount: refcount_t,
        pub __bindgen_padding_0: [u64; 7usize],
        pub hashinfo: *mut inet_hashinfo,
        pub sysctl_max_tw_buckets: ::cty::c_int,
    }
    #[test]
    fn bindgen_test_layout_inet_timewait_death_row() {
        assert_eq!(
            ::core::mem::size_of::<inet_timewait_death_row>(),
            128usize,
            concat!("Size of: ", stringify!(inet_timewait_death_row))
        );
        assert_eq!(
            ::core::mem::align_of::<inet_timewait_death_row>(),
            64usize,
            concat!("Alignment of ", stringify!(inet_timewait_death_row))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_timewait_death_row>())).tw_refcount as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_timewait_death_row),
                "::",
                stringify!(tw_refcount)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_timewait_death_row>())).hashinfo as *const _ as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_timewait_death_row),
                "::",
                stringify!(hashinfo)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_timewait_death_row>())).sysctl_max_tw_buckets
                    as *const _ as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_timewait_death_row),
                "::",
                stringify!(sysctl_max_tw_buckets)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct tcp_fastopen_context {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[repr(align(64))]
    #[derive(Copy, Clone)]
    pub struct netns_ipv4 {
        pub tcp_death_row: inet_timewait_death_row,
        pub udp_table: *mut udp_table,
        pub forw_hdr: *mut ctl_table_header,
        pub frags_hdr: *mut ctl_table_header,
        pub ipv4_hdr: *mut ctl_table_header,
        pub route_hdr: *mut ctl_table_header,
        pub xfrm4_hdr: *mut ctl_table_header,
        pub devconf_all: *mut ipv4_devconf,
        pub devconf_dflt: *mut ipv4_devconf,
        pub ra_chain: *mut ip_ra_chain,
        pub ra_mutex: mutex,
        pub rules_ops: *mut fib_rules_ops,
        pub fib_main: *mut fib_table,
        pub fib_default: *mut fib_table,
        pub fib_rules_require_fldissect: ::cty::c_uint,
        pub fib_has_custom_rules: bool_,
        pub fib_has_custom_local_routes: bool_,
        pub fib_offload_disabled: bool_,
        pub sysctl_tcp_shrink_window: _cargo_bpf_u8,
        pub fib_num_tclassid_users: atomic_t,
        pub fib_table_hash: *mut hlist_head,
        pub fibnl: *mut sock,
        pub mc_autojoin_sk: *mut sock,
        pub peers: *mut inet_peer_base,
        pub fqdir: *mut fqdir,
        pub sysctl_icmp_echo_ignore_all: _cargo_bpf_u8,
        pub sysctl_icmp_echo_enable_probe: _cargo_bpf_u8,
        pub sysctl_icmp_echo_ignore_broadcasts: _cargo_bpf_u8,
        pub sysctl_icmp_ignore_bogus_error_responses: _cargo_bpf_u8,
        pub sysctl_icmp_errors_use_inbound_ifaddr: _cargo_bpf_u8,
        pub sysctl_icmp_ratelimit: ::cty::c_int,
        pub sysctl_icmp_ratemask: ::cty::c_int,
        pub ip_rt_min_pmtu: _cargo_bpf_u32,
        pub ip_rt_mtu_expires: ::cty::c_int,
        pub ip_rt_min_advmss: ::cty::c_int,
        pub ip_local_ports: local_ports,
        pub sysctl_tcp_ecn: _cargo_bpf_u8,
        pub sysctl_tcp_ecn_fallback: _cargo_bpf_u8,
        pub sysctl_ip_default_ttl: _cargo_bpf_u8,
        pub sysctl_ip_no_pmtu_disc: _cargo_bpf_u8,
        pub sysctl_ip_fwd_use_pmtu: _cargo_bpf_u8,
        pub sysctl_ip_fwd_update_priority: _cargo_bpf_u8,
        pub sysctl_ip_nonlocal_bind: _cargo_bpf_u8,
        pub sysctl_ip_autobind_reuse: _cargo_bpf_u8,
        pub sysctl_ip_dynaddr: _cargo_bpf_u8,
        pub sysctl_ip_early_demux: _cargo_bpf_u8,
        pub sysctl_raw_l3mdev_accept: _cargo_bpf_u8,
        pub sysctl_tcp_early_demux: _cargo_bpf_u8,
        pub sysctl_udp_early_demux: _cargo_bpf_u8,
        pub sysctl_nexthop_compat_mode: _cargo_bpf_u8,
        pub sysctl_fwmark_reflect: _cargo_bpf_u8,
        pub sysctl_tcp_fwmark_accept: _cargo_bpf_u8,
        pub sysctl_tcp_l3mdev_accept: _cargo_bpf_u8,
        pub sysctl_tcp_mtu_probing: _cargo_bpf_u8,
        pub sysctl_tcp_mtu_probe_floor: ::cty::c_int,
        pub sysctl_tcp_base_mss: ::cty::c_int,
        pub sysctl_tcp_min_snd_mss: ::cty::c_int,
        pub sysctl_tcp_probe_threshold: ::cty::c_int,
        pub sysctl_tcp_probe_interval: _cargo_bpf_u32,
        pub sysctl_tcp_keepalive_time: ::cty::c_int,
        pub sysctl_tcp_keepalive_intvl: ::cty::c_int,
        pub sysctl_tcp_keepalive_probes: _cargo_bpf_u8,
        pub sysctl_tcp_syn_retries: _cargo_bpf_u8,
        pub sysctl_tcp_synack_retries: _cargo_bpf_u8,
        pub sysctl_tcp_syncookies: _cargo_bpf_u8,
        pub sysctl_tcp_migrate_req: _cargo_bpf_u8,
        pub sysctl_tcp_comp_sack_nr: _cargo_bpf_u8,
        pub sysctl_tcp_reordering: ::cty::c_int,
        pub sysctl_tcp_retries1: _cargo_bpf_u8,
        pub sysctl_tcp_retries2: _cargo_bpf_u8,
        pub sysctl_tcp_orphan_retries: _cargo_bpf_u8,
        pub sysctl_tcp_tw_reuse: _cargo_bpf_u8,
        pub sysctl_tcp_fin_timeout: ::cty::c_int,
        pub sysctl_tcp_notsent_lowat: ::cty::c_uint,
        pub sysctl_tcp_sack: _cargo_bpf_u8,
        pub sysctl_tcp_window_scaling: _cargo_bpf_u8,
        pub sysctl_tcp_timestamps: _cargo_bpf_u8,
        pub sysctl_tcp_early_retrans: _cargo_bpf_u8,
        pub sysctl_tcp_recovery: _cargo_bpf_u8,
        pub sysctl_tcp_thin_linear_timeouts: _cargo_bpf_u8,
        pub sysctl_tcp_slow_start_after_idle: _cargo_bpf_u8,
        pub sysctl_tcp_retrans_collapse: _cargo_bpf_u8,
        pub sysctl_tcp_stdurg: _cargo_bpf_u8,
        pub sysctl_tcp_rfc1337: _cargo_bpf_u8,
        pub sysctl_tcp_abort_on_overflow: _cargo_bpf_u8,
        pub sysctl_tcp_fack: _cargo_bpf_u8,
        pub sysctl_tcp_max_reordering: ::cty::c_int,
        pub sysctl_tcp_adv_win_scale: ::cty::c_int,
        pub sysctl_tcp_dsack: _cargo_bpf_u8,
        pub sysctl_tcp_app_win: _cargo_bpf_u8,
        pub sysctl_tcp_frto: _cargo_bpf_u8,
        pub sysctl_tcp_nometrics_save: _cargo_bpf_u8,
        pub sysctl_tcp_no_ssthresh_metrics_save: _cargo_bpf_u8,
        pub sysctl_tcp_moderate_rcvbuf: _cargo_bpf_u8,
        pub sysctl_tcp_tso_win_divisor: _cargo_bpf_u8,
        pub sysctl_tcp_workaround_signed_windows: _cargo_bpf_u8,
        pub sysctl_tcp_limit_output_bytes: ::cty::c_int,
        pub sysctl_tcp_challenge_ack_limit: ::cty::c_int,
        pub sysctl_tcp_min_rtt_wlen: ::cty::c_int,
        pub sysctl_tcp_min_tso_segs: _cargo_bpf_u8,
        pub sysctl_tcp_tso_rtt_log: _cargo_bpf_u8,
        pub sysctl_tcp_autocorking: _cargo_bpf_u8,
        pub sysctl_tcp_reflect_tos: _cargo_bpf_u8,
        pub sysctl_tcp_invalid_ratelimit: ::cty::c_int,
        pub sysctl_tcp_pacing_ss_ratio: ::cty::c_int,
        pub sysctl_tcp_pacing_ca_ratio: ::cty::c_int,
        pub sysctl_tcp_wmem: [::cty::c_int; 3usize],
        pub sysctl_tcp_rmem: [::cty::c_int; 3usize],
        pub sysctl_tcp_child_ehash_entries: ::cty::c_uint,
        pub sysctl_tcp_comp_sack_delay_ns: ::cty::c_ulong,
        pub sysctl_tcp_comp_sack_slack_ns: ::cty::c_ulong,
        pub sysctl_max_syn_backlog: ::cty::c_int,
        pub sysctl_tcp_fastopen: ::cty::c_int,
        pub tcp_congestion_control: *const tcp_congestion_ops,
        pub tcp_fastopen_ctx: *mut tcp_fastopen_context,
        pub sysctl_tcp_fastopen_blackhole_timeout: ::cty::c_uint,
        pub tfo_active_disable_times: atomic_t,
        pub tfo_active_disable_stamp: ::cty::c_ulong,
        pub tcp_challenge_timestamp: _cargo_bpf_u32,
        pub tcp_challenge_count: _cargo_bpf_u32,
        pub sysctl_tcp_plb_enabled: _cargo_bpf_u8,
        pub sysctl_tcp_plb_idle_rehash_rounds: _cargo_bpf_u8,
        pub sysctl_tcp_plb_rehash_rounds: _cargo_bpf_u8,
        pub sysctl_tcp_plb_suspend_rto_sec: _cargo_bpf_u8,
        pub sysctl_tcp_plb_cong_thresh: ::cty::c_int,
        pub sysctl_udp_wmem_min: ::cty::c_int,
        pub sysctl_udp_rmem_min: ::cty::c_int,
        pub sysctl_fib_notify_on_flag_change: _cargo_bpf_u8,
        pub sysctl_tcp_syn_linear_timeouts: _cargo_bpf_u8,
        pub sysctl_udp_l3mdev_accept: _cargo_bpf_u8,
        pub sysctl_igmp_llm_reports: _cargo_bpf_u8,
        pub sysctl_igmp_max_memberships: ::cty::c_int,
        pub sysctl_igmp_max_msf: ::cty::c_int,
        pub sysctl_igmp_qrv: ::cty::c_int,
        pub ping_group_range: ping_group_range,
        pub dev_addr_genid: atomic_t,
        pub sysctl_udp_child_hash_entries: ::cty::c_uint,
        pub sysctl_local_reserved_ports: *mut ::cty::c_ulong,
        pub sysctl_ip_prot_sock: ::cty::c_int,
        pub mr_tables: list_head,
        pub mr_rules_ops: *mut fib_rules_ops,
        pub sysctl_fib_multipath_hash_fields: _cargo_bpf_u32,
        pub sysctl_fib_multipath_use_neigh: _cargo_bpf_u8,
        pub sysctl_fib_multipath_hash_policy: _cargo_bpf_u8,
        pub notifier_ops: *mut fib_notifier_ops,
        pub fib_seq: ::cty::c_uint,
        pub ipmr_notifier_ops: *mut fib_notifier_ops,
        pub ipmr_seq: ::cty::c_uint,
        pub rt_genid: atomic_t,
        pub ip_id_key: siphash_key_t,
    }
    #[test]
    fn bindgen_test_layout_netns_ipv4() {
        assert_eq!(
            ::core::mem::size_of::<netns_ipv4>(),
            768usize,
            concat!("Size of: ", stringify!(netns_ipv4))
        );
        assert_eq!(
            ::core::mem::align_of::<netns_ipv4>(),
            64usize,
            concat!("Alignment of ", stringify!(netns_ipv4))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv4>())).tcp_death_row as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(tcp_death_row)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv4>())).udp_table as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(udp_table)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv4>())).forw_hdr as *const _ as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(forw_hdr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv4>())).frags_hdr as *const _ as usize },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(frags_hdr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv4>())).ipv4_hdr as *const _ as usize },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(ipv4_hdr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv4>())).route_hdr as *const _ as usize },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(route_hdr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv4>())).xfrm4_hdr as *const _ as usize },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(xfrm4_hdr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv4>())).devconf_all as *const _ as usize },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(devconf_all)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv4>())).devconf_dflt as *const _ as usize },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(devconf_dflt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv4>())).ra_chain as *const _ as usize },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(ra_chain)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv4>())).ra_mutex as *const _ as usize },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(ra_mutex)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv4>())).rules_ops as *const _ as usize },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(rules_ops)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv4>())).fib_main as *const _ as usize },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(fib_main)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv4>())).fib_default as *const _ as usize },
            248usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(fib_default)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).fib_rules_require_fldissect as *const _
                    as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(fib_rules_require_fldissect)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).fib_has_custom_rules as *const _ as usize
            },
            260usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(fib_has_custom_rules)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).fib_has_custom_local_routes as *const _
                    as usize
            },
            261usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(fib_has_custom_local_routes)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).fib_offload_disabled as *const _ as usize
            },
            262usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(fib_offload_disabled)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_shrink_window as *const _
                    as usize
            },
            263usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_shrink_window)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).fib_num_tclassid_users as *const _ as usize
            },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(fib_num_tclassid_users)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv4>())).fib_table_hash as *const _ as usize },
            272usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(fib_table_hash)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv4>())).fibnl as *const _ as usize },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(fibnl)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv4>())).mc_autojoin_sk as *const _ as usize },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(mc_autojoin_sk)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv4>())).peers as *const _ as usize },
            296usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(peers)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv4>())).fqdir as *const _ as usize },
            304usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(fqdir)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_icmp_echo_ignore_all as *const _
                    as usize
            },
            312usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_icmp_echo_ignore_all)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_icmp_echo_enable_probe as *const _
                    as usize
            },
            313usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_icmp_echo_enable_probe)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_icmp_echo_ignore_broadcasts
                    as *const _ as usize
            },
            314usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_icmp_echo_ignore_broadcasts)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_icmp_ignore_bogus_error_responses
                    as *const _ as usize
            },
            315usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_icmp_ignore_bogus_error_responses)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_icmp_errors_use_inbound_ifaddr
                    as *const _ as usize
            },
            316usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_icmp_errors_use_inbound_ifaddr)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_icmp_ratelimit as *const _ as usize
            },
            320usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_icmp_ratelimit)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_icmp_ratemask as *const _ as usize
            },
            324usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_icmp_ratemask)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv4>())).ip_rt_min_pmtu as *const _ as usize },
            328usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(ip_rt_min_pmtu)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).ip_rt_mtu_expires as *const _ as usize
            },
            332usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(ip_rt_mtu_expires)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).ip_rt_min_advmss as *const _ as usize
            },
            336usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(ip_rt_min_advmss)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv4>())).ip_local_ports as *const _ as usize },
            340usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(ip_local_ports)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_ecn as *const _ as usize },
            360usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_ecn)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_ecn_fallback as *const _ as usize
            },
            361usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_ecn_fallback)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_ip_default_ttl as *const _ as usize
            },
            362usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_ip_default_ttl)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_ip_no_pmtu_disc as *const _ as usize
            },
            363usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_ip_no_pmtu_disc)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_ip_fwd_use_pmtu as *const _ as usize
            },
            364usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_ip_fwd_use_pmtu)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_ip_fwd_update_priority as *const _
                    as usize
            },
            365usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_ip_fwd_update_priority)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_ip_nonlocal_bind as *const _ as usize
            },
            366usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_ip_nonlocal_bind)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_ip_autobind_reuse as *const _
                    as usize
            },
            367usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_ip_autobind_reuse)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_ip_dynaddr as *const _ as usize
            },
            368usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_ip_dynaddr)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_ip_early_demux as *const _ as usize
            },
            369usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_ip_early_demux)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_raw_l3mdev_accept as *const _
                    as usize
            },
            370usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_raw_l3mdev_accept)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_early_demux as *const _ as usize
            },
            371usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_early_demux)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_udp_early_demux as *const _ as usize
            },
            372usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_udp_early_demux)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_nexthop_compat_mode as *const _
                    as usize
            },
            373usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_nexthop_compat_mode)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_fwmark_reflect as *const _ as usize
            },
            374usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_fwmark_reflect)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_fwmark_accept as *const _
                    as usize
            },
            375usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_fwmark_accept)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_l3mdev_accept as *const _
                    as usize
            },
            376usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_l3mdev_accept)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_mtu_probing as *const _ as usize
            },
            377usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_mtu_probing)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_mtu_probe_floor as *const _
                    as usize
            },
            380usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_mtu_probe_floor)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_base_mss as *const _ as usize
            },
            384usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_base_mss)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_min_snd_mss as *const _ as usize
            },
            388usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_min_snd_mss)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_probe_threshold as *const _
                    as usize
            },
            392usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_probe_threshold)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_probe_interval as *const _
                    as usize
            },
            396usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_probe_interval)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_keepalive_time as *const _
                    as usize
            },
            400usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_keepalive_time)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_keepalive_intvl as *const _
                    as usize
            },
            404usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_keepalive_intvl)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_keepalive_probes as *const _
                    as usize
            },
            408usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_keepalive_probes)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_syn_retries as *const _ as usize
            },
            409usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_syn_retries)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_synack_retries as *const _
                    as usize
            },
            410usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_synack_retries)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_syncookies as *const _ as usize
            },
            411usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_syncookies)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_migrate_req as *const _ as usize
            },
            412usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_migrate_req)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_comp_sack_nr as *const _ as usize
            },
            413usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_comp_sack_nr)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_reordering as *const _ as usize
            },
            416usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_reordering)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_retries1 as *const _ as usize
            },
            420usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_retries1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_retries2 as *const _ as usize
            },
            421usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_retries2)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_orphan_retries as *const _
                    as usize
            },
            422usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_orphan_retries)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_tw_reuse as *const _ as usize
            },
            423usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_tw_reuse)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_fin_timeout as *const _ as usize
            },
            424usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_fin_timeout)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_notsent_lowat as *const _
                    as usize
            },
            428usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_notsent_lowat)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_sack as *const _ as usize },
            432usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_sack)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_window_scaling as *const _
                    as usize
            },
            433usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_window_scaling)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_timestamps as *const _ as usize
            },
            434usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_timestamps)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_early_retrans as *const _
                    as usize
            },
            435usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_early_retrans)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_recovery as *const _ as usize
            },
            436usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_recovery)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_thin_linear_timeouts as *const _
                    as usize
            },
            437usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_thin_linear_timeouts)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_slow_start_after_idle as *const _
                    as usize
            },
            438usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_slow_start_after_idle)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_retrans_collapse as *const _
                    as usize
            },
            439usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_retrans_collapse)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_stdurg as *const _ as usize
            },
            440usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_stdurg)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_rfc1337 as *const _ as usize
            },
            441usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_rfc1337)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_abort_on_overflow as *const _
                    as usize
            },
            442usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_abort_on_overflow)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_fack as *const _ as usize },
            443usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_fack)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_max_reordering as *const _
                    as usize
            },
            444usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_max_reordering)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_adv_win_scale as *const _
                    as usize
            },
            448usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_adv_win_scale)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_dsack as *const _ as usize
            },
            452usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_dsack)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_app_win as *const _ as usize
            },
            453usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_app_win)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_frto as *const _ as usize },
            454usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_frto)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_nometrics_save as *const _
                    as usize
            },
            455usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_nometrics_save)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_no_ssthresh_metrics_save
                    as *const _ as usize
            },
            456usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_no_ssthresh_metrics_save)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_moderate_rcvbuf as *const _
                    as usize
            },
            457usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_moderate_rcvbuf)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_tso_win_divisor as *const _
                    as usize
            },
            458usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_tso_win_divisor)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_workaround_signed_windows
                    as *const _ as usize
            },
            459usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_workaround_signed_windows)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_limit_output_bytes as *const _
                    as usize
            },
            460usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_limit_output_bytes)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_challenge_ack_limit as *const _
                    as usize
            },
            464usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_challenge_ack_limit)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_min_rtt_wlen as *const _ as usize
            },
            468usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_min_rtt_wlen)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_min_tso_segs as *const _ as usize
            },
            472usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_min_tso_segs)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_tso_rtt_log as *const _ as usize
            },
            473usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_tso_rtt_log)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_autocorking as *const _ as usize
            },
            474usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_autocorking)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_reflect_tos as *const _ as usize
            },
            475usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_reflect_tos)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_invalid_ratelimit as *const _
                    as usize
            },
            476usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_invalid_ratelimit)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_pacing_ss_ratio as *const _
                    as usize
            },
            480usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_pacing_ss_ratio)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_pacing_ca_ratio as *const _
                    as usize
            },
            484usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_pacing_ca_ratio)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_wmem as *const _ as usize },
            488usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_wmem)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_rmem as *const _ as usize },
            500usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_rmem)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_child_ehash_entries as *const _
                    as usize
            },
            512usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_child_ehash_entries)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_comp_sack_delay_ns as *const _
                    as usize
            },
            520usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_comp_sack_delay_ns)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_comp_sack_slack_ns as *const _
                    as usize
            },
            528usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_comp_sack_slack_ns)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_max_syn_backlog as *const _ as usize
            },
            536usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_max_syn_backlog)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_fastopen as *const _ as usize
            },
            540usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_fastopen)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).tcp_congestion_control as *const _ as usize
            },
            544usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(tcp_congestion_control)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).tcp_fastopen_ctx as *const _ as usize
            },
            552usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(tcp_fastopen_ctx)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_fastopen_blackhole_timeout
                    as *const _ as usize
            },
            560usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_fastopen_blackhole_timeout)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).tfo_active_disable_times as *const _
                    as usize
            },
            564usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(tfo_active_disable_times)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).tfo_active_disable_stamp as *const _
                    as usize
            },
            568usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(tfo_active_disable_stamp)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).tcp_challenge_timestamp as *const _ as usize
            },
            576usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(tcp_challenge_timestamp)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).tcp_challenge_count as *const _ as usize
            },
            580usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(tcp_challenge_count)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_plb_enabled as *const _ as usize
            },
            584usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_plb_enabled)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_plb_idle_rehash_rounds
                    as *const _ as usize
            },
            585usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_plb_idle_rehash_rounds)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_plb_rehash_rounds as *const _
                    as usize
            },
            586usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_plb_rehash_rounds)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_plb_suspend_rto_sec as *const _
                    as usize
            },
            587usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_plb_suspend_rto_sec)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_plb_cong_thresh as *const _
                    as usize
            },
            588usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_plb_cong_thresh)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_udp_wmem_min as *const _ as usize
            },
            592usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_udp_wmem_min)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_udp_rmem_min as *const _ as usize
            },
            596usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_udp_rmem_min)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_fib_notify_on_flag_change as *const _
                    as usize
            },
            600usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_fib_notify_on_flag_change)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_tcp_syn_linear_timeouts as *const _
                    as usize
            },
            601usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_tcp_syn_linear_timeouts)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_udp_l3mdev_accept as *const _
                    as usize
            },
            602usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_udp_l3mdev_accept)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_igmp_llm_reports as *const _ as usize
            },
            603usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_igmp_llm_reports)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_igmp_max_memberships as *const _
                    as usize
            },
            604usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_igmp_max_memberships)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_igmp_max_msf as *const _ as usize
            },
            608usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_igmp_max_msf)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv4>())).sysctl_igmp_qrv as *const _ as usize },
            612usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_igmp_qrv)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).ping_group_range as *const _ as usize
            },
            616usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(ping_group_range)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv4>())).dev_addr_genid as *const _ as usize },
            632usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(dev_addr_genid)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_udp_child_hash_entries as *const _
                    as usize
            },
            636usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_udp_child_hash_entries)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_local_reserved_ports as *const _
                    as usize
            },
            640usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_local_reserved_ports)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_ip_prot_sock as *const _ as usize
            },
            648usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_ip_prot_sock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv4>())).mr_tables as *const _ as usize },
            656usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(mr_tables)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv4>())).mr_rules_ops as *const _ as usize },
            672usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(mr_rules_ops)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_fib_multipath_hash_fields as *const _
                    as usize
            },
            680usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_fib_multipath_hash_fields)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_fib_multipath_use_neigh as *const _
                    as usize
            },
            684usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_fib_multipath_use_neigh)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).sysctl_fib_multipath_hash_policy as *const _
                    as usize
            },
            685usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(sysctl_fib_multipath_hash_policy)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv4>())).notifier_ops as *const _ as usize },
            688usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(notifier_ops)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv4>())).fib_seq as *const _ as usize },
            696usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(fib_seq)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv4>())).ipmr_notifier_ops as *const _ as usize
            },
            704usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(ipmr_notifier_ops)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv4>())).ipmr_seq as *const _ as usize },
            712usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(ipmr_seq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv4>())).rt_genid as *const _ as usize },
            716usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(rt_genid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv4>())).ip_id_key as *const _ as usize },
            720usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv4),
                "::",
                stringify!(ip_id_key)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct percpu_counter {
        pub lock: raw_spinlock_t,
        pub count: s64,
        pub list: list_head,
        pub counters: *mut s32,
    }
    #[test]
    fn bindgen_test_layout_percpu_counter() {
        assert_eq!(
            ::core::mem::size_of::<percpu_counter>(),
            40usize,
            concat!("Size of: ", stringify!(percpu_counter))
        );
        assert_eq!(
            ::core::mem::align_of::<percpu_counter>(),
            8usize,
            concat!("Alignment of ", stringify!(percpu_counter))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<percpu_counter>())).lock as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(percpu_counter),
                "::",
                stringify!(lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<percpu_counter>())).count as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(percpu_counter),
                "::",
                stringify!(count)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<percpu_counter>())).list as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(percpu_counter),
                "::",
                stringify!(list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<percpu_counter>())).counters as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(percpu_counter),
                "::",
                stringify!(counters)
            )
        );
    }
    #[repr(C)]
    #[repr(align(64))]
    #[derive(Copy, Clone)]
    pub struct dst_ops {
        pub family: ::cty::c_ushort,
        pub gc_thresh: ::cty::c_uint,
        pub gc: ::core::option::Option<unsafe extern "C" fn(ops: *mut dst_ops)>,
        pub check: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut dst_entry, cookie: __u32) -> *mut dst_entry,
        >,
        pub default_advmss:
            ::core::option::Option<unsafe extern "C" fn(arg1: *const dst_entry) -> ::cty::c_uint>,
        pub mtu:
            ::core::option::Option<unsafe extern "C" fn(arg1: *const dst_entry) -> ::cty::c_uint>,
        pub cow_metrics: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut dst_entry, arg2: ::cty::c_ulong) -> *mut _cargo_bpf_u32,
        >,
        pub destroy: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dst_entry)>,
        pub ifdown: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut dst_entry, dev: *mut net_device, how: ::cty::c_int),
        >,
        pub negative_advice:
            ::core::option::Option<unsafe extern "C" fn(arg1: *mut dst_entry) -> *mut dst_entry>,
        pub link_failure: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sk_buff)>,
        pub update_pmtu: ::core::option::Option<
            unsafe extern "C" fn(
                dst: *mut dst_entry,
                sk: *mut sock,
                skb: *mut sk_buff,
                mtu: _cargo_bpf_u32,
                confirm_neigh: bool_,
            ),
        >,
        pub redirect: ::core::option::Option<
            unsafe extern "C" fn(dst: *mut dst_entry, sk: *mut sock, skb: *mut sk_buff),
        >,
        pub local_out: ::core::option::Option<
            unsafe extern "C" fn(net: *mut net, sk: *mut sock, skb: *mut sk_buff) -> ::cty::c_int,
        >,
        pub neigh_lookup: ::core::option::Option<
            unsafe extern "C" fn(
                dst: *const dst_entry,
                skb: *mut sk_buff,
                daddr: *const ::cty::c_void,
            ) -> *mut neighbour,
        >,
        pub confirm_neigh: ::core::option::Option<
            unsafe extern "C" fn(dst: *const dst_entry, daddr: *const ::cty::c_void),
        >,
        pub kmem_cachep: *mut kmem_cache,
        pub pcpuc_entries: percpu_counter,
    }
    #[test]
    fn bindgen_test_layout_dst_ops() {
        assert_eq!(
            ::core::mem::size_of::<dst_ops>(),
            192usize,
            concat!("Size of: ", stringify!(dst_ops))
        );
        assert_eq!(
            ::core::mem::align_of::<dst_ops>(),
            64usize,
            concat!("Alignment of ", stringify!(dst_ops))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dst_ops>())).family as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(dst_ops),
                "::",
                stringify!(family)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dst_ops>())).gc_thresh as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(dst_ops),
                "::",
                stringify!(gc_thresh)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dst_ops>())).gc as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(dst_ops),
                "::",
                stringify!(gc)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dst_ops>())).check as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(dst_ops),
                "::",
                stringify!(check)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dst_ops>())).default_advmss as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(dst_ops),
                "::",
                stringify!(default_advmss)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dst_ops>())).mtu as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(dst_ops),
                "::",
                stringify!(mtu)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dst_ops>())).cow_metrics as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(dst_ops),
                "::",
                stringify!(cow_metrics)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dst_ops>())).destroy as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(dst_ops),
                "::",
                stringify!(destroy)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dst_ops>())).ifdown as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(dst_ops),
                "::",
                stringify!(ifdown)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dst_ops>())).negative_advice as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(dst_ops),
                "::",
                stringify!(negative_advice)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dst_ops>())).link_failure as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(dst_ops),
                "::",
                stringify!(link_failure)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dst_ops>())).update_pmtu as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(dst_ops),
                "::",
                stringify!(update_pmtu)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dst_ops>())).redirect as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(dst_ops),
                "::",
                stringify!(redirect)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dst_ops>())).local_out as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(dst_ops),
                "::",
                stringify!(local_out)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dst_ops>())).neigh_lookup as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(dst_ops),
                "::",
                stringify!(neigh_lookup)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dst_ops>())).confirm_neigh as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(dst_ops),
                "::",
                stringify!(confirm_neigh)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dst_ops>())).kmem_cachep as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(dst_ops),
                "::",
                stringify!(kmem_cachep)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dst_ops>())).pcpuc_entries as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(dst_ops),
                "::",
                stringify!(pcpuc_entries)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct netns_sysctl_ipv6 {
        pub hdr: *mut ctl_table_header,
        pub route_hdr: *mut ctl_table_header,
        pub icmp_hdr: *mut ctl_table_header,
        pub frags_hdr: *mut ctl_table_header,
        pub xfrm6_hdr: *mut ctl_table_header,
        pub flush_delay: ::cty::c_int,
        pub ip6_rt_max_size: ::cty::c_int,
        pub ip6_rt_gc_min_interval: ::cty::c_int,
        pub ip6_rt_gc_timeout: ::cty::c_int,
        pub ip6_rt_gc_interval: ::cty::c_int,
        pub ip6_rt_gc_elasticity: ::cty::c_int,
        pub ip6_rt_mtu_expires: ::cty::c_int,
        pub ip6_rt_min_advmss: ::cty::c_int,
        pub multipath_hash_fields: _cargo_bpf_u32,
        pub multipath_hash_policy: _cargo_bpf_u8,
        pub bindv6only: _cargo_bpf_u8,
        pub flowlabel_consistency: _cargo_bpf_u8,
        pub auto_flowlabels: _cargo_bpf_u8,
        pub icmpv6_time: ::cty::c_int,
        pub icmpv6_echo_ignore_all: _cargo_bpf_u8,
        pub icmpv6_echo_ignore_multicast: _cargo_bpf_u8,
        pub icmpv6_echo_ignore_anycast: _cargo_bpf_u8,
        pub icmpv6_ratemask: [::cty::c_ulong; 4usize],
        pub icmpv6_ratemask_ptr: *mut ::cty::c_ulong,
        pub anycast_src_echo_reply: _cargo_bpf_u8,
        pub ip_nonlocal_bind: _cargo_bpf_u8,
        pub fwmark_reflect: _cargo_bpf_u8,
        pub flowlabel_state_ranges: _cargo_bpf_u8,
        pub idgen_retries: ::cty::c_int,
        pub idgen_delay: ::cty::c_int,
        pub flowlabel_reflect: ::cty::c_int,
        pub max_dst_opts_cnt: ::cty::c_int,
        pub max_hbh_opts_cnt: ::cty::c_int,
        pub max_dst_opts_len: ::cty::c_int,
        pub max_hbh_opts_len: ::cty::c_int,
        pub seg6_flowlabel: ::cty::c_int,
        pub ioam6_id: _cargo_bpf_u32,
        pub ioam6_id_wide: _cargo_bpf_u64,
        pub skip_notify_on_dev_down: _cargo_bpf_u8,
        pub fib_notify_on_flag_change: _cargo_bpf_u8,
        pub icmpv6_error_anycast_as_unicast: _cargo_bpf_u8,
    }
    #[test]
    fn bindgen_test_layout_netns_sysctl_ipv6() {
        assert_eq!(
            ::core::mem::size_of::<netns_sysctl_ipv6>(),
            184usize,
            concat!("Size of: ", stringify!(netns_sysctl_ipv6))
        );
        assert_eq!(
            ::core::mem::align_of::<netns_sysctl_ipv6>(),
            8usize,
            concat!("Alignment of ", stringify!(netns_sysctl_ipv6))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_sysctl_ipv6>())).hdr as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sysctl_ipv6),
                "::",
                stringify!(hdr)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_sysctl_ipv6>())).route_hdr as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sysctl_ipv6),
                "::",
                stringify!(route_hdr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_sysctl_ipv6>())).icmp_hdr as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sysctl_ipv6),
                "::",
                stringify!(icmp_hdr)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_sysctl_ipv6>())).frags_hdr as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sysctl_ipv6),
                "::",
                stringify!(frags_hdr)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_sysctl_ipv6>())).xfrm6_hdr as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sysctl_ipv6),
                "::",
                stringify!(xfrm6_hdr)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_sysctl_ipv6>())).flush_delay as *const _ as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sysctl_ipv6),
                "::",
                stringify!(flush_delay)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_sysctl_ipv6>())).ip6_rt_max_size as *const _ as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sysctl_ipv6),
                "::",
                stringify!(ip6_rt_max_size)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_sysctl_ipv6>())).ip6_rt_gc_min_interval as *const _
                    as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sysctl_ipv6),
                "::",
                stringify!(ip6_rt_gc_min_interval)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_sysctl_ipv6>())).ip6_rt_gc_timeout as *const _
                    as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sysctl_ipv6),
                "::",
                stringify!(ip6_rt_gc_timeout)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_sysctl_ipv6>())).ip6_rt_gc_interval as *const _
                    as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sysctl_ipv6),
                "::",
                stringify!(ip6_rt_gc_interval)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_sysctl_ipv6>())).ip6_rt_gc_elasticity as *const _
                    as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sysctl_ipv6),
                "::",
                stringify!(ip6_rt_gc_elasticity)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_sysctl_ipv6>())).ip6_rt_mtu_expires as *const _
                    as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sysctl_ipv6),
                "::",
                stringify!(ip6_rt_mtu_expires)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_sysctl_ipv6>())).ip6_rt_min_advmss as *const _
                    as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sysctl_ipv6),
                "::",
                stringify!(ip6_rt_min_advmss)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_sysctl_ipv6>())).multipath_hash_fields as *const _
                    as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sysctl_ipv6),
                "::",
                stringify!(multipath_hash_fields)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_sysctl_ipv6>())).multipath_hash_policy as *const _
                    as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sysctl_ipv6),
                "::",
                stringify!(multipath_hash_policy)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_sysctl_ipv6>())).bindv6only as *const _ as usize
            },
            77usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sysctl_ipv6),
                "::",
                stringify!(bindv6only)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_sysctl_ipv6>())).flowlabel_consistency as *const _
                    as usize
            },
            78usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sysctl_ipv6),
                "::",
                stringify!(flowlabel_consistency)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_sysctl_ipv6>())).auto_flowlabels as *const _ as usize
            },
            79usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sysctl_ipv6),
                "::",
                stringify!(auto_flowlabels)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_sysctl_ipv6>())).icmpv6_time as *const _ as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sysctl_ipv6),
                "::",
                stringify!(icmpv6_time)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_sysctl_ipv6>())).icmpv6_echo_ignore_all as *const _
                    as usize
            },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sysctl_ipv6),
                "::",
                stringify!(icmpv6_echo_ignore_all)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_sysctl_ipv6>())).icmpv6_echo_ignore_multicast
                    as *const _ as usize
            },
            85usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sysctl_ipv6),
                "::",
                stringify!(icmpv6_echo_ignore_multicast)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_sysctl_ipv6>())).icmpv6_echo_ignore_anycast
                    as *const _ as usize
            },
            86usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sysctl_ipv6),
                "::",
                stringify!(icmpv6_echo_ignore_anycast)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_sysctl_ipv6>())).icmpv6_ratemask as *const _ as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sysctl_ipv6),
                "::",
                stringify!(icmpv6_ratemask)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_sysctl_ipv6>())).icmpv6_ratemask_ptr as *const _
                    as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sysctl_ipv6),
                "::",
                stringify!(icmpv6_ratemask_ptr)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_sysctl_ipv6>())).anycast_src_echo_reply as *const _
                    as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sysctl_ipv6),
                "::",
                stringify!(anycast_src_echo_reply)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_sysctl_ipv6>())).ip_nonlocal_bind as *const _ as usize
            },
            129usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sysctl_ipv6),
                "::",
                stringify!(ip_nonlocal_bind)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_sysctl_ipv6>())).fwmark_reflect as *const _ as usize
            },
            130usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sysctl_ipv6),
                "::",
                stringify!(fwmark_reflect)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_sysctl_ipv6>())).flowlabel_state_ranges as *const _
                    as usize
            },
            131usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sysctl_ipv6),
                "::",
                stringify!(flowlabel_state_ranges)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_sysctl_ipv6>())).idgen_retries as *const _ as usize
            },
            132usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sysctl_ipv6),
                "::",
                stringify!(idgen_retries)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_sysctl_ipv6>())).idgen_delay as *const _ as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sysctl_ipv6),
                "::",
                stringify!(idgen_delay)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_sysctl_ipv6>())).flowlabel_reflect as *const _
                    as usize
            },
            140usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sysctl_ipv6),
                "::",
                stringify!(flowlabel_reflect)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_sysctl_ipv6>())).max_dst_opts_cnt as *const _ as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sysctl_ipv6),
                "::",
                stringify!(max_dst_opts_cnt)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_sysctl_ipv6>())).max_hbh_opts_cnt as *const _ as usize
            },
            148usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sysctl_ipv6),
                "::",
                stringify!(max_hbh_opts_cnt)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_sysctl_ipv6>())).max_dst_opts_len as *const _ as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sysctl_ipv6),
                "::",
                stringify!(max_dst_opts_len)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_sysctl_ipv6>())).max_hbh_opts_len as *const _ as usize
            },
            156usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sysctl_ipv6),
                "::",
                stringify!(max_hbh_opts_len)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_sysctl_ipv6>())).seg6_flowlabel as *const _ as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sysctl_ipv6),
                "::",
                stringify!(seg6_flowlabel)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_sysctl_ipv6>())).ioam6_id as *const _ as usize },
            164usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sysctl_ipv6),
                "::",
                stringify!(ioam6_id)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_sysctl_ipv6>())).ioam6_id_wide as *const _ as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sysctl_ipv6),
                "::",
                stringify!(ioam6_id_wide)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_sysctl_ipv6>())).skip_notify_on_dev_down as *const _
                    as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sysctl_ipv6),
                "::",
                stringify!(skip_notify_on_dev_down)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_sysctl_ipv6>())).fib_notify_on_flag_change as *const _
                    as usize
            },
            177usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sysctl_ipv6),
                "::",
                stringify!(fib_notify_on_flag_change)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_sysctl_ipv6>())).icmpv6_error_anycast_as_unicast
                    as *const _ as usize
            },
            178usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sysctl_ipv6),
                "::",
                stringify!(icmpv6_error_anycast_as_unicast)
            )
        );
    }
    #[repr(C)]
    #[repr(align(64))]
    #[derive(Copy, Clone)]
    pub struct netns_ipv6 {
        pub ip6_dst_ops: dst_ops,
        pub sysctl: netns_sysctl_ipv6,
        pub devconf_all: *mut ipv6_devconf,
        pub devconf_dflt: *mut ipv6_devconf,
        pub peers: *mut inet_peer_base,
        pub fqdir: *mut fqdir,
        pub fib6_null_entry: *mut fib6_info,
        pub ip6_null_entry: *mut rt6_info,
        pub rt6_stats: *mut rt6_statistics,
        pub ip6_fib_timer: timer_list,
        pub fib_table_hash: *mut hlist_head,
        pub fib6_main_tbl: *mut fib6_table,
        pub fib6_walkers: list_head,
        pub fib6_walker_lock: rwlock_t,
        pub fib6_gc_lock: spinlock_t,
        pub ip6_rt_gc_expire: atomic_t,
        pub ip6_rt_last_gc: ::cty::c_ulong,
        pub flowlabel_has_excl: ::cty::c_uchar,
        pub fib6_has_custom_rules: bool_,
        pub fib6_rules_require_fldissect: ::cty::c_uint,
        pub fib6_routes_require_src: ::cty::c_uint,
        pub ip6_prohibit_entry: *mut rt6_info,
        pub ip6_blk_hole_entry: *mut rt6_info,
        pub fib6_local_tbl: *mut fib6_table,
        pub fib6_rules_ops: *mut fib_rules_ops,
        pub ndisc_sk: *mut sock,
        pub tcp_sk: *mut sock,
        pub igmp_sk: *mut sock,
        pub mc_autojoin_sk: *mut sock,
        pub inet6_addr_lst: *mut hlist_head,
        pub addrconf_hash_lock: spinlock_t,
        pub addr_chk_work: delayed_work,
        pub mr6_tables: list_head,
        pub mr6_rules_ops: *mut fib_rules_ops,
        pub dev_addr_genid: atomic_t,
        pub fib6_sernum: atomic_t,
        pub seg6_data: *mut seg6_pernet_data,
        pub notifier_ops: *mut fib_notifier_ops,
        pub ip6mr_notifier_ops: *mut fib_notifier_ops,
        pub ipmr_seq: ::cty::c_uint,
        pub ip6addrlbl_table: netns_ipv6__bindgen_ty_1,
        pub ioam6_data: *mut ioam6_pernet_data,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct netns_ipv6__bindgen_ty_1 {
        pub head: hlist_head,
        pub lock: spinlock_t,
        pub seq: _cargo_bpf_u32,
    }
    #[test]
    fn bindgen_test_layout_netns_ipv6__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<netns_ipv6__bindgen_ty_1>(),
            16usize,
            concat!("Size of: ", stringify!(netns_ipv6__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<netns_ipv6__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(netns_ipv6__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv6__bindgen_ty_1>())).head as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv6__bindgen_ty_1),
                "::",
                stringify!(head)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv6__bindgen_ty_1>())).lock as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv6__bindgen_ty_1),
                "::",
                stringify!(lock)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv6__bindgen_ty_1>())).seq as *const _ as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv6__bindgen_ty_1),
                "::",
                stringify!(seq)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_netns_ipv6() {
        assert_eq!(
            ::core::mem::size_of::<netns_ipv6>(),
            832usize,
            concat!("Size of: ", stringify!(netns_ipv6))
        );
        assert_eq!(
            ::core::mem::align_of::<netns_ipv6>(),
            64usize,
            concat!("Alignment of ", stringify!(netns_ipv6))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv6>())).ip6_dst_ops as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv6),
                "::",
                stringify!(ip6_dst_ops)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv6>())).sysctl as *const _ as usize },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv6),
                "::",
                stringify!(sysctl)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv6>())).devconf_all as *const _ as usize },
            376usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv6),
                "::",
                stringify!(devconf_all)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv6>())).devconf_dflt as *const _ as usize },
            384usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv6),
                "::",
                stringify!(devconf_dflt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv6>())).peers as *const _ as usize },
            392usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv6),
                "::",
                stringify!(peers)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv6>())).fqdir as *const _ as usize },
            400usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv6),
                "::",
                stringify!(fqdir)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv6>())).fib6_null_entry as *const _ as usize },
            408usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv6),
                "::",
                stringify!(fib6_null_entry)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv6>())).ip6_null_entry as *const _ as usize },
            416usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv6),
                "::",
                stringify!(ip6_null_entry)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv6>())).rt6_stats as *const _ as usize },
            424usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv6),
                "::",
                stringify!(rt6_stats)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv6>())).ip6_fib_timer as *const _ as usize },
            432usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv6),
                "::",
                stringify!(ip6_fib_timer)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv6>())).fib_table_hash as *const _ as usize },
            472usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv6),
                "::",
                stringify!(fib_table_hash)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv6>())).fib6_main_tbl as *const _ as usize },
            480usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv6),
                "::",
                stringify!(fib6_main_tbl)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv6>())).fib6_walkers as *const _ as usize },
            488usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv6),
                "::",
                stringify!(fib6_walkers)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv6>())).fib6_walker_lock as *const _ as usize
            },
            504usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv6),
                "::",
                stringify!(fib6_walker_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv6>())).fib6_gc_lock as *const _ as usize },
            512usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv6),
                "::",
                stringify!(fib6_gc_lock)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv6>())).ip6_rt_gc_expire as *const _ as usize
            },
            516usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv6),
                "::",
                stringify!(ip6_rt_gc_expire)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv6>())).ip6_rt_last_gc as *const _ as usize },
            520usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv6),
                "::",
                stringify!(ip6_rt_last_gc)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv6>())).flowlabel_has_excl as *const _ as usize
            },
            528usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv6),
                "::",
                stringify!(flowlabel_has_excl)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv6>())).fib6_has_custom_rules as *const _ as usize
            },
            529usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv6),
                "::",
                stringify!(fib6_has_custom_rules)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv6>())).fib6_rules_require_fldissect as *const _
                    as usize
            },
            532usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv6),
                "::",
                stringify!(fib6_rules_require_fldissect)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv6>())).fib6_routes_require_src as *const _ as usize
            },
            536usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv6),
                "::",
                stringify!(fib6_routes_require_src)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv6>())).ip6_prohibit_entry as *const _ as usize
            },
            544usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv6),
                "::",
                stringify!(ip6_prohibit_entry)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv6>())).ip6_blk_hole_entry as *const _ as usize
            },
            552usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv6),
                "::",
                stringify!(ip6_blk_hole_entry)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv6>())).fib6_local_tbl as *const _ as usize },
            560usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv6),
                "::",
                stringify!(fib6_local_tbl)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv6>())).fib6_rules_ops as *const _ as usize },
            568usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv6),
                "::",
                stringify!(fib6_rules_ops)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv6>())).ndisc_sk as *const _ as usize },
            576usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv6),
                "::",
                stringify!(ndisc_sk)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv6>())).tcp_sk as *const _ as usize },
            584usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv6),
                "::",
                stringify!(tcp_sk)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv6>())).igmp_sk as *const _ as usize },
            592usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv6),
                "::",
                stringify!(igmp_sk)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv6>())).mc_autojoin_sk as *const _ as usize },
            600usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv6),
                "::",
                stringify!(mc_autojoin_sk)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv6>())).inet6_addr_lst as *const _ as usize },
            608usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv6),
                "::",
                stringify!(inet6_addr_lst)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv6>())).addrconf_hash_lock as *const _ as usize
            },
            616usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv6),
                "::",
                stringify!(addrconf_hash_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv6>())).addr_chk_work as *const _ as usize },
            624usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv6),
                "::",
                stringify!(addr_chk_work)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv6>())).mr6_tables as *const _ as usize },
            712usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv6),
                "::",
                stringify!(mr6_tables)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv6>())).mr6_rules_ops as *const _ as usize },
            728usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv6),
                "::",
                stringify!(mr6_rules_ops)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv6>())).dev_addr_genid as *const _ as usize },
            736usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv6),
                "::",
                stringify!(dev_addr_genid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv6>())).fib6_sernum as *const _ as usize },
            740usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv6),
                "::",
                stringify!(fib6_sernum)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv6>())).seg6_data as *const _ as usize },
            744usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv6),
                "::",
                stringify!(seg6_data)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv6>())).notifier_ops as *const _ as usize },
            752usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv6),
                "::",
                stringify!(notifier_ops)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv6>())).ip6mr_notifier_ops as *const _ as usize
            },
            760usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv6),
                "::",
                stringify!(ip6mr_notifier_ops)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv6>())).ipmr_seq as *const _ as usize },
            768usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv6),
                "::",
                stringify!(ipmr_seq)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ipv6>())).ip6addrlbl_table as *const _ as usize
            },
            776usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv6),
                "::",
                stringify!(ip6addrlbl_table)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ipv6>())).ioam6_data as *const _ as usize },
            792usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ipv6),
                "::",
                stringify!(ioam6_data)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct rw_semaphore {
        pub count: atomic_long_t,
        pub owner: atomic_long_t,
        pub osq: optimistic_spin_queue,
        pub wait_lock: raw_spinlock_t,
        pub wait_list: list_head,
    }
    #[test]
    fn bindgen_test_layout_rw_semaphore() {
        assert_eq!(
            ::core::mem::size_of::<rw_semaphore>(),
            40usize,
            concat!("Size of: ", stringify!(rw_semaphore))
        );
        assert_eq!(
            ::core::mem::align_of::<rw_semaphore>(),
            8usize,
            concat!("Alignment of ", stringify!(rw_semaphore))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rw_semaphore>())).count as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rw_semaphore),
                "::",
                stringify!(count)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rw_semaphore>())).owner as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rw_semaphore),
                "::",
                stringify!(owner)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rw_semaphore>())).osq as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rw_semaphore),
                "::",
                stringify!(osq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rw_semaphore>())).wait_lock as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(rw_semaphore),
                "::",
                stringify!(wait_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rw_semaphore>())).wait_list as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rw_semaphore),
                "::",
                stringify!(wait_list)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct rcu_segcblist {
        pub head: *mut callback_head,
        pub tails: [*mut *mut callback_head; 4usize],
        pub gp_seq: [::cty::c_ulong; 4usize],
        pub len: ::cty::c_long,
        pub seglen: [::cty::c_long; 4usize],
        pub flags: _cargo_bpf_u8,
    }
    #[test]
    fn bindgen_test_layout_rcu_segcblist() {
        assert_eq!(
            ::core::mem::size_of::<rcu_segcblist>(),
            120usize,
            concat!("Size of: ", stringify!(rcu_segcblist))
        );
        assert_eq!(
            ::core::mem::align_of::<rcu_segcblist>(),
            8usize,
            concat!("Alignment of ", stringify!(rcu_segcblist))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rcu_segcblist>())).head as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcu_segcblist),
                "::",
                stringify!(head)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rcu_segcblist>())).tails as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rcu_segcblist),
                "::",
                stringify!(tails)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rcu_segcblist>())).gp_seq as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(rcu_segcblist),
                "::",
                stringify!(gp_seq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rcu_segcblist>())).len as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(rcu_segcblist),
                "::",
                stringify!(len)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rcu_segcblist>())).seglen as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(rcu_segcblist),
                "::",
                stringify!(seglen)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rcu_segcblist>())).flags as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(rcu_segcblist),
                "::",
                stringify!(flags)
            )
        );
    }
    #[repr(C)]
    #[repr(align(64))]
    #[derive(Copy, Clone)]
    pub struct srcu_data {
        pub srcu_lock_count: [atomic_long_t; 2usize],
        pub srcu_unlock_count: [atomic_long_t; 2usize],
        pub srcu_nmi_safety: ::cty::c_int,
        pub __bindgen_padding_0: [u32; 7usize],
        pub lock: spinlock_t,
        pub srcu_cblist: rcu_segcblist,
        pub srcu_gp_seq_needed: ::cty::c_ulong,
        pub srcu_gp_seq_needed_exp: ::cty::c_ulong,
        pub srcu_cblist_invoking: bool_,
        pub delay_work: timer_list,
        pub work: work_struct,
        pub srcu_barrier_head: callback_head,
        pub mynode: *mut srcu_node,
        pub grpmask: ::cty::c_ulong,
        pub cpu: ::cty::c_int,
        pub ssp: *mut srcu_struct,
    }
    #[test]
    fn bindgen_test_layout_srcu_data() {
        assert_eq!(
            ::core::mem::size_of::<srcu_data>(),
            384usize,
            concat!("Size of: ", stringify!(srcu_data))
        );
        assert_eq!(
            ::core::mem::align_of::<srcu_data>(),
            64usize,
            concat!("Alignment of ", stringify!(srcu_data))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<srcu_data>())).srcu_lock_count as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(srcu_data),
                "::",
                stringify!(srcu_lock_count)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<srcu_data>())).srcu_unlock_count as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(srcu_data),
                "::",
                stringify!(srcu_unlock_count)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<srcu_data>())).srcu_nmi_safety as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(srcu_data),
                "::",
                stringify!(srcu_nmi_safety)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<srcu_data>())).lock as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(srcu_data),
                "::",
                stringify!(lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<srcu_data>())).srcu_cblist as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(srcu_data),
                "::",
                stringify!(srcu_cblist)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<srcu_data>())).srcu_gp_seq_needed as *const _ as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(srcu_data),
                "::",
                stringify!(srcu_gp_seq_needed)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<srcu_data>())).srcu_gp_seq_needed_exp as *const _ as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(srcu_data),
                "::",
                stringify!(srcu_gp_seq_needed_exp)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<srcu_data>())).srcu_cblist_invoking as *const _ as usize
            },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(srcu_data),
                "::",
                stringify!(srcu_cblist_invoking)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<srcu_data>())).delay_work as *const _ as usize },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(srcu_data),
                "::",
                stringify!(delay_work)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<srcu_data>())).work as *const _ as usize },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(srcu_data),
                "::",
                stringify!(work)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<srcu_data>())).srcu_barrier_head as *const _ as usize
            },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(srcu_data),
                "::",
                stringify!(srcu_barrier_head)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<srcu_data>())).mynode as *const _ as usize },
            304usize,
            concat!(
                "Offset of field: ",
                stringify!(srcu_data),
                "::",
                stringify!(mynode)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<srcu_data>())).grpmask as *const _ as usize },
            312usize,
            concat!(
                "Offset of field: ",
                stringify!(srcu_data),
                "::",
                stringify!(grpmask)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<srcu_data>())).cpu as *const _ as usize },
            320usize,
            concat!(
                "Offset of field: ",
                stringify!(srcu_data),
                "::",
                stringify!(cpu)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<srcu_data>())).ssp as *const _ as usize },
            328usize,
            concat!(
                "Offset of field: ",
                stringify!(srcu_data),
                "::",
                stringify!(ssp)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct srcu_node {
        pub lock: spinlock_t,
        pub srcu_have_cbs: [::cty::c_ulong; 4usize],
        pub srcu_data_have_cbs: [::cty::c_ulong; 4usize],
        pub srcu_gp_seq_needed_exp: ::cty::c_ulong,
        pub srcu_parent: *mut srcu_node,
        pub grplo: ::cty::c_int,
        pub grphi: ::cty::c_int,
    }
    #[test]
    fn bindgen_test_layout_srcu_node() {
        assert_eq!(
            ::core::mem::size_of::<srcu_node>(),
            96usize,
            concat!("Size of: ", stringify!(srcu_node))
        );
        assert_eq!(
            ::core::mem::align_of::<srcu_node>(),
            8usize,
            concat!("Alignment of ", stringify!(srcu_node))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<srcu_node>())).lock as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(srcu_node),
                "::",
                stringify!(lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<srcu_node>())).srcu_have_cbs as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(srcu_node),
                "::",
                stringify!(srcu_have_cbs)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<srcu_node>())).srcu_data_have_cbs as *const _ as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(srcu_node),
                "::",
                stringify!(srcu_data_have_cbs)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<srcu_node>())).srcu_gp_seq_needed_exp as *const _ as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(srcu_node),
                "::",
                stringify!(srcu_gp_seq_needed_exp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<srcu_node>())).srcu_parent as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(srcu_node),
                "::",
                stringify!(srcu_parent)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<srcu_node>())).grplo as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(srcu_node),
                "::",
                stringify!(grplo)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<srcu_node>())).grphi as *const _ as usize },
            92usize,
            concat!(
                "Offset of field: ",
                stringify!(srcu_node),
                "::",
                stringify!(grphi)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct srcu_usage {
        pub node: *mut srcu_node,
        pub level: [*mut srcu_node; 4usize],
        pub srcu_size_state: ::cty::c_int,
        pub srcu_cb_mutex: mutex,
        pub lock: spinlock_t,
        pub srcu_gp_mutex: mutex,
        pub srcu_gp_seq: ::cty::c_ulong,
        pub srcu_gp_seq_needed: ::cty::c_ulong,
        pub srcu_gp_seq_needed_exp: ::cty::c_ulong,
        pub srcu_gp_start: ::cty::c_ulong,
        pub srcu_last_gp_end: ::cty::c_ulong,
        pub srcu_size_jiffies: ::cty::c_ulong,
        pub srcu_n_lock_retries: ::cty::c_ulong,
        pub srcu_n_exp_nodelay: ::cty::c_ulong,
        pub sda_is_static: bool_,
        pub srcu_barrier_seq: ::cty::c_ulong,
        pub srcu_barrier_mutex: mutex,
        pub srcu_barrier_completion: completion,
        pub srcu_barrier_cpu_cnt: atomic_t,
        pub reschedule_jiffies: ::cty::c_ulong,
        pub reschedule_count: ::cty::c_ulong,
        pub work: delayed_work,
        pub srcu_ssp: *mut srcu_struct,
    }
    #[test]
    fn bindgen_test_layout_srcu_usage() {
        assert_eq!(
            ::core::mem::size_of::<srcu_usage>(),
            384usize,
            concat!("Size of: ", stringify!(srcu_usage))
        );
        assert_eq!(
            ::core::mem::align_of::<srcu_usage>(),
            8usize,
            concat!("Alignment of ", stringify!(srcu_usage))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<srcu_usage>())).node as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(srcu_usage),
                "::",
                stringify!(node)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<srcu_usage>())).level as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(srcu_usage),
                "::",
                stringify!(level)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<srcu_usage>())).srcu_size_state as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(srcu_usage),
                "::",
                stringify!(srcu_size_state)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<srcu_usage>())).srcu_cb_mutex as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(srcu_usage),
                "::",
                stringify!(srcu_cb_mutex)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<srcu_usage>())).lock as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(srcu_usage),
                "::",
                stringify!(lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<srcu_usage>())).srcu_gp_mutex as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(srcu_usage),
                "::",
                stringify!(srcu_gp_mutex)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<srcu_usage>())).srcu_gp_seq as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(srcu_usage),
                "::",
                stringify!(srcu_gp_seq)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<srcu_usage>())).srcu_gp_seq_needed as *const _ as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(srcu_usage),
                "::",
                stringify!(srcu_gp_seq_needed)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<srcu_usage>())).srcu_gp_seq_needed_exp as *const _ as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(srcu_usage),
                "::",
                stringify!(srcu_gp_seq_needed_exp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<srcu_usage>())).srcu_gp_start as *const _ as usize },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(srcu_usage),
                "::",
                stringify!(srcu_gp_start)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<srcu_usage>())).srcu_last_gp_end as *const _ as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(srcu_usage),
                "::",
                stringify!(srcu_last_gp_end)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<srcu_usage>())).srcu_size_jiffies as *const _ as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(srcu_usage),
                "::",
                stringify!(srcu_size_jiffies)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<srcu_usage>())).srcu_n_lock_retries as *const _ as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(srcu_usage),
                "::",
                stringify!(srcu_n_lock_retries)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<srcu_usage>())).srcu_n_exp_nodelay as *const _ as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(srcu_usage),
                "::",
                stringify!(srcu_n_exp_nodelay)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<srcu_usage>())).sda_is_static as *const _ as usize },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(srcu_usage),
                "::",
                stringify!(sda_is_static)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<srcu_usage>())).srcu_barrier_seq as *const _ as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(srcu_usage),
                "::",
                stringify!(srcu_barrier_seq)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<srcu_usage>())).srcu_barrier_mutex as *const _ as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(srcu_usage),
                "::",
                stringify!(srcu_barrier_mutex)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<srcu_usage>())).srcu_barrier_completion as *const _ as usize
            },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(srcu_usage),
                "::",
                stringify!(srcu_barrier_completion)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<srcu_usage>())).srcu_barrier_cpu_cnt as *const _ as usize
            },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(srcu_usage),
                "::",
                stringify!(srcu_barrier_cpu_cnt)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<srcu_usage>())).reschedule_jiffies as *const _ as usize
            },
            272usize,
            concat!(
                "Offset of field: ",
                stringify!(srcu_usage),
                "::",
                stringify!(reschedule_jiffies)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<srcu_usage>())).reschedule_count as *const _ as usize
            },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(srcu_usage),
                "::",
                stringify!(reschedule_count)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<srcu_usage>())).work as *const _ as usize },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(srcu_usage),
                "::",
                stringify!(work)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<srcu_usage>())).srcu_ssp as *const _ as usize },
            376usize,
            concat!(
                "Offset of field: ",
                stringify!(srcu_usage),
                "::",
                stringify!(srcu_ssp)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct srcu_struct {
        pub srcu_idx: ::cty::c_uint,
        pub sda: *mut srcu_data,
        pub dep_map: lockdep_map,
        pub srcu_sup: *mut srcu_usage,
    }
    #[test]
    fn bindgen_test_layout_srcu_struct() {
        assert_eq!(
            ::core::mem::size_of::<srcu_struct>(),
            24usize,
            concat!("Size of: ", stringify!(srcu_struct))
        );
        assert_eq!(
            ::core::mem::align_of::<srcu_struct>(),
            8usize,
            concat!("Alignment of ", stringify!(srcu_struct))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<srcu_struct>())).srcu_idx as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(srcu_struct),
                "::",
                stringify!(srcu_idx)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<srcu_struct>())).sda as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(srcu_struct),
                "::",
                stringify!(sda)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<srcu_struct>())).dep_map as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(srcu_struct),
                "::",
                stringify!(dep_map)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<srcu_struct>())).srcu_sup as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(srcu_struct),
                "::",
                stringify!(srcu_sup)
            )
        );
    }
    pub type notifier_fn_t = ::core::option::Option<
        unsafe extern "C" fn(
            nb: *mut notifier_block,
            action: ::cty::c_ulong,
            data: *mut ::cty::c_void,
        ) -> ::cty::c_int,
    >;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct notifier_block {
        pub notifier_call: notifier_fn_t,
        pub next: *mut notifier_block,
        pub priority: ::cty::c_int,
    }
    #[test]
    fn bindgen_test_layout_notifier_block() {
        assert_eq!(
            ::core::mem::size_of::<notifier_block>(),
            24usize,
            concat!("Size of: ", stringify!(notifier_block))
        );
        assert_eq!(
            ::core::mem::align_of::<notifier_block>(),
            8usize,
            concat!("Alignment of ", stringify!(notifier_block))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<notifier_block>())).notifier_call as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(notifier_block),
                "::",
                stringify!(notifier_call)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<notifier_block>())).next as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(notifier_block),
                "::",
                stringify!(next)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<notifier_block>())).priority as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(notifier_block),
                "::",
                stringify!(priority)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct blocking_notifier_head {
        pub rwsem: rw_semaphore,
        pub head: *mut notifier_block,
    }
    #[test]
    fn bindgen_test_layout_blocking_notifier_head() {
        assert_eq!(
            ::core::mem::size_of::<blocking_notifier_head>(),
            48usize,
            concat!("Size of: ", stringify!(blocking_notifier_head))
        );
        assert_eq!(
            ::core::mem::align_of::<blocking_notifier_head>(),
            8usize,
            concat!("Alignment of ", stringify!(blocking_notifier_head))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<blocking_notifier_head>())).rwsem as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(blocking_notifier_head),
                "::",
                stringify!(rwsem)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<blocking_notifier_head>())).head as *const _ as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(blocking_notifier_head),
                "::",
                stringify!(head)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct raw_notifier_head {
        pub head: *mut notifier_block,
    }
    #[test]
    fn bindgen_test_layout_raw_notifier_head() {
        assert_eq!(
            ::core::mem::size_of::<raw_notifier_head>(),
            8usize,
            concat!("Size of: ", stringify!(raw_notifier_head))
        );
        assert_eq!(
            ::core::mem::align_of::<raw_notifier_head>(),
            8usize,
            concat!("Alignment of ", stringify!(raw_notifier_head))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<raw_notifier_head>())).head as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(raw_notifier_head),
                "::",
                stringify!(head)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct netns_nexthop {
        pub rb_root: rb_root,
        pub devhash: *mut hlist_head,
        pub seq: ::cty::c_uint,
        pub last_id_allocated: _cargo_bpf_u32,
        pub notifier_chain: blocking_notifier_head,
    }
    #[test]
    fn bindgen_test_layout_netns_nexthop() {
        assert_eq!(
            ::core::mem::size_of::<netns_nexthop>(),
            72usize,
            concat!("Size of: ", stringify!(netns_nexthop))
        );
        assert_eq!(
            ::core::mem::align_of::<netns_nexthop>(),
            8usize,
            concat!("Alignment of ", stringify!(netns_nexthop))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_nexthop>())).rb_root as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_nexthop),
                "::",
                stringify!(rb_root)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_nexthop>())).devhash as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_nexthop),
                "::",
                stringify!(devhash)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_nexthop>())).seq as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_nexthop),
                "::",
                stringify!(seq)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_nexthop>())).last_id_allocated as *const _ as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_nexthop),
                "::",
                stringify!(last_id_allocated)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_nexthop>())).notifier_chain as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_nexthop),
                "::",
                stringify!(notifier_chain)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct netns_sysctl_lowpan {
        pub frags_hdr: *mut ctl_table_header,
    }
    #[test]
    fn bindgen_test_layout_netns_sysctl_lowpan() {
        assert_eq!(
            ::core::mem::size_of::<netns_sysctl_lowpan>(),
            8usize,
            concat!("Size of: ", stringify!(netns_sysctl_lowpan))
        );
        assert_eq!(
            ::core::mem::align_of::<netns_sysctl_lowpan>(),
            8usize,
            concat!("Alignment of ", stringify!(netns_sysctl_lowpan))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_sysctl_lowpan>())).frags_hdr as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sysctl_lowpan),
                "::",
                stringify!(frags_hdr)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct netns_ieee802154_lowpan {
        pub sysctl: netns_sysctl_lowpan,
        pub fqdir: *mut fqdir,
    }
    #[test]
    fn bindgen_test_layout_netns_ieee802154_lowpan() {
        assert_eq!(
            ::core::mem::size_of::<netns_ieee802154_lowpan>(),
            16usize,
            concat!("Size of: ", stringify!(netns_ieee802154_lowpan))
        );
        assert_eq!(
            ::core::mem::align_of::<netns_ieee802154_lowpan>(),
            8usize,
            concat!("Alignment of ", stringify!(netns_ieee802154_lowpan))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ieee802154_lowpan>())).sysctl as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ieee802154_lowpan),
                "::",
                stringify!(sysctl)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ieee802154_lowpan>())).fqdir as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ieee802154_lowpan),
                "::",
                stringify!(fqdir)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct proc_dir_entry {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct sctp_mib {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct netns_sctp {
        pub sctp_statistics: *mut sctp_mib,
        pub proc_net_sctp: *mut proc_dir_entry,
        pub sysctl_header: *mut ctl_table_header,
        pub ctl_sock: *mut sock,
        pub udp4_sock: *mut sock,
        pub udp6_sock: *mut sock,
        pub udp_port: ::cty::c_int,
        pub encap_port: ::cty::c_int,
        pub local_addr_list: list_head,
        pub addr_waitq: list_head,
        pub addr_wq_timer: timer_list,
        pub auto_asconf_splist: list_head,
        pub addr_wq_lock: spinlock_t,
        pub local_addr_lock: spinlock_t,
        pub rto_initial: ::cty::c_uint,
        pub rto_min: ::cty::c_uint,
        pub rto_max: ::cty::c_uint,
        pub rto_alpha: ::cty::c_int,
        pub rto_beta: ::cty::c_int,
        pub max_burst: ::cty::c_int,
        pub cookie_preserve_enable: ::cty::c_int,
        pub sctp_hmac_alg: *mut ::cty::c_char,
        pub valid_cookie_life: ::cty::c_uint,
        pub sack_timeout: ::cty::c_uint,
        pub hb_interval: ::cty::c_uint,
        pub probe_interval: ::cty::c_uint,
        pub max_retrans_association: ::cty::c_int,
        pub max_retrans_path: ::cty::c_int,
        pub max_retrans_init: ::cty::c_int,
        pub pf_retrans: ::cty::c_int,
        pub ps_retrans: ::cty::c_int,
        pub pf_enable: ::cty::c_int,
        pub pf_expose: ::cty::c_int,
        pub sndbuf_policy: ::cty::c_int,
        pub rcvbuf_policy: ::cty::c_int,
        pub default_auto_asconf: ::cty::c_int,
        pub addip_enable: ::cty::c_int,
        pub addip_noauth: ::cty::c_int,
        pub prsctp_enable: ::cty::c_int,
        pub reconf_enable: ::cty::c_int,
        pub auth_enable: ::cty::c_int,
        pub intl_enable: ::cty::c_int,
        pub ecn_enable: ::cty::c_int,
        pub scope_policy: ::cty::c_int,
        pub rwnd_upd_shift: ::cty::c_int,
        pub max_autoclose: ::cty::c_ulong,
        pub l3mdev_accept: ::cty::c_int,
    }
    #[test]
    fn bindgen_test_layout_netns_sctp() {
        assert_eq!(
            ::core::mem::size_of::<netns_sctp>(),
            304usize,
            concat!("Size of: ", stringify!(netns_sctp))
        );
        assert_eq!(
            ::core::mem::align_of::<netns_sctp>(),
            8usize,
            concat!("Alignment of ", stringify!(netns_sctp))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_sctp>())).sctp_statistics as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sctp),
                "::",
                stringify!(sctp_statistics)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_sctp>())).proc_net_sctp as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sctp),
                "::",
                stringify!(proc_net_sctp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_sctp>())).sysctl_header as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sctp),
                "::",
                stringify!(sysctl_header)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_sctp>())).ctl_sock as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sctp),
                "::",
                stringify!(ctl_sock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_sctp>())).udp4_sock as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sctp),
                "::",
                stringify!(udp4_sock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_sctp>())).udp6_sock as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sctp),
                "::",
                stringify!(udp6_sock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_sctp>())).udp_port as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sctp),
                "::",
                stringify!(udp_port)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_sctp>())).encap_port as *const _ as usize },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sctp),
                "::",
                stringify!(encap_port)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_sctp>())).local_addr_list as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sctp),
                "::",
                stringify!(local_addr_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_sctp>())).addr_waitq as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sctp),
                "::",
                stringify!(addr_waitq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_sctp>())).addr_wq_timer as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sctp),
                "::",
                stringify!(addr_wq_timer)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_sctp>())).auto_asconf_splist as *const _ as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sctp),
                "::",
                stringify!(auto_asconf_splist)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_sctp>())).addr_wq_lock as *const _ as usize },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sctp),
                "::",
                stringify!(addr_wq_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_sctp>())).local_addr_lock as *const _ as usize },
            148usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sctp),
                "::",
                stringify!(local_addr_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_sctp>())).rto_initial as *const _ as usize },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sctp),
                "::",
                stringify!(rto_initial)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_sctp>())).rto_min as *const _ as usize },
            156usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sctp),
                "::",
                stringify!(rto_min)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_sctp>())).rto_max as *const _ as usize },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sctp),
                "::",
                stringify!(rto_max)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_sctp>())).rto_alpha as *const _ as usize },
            164usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sctp),
                "::",
                stringify!(rto_alpha)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_sctp>())).rto_beta as *const _ as usize },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sctp),
                "::",
                stringify!(rto_beta)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_sctp>())).max_burst as *const _ as usize },
            172usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sctp),
                "::",
                stringify!(max_burst)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_sctp>())).cookie_preserve_enable as *const _ as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sctp),
                "::",
                stringify!(cookie_preserve_enable)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_sctp>())).sctp_hmac_alg as *const _ as usize },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sctp),
                "::",
                stringify!(sctp_hmac_alg)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_sctp>())).valid_cookie_life as *const _ as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sctp),
                "::",
                stringify!(valid_cookie_life)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_sctp>())).sack_timeout as *const _ as usize },
            196usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sctp),
                "::",
                stringify!(sack_timeout)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_sctp>())).hb_interval as *const _ as usize },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sctp),
                "::",
                stringify!(hb_interval)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_sctp>())).probe_interval as *const _ as usize },
            204usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sctp),
                "::",
                stringify!(probe_interval)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_sctp>())).max_retrans_association as *const _ as usize
            },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sctp),
                "::",
                stringify!(max_retrans_association)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_sctp>())).max_retrans_path as *const _ as usize
            },
            212usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sctp),
                "::",
                stringify!(max_retrans_path)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_sctp>())).max_retrans_init as *const _ as usize
            },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sctp),
                "::",
                stringify!(max_retrans_init)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_sctp>())).pf_retrans as *const _ as usize },
            220usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sctp),
                "::",
                stringify!(pf_retrans)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_sctp>())).ps_retrans as *const _ as usize },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sctp),
                "::",
                stringify!(ps_retrans)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_sctp>())).pf_enable as *const _ as usize },
            228usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sctp),
                "::",
                stringify!(pf_enable)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_sctp>())).pf_expose as *const _ as usize },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sctp),
                "::",
                stringify!(pf_expose)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_sctp>())).sndbuf_policy as *const _ as usize },
            236usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sctp),
                "::",
                stringify!(sndbuf_policy)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_sctp>())).rcvbuf_policy as *const _ as usize },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sctp),
                "::",
                stringify!(rcvbuf_policy)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_sctp>())).default_auto_asconf as *const _ as usize
            },
            244usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sctp),
                "::",
                stringify!(default_auto_asconf)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_sctp>())).addip_enable as *const _ as usize },
            248usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sctp),
                "::",
                stringify!(addip_enable)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_sctp>())).addip_noauth as *const _ as usize },
            252usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sctp),
                "::",
                stringify!(addip_noauth)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_sctp>())).prsctp_enable as *const _ as usize },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sctp),
                "::",
                stringify!(prsctp_enable)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_sctp>())).reconf_enable as *const _ as usize },
            260usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sctp),
                "::",
                stringify!(reconf_enable)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_sctp>())).auth_enable as *const _ as usize },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sctp),
                "::",
                stringify!(auth_enable)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_sctp>())).intl_enable as *const _ as usize },
            268usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sctp),
                "::",
                stringify!(intl_enable)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_sctp>())).ecn_enable as *const _ as usize },
            272usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sctp),
                "::",
                stringify!(ecn_enable)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_sctp>())).scope_policy as *const _ as usize },
            276usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sctp),
                "::",
                stringify!(scope_policy)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_sctp>())).rwnd_upd_shift as *const _ as usize },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sctp),
                "::",
                stringify!(rwnd_upd_shift)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_sctp>())).max_autoclose as *const _ as usize },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sctp),
                "::",
                stringify!(max_autoclose)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_sctp>())).l3mdev_accept as *const _ as usize },
            296usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_sctp),
                "::",
                stringify!(l3mdev_accept)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct kref {
        pub refcount: refcount_t,
    }
    #[test]
    fn bindgen_test_layout_kref() {
        assert_eq!(
            ::core::mem::size_of::<kref>(),
            4usize,
            concat!("Size of: ", stringify!(kref))
        );
        assert_eq!(
            ::core::mem::align_of::<kref>(),
            4usize,
            concat!("Alignment of ", stringify!(kref))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kref>())).refcount as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(kref),
                "::",
                stringify!(refcount)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct lockdep_map_p {}
    #[test]
    fn bindgen_test_layout_lockdep_map_p() {
        assert_eq!(
            ::core::mem::size_of::<lockdep_map_p>(),
            0usize,
            concat!("Size of: ", stringify!(lockdep_map_p))
        );
        assert_eq!(
            ::core::mem::align_of::<lockdep_map_p>(),
            1usize,
            concat!("Alignment of ", stringify!(lockdep_map_p))
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct maple_tree {
        pub __bindgen_anon_1: maple_tree__bindgen_ty_1,
        pub ma_root: *mut ::cty::c_void,
        pub ma_flags: ::cty::c_uint,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union maple_tree__bindgen_ty_1 {
        pub ma_lock: spinlock_t,
        pub ma_external_lock: lockdep_map_p,
    }
    #[test]
    fn bindgen_test_layout_maple_tree__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<maple_tree__bindgen_ty_1>(),
            4usize,
            concat!("Size of: ", stringify!(maple_tree__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<maple_tree__bindgen_ty_1>(),
            4usize,
            concat!("Alignment of ", stringify!(maple_tree__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<maple_tree__bindgen_ty_1>())).ma_lock as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(maple_tree__bindgen_ty_1),
                "::",
                stringify!(ma_lock)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<maple_tree__bindgen_ty_1>())).ma_external_lock as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(maple_tree__bindgen_ty_1),
                "::",
                stringify!(ma_external_lock)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_maple_tree() {
        assert_eq!(
            ::core::mem::size_of::<maple_tree>(),
            24usize,
            concat!("Size of: ", stringify!(maple_tree))
        );
        assert_eq!(
            ::core::mem::align_of::<maple_tree>(),
            8usize,
            concat!("Alignment of ", stringify!(maple_tree))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<maple_tree>())).ma_root as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(maple_tree),
                "::",
                stringify!(ma_root)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<maple_tree>())).ma_flags as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(maple_tree),
                "::",
                stringify!(ma_flags)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct arch_uprobe_task {
        pub saved_scratch_register: ::cty::c_ulong,
        pub saved_trap_nr: ::cty::c_uint,
        pub saved_tf: ::cty::c_uint,
    }
    #[test]
    fn bindgen_test_layout_arch_uprobe_task() {
        assert_eq!(
            ::core::mem::size_of::<arch_uprobe_task>(),
            16usize,
            concat!("Size of: ", stringify!(arch_uprobe_task))
        );
        assert_eq!(
            ::core::mem::align_of::<arch_uprobe_task>(),
            8usize,
            concat!("Alignment of ", stringify!(arch_uprobe_task))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<arch_uprobe_task>())).saved_scratch_register as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(arch_uprobe_task),
                "::",
                stringify!(saved_scratch_register)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<arch_uprobe_task>())).saved_trap_nr as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(arch_uprobe_task),
                "::",
                stringify!(saved_trap_nr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<arch_uprobe_task>())).saved_tf as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(arch_uprobe_task),
                "::",
                stringify!(saved_tf)
            )
        );
    }
    pub const uprobe_task_state_UTASK_RUNNING: uprobe_task_state = 0;
    pub const uprobe_task_state_UTASK_SSTEP: uprobe_task_state = 1;
    pub const uprobe_task_state_UTASK_SSTEP_ACK: uprobe_task_state = 2;
    pub const uprobe_task_state_UTASK_SSTEP_TRAPPED: uprobe_task_state = 3;
    pub type uprobe_task_state = ::cty::c_uint;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct uprobe_task {
        pub state: uprobe_task_state,
        pub __bindgen_anon_1: uprobe_task__bindgen_ty_1,
        pub active_uprobe: *mut uprobe,
        pub xol_vaddr: ::cty::c_ulong,
        pub return_instances: *mut return_instance,
        pub depth: ::cty::c_uint,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union uprobe_task__bindgen_ty_1 {
        pub __bindgen_anon_1: uprobe_task__bindgen_ty_1__bindgen_ty_1,
        pub __bindgen_anon_2: uprobe_task__bindgen_ty_1__bindgen_ty_2,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct uprobe_task__bindgen_ty_1__bindgen_ty_1 {
        pub autask: arch_uprobe_task,
        pub vaddr: ::cty::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_uprobe_task__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<uprobe_task__bindgen_ty_1__bindgen_ty_1>(),
            24usize,
            concat!(
                "Size of: ",
                stringify!(uprobe_task__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<uprobe_task__bindgen_ty_1__bindgen_ty_1>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(uprobe_task__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<uprobe_task__bindgen_ty_1__bindgen_ty_1>())).autask
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(uprobe_task__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(autask)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<uprobe_task__bindgen_ty_1__bindgen_ty_1>())).vaddr
                    as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(uprobe_task__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(vaddr)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct uprobe_task__bindgen_ty_1__bindgen_ty_2 {
        pub dup_xol_work: callback_head,
        pub dup_xol_addr: ::cty::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_uprobe_task__bindgen_ty_1__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<uprobe_task__bindgen_ty_1__bindgen_ty_2>(),
            24usize,
            concat!(
                "Size of: ",
                stringify!(uprobe_task__bindgen_ty_1__bindgen_ty_2)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<uprobe_task__bindgen_ty_1__bindgen_ty_2>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(uprobe_task__bindgen_ty_1__bindgen_ty_2)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<uprobe_task__bindgen_ty_1__bindgen_ty_2>())).dup_xol_work
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(uprobe_task__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(dup_xol_work)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<uprobe_task__bindgen_ty_1__bindgen_ty_2>())).dup_xol_addr
                    as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(uprobe_task__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(dup_xol_addr)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_uprobe_task__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<uprobe_task__bindgen_ty_1>(),
            24usize,
            concat!("Size of: ", stringify!(uprobe_task__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<uprobe_task__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(uprobe_task__bindgen_ty_1))
        );
    }
    #[test]
    fn bindgen_test_layout_uprobe_task() {
        assert_eq!(
            ::core::mem::size_of::<uprobe_task>(),
            64usize,
            concat!("Size of: ", stringify!(uprobe_task))
        );
        assert_eq!(
            ::core::mem::align_of::<uprobe_task>(),
            8usize,
            concat!("Alignment of ", stringify!(uprobe_task))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<uprobe_task>())).state as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(uprobe_task),
                "::",
                stringify!(state)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<uprobe_task>())).active_uprobe as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(uprobe_task),
                "::",
                stringify!(active_uprobe)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<uprobe_task>())).xol_vaddr as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(uprobe_task),
                "::",
                stringify!(xol_vaddr)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<uprobe_task>())).return_instances as *const _ as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(uprobe_task),
                "::",
                stringify!(return_instances)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<uprobe_task>())).depth as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(uprobe_task),
                "::",
                stringify!(depth)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct return_instance {
        pub uprobe: *mut uprobe,
        pub func: ::cty::c_ulong,
        pub stack: ::cty::c_ulong,
        pub orig_ret_vaddr: ::cty::c_ulong,
        pub chained: bool_,
        pub next: *mut return_instance,
    }
    #[test]
    fn bindgen_test_layout_return_instance() {
        assert_eq!(
            ::core::mem::size_of::<return_instance>(),
            48usize,
            concat!("Size of: ", stringify!(return_instance))
        );
        assert_eq!(
            ::core::mem::align_of::<return_instance>(),
            8usize,
            concat!("Alignment of ", stringify!(return_instance))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<return_instance>())).uprobe as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(return_instance),
                "::",
                stringify!(uprobe)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<return_instance>())).func as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(return_instance),
                "::",
                stringify!(func)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<return_instance>())).stack as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(return_instance),
                "::",
                stringify!(stack)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<return_instance>())).orig_ret_vaddr as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(return_instance),
                "::",
                stringify!(orig_ret_vaddr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<return_instance>())).chained as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(return_instance),
                "::",
                stringify!(chained)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<return_instance>())).next as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(return_instance),
                "::",
                stringify!(next)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct xol_area {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct uprobes_state {
        pub xol_area: *mut xol_area,
    }
    #[test]
    fn bindgen_test_layout_uprobes_state() {
        assert_eq!(
            ::core::mem::size_of::<uprobes_state>(),
            8usize,
            concat!("Size of: ", stringify!(uprobes_state))
        );
        assert_eq!(
            ::core::mem::align_of::<uprobes_state>(),
            8usize,
            concat!("Alignment of ", stringify!(uprobes_state))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<uprobes_state>())).xol_area as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(uprobes_state),
                "::",
                stringify!(xol_area)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct mm_context_t {
        pub ctx_id: _cargo_bpf_u64,
        pub tlb_gen: atomic64_t,
        pub ldt_usr_sem: rw_semaphore,
        pub ldt: *mut ldt_struct,
        pub flags: ::cty::c_ulong,
        pub lam_cr3_mask: ::cty::c_ulong,
        pub untag_mask: _cargo_bpf_u64,
        pub lock: mutex,
        pub vdso: *mut ::cty::c_void,
        pub vdso_image: *const vdso_image,
        pub perf_rdpmc_allowed: atomic_t,
        pub pkey_allocation_map: _cargo_bpf_u16,
        pub execute_only_pkey: s16,
    }
    #[test]
    fn bindgen_test_layout_mm_context_t() {
        assert_eq!(
            ::core::mem::size_of::<mm_context_t>(),
            144usize,
            concat!("Size of: ", stringify!(mm_context_t))
        );
        assert_eq!(
            ::core::mem::align_of::<mm_context_t>(),
            8usize,
            concat!("Alignment of ", stringify!(mm_context_t))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mm_context_t>())).ctx_id as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_context_t),
                "::",
                stringify!(ctx_id)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mm_context_t>())).tlb_gen as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_context_t),
                "::",
                stringify!(tlb_gen)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mm_context_t>())).ldt_usr_sem as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_context_t),
                "::",
                stringify!(ldt_usr_sem)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mm_context_t>())).ldt as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_context_t),
                "::",
                stringify!(ldt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mm_context_t>())).flags as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_context_t),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mm_context_t>())).lam_cr3_mask as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_context_t),
                "::",
                stringify!(lam_cr3_mask)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mm_context_t>())).untag_mask as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_context_t),
                "::",
                stringify!(untag_mask)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mm_context_t>())).lock as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_context_t),
                "::",
                stringify!(lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mm_context_t>())).vdso as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_context_t),
                "::",
                stringify!(vdso)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mm_context_t>())).vdso_image as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_context_t),
                "::",
                stringify!(vdso_image)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_context_t>())).perf_rdpmc_allowed as *const _ as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_context_t),
                "::",
                stringify!(perf_rdpmc_allowed)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_context_t>())).pkey_allocation_map as *const _ as usize
            },
            140usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_context_t),
                "::",
                stringify!(pkey_allocation_map)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_context_t>())).execute_only_pkey as *const _ as usize
            },
            142usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_context_t),
                "::",
                stringify!(execute_only_pkey)
            )
        );
    }
    #[repr(C)]
    #[repr(align(16))]
    #[derive(Copy, Clone)]
    pub struct page {
        pub flags: ::cty::c_ulong,
        pub __bindgen_anon_1: page__bindgen_ty_1,
        pub __bindgen_anon_2: page__bindgen_ty_2,
        pub _refcount: atomic_t,
        pub memcg_data: ::cty::c_ulong,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union page__bindgen_ty_1 {
        pub __bindgen_anon_1: page__bindgen_ty_1__bindgen_ty_1,
        pub __bindgen_anon_2: page__bindgen_ty_1__bindgen_ty_2,
        pub __bindgen_anon_3: page__bindgen_ty_1__bindgen_ty_3,
        pub __bindgen_anon_4: page__bindgen_ty_1__bindgen_ty_4,
        pub __bindgen_anon_5: page__bindgen_ty_1__bindgen_ty_5,
        pub callback_head: callback_head,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct page__bindgen_ty_1__bindgen_ty_1 {
        pub __bindgen_anon_1: page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
        pub mapping: *mut address_space,
        pub __bindgen_anon_2: page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2,
        #[doc = " @private: Mapping-private opaque data."]
        #[doc = " Usually used for buffer_heads if PagePrivate."]
        #[doc = " Used for swp_entry_t if PageSwapCache."]
        #[doc = " Indicates order in the buddy system if PageBuddy."]
        pub private: ::cty::c_ulong,
    }
    #[doc = " @lru: Pageout list, eg. active_list protected by"]
    #[doc = " lruvec->lru_lock.  Sometimes used as a generic list"]
    #[doc = " by the page owner."]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
        pub lru: list_head,
        pub __bindgen_anon_1: page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
        pub buddy_list: list_head,
        pub pcp_list: list_head,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
        pub __filler: *mut ::cty::c_void,
        pub mlock_count: ::cty::c_uint,
    }
    #[test]
    fn bindgen_test_layout_page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
            16usize,
            concat!(
                "Size of: ",
                stringify!(page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<
                    page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
                >()))
                .__filler as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(__filler)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<
                    page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
                >()))
                .mlock_count as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(mlock_count)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
            16usize,
            concat!(
                "Size of: ",
                stringify!(page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).lru
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(lru)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()))
                    .buddy_list as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(buddy_list)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).pcp_list
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(pcp_list)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
        pub index: ::cty::c_ulong,
        pub share: ::cty::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2>(),
            8usize,
            concat!(
                "Size of: ",
                stringify!(page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2>())).index
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(index)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2>())).share
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(share)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_page__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<page__bindgen_ty_1__bindgen_ty_1>(),
            40usize,
            concat!("Size of: ", stringify!(page__bindgen_ty_1__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<page__bindgen_ty_1__bindgen_ty_1>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(page__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_1>())).mapping as *const _
                    as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(page__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(mapping)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_1>())).private as *const _
                    as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(page__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(private)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct page__bindgen_ty_1__bindgen_ty_2 {
        #[doc = " @pp_magic: magic value to avoid recycling non"]
        #[doc = " page_pool allocated pages."]
        pub pp_magic: ::cty::c_ulong,
        pub pp: *mut page_pool,
        pub _pp_mapping_pad: ::cty::c_ulong,
        pub dma_addr: ::cty::c_ulong,
        pub __bindgen_anon_1: page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
        #[doc = " dma_addr_upper: might require a 64-bit"]
        #[doc = " value on 32-bit architectures."]
        pub dma_addr_upper: ::cty::c_ulong,
        #[doc = " For frag page support, not supported in"]
        #[doc = " 32-bit architectures with 64-bit DMA."]
        pub pp_frag_count: atomic_long_t,
    }
    #[test]
    fn bindgen_test_layout_page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>(),
            8usize,
            concat!(
                "Size of: ",
                stringify!(page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>()))
                    .dma_addr_upper as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1),
                "::",
                stringify!(dma_addr_upper)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>()))
                    .pp_frag_count as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1),
                "::",
                stringify!(pp_frag_count)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_page__bindgen_ty_1__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<page__bindgen_ty_1__bindgen_ty_2>(),
            40usize,
            concat!("Size of: ", stringify!(page__bindgen_ty_1__bindgen_ty_2))
        );
        assert_eq!(
            ::core::mem::align_of::<page__bindgen_ty_1__bindgen_ty_2>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(page__bindgen_ty_1__bindgen_ty_2)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_2>())).pp_magic as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(page__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(pp_magic)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_2>())).pp as *const _
                    as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(page__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(pp)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_2>()))._pp_mapping_pad
                    as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(page__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(_pp_mapping_pad)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_2>())).dma_addr as *const _
                    as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(page__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(dma_addr)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct page__bindgen_ty_1__bindgen_ty_3 {
        pub compound_head: ::cty::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_page__bindgen_ty_1__bindgen_ty_3() {
        assert_eq!(
            ::core::mem::size_of::<page__bindgen_ty_1__bindgen_ty_3>(),
            8usize,
            concat!("Size of: ", stringify!(page__bindgen_ty_1__bindgen_ty_3))
        );
        assert_eq!(
            ::core::mem::align_of::<page__bindgen_ty_1__bindgen_ty_3>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(page__bindgen_ty_1__bindgen_ty_3)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_3>())).compound_head
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(page__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(compound_head)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct page__bindgen_ty_1__bindgen_ty_4 {
        pub _pt_pad_1: ::cty::c_ulong,
        pub pmd_huge_pte: pgtable_t,
        pub _pt_pad_2: ::cty::c_ulong,
        pub __bindgen_anon_1: page__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1,
        pub ptl: spinlock_t,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union page__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 {
        pub pt_mm: *mut mm_struct,
        pub pt_frag_refcount: atomic_t,
    }
    #[test]
    fn bindgen_test_layout_page__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<page__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1>(),
            8usize,
            concat!(
                "Size of: ",
                stringify!(page__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<page__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(page__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1>())).pt_mm
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(page__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1),
                "::",
                stringify!(pt_mm)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1>()))
                    .pt_frag_refcount as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(page__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1),
                "::",
                stringify!(pt_frag_refcount)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_page__bindgen_ty_1__bindgen_ty_4() {
        assert_eq!(
            ::core::mem::size_of::<page__bindgen_ty_1__bindgen_ty_4>(),
            40usize,
            concat!("Size of: ", stringify!(page__bindgen_ty_1__bindgen_ty_4))
        );
        assert_eq!(
            ::core::mem::align_of::<page__bindgen_ty_1__bindgen_ty_4>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(page__bindgen_ty_1__bindgen_ty_4)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_4>()))._pt_pad_1 as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(page__bindgen_ty_1__bindgen_ty_4),
                "::",
                stringify!(_pt_pad_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_4>())).pmd_huge_pte
                    as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(page__bindgen_ty_1__bindgen_ty_4),
                "::",
                stringify!(pmd_huge_pte)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_4>()))._pt_pad_2 as *const _
                    as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(page__bindgen_ty_1__bindgen_ty_4),
                "::",
                stringify!(_pt_pad_2)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_4>())).ptl as *const _
                    as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(page__bindgen_ty_1__bindgen_ty_4),
                "::",
                stringify!(ptl)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct page__bindgen_ty_1__bindgen_ty_5 {
        #[doc = " @pgmap: Points to the hosting device page map."]
        pub pgmap: *mut dev_pagemap,
        pub zone_device_data: *mut ::cty::c_void,
    }
    #[test]
    fn bindgen_test_layout_page__bindgen_ty_1__bindgen_ty_5() {
        assert_eq!(
            ::core::mem::size_of::<page__bindgen_ty_1__bindgen_ty_5>(),
            16usize,
            concat!("Size of: ", stringify!(page__bindgen_ty_1__bindgen_ty_5))
        );
        assert_eq!(
            ::core::mem::align_of::<page__bindgen_ty_1__bindgen_ty_5>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(page__bindgen_ty_1__bindgen_ty_5)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_5>())).pgmap as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(page__bindgen_ty_1__bindgen_ty_5),
                "::",
                stringify!(pgmap)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<page__bindgen_ty_1__bindgen_ty_5>())).zone_device_data
                    as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(page__bindgen_ty_1__bindgen_ty_5),
                "::",
                stringify!(zone_device_data)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_page__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<page__bindgen_ty_1>(),
            40usize,
            concat!("Size of: ", stringify!(page__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<page__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(page__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<page__bindgen_ty_1>())).callback_head as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(page__bindgen_ty_1),
                "::",
                stringify!(callback_head)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union page__bindgen_ty_2 {
        pub _mapcount: atomic_t,
        pub page_type: ::cty::c_uint,
    }
    #[test]
    fn bindgen_test_layout_page__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<page__bindgen_ty_2>(),
            4usize,
            concat!("Size of: ", stringify!(page__bindgen_ty_2))
        );
        assert_eq!(
            ::core::mem::align_of::<page__bindgen_ty_2>(),
            4usize,
            concat!("Alignment of ", stringify!(page__bindgen_ty_2))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<page__bindgen_ty_2>()))._mapcount as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(page__bindgen_ty_2),
                "::",
                stringify!(_mapcount)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<page__bindgen_ty_2>())).page_type as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(page__bindgen_ty_2),
                "::",
                stringify!(page_type)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_page() {
        assert_eq!(
            ::core::mem::size_of::<page>(),
            64usize,
            concat!("Size of: ", stringify!(page))
        );
        assert_eq!(
            ::core::mem::align_of::<page>(),
            16usize,
            concat!("Alignment of ", stringify!(page))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<page>())).flags as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(page),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<page>()))._refcount as *const _ as usize },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(page),
                "::",
                stringify!(_refcount)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<page>())).memcg_data as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(page),
                "::",
                stringify!(memcg_data)
            )
        );
    }
    #[doc = " struct folio - Represents a contiguous set of bytes."]
    #[doc = " @flags: Identical to the page flags."]
    #[doc = " @lru: Least Recently Used list; tracks how recently this folio was used."]
    #[doc = " @mlock_count: Number of times this folio has been pinned by mlock()."]
    #[doc = " @mapping: The file this page belongs to, or refers to the anon_vma for"]
    #[doc = "    anonymous memory."]
    #[doc = " @index: Offset within the file, in units of pages.  For anonymous memory,"]
    #[doc = "    this is the index from the beginning of the mmap."]
    #[doc = " @private: Filesystem per-folio data (see folio_attach_private())."]
    #[doc = "    Used for swp_entry_t if folio_test_swapcache()."]
    #[doc = " @_mapcount: Do not access this member directly.  Use folio_mapcount() to"]
    #[doc = "    find out how many times this folio is mapped by userspace."]
    #[doc = " @_refcount: Do not access this member directly.  Use folio_ref_count()"]
    #[doc = "    to find how many references there are to this folio."]
    #[doc = " @memcg_data: Memory Control Group data."]
    #[doc = " @_folio_dtor: Which destructor to use for this folio."]
    #[doc = " @_folio_order: Do not use directly, call folio_order()."]
    #[doc = " @_entire_mapcount: Do not use directly, call folio_entire_mapcount()."]
    #[doc = " @_nr_pages_mapped: Do not use directly, call folio_mapcount()."]
    #[doc = " @_pincount: Do not use directly, call folio_maybe_dma_pinned()."]
    #[doc = " @_folio_nr_pages: Do not use directly, call folio_nr_pages()."]
    #[doc = " @_hugetlb_subpool: Do not use directly, use accessor in hugetlb.h."]
    #[doc = " @_hugetlb_cgroup: Do not use directly, use accessor in hugetlb_cgroup.h."]
    #[doc = " @_hugetlb_cgroup_rsvd: Do not use directly, use accessor in hugetlb_cgroup.h."]
    #[doc = " @_hugetlb_hwpoison: Do not use directly, call raw_hwp_list_head()."]
    #[doc = " @_deferred_list: Folios to be split under memory pressure."]
    #[doc = ""]
    #[doc = " A folio is a physically, virtually and logically contiguous set"]
    #[doc = " of bytes.  It is a power-of-two in size, and it is aligned to that"]
    #[doc = " same power-of-two.  It is at least as large as %PAGE_SIZE.  If it is"]
    #[doc = " in the page cache, it is at a file offset which is a multiple of that"]
    #[doc = " power-of-two.  It may be mapped into userspace at an address which is"]
    #[doc = " at an arbitrary page offset, but its kernel virtual address is aligned"]
    #[doc = " to its size."]
    #[repr(C)]
    #[repr(align(16))]
    #[derive(Copy, Clone)]
    pub struct folio {
        pub __bindgen_anon_1: folio__bindgen_ty_1,
        pub __bindgen_anon_2: folio__bindgen_ty_2,
        pub __bindgen_anon_3: folio__bindgen_ty_3,
    }
    #[repr(C)]
    #[repr(align(16))]
    #[derive(Copy, Clone)]
    pub union folio__bindgen_ty_1 {
        pub __bindgen_anon_1: folio__bindgen_ty_1__bindgen_ty_1,
        pub page: page,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct folio__bindgen_ty_1__bindgen_ty_1 {
        pub flags: ::cty::c_ulong,
        pub __bindgen_anon_1: folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
        pub mapping: *mut address_space,
        pub index: ::cty::c_ulong,
        pub private: *mut ::cty::c_void,
        pub _mapcount: atomic_t,
        pub _refcount: atomic_t,
        pub memcg_data: ::cty::c_ulong,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
        pub lru: list_head,
        pub __bindgen_anon_1: folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
        pub __filler: *mut ::cty::c_void,
        pub mlock_count: ::cty::c_uint,
    }
    #[test]
    fn bindgen_test_layout_folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
            16usize,
            concat!(
                "Size of: ",
                stringify!(folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(
            ),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<
                    folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
                >()))
                .__filler as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(__filler)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<
                    folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
                >()))
                .mlock_count as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(mlock_count)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
            16usize,
            concat!(
                "Size of: ",
                stringify!(folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).lru
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(lru)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_folio__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<folio__bindgen_ty_1__bindgen_ty_1>(),
            64usize,
            concat!("Size of: ", stringify!(folio__bindgen_ty_1__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<folio__bindgen_ty_1__bindgen_ty_1>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(folio__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<folio__bindgen_ty_1__bindgen_ty_1>())).flags as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(folio__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<folio__bindgen_ty_1__bindgen_ty_1>())).mapping as *const _
                    as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(folio__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(mapping)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<folio__bindgen_ty_1__bindgen_ty_1>())).index as *const _
                    as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(folio__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(index)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<folio__bindgen_ty_1__bindgen_ty_1>())).private as *const _
                    as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(folio__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(private)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<folio__bindgen_ty_1__bindgen_ty_1>()))._mapcount as *const _
                    as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(folio__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(_mapcount)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<folio__bindgen_ty_1__bindgen_ty_1>()))._refcount as *const _
                    as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(folio__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(_refcount)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<folio__bindgen_ty_1__bindgen_ty_1>())).memcg_data
                    as *const _ as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(folio__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(memcg_data)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_folio__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<folio__bindgen_ty_1>(),
            64usize,
            concat!("Size of: ", stringify!(folio__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<folio__bindgen_ty_1>(),
            16usize,
            concat!("Alignment of ", stringify!(folio__bindgen_ty_1))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<folio__bindgen_ty_1>())).page as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(folio__bindgen_ty_1),
                "::",
                stringify!(page)
            )
        );
    }
    #[repr(C)]
    #[repr(align(16))]
    #[derive(Copy, Clone)]
    pub union folio__bindgen_ty_2 {
        pub __bindgen_anon_1: folio__bindgen_ty_2__bindgen_ty_1,
        pub __page_1: page,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct folio__bindgen_ty_2__bindgen_ty_1 {
        pub _flags_1: ::cty::c_ulong,
        pub _head_1: ::cty::c_ulong,
        pub _folio_dtor: ::cty::c_uchar,
        pub _folio_order: ::cty::c_uchar,
        pub _entire_mapcount: atomic_t,
        pub _nr_pages_mapped: atomic_t,
        pub _pincount: atomic_t,
        pub _folio_nr_pages: ::cty::c_uint,
    }
    #[test]
    fn bindgen_test_layout_folio__bindgen_ty_2__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<folio__bindgen_ty_2__bindgen_ty_1>(),
            40usize,
            concat!("Size of: ", stringify!(folio__bindgen_ty_2__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<folio__bindgen_ty_2__bindgen_ty_1>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(folio__bindgen_ty_2__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<folio__bindgen_ty_2__bindgen_ty_1>()))._flags_1 as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(folio__bindgen_ty_2__bindgen_ty_1),
                "::",
                stringify!(_flags_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<folio__bindgen_ty_2__bindgen_ty_1>()))._head_1 as *const _
                    as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(folio__bindgen_ty_2__bindgen_ty_1),
                "::",
                stringify!(_head_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<folio__bindgen_ty_2__bindgen_ty_1>()))._folio_dtor
                    as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(folio__bindgen_ty_2__bindgen_ty_1),
                "::",
                stringify!(_folio_dtor)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<folio__bindgen_ty_2__bindgen_ty_1>()))._folio_order
                    as *const _ as usize
            },
            17usize,
            concat!(
                "Offset of field: ",
                stringify!(folio__bindgen_ty_2__bindgen_ty_1),
                "::",
                stringify!(_folio_order)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<folio__bindgen_ty_2__bindgen_ty_1>()))._entire_mapcount
                    as *const _ as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(folio__bindgen_ty_2__bindgen_ty_1),
                "::",
                stringify!(_entire_mapcount)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<folio__bindgen_ty_2__bindgen_ty_1>()))._nr_pages_mapped
                    as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(folio__bindgen_ty_2__bindgen_ty_1),
                "::",
                stringify!(_nr_pages_mapped)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<folio__bindgen_ty_2__bindgen_ty_1>()))._pincount as *const _
                    as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(folio__bindgen_ty_2__bindgen_ty_1),
                "::",
                stringify!(_pincount)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<folio__bindgen_ty_2__bindgen_ty_1>()))._folio_nr_pages
                    as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(folio__bindgen_ty_2__bindgen_ty_1),
                "::",
                stringify!(_folio_nr_pages)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_folio__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<folio__bindgen_ty_2>(),
            64usize,
            concat!("Size of: ", stringify!(folio__bindgen_ty_2))
        );
        assert_eq!(
            ::core::mem::align_of::<folio__bindgen_ty_2>(),
            16usize,
            concat!("Alignment of ", stringify!(folio__bindgen_ty_2))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<folio__bindgen_ty_2>())).__page_1 as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(folio__bindgen_ty_2),
                "::",
                stringify!(__page_1)
            )
        );
    }
    #[repr(C)]
    #[repr(align(16))]
    #[derive(Copy, Clone)]
    pub union folio__bindgen_ty_3 {
        pub __bindgen_anon_1: folio__bindgen_ty_3__bindgen_ty_1,
        pub __bindgen_anon_2: folio__bindgen_ty_3__bindgen_ty_2,
        pub __page_2: page,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct folio__bindgen_ty_3__bindgen_ty_1 {
        pub _flags_2: ::cty::c_ulong,
        pub _head_2: ::cty::c_ulong,
        pub _hugetlb_subpool: *mut ::cty::c_void,
        pub _hugetlb_cgroup: *mut ::cty::c_void,
        pub _hugetlb_cgroup_rsvd: *mut ::cty::c_void,
        pub _hugetlb_hwpoison: *mut ::cty::c_void,
    }
    #[test]
    fn bindgen_test_layout_folio__bindgen_ty_3__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<folio__bindgen_ty_3__bindgen_ty_1>(),
            48usize,
            concat!("Size of: ", stringify!(folio__bindgen_ty_3__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<folio__bindgen_ty_3__bindgen_ty_1>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(folio__bindgen_ty_3__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<folio__bindgen_ty_3__bindgen_ty_1>()))._flags_2 as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(folio__bindgen_ty_3__bindgen_ty_1),
                "::",
                stringify!(_flags_2)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<folio__bindgen_ty_3__bindgen_ty_1>()))._head_2 as *const _
                    as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(folio__bindgen_ty_3__bindgen_ty_1),
                "::",
                stringify!(_head_2)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<folio__bindgen_ty_3__bindgen_ty_1>()))._hugetlb_subpool
                    as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(folio__bindgen_ty_3__bindgen_ty_1),
                "::",
                stringify!(_hugetlb_subpool)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<folio__bindgen_ty_3__bindgen_ty_1>()))._hugetlb_cgroup
                    as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(folio__bindgen_ty_3__bindgen_ty_1),
                "::",
                stringify!(_hugetlb_cgroup)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<folio__bindgen_ty_3__bindgen_ty_1>()))._hugetlb_cgroup_rsvd
                    as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(folio__bindgen_ty_3__bindgen_ty_1),
                "::",
                stringify!(_hugetlb_cgroup_rsvd)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<folio__bindgen_ty_3__bindgen_ty_1>()))._hugetlb_hwpoison
                    as *const _ as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(folio__bindgen_ty_3__bindgen_ty_1),
                "::",
                stringify!(_hugetlb_hwpoison)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct folio__bindgen_ty_3__bindgen_ty_2 {
        pub _flags_2a: ::cty::c_ulong,
        pub _head_2a: ::cty::c_ulong,
        pub _deferred_list: list_head,
    }
    #[test]
    fn bindgen_test_layout_folio__bindgen_ty_3__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<folio__bindgen_ty_3__bindgen_ty_2>(),
            32usize,
            concat!("Size of: ", stringify!(folio__bindgen_ty_3__bindgen_ty_2))
        );
        assert_eq!(
            ::core::mem::align_of::<folio__bindgen_ty_3__bindgen_ty_2>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(folio__bindgen_ty_3__bindgen_ty_2)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<folio__bindgen_ty_3__bindgen_ty_2>()))._flags_2a as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(folio__bindgen_ty_3__bindgen_ty_2),
                "::",
                stringify!(_flags_2a)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<folio__bindgen_ty_3__bindgen_ty_2>()))._head_2a as *const _
                    as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(folio__bindgen_ty_3__bindgen_ty_2),
                "::",
                stringify!(_head_2a)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<folio__bindgen_ty_3__bindgen_ty_2>()))._deferred_list
                    as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(folio__bindgen_ty_3__bindgen_ty_2),
                "::",
                stringify!(_deferred_list)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_folio__bindgen_ty_3() {
        assert_eq!(
            ::core::mem::size_of::<folio__bindgen_ty_3>(),
            64usize,
            concat!("Size of: ", stringify!(folio__bindgen_ty_3))
        );
        assert_eq!(
            ::core::mem::align_of::<folio__bindgen_ty_3>(),
            16usize,
            concat!("Alignment of ", stringify!(folio__bindgen_ty_3))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<folio__bindgen_ty_3>())).__page_2 as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(folio__bindgen_ty_3),
                "::",
                stringify!(__page_2)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_folio() {
        assert_eq!(
            ::core::mem::size_of::<folio>(),
            192usize,
            concat!("Size of: ", stringify!(folio))
        );
        assert_eq!(
            ::core::mem::align_of::<folio>(),
            16usize,
            concat!("Alignment of ", stringify!(folio))
        );
    }
    pub type vm_flags_t = ::cty::c_ulong;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct vm_userfaultfd_ctx {
        pub ctx: *mut userfaultfd_ctx,
    }
    #[test]
    fn bindgen_test_layout_vm_userfaultfd_ctx() {
        assert_eq!(
            ::core::mem::size_of::<vm_userfaultfd_ctx>(),
            8usize,
            concat!("Size of: ", stringify!(vm_userfaultfd_ctx))
        );
        assert_eq!(
            ::core::mem::align_of::<vm_userfaultfd_ctx>(),
            8usize,
            concat!("Alignment of ", stringify!(vm_userfaultfd_ctx))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vm_userfaultfd_ctx>())).ctx as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_userfaultfd_ctx),
                "::",
                stringify!(ctx)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct anon_vma_name {
        pub kref: kref,
        pub name: __IncompleteArrayField<::cty::c_char>,
    }
    #[test]
    fn bindgen_test_layout_anon_vma_name() {
        assert_eq!(
            ::core::mem::size_of::<anon_vma_name>(),
            4usize,
            concat!("Size of: ", stringify!(anon_vma_name))
        );
        assert_eq!(
            ::core::mem::align_of::<anon_vma_name>(),
            4usize,
            concat!("Alignment of ", stringify!(anon_vma_name))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<anon_vma_name>())).kref as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(anon_vma_name),
                "::",
                stringify!(kref)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<anon_vma_name>())).name as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(anon_vma_name),
                "::",
                stringify!(name)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct vma_lock {
        pub lock: rw_semaphore,
    }
    #[test]
    fn bindgen_test_layout_vma_lock() {
        assert_eq!(
            ::core::mem::size_of::<vma_lock>(),
            40usize,
            concat!("Size of: ", stringify!(vma_lock))
        );
        assert_eq!(
            ::core::mem::align_of::<vma_lock>(),
            8usize,
            concat!("Alignment of ", stringify!(vma_lock))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vma_lock>())).lock as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(vma_lock),
                "::",
                stringify!(lock)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct vma_numab_state {
        pub next_scan: ::cty::c_ulong,
        pub next_pid_reset: ::cty::c_ulong,
        pub access_pids: [::cty::c_ulong; 2usize],
    }
    #[test]
    fn bindgen_test_layout_vma_numab_state() {
        assert_eq!(
            ::core::mem::size_of::<vma_numab_state>(),
            32usize,
            concat!("Size of: ", stringify!(vma_numab_state))
        );
        assert_eq!(
            ::core::mem::align_of::<vma_numab_state>(),
            8usize,
            concat!("Alignment of ", stringify!(vma_numab_state))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vma_numab_state>())).next_scan as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(vma_numab_state),
                "::",
                stringify!(next_scan)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<vma_numab_state>())).next_pid_reset as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(vma_numab_state),
                "::",
                stringify!(next_pid_reset)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<vma_numab_state>())).access_pids as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(vma_numab_state),
                "::",
                stringify!(access_pids)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct vm_area_struct {
        pub __bindgen_anon_1: vm_area_struct__bindgen_ty_1,
        pub vm_mm: *mut mm_struct,
        pub vm_page_prot: pgprot_t,
        pub __bindgen_anon_2: vm_area_struct__bindgen_ty_2,
        pub vm_lock_seq: ::cty::c_int,
        pub vm_lock: *mut vma_lock,
        pub detached: bool_,
        pub shared: vm_area_struct__bindgen_ty_3,
        pub anon_vma_chain: list_head,
        pub anon_vma: *mut anon_vma,
        pub vm_ops: *const vm_operations_struct,
        pub vm_pgoff: ::cty::c_ulong,
        pub vm_file: *mut file,
        pub vm_private_data: *mut ::cty::c_void,
        pub anon_name: *mut anon_vma_name,
        pub swap_readahead_info: atomic_long_t,
        pub vm_policy: *mut mempolicy,
        pub numab_state: *mut vma_numab_state,
        pub vm_userfaultfd_ctx: vm_userfaultfd_ctx,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union vm_area_struct__bindgen_ty_1 {
        pub __bindgen_anon_1: vm_area_struct__bindgen_ty_1__bindgen_ty_1,
        pub vm_rcu: callback_head,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct vm_area_struct__bindgen_ty_1__bindgen_ty_1 {
        pub vm_start: ::cty::c_ulong,
        pub vm_end: ::cty::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_vm_area_struct__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<vm_area_struct__bindgen_ty_1__bindgen_ty_1>(),
            16usize,
            concat!(
                "Size of: ",
                stringify!(vm_area_struct__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<vm_area_struct__bindgen_ty_1__bindgen_ty_1>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(vm_area_struct__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<vm_area_struct__bindgen_ty_1__bindgen_ty_1>())).vm_start
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_area_struct__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(vm_start)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<vm_area_struct__bindgen_ty_1__bindgen_ty_1>())).vm_end
                    as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_area_struct__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(vm_end)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_vm_area_struct__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<vm_area_struct__bindgen_ty_1>(),
            16usize,
            concat!("Size of: ", stringify!(vm_area_struct__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<vm_area_struct__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(vm_area_struct__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<vm_area_struct__bindgen_ty_1>())).vm_rcu as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_area_struct__bindgen_ty_1),
                "::",
                stringify!(vm_rcu)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union vm_area_struct__bindgen_ty_2 {
        pub vm_flags: vm_flags_t,
        pub __vm_flags: vm_flags_t,
    }
    #[test]
    fn bindgen_test_layout_vm_area_struct__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<vm_area_struct__bindgen_ty_2>(),
            8usize,
            concat!("Size of: ", stringify!(vm_area_struct__bindgen_ty_2))
        );
        assert_eq!(
            ::core::mem::align_of::<vm_area_struct__bindgen_ty_2>(),
            8usize,
            concat!("Alignment of ", stringify!(vm_area_struct__bindgen_ty_2))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<vm_area_struct__bindgen_ty_2>())).vm_flags as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_area_struct__bindgen_ty_2),
                "::",
                stringify!(vm_flags)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<vm_area_struct__bindgen_ty_2>())).__vm_flags as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_area_struct__bindgen_ty_2),
                "::",
                stringify!(__vm_flags)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct vm_area_struct__bindgen_ty_3 {
        pub rb: rb_node,
        pub rb_subtree_last: ::cty::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_vm_area_struct__bindgen_ty_3() {
        assert_eq!(
            ::core::mem::size_of::<vm_area_struct__bindgen_ty_3>(),
            32usize,
            concat!("Size of: ", stringify!(vm_area_struct__bindgen_ty_3))
        );
        assert_eq!(
            ::core::mem::align_of::<vm_area_struct__bindgen_ty_3>(),
            8usize,
            concat!("Alignment of ", stringify!(vm_area_struct__bindgen_ty_3))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<vm_area_struct__bindgen_ty_3>())).rb as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_area_struct__bindgen_ty_3),
                "::",
                stringify!(rb)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<vm_area_struct__bindgen_ty_3>())).rb_subtree_last
                    as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_area_struct__bindgen_ty_3),
                "::",
                stringify!(rb_subtree_last)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_vm_area_struct() {
        assert_eq!(
            ::core::mem::size_of::<vm_area_struct>(),
            192usize,
            concat!("Size of: ", stringify!(vm_area_struct))
        );
        assert_eq!(
            ::core::mem::align_of::<vm_area_struct>(),
            8usize,
            concat!("Alignment of ", stringify!(vm_area_struct))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vm_area_struct>())).vm_mm as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_area_struct),
                "::",
                stringify!(vm_mm)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<vm_area_struct>())).vm_page_prot as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_area_struct),
                "::",
                stringify!(vm_page_prot)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vm_area_struct>())).vm_lock_seq as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_area_struct),
                "::",
                stringify!(vm_lock_seq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vm_area_struct>())).vm_lock as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_area_struct),
                "::",
                stringify!(vm_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vm_area_struct>())).detached as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_area_struct),
                "::",
                stringify!(detached)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vm_area_struct>())).shared as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_area_struct),
                "::",
                stringify!(shared)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<vm_area_struct>())).anon_vma_chain as *const _ as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_area_struct),
                "::",
                stringify!(anon_vma_chain)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vm_area_struct>())).anon_vma as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_area_struct),
                "::",
                stringify!(anon_vma)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vm_area_struct>())).vm_ops as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_area_struct),
                "::",
                stringify!(vm_ops)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vm_area_struct>())).vm_pgoff as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_area_struct),
                "::",
                stringify!(vm_pgoff)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vm_area_struct>())).vm_file as *const _ as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_area_struct),
                "::",
                stringify!(vm_file)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<vm_area_struct>())).vm_private_data as *const _ as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_area_struct),
                "::",
                stringify!(vm_private_data)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vm_area_struct>())).anon_name as *const _ as usize },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_area_struct),
                "::",
                stringify!(anon_name)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<vm_area_struct>())).swap_readahead_info as *const _ as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_area_struct),
                "::",
                stringify!(swap_readahead_info)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vm_area_struct>())).vm_policy as *const _ as usize },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_area_struct),
                "::",
                stringify!(vm_policy)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vm_area_struct>())).numab_state as *const _ as usize },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_area_struct),
                "::",
                stringify!(numab_state)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<vm_area_struct>())).vm_userfaultfd_ctx as *const _ as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_area_struct),
                "::",
                stringify!(vm_userfaultfd_ctx)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct mm_cid {
        pub time: _cargo_bpf_u64,
        pub cid: ::cty::c_int,
    }
    #[test]
    fn bindgen_test_layout_mm_cid() {
        assert_eq!(
            ::core::mem::size_of::<mm_cid>(),
            16usize,
            concat!("Size of: ", stringify!(mm_cid))
        );
        assert_eq!(
            ::core::mem::align_of::<mm_cid>(),
            8usize,
            concat!("Alignment of ", stringify!(mm_cid))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mm_cid>())).time as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_cid),
                "::",
                stringify!(time)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mm_cid>())).cid as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_cid),
                "::",
                stringify!(cid)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct kioctx_table {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[repr(align(64))]
    pub struct mm_struct {
        pub __bindgen_anon_1: mm_struct__bindgen_ty_1,
        pub cpu_bitmap: __IncompleteArrayField<::cty::c_ulong>,
    }
    #[repr(C)]
    #[repr(align(64))]
    #[derive(Copy, Clone)]
    pub struct mm_struct__bindgen_ty_1 {
        pub __bindgen_anon_1: mm_struct__bindgen_ty_1__bindgen_ty_1,
        pub mm_mt: maple_tree,
        pub get_unmapped_area: ::core::option::Option<
            unsafe extern "C" fn(
                filp: *mut file,
                addr: ::cty::c_ulong,
                len: ::cty::c_ulong,
                pgoff: ::cty::c_ulong,
                flags: ::cty::c_ulong,
            ) -> ::cty::c_ulong,
        >,
        pub mmap_base: ::cty::c_ulong,
        pub mmap_legacy_base: ::cty::c_ulong,
        pub mmap_compat_base: ::cty::c_ulong,
        pub mmap_compat_legacy_base: ::cty::c_ulong,
        pub task_size: ::cty::c_ulong,
        pub pgd: *mut pgd_t,
        #[doc = " @membarrier_state: Flags controlling membarrier behavior."]
        #[doc = ""]
        #[doc = " This field is close to @pgd to hopefully fit in the same"]
        #[doc = " cache-line, which needs to be touched by switch_mm()."]
        pub membarrier_state: atomic_t,
        #[doc = " @mm_users: The number of users including userspace."]
        #[doc = ""]
        #[doc = " Use mmget()/mmget_not_zero()/mmput() to modify. When this"]
        #[doc = " drops to 0 (i.e. when the task exits and there are no other"]
        #[doc = " temporary reference holders), we also release a reference on"]
        #[doc = " @mm_count (which may then free the &struct mm_struct if"]
        #[doc = " @mm_count also drops to 0)."]
        pub mm_users: atomic_t,
        #[doc = " @pcpu_cid: Per-cpu current cid."]
        #[doc = ""]
        #[doc = " Keep track of the currently allocated mm_cid for each cpu."]
        #[doc = " The per-cpu mm_cid values are serialized by their respective"]
        #[doc = " runqueue locks."]
        pub pcpu_cid: *mut mm_cid,
        pub mm_cid_next_scan: ::cty::c_ulong,
        pub pgtables_bytes: atomic_long_t,
        pub map_count: ::cty::c_int,
        pub page_table_lock: spinlock_t,
        pub mmap_lock: rw_semaphore,
        pub mmlist: list_head,
        pub mm_lock_seq: ::cty::c_int,
        pub hiwater_rss: ::cty::c_ulong,
        pub hiwater_vm: ::cty::c_ulong,
        pub total_vm: ::cty::c_ulong,
        pub locked_vm: ::cty::c_ulong,
        pub pinned_vm: atomic64_t,
        pub data_vm: ::cty::c_ulong,
        pub exec_vm: ::cty::c_ulong,
        pub stack_vm: ::cty::c_ulong,
        pub def_flags: ::cty::c_ulong,
        #[doc = " @write_protect_seq: Locked when any thread is write"]
        #[doc = " protecting pages mapped by this mm to enforce a later COW,"]
        #[doc = " for instance during page table copying for fork()."]
        pub write_protect_seq: seqcount_t,
        pub arg_lock: spinlock_t,
        pub start_code: ::cty::c_ulong,
        pub end_code: ::cty::c_ulong,
        pub start_data: ::cty::c_ulong,
        pub end_data: ::cty::c_ulong,
        pub start_brk: ::cty::c_ulong,
        pub brk: ::cty::c_ulong,
        pub start_stack: ::cty::c_ulong,
        pub arg_start: ::cty::c_ulong,
        pub arg_end: ::cty::c_ulong,
        pub env_start: ::cty::c_ulong,
        pub env_end: ::cty::c_ulong,
        pub saved_auxv: [::cty::c_ulong; 52usize],
        pub rss_stat: [percpu_counter; 4usize],
        pub binfmt: *mut linux_binfmt,
        pub context: mm_context_t,
        pub flags: ::cty::c_ulong,
        pub ioctx_lock: spinlock_t,
        pub ioctx_table: *mut kioctx_table,
        pub owner: *mut task_struct,
        pub user_ns: *mut user_namespace,
        pub exe_file: *mut file,
        pub notifier_subscriptions: *mut mmu_notifier_subscriptions,
        pub numa_next_scan: ::cty::c_ulong,
        pub numa_scan_offset: ::cty::c_ulong,
        pub numa_scan_seq: ::cty::c_int,
        pub tlb_flush_pending: atomic_t,
        pub tlb_flush_batched: atomic_t,
        pub uprobes_state: uprobes_state,
        pub hugetlb_usage: atomic_long_t,
        pub async_put_work: work_struct,
        pub pasid: _cargo_bpf_u32,
        pub ksm_merging_pages: ::cty::c_ulong,
        pub ksm_rmap_items: ::cty::c_ulong,
        pub lru_gen: mm_struct__bindgen_ty_1__bindgen_ty_2,
    }
    #[repr(C)]
    #[repr(align(64))]
    #[derive(Debug, Copy, Clone)]
    pub struct mm_struct__bindgen_ty_1__bindgen_ty_1 {
        #[doc = " @mm_count: The number of references to &struct"]
        #[doc = " mm_struct (@mm_users count as 1)."]
        #[doc = ""]
        #[doc = " Use mmgrab()/mmdrop() to modify. When this drops to"]
        #[doc = " 0, the &struct mm_struct is freed."]
        pub mm_count: atomic_t,
    }
    #[test]
    fn bindgen_test_layout_mm_struct__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<mm_struct__bindgen_ty_1__bindgen_ty_1>(),
            64usize,
            concat!(
                "Size of: ",
                stringify!(mm_struct__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<mm_struct__bindgen_ty_1__bindgen_ty_1>(),
            64usize,
            concat!(
                "Alignment of ",
                stringify!(mm_struct__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1__bindgen_ty_1>())).mm_count
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(mm_count)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct mm_struct__bindgen_ty_1__bindgen_ty_2 {
        pub list: list_head,
        pub bitmap: ::cty::c_ulong,
        pub memcg: *mut mem_cgroup,
    }
    #[test]
    fn bindgen_test_layout_mm_struct__bindgen_ty_1__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<mm_struct__bindgen_ty_1__bindgen_ty_2>(),
            32usize,
            concat!(
                "Size of: ",
                stringify!(mm_struct__bindgen_ty_1__bindgen_ty_2)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<mm_struct__bindgen_ty_1__bindgen_ty_2>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(mm_struct__bindgen_ty_1__bindgen_ty_2)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1__bindgen_ty_2>())).list as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(list)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1__bindgen_ty_2>())).bitmap
                    as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(bitmap)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1__bindgen_ty_2>())).memcg as *const _
                    as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(memcg)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_mm_struct__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<mm_struct__bindgen_ty_1>(),
            1344usize,
            concat!("Size of: ", stringify!(mm_struct__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<mm_struct__bindgen_ty_1>(),
            64usize,
            concat!("Alignment of ", stringify!(mm_struct__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).mm_mt as *const _ as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(mm_mt)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).get_unmapped_area as *const _
                    as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(get_unmapped_area)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).mmap_base as *const _ as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(mmap_base)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).mmap_legacy_base as *const _
                    as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(mmap_legacy_base)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).mmap_compat_base as *const _
                    as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(mmap_compat_base)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).mmap_compat_legacy_base
                    as *const _ as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(mmap_compat_legacy_base)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).task_size as *const _ as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(task_size)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).pgd as *const _ as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(pgd)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).membarrier_state as *const _
                    as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(membarrier_state)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).mm_users as *const _ as usize
            },
            148usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(mm_users)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).pcpu_cid as *const _ as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(pcpu_cid)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).mm_cid_next_scan as *const _
                    as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(mm_cid_next_scan)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).pgtables_bytes as *const _
                    as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(pgtables_bytes)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).map_count as *const _ as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(map_count)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).page_table_lock as *const _
                    as usize
            },
            180usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(page_table_lock)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).mmap_lock as *const _ as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(mmap_lock)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).mmlist as *const _ as usize
            },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(mmlist)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).mm_lock_seq as *const _
                    as usize
            },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(mm_lock_seq)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).hiwater_rss as *const _
                    as usize
            },
            248usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(hiwater_rss)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).hiwater_vm as *const _ as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(hiwater_vm)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).total_vm as *const _ as usize
            },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(total_vm)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).locked_vm as *const _ as usize
            },
            272usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(locked_vm)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).pinned_vm as *const _ as usize
            },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(pinned_vm)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).data_vm as *const _ as usize
            },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(data_vm)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).exec_vm as *const _ as usize
            },
            296usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(exec_vm)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).stack_vm as *const _ as usize
            },
            304usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(stack_vm)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).def_flags as *const _ as usize
            },
            312usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(def_flags)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).write_protect_seq as *const _
                    as usize
            },
            320usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(write_protect_seq)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).arg_lock as *const _ as usize
            },
            324usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(arg_lock)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).start_code as *const _ as usize
            },
            328usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(start_code)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).end_code as *const _ as usize
            },
            336usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(end_code)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).start_data as *const _ as usize
            },
            344usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(start_data)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).end_data as *const _ as usize
            },
            352usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(end_data)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).start_brk as *const _ as usize
            },
            360usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(start_brk)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).brk as *const _ as usize
            },
            368usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(brk)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).start_stack as *const _
                    as usize
            },
            376usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(start_stack)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).arg_start as *const _ as usize
            },
            384usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(arg_start)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).arg_end as *const _ as usize
            },
            392usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(arg_end)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).env_start as *const _ as usize
            },
            400usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(env_start)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).env_end as *const _ as usize
            },
            408usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(env_end)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).saved_auxv as *const _ as usize
            },
            416usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(saved_auxv)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).rss_stat as *const _ as usize
            },
            832usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(rss_stat)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).binfmt as *const _ as usize
            },
            992usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(binfmt)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).context as *const _ as usize
            },
            1000usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(context)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).flags as *const _ as usize
            },
            1144usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).ioctx_lock as *const _ as usize
            },
            1152usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(ioctx_lock)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).ioctx_table as *const _
                    as usize
            },
            1160usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(ioctx_table)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).owner as *const _ as usize
            },
            1168usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(owner)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).user_ns as *const _ as usize
            },
            1176usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(user_ns)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).exe_file as *const _ as usize
            },
            1184usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(exe_file)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).notifier_subscriptions
                    as *const _ as usize
            },
            1192usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(notifier_subscriptions)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).numa_next_scan as *const _
                    as usize
            },
            1200usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(numa_next_scan)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).numa_scan_offset as *const _
                    as usize
            },
            1208usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(numa_scan_offset)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).numa_scan_seq as *const _
                    as usize
            },
            1216usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(numa_scan_seq)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).tlb_flush_pending as *const _
                    as usize
            },
            1220usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(tlb_flush_pending)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).tlb_flush_batched as *const _
                    as usize
            },
            1224usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(tlb_flush_batched)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).uprobes_state as *const _
                    as usize
            },
            1232usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(uprobes_state)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).hugetlb_usage as *const _
                    as usize
            },
            1240usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(hugetlb_usage)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).async_put_work as *const _
                    as usize
            },
            1248usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(async_put_work)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).pasid as *const _ as usize
            },
            1280usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(pasid)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).ksm_merging_pages as *const _
                    as usize
            },
            1288usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(ksm_merging_pages)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).ksm_rmap_items as *const _
                    as usize
            },
            1296usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(ksm_rmap_items)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mm_struct__bindgen_ty_1>())).lru_gen as *const _ as usize
            },
            1304usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct__bindgen_ty_1),
                "::",
                stringify!(lru_gen)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_mm_struct() {
        assert_eq!(
            ::core::mem::size_of::<mm_struct>(),
            1344usize,
            concat!("Size of: ", stringify!(mm_struct))
        );
        assert_eq!(
            ::core::mem::align_of::<mm_struct>(),
            64usize,
            concat!("Alignment of ", stringify!(mm_struct))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mm_struct>())).cpu_bitmap as *const _ as usize },
            1344usize,
            concat!(
                "Offset of field: ",
                stringify!(mm_struct),
                "::",
                stringify!(cpu_bitmap)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct lru_gen_mm_list {
        pub fifo: list_head,
        pub lock: spinlock_t,
    }
    #[test]
    fn bindgen_test_layout_lru_gen_mm_list() {
        assert_eq!(
            ::core::mem::size_of::<lru_gen_mm_list>(),
            24usize,
            concat!("Size of: ", stringify!(lru_gen_mm_list))
        );
        assert_eq!(
            ::core::mem::align_of::<lru_gen_mm_list>(),
            8usize,
            concat!("Alignment of ", stringify!(lru_gen_mm_list))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<lru_gen_mm_list>())).fifo as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(lru_gen_mm_list),
                "::",
                stringify!(fifo)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<lru_gen_mm_list>())).lock as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(lru_gen_mm_list),
                "::",
                stringify!(lock)
            )
        );
    }
    #[doc = " typedef vm_fault_t - Return type for page fault handlers."]
    #[doc = ""]
    #[doc = " Page fault handlers return a bitmask of %VM_FAULT values."]
    pub type vm_fault_t = ::cty::c_uint;
    pub const fault_flag_FAULT_FLAG_WRITE: fault_flag = 1;
    pub const fault_flag_FAULT_FLAG_MKWRITE: fault_flag = 2;
    pub const fault_flag_FAULT_FLAG_ALLOW_RETRY: fault_flag = 4;
    pub const fault_flag_FAULT_FLAG_RETRY_NOWAIT: fault_flag = 8;
    pub const fault_flag_FAULT_FLAG_KILLABLE: fault_flag = 16;
    pub const fault_flag_FAULT_FLAG_TRIED: fault_flag = 32;
    pub const fault_flag_FAULT_FLAG_USER: fault_flag = 64;
    pub const fault_flag_FAULT_FLAG_REMOTE: fault_flag = 128;
    pub const fault_flag_FAULT_FLAG_INSTRUCTION: fault_flag = 256;
    pub const fault_flag_FAULT_FLAG_INTERRUPTIBLE: fault_flag = 512;
    pub const fault_flag_FAULT_FLAG_UNSHARE: fault_flag = 1024;
    pub const fault_flag_FAULT_FLAG_ORIG_PTE_VALID: fault_flag = 2048;
    pub const fault_flag_FAULT_FLAG_VMA_LOCK: fault_flag = 4096;
    #[doc = " enum fault_flag - Fault flag definitions."]
    #[doc = " @FAULT_FLAG_WRITE: Fault was a write fault."]
    #[doc = " @FAULT_FLAG_MKWRITE: Fault was mkwrite of existing PTE."]
    #[doc = " @FAULT_FLAG_ALLOW_RETRY: Allow to retry the fault if blocked."]
    #[doc = " @FAULT_FLAG_RETRY_NOWAIT: Don't drop mmap_lock and wait when retrying."]
    #[doc = " @FAULT_FLAG_KILLABLE: The fault task is in SIGKILL killable region."]
    #[doc = " @FAULT_FLAG_TRIED: The fault has been tried once."]
    #[doc = " @FAULT_FLAG_USER: The fault originated in userspace."]
    #[doc = " @FAULT_FLAG_REMOTE: The fault is not for current task/mm."]
    #[doc = " @FAULT_FLAG_INSTRUCTION: The fault was during an instruction fetch."]
    #[doc = " @FAULT_FLAG_INTERRUPTIBLE: The fault can be interrupted by non-fatal signals."]
    #[doc = " @FAULT_FLAG_UNSHARE: The fault is an unsharing request to break COW in a"]
    #[doc = "                      COW mapping, making sure that an exclusive anon page is"]
    #[doc = "                      mapped after the fault."]
    #[doc = " @FAULT_FLAG_ORIG_PTE_VALID: whether the fault has vmf->orig_pte cached."]
    #[doc = "                        We should only access orig_pte if this flag set."]
    #[doc = " @FAULT_FLAG_VMA_LOCK: The fault is handled under VMA lock."]
    #[doc = ""]
    #[doc = " About @FAULT_FLAG_ALLOW_RETRY and @FAULT_FLAG_TRIED: we can specify"]
    #[doc = " whether we would allow page faults to retry by specifying these two"]
    #[doc = " fault flags correctly.  Currently there can be three legal combinations:"]
    #[doc = ""]
    #[doc = " (a) ALLOW_RETRY and !TRIED:  this means the page fault allows retry, and"]
    #[doc = "                              this is the first try"]
    #[doc = ""]
    #[doc = " (b) ALLOW_RETRY and TRIED:   this means the page fault allows retry, and"]
    #[doc = "                              we've already tried at least once"]
    #[doc = ""]
    #[doc = " (c) !ALLOW_RETRY and !TRIED: this means the page fault does not allow retry"]
    #[doc = ""]
    #[doc = " The unlisted combination (!ALLOW_RETRY && TRIED) is illegal and should never"]
    #[doc = " be used.  Note that page faults can be allowed to retry for multiple times,"]
    #[doc = " in which case we'll have an initial fault with flags (a) then later on"]
    #[doc = " continuous faults with flags (b).  We should always try to detect pending"]
    #[doc = " signals before a retry to make sure the continuous page faults can still be"]
    #[doc = " interrupted if necessary."]
    #[doc = ""]
    #[doc = " The combination FAULT_FLAG_WRITE|FAULT_FLAG_UNSHARE is illegal."]
    #[doc = " FAULT_FLAG_UNSHARE is ignored and treated like an ordinary read fault when"]
    #[doc = " applied to mappings that are not COW mappings."]
    pub type fault_flag = ::cty::c_uint;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct iovec {
        pub iov_base: *mut ::cty::c_void,
        pub iov_len: __kernel_size_t,
    }
    #[test]
    fn bindgen_test_layout_iovec() {
        assert_eq!(
            ::core::mem::size_of::<iovec>(),
            16usize,
            concat!("Size of: ", stringify!(iovec))
        );
        assert_eq!(
            ::core::mem::align_of::<iovec>(),
            8usize,
            concat!("Alignment of ", stringify!(iovec))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<iovec>())).iov_base as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(iovec),
                "::",
                stringify!(iov_base)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<iovec>())).iov_len as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(iovec),
                "::",
                stringify!(iov_len)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct kvec {
        pub iov_base: *mut ::cty::c_void,
        pub iov_len: size_t,
    }
    #[test]
    fn bindgen_test_layout_kvec() {
        assert_eq!(
            ::core::mem::size_of::<kvec>(),
            16usize,
            concat!("Size of: ", stringify!(kvec))
        );
        assert_eq!(
            ::core::mem::align_of::<kvec>(),
            8usize,
            concat!("Alignment of ", stringify!(kvec))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kvec>())).iov_base as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(kvec),
                "::",
                stringify!(iov_base)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kvec>())).iov_len as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(kvec),
                "::",
                stringify!(iov_len)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct iov_iter {
        pub iter_type: _cargo_bpf_u8,
        pub copy_mc: bool_,
        pub nofault: bool_,
        pub data_source: bool_,
        pub user_backed: bool_,
        pub __bindgen_anon_1: iov_iter__bindgen_ty_1,
        pub __bindgen_anon_2: iov_iter__bindgen_ty_2,
        pub __bindgen_anon_3: iov_iter__bindgen_ty_3,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union iov_iter__bindgen_ty_1 {
        pub iov_offset: size_t,
        pub last_offset: ::cty::c_int,
    }
    #[test]
    fn bindgen_test_layout_iov_iter__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<iov_iter__bindgen_ty_1>(),
            8usize,
            concat!("Size of: ", stringify!(iov_iter__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<iov_iter__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(iov_iter__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<iov_iter__bindgen_ty_1>())).iov_offset as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(iov_iter__bindgen_ty_1),
                "::",
                stringify!(iov_offset)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<iov_iter__bindgen_ty_1>())).last_offset as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(iov_iter__bindgen_ty_1),
                "::",
                stringify!(last_offset)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union iov_iter__bindgen_ty_2 {
        pub __ubuf_iovec: iovec,
        pub __bindgen_anon_1: iov_iter__bindgen_ty_2__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct iov_iter__bindgen_ty_2__bindgen_ty_1 {
        pub __bindgen_anon_1: iov_iter__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
        pub count: size_t,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union iov_iter__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
        pub __iov: *const iovec,
        pub kvec: *const kvec,
        pub bvec: *const bio_vec,
        pub xarray: *mut xarray,
        pub ubuf: *mut ::cty::c_void,
    }
    #[test]
    fn bindgen_test_layout_iov_iter__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<iov_iter__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>(),
            8usize,
            concat!(
                "Size of: ",
                stringify!(iov_iter__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<iov_iter__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(iov_iter__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<iov_iter__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>()))
                    .__iov as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(iov_iter__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(__iov)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<iov_iter__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>())).kvec
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(iov_iter__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(kvec)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<iov_iter__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>())).bvec
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(iov_iter__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(bvec)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<iov_iter__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>()))
                    .xarray as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(iov_iter__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(xarray)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<iov_iter__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>())).ubuf
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(iov_iter__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(ubuf)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_iov_iter__bindgen_ty_2__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<iov_iter__bindgen_ty_2__bindgen_ty_1>(),
            16usize,
            concat!(
                "Size of: ",
                stringify!(iov_iter__bindgen_ty_2__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<iov_iter__bindgen_ty_2__bindgen_ty_1>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(iov_iter__bindgen_ty_2__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<iov_iter__bindgen_ty_2__bindgen_ty_1>())).count as *const _
                    as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(iov_iter__bindgen_ty_2__bindgen_ty_1),
                "::",
                stringify!(count)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_iov_iter__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<iov_iter__bindgen_ty_2>(),
            16usize,
            concat!("Size of: ", stringify!(iov_iter__bindgen_ty_2))
        );
        assert_eq!(
            ::core::mem::align_of::<iov_iter__bindgen_ty_2>(),
            8usize,
            concat!("Alignment of ", stringify!(iov_iter__bindgen_ty_2))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<iov_iter__bindgen_ty_2>())).__ubuf_iovec as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(iov_iter__bindgen_ty_2),
                "::",
                stringify!(__ubuf_iovec)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union iov_iter__bindgen_ty_3 {
        pub nr_segs: ::cty::c_ulong,
        pub xarray_start: loff_t,
    }
    #[test]
    fn bindgen_test_layout_iov_iter__bindgen_ty_3() {
        assert_eq!(
            ::core::mem::size_of::<iov_iter__bindgen_ty_3>(),
            8usize,
            concat!("Size of: ", stringify!(iov_iter__bindgen_ty_3))
        );
        assert_eq!(
            ::core::mem::align_of::<iov_iter__bindgen_ty_3>(),
            8usize,
            concat!("Alignment of ", stringify!(iov_iter__bindgen_ty_3))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<iov_iter__bindgen_ty_3>())).nr_segs as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(iov_iter__bindgen_ty_3),
                "::",
                stringify!(nr_segs)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<iov_iter__bindgen_ty_3>())).xarray_start as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(iov_iter__bindgen_ty_3),
                "::",
                stringify!(xarray_start)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_iov_iter() {
        assert_eq!(
            ::core::mem::size_of::<iov_iter>(),
            40usize,
            concat!("Size of: ", stringify!(iov_iter))
        );
        assert_eq!(
            ::core::mem::align_of::<iov_iter>(),
            8usize,
            concat!("Alignment of ", stringify!(iov_iter))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<iov_iter>())).iter_type as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(iov_iter),
                "::",
                stringify!(iter_type)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<iov_iter>())).copy_mc as *const _ as usize },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(iov_iter),
                "::",
                stringify!(copy_mc)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<iov_iter>())).nofault as *const _ as usize },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(iov_iter),
                "::",
                stringify!(nofault)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<iov_iter>())).data_source as *const _ as usize },
            3usize,
            concat!(
                "Offset of field: ",
                stringify!(iov_iter),
                "::",
                stringify!(data_source)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<iov_iter>())).user_backed as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(iov_iter),
                "::",
                stringify!(user_backed)
            )
        );
    }
    pub type __kernel_sa_family_t = ::cty::c_ushort;
    pub type sa_family_t = __kernel_sa_family_t;
    #[repr(C)]
    pub struct sockaddr {
        pub sa_family: sa_family_t,
        pub __bindgen_anon_1: sockaddr__bindgen_ty_1,
    }
    #[repr(C)]
    pub struct sockaddr__bindgen_ty_1 {
        pub sa_data_min: __BindgenUnionField<[::cty::c_char; 14usize]>,
        pub __bindgen_anon_1: __BindgenUnionField<sockaddr__bindgen_ty_1__bindgen_ty_1>,
        pub bindgen_union_field: [u8; 14usize],
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct sockaddr__bindgen_ty_1__bindgen_ty_1 {
        pub __empty_sa_data: sockaddr__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
        pub sa_data: __IncompleteArrayField<::cty::c_char>,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct sockaddr__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {}
    #[test]
    fn bindgen_test_layout_sockaddr__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<sockaddr__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
            0usize,
            concat!(
                "Size of: ",
                stringify!(sockaddr__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<sockaddr__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
            1usize,
            concat!(
                "Alignment of ",
                stringify!(sockaddr__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_sockaddr__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<sockaddr__bindgen_ty_1__bindgen_ty_1>(),
            0usize,
            concat!(
                "Size of: ",
                stringify!(sockaddr__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<sockaddr__bindgen_ty_1__bindgen_ty_1>(),
            1usize,
            concat!(
                "Alignment of ",
                stringify!(sockaddr__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sockaddr__bindgen_ty_1__bindgen_ty_1>())).__empty_sa_data
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(__empty_sa_data)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sockaddr__bindgen_ty_1__bindgen_ty_1>())).sa_data
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(sa_data)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_sockaddr__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<sockaddr__bindgen_ty_1>(),
            14usize,
            concat!("Size of: ", stringify!(sockaddr__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<sockaddr__bindgen_ty_1>(),
            1usize,
            concat!("Alignment of ", stringify!(sockaddr__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sockaddr__bindgen_ty_1>())).sa_data_min as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr__bindgen_ty_1),
                "::",
                stringify!(sa_data_min)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_sockaddr() {
        assert_eq!(
            ::core::mem::size_of::<sockaddr>(),
            16usize,
            concat!("Size of: ", stringify!(sockaddr))
        );
        assert_eq!(
            ::core::mem::align_of::<sockaddr>(),
            2usize,
            concat!("Alignment of ", stringify!(sockaddr))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sockaddr>())).sa_family as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr),
                "::",
                stringify!(sa_family)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct msghdr {
        pub msg_name: *mut ::cty::c_void,
        pub msg_namelen: ::cty::c_int,
        pub msg_inq: ::cty::c_int,
        pub msg_iter: iov_iter,
        pub __bindgen_anon_1: msghdr__bindgen_ty_1,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
        pub msg_flags: ::cty::c_uint,
        pub msg_controllen: __kernel_size_t,
        pub msg_iocb: *mut kiocb,
        pub msg_ubuf: *mut ubuf_info,
        pub sg_from_iter: ::core::option::Option<
            unsafe extern "C" fn(
                sk: *mut sock,
                skb: *mut sk_buff,
                from: *mut iov_iter,
                length: size_t,
            ) -> ::cty::c_int,
        >,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union msghdr__bindgen_ty_1 {
        pub msg_control: *mut ::cty::c_void,
        pub msg_control_user: *mut ::cty::c_void,
    }
    #[test]
    fn bindgen_test_layout_msghdr__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<msghdr__bindgen_ty_1>(),
            8usize,
            concat!("Size of: ", stringify!(msghdr__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<msghdr__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(msghdr__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<msghdr__bindgen_ty_1>())).msg_control as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(msghdr__bindgen_ty_1),
                "::",
                stringify!(msg_control)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<msghdr__bindgen_ty_1>())).msg_control_user as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(msghdr__bindgen_ty_1),
                "::",
                stringify!(msg_control_user)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_msghdr() {
        assert_eq!(
            ::core::mem::size_of::<msghdr>(),
            104usize,
            concat!("Size of: ", stringify!(msghdr))
        );
        assert_eq!(
            ::core::mem::align_of::<msghdr>(),
            8usize,
            concat!("Alignment of ", stringify!(msghdr))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<msghdr>())).msg_name as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(msghdr),
                "::",
                stringify!(msg_name)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<msghdr>())).msg_namelen as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(msghdr),
                "::",
                stringify!(msg_namelen)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<msghdr>())).msg_inq as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(msghdr),
                "::",
                stringify!(msg_inq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<msghdr>())).msg_iter as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(msghdr),
                "::",
                stringify!(msg_iter)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<msghdr>())).msg_flags as *const _ as usize },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(msghdr),
                "::",
                stringify!(msg_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<msghdr>())).msg_controllen as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(msghdr),
                "::",
                stringify!(msg_controllen)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<msghdr>())).msg_iocb as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(msghdr),
                "::",
                stringify!(msg_iocb)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<msghdr>())).msg_ubuf as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(msghdr),
                "::",
                stringify!(msg_ubuf)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<msghdr>())).sg_from_iter as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(msghdr),
                "::",
                stringify!(sg_from_iter)
            )
        );
    }
    impl msghdr {
        #[inline]
        pub fn msg_control_is_user(&self) -> bool_ {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_msg_control_is_user(&mut self, val: bool_) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn msg_get_inq(&self) -> bool_ {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_msg_get_inq(&mut self, val: bool_) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(1usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            msg_control_is_user: bool_,
            msg_get_inq: bool_,
        ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 1u8, {
                let msg_control_is_user: u8 =
                    unsafe { ::core::mem::transmute(msg_control_is_user) };
                msg_control_is_user as u64
            });
            __bindgen_bitfield_unit.set(1usize, 1u8, {
                let msg_get_inq: u8 = unsafe { ::core::mem::transmute(msg_get_inq) };
                msg_get_inq as u64
            });
            __bindgen_bitfield_unit
        }
    }
    pub const IPPROTO_IP: ::cty::c_uint = 0;
    pub const IPPROTO_ICMP: ::cty::c_uint = 1;
    pub const IPPROTO_IGMP: ::cty::c_uint = 2;
    pub const IPPROTO_IPIP: ::cty::c_uint = 4;
    pub const IPPROTO_TCP: ::cty::c_uint = 6;
    pub const IPPROTO_EGP: ::cty::c_uint = 8;
    pub const IPPROTO_PUP: ::cty::c_uint = 12;
    pub const IPPROTO_UDP: ::cty::c_uint = 17;
    pub const IPPROTO_IDP: ::cty::c_uint = 22;
    pub const IPPROTO_TP: ::cty::c_uint = 29;
    pub const IPPROTO_DCCP: ::cty::c_uint = 33;
    pub const IPPROTO_IPV6: ::cty::c_uint = 41;
    pub const IPPROTO_RSVP: ::cty::c_uint = 46;
    pub const IPPROTO_GRE: ::cty::c_uint = 47;
    pub const IPPROTO_ESP: ::cty::c_uint = 50;
    pub const IPPROTO_AH: ::cty::c_uint = 51;
    pub const IPPROTO_MTP: ::cty::c_uint = 92;
    pub const IPPROTO_BEETPH: ::cty::c_uint = 94;
    pub const IPPROTO_ENCAP: ::cty::c_uint = 98;
    pub const IPPROTO_PIM: ::cty::c_uint = 103;
    pub const IPPROTO_COMP: ::cty::c_uint = 108;
    pub const IPPROTO_L2TP: ::cty::c_uint = 115;
    pub const IPPROTO_SCTP: ::cty::c_uint = 132;
    pub const IPPROTO_UDPLITE: ::cty::c_uint = 136;
    pub const IPPROTO_MPLS: ::cty::c_uint = 137;
    pub const IPPROTO_ETHERNET: ::cty::c_uint = 143;
    pub const IPPROTO_RAW: ::cty::c_uint = 255;
    pub const IPPROTO_MPTCP: ::cty::c_uint = 262;
    pub const IPPROTO_MAX: ::cty::c_uint = 263;
    pub type _bindgen_ty_115 = ::cty::c_uint;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct in_addr {
        pub s_addr: __be32,
    }
    #[test]
    fn bindgen_test_layout_in_addr() {
        assert_eq!(
            ::core::mem::size_of::<in_addr>(),
            4usize,
            concat!("Size of: ", stringify!(in_addr))
        );
        assert_eq!(
            ::core::mem::align_of::<in_addr>(),
            4usize,
            concat!("Alignment of ", stringify!(in_addr))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<in_addr>())).s_addr as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(in_addr),
                "::",
                stringify!(s_addr)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct sockaddr_in {
        pub sin_family: __kernel_sa_family_t,
        pub sin_port: __be16,
        pub sin_addr: in_addr,
        pub __pad: [::cty::c_uchar; 8usize],
    }
    #[test]
    fn bindgen_test_layout_sockaddr_in() {
        assert_eq!(
            ::core::mem::size_of::<sockaddr_in>(),
            16usize,
            concat!("Size of: ", stringify!(sockaddr_in))
        );
        assert_eq!(
            ::core::mem::align_of::<sockaddr_in>(),
            4usize,
            concat!("Alignment of ", stringify!(sockaddr_in))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sockaddr_in>())).sin_family as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_in),
                "::",
                stringify!(sin_family)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sockaddr_in>())).sin_port as *const _ as usize },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_in),
                "::",
                stringify!(sin_port)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sockaddr_in>())).sin_addr as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_in),
                "::",
                stringify!(sin_addr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sockaddr_in>())).__pad as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_in),
                "::",
                stringify!(__pad)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nf_logger {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct netns_nf {
        pub proc_netfilter: *mut proc_dir_entry,
        pub nf_loggers: [*const nf_logger; 11usize],
        pub nf_log_dir_header: *mut ctl_table_header,
        pub hooks_ipv4: [*mut nf_hook_entries; 5usize],
        pub hooks_ipv6: [*mut nf_hook_entries; 5usize],
        pub hooks_arp: [*mut nf_hook_entries; 3usize],
        pub hooks_bridge: [*mut nf_hook_entries; 5usize],
        pub defrag_ipv4_users: ::cty::c_uint,
        pub defrag_ipv6_users: ::cty::c_uint,
    }
    #[test]
    fn bindgen_test_layout_netns_nf() {
        assert_eq!(
            ::core::mem::size_of::<netns_nf>(),
            256usize,
            concat!("Size of: ", stringify!(netns_nf))
        );
        assert_eq!(
            ::core::mem::align_of::<netns_nf>(),
            8usize,
            concat!("Alignment of ", stringify!(netns_nf))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_nf>())).proc_netfilter as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_nf),
                "::",
                stringify!(proc_netfilter)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_nf>())).nf_loggers as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_nf),
                "::",
                stringify!(nf_loggers)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_nf>())).nf_log_dir_header as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_nf),
                "::",
                stringify!(nf_log_dir_header)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_nf>())).hooks_ipv4 as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_nf),
                "::",
                stringify!(hooks_ipv4)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_nf>())).hooks_ipv6 as *const _ as usize },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_nf),
                "::",
                stringify!(hooks_ipv6)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_nf>())).hooks_arp as *const _ as usize },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_nf),
                "::",
                stringify!(hooks_arp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_nf>())).hooks_bridge as *const _ as usize },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_nf),
                "::",
                stringify!(hooks_bridge)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_nf>())).defrag_ipv4_users as *const _ as usize },
            248usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_nf),
                "::",
                stringify!(defrag_ipv4_users)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_nf>())).defrag_ipv6_users as *const _ as usize },
            252usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_nf),
                "::",
                stringify!(defrag_ipv6_users)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ip_conntrack_stat {
        pub found: ::cty::c_uint,
        pub invalid: ::cty::c_uint,
        pub insert: ::cty::c_uint,
        pub insert_failed: ::cty::c_uint,
        pub clash_resolve: ::cty::c_uint,
        pub drop: ::cty::c_uint,
        pub early_drop: ::cty::c_uint,
        pub error: ::cty::c_uint,
        pub expect_new: ::cty::c_uint,
        pub expect_create: ::cty::c_uint,
        pub expect_delete: ::cty::c_uint,
        pub search_restart: ::cty::c_uint,
        pub chaintoolong: ::cty::c_uint,
    }
    #[test]
    fn bindgen_test_layout_ip_conntrack_stat() {
        assert_eq!(
            ::core::mem::size_of::<ip_conntrack_stat>(),
            52usize,
            concat!("Size of: ", stringify!(ip_conntrack_stat))
        );
        assert_eq!(
            ::core::mem::align_of::<ip_conntrack_stat>(),
            4usize,
            concat!("Alignment of ", stringify!(ip_conntrack_stat))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ip_conntrack_stat>())).found as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ip_conntrack_stat),
                "::",
                stringify!(found)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ip_conntrack_stat>())).invalid as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(ip_conntrack_stat),
                "::",
                stringify!(invalid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ip_conntrack_stat>())).insert as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ip_conntrack_stat),
                "::",
                stringify!(insert)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ip_conntrack_stat>())).insert_failed as *const _ as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(ip_conntrack_stat),
                "::",
                stringify!(insert_failed)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ip_conntrack_stat>())).clash_resolve as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ip_conntrack_stat),
                "::",
                stringify!(clash_resolve)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ip_conntrack_stat>())).drop as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(ip_conntrack_stat),
                "::",
                stringify!(drop)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ip_conntrack_stat>())).early_drop as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(ip_conntrack_stat),
                "::",
                stringify!(early_drop)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ip_conntrack_stat>())).error as *const _ as usize },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(ip_conntrack_stat),
                "::",
                stringify!(error)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ip_conntrack_stat>())).expect_new as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(ip_conntrack_stat),
                "::",
                stringify!(expect_new)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ip_conntrack_stat>())).expect_create as *const _ as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(ip_conntrack_stat),
                "::",
                stringify!(expect_create)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ip_conntrack_stat>())).expect_delete as *const _ as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(ip_conntrack_stat),
                "::",
                stringify!(expect_delete)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ip_conntrack_stat>())).search_restart as *const _ as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(ip_conntrack_stat),
                "::",
                stringify!(search_restart)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ip_conntrack_stat>())).chaintoolong as *const _ as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(ip_conntrack_stat),
                "::",
                stringify!(chaintoolong)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nf_generic_net {
        pub timeout: ::cty::c_uint,
    }
    #[test]
    fn bindgen_test_layout_nf_generic_net() {
        assert_eq!(
            ::core::mem::size_of::<nf_generic_net>(),
            4usize,
            concat!("Size of: ", stringify!(nf_generic_net))
        );
        assert_eq!(
            ::core::mem::align_of::<nf_generic_net>(),
            4usize,
            concat!("Alignment of ", stringify!(nf_generic_net))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<nf_generic_net>())).timeout as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(nf_generic_net),
                "::",
                stringify!(timeout)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nf_tcp_net {
        pub timeouts: [::cty::c_uint; 14usize],
        pub tcp_loose: _cargo_bpf_u8,
        pub tcp_be_liberal: _cargo_bpf_u8,
        pub tcp_max_retrans: _cargo_bpf_u8,
        pub tcp_ignore_invalid_rst: _cargo_bpf_u8,
        pub offload_timeout: ::cty::c_uint,
    }
    #[test]
    fn bindgen_test_layout_nf_tcp_net() {
        assert_eq!(
            ::core::mem::size_of::<nf_tcp_net>(),
            64usize,
            concat!("Size of: ", stringify!(nf_tcp_net))
        );
        assert_eq!(
            ::core::mem::align_of::<nf_tcp_net>(),
            4usize,
            concat!("Alignment of ", stringify!(nf_tcp_net))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<nf_tcp_net>())).timeouts as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(nf_tcp_net),
                "::",
                stringify!(timeouts)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<nf_tcp_net>())).tcp_loose as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(nf_tcp_net),
                "::",
                stringify!(tcp_loose)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<nf_tcp_net>())).tcp_be_liberal as *const _ as usize },
            57usize,
            concat!(
                "Offset of field: ",
                stringify!(nf_tcp_net),
                "::",
                stringify!(tcp_be_liberal)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<nf_tcp_net>())).tcp_max_retrans as *const _ as usize },
            58usize,
            concat!(
                "Offset of field: ",
                stringify!(nf_tcp_net),
                "::",
                stringify!(tcp_max_retrans)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<nf_tcp_net>())).tcp_ignore_invalid_rst as *const _ as usize
            },
            59usize,
            concat!(
                "Offset of field: ",
                stringify!(nf_tcp_net),
                "::",
                stringify!(tcp_ignore_invalid_rst)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<nf_tcp_net>())).offload_timeout as *const _ as usize },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(nf_tcp_net),
                "::",
                stringify!(offload_timeout)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nf_udp_net {
        pub timeouts: [::cty::c_uint; 2usize],
        pub offload_timeout: ::cty::c_uint,
    }
    #[test]
    fn bindgen_test_layout_nf_udp_net() {
        assert_eq!(
            ::core::mem::size_of::<nf_udp_net>(),
            12usize,
            concat!("Size of: ", stringify!(nf_udp_net))
        );
        assert_eq!(
            ::core::mem::align_of::<nf_udp_net>(),
            4usize,
            concat!("Alignment of ", stringify!(nf_udp_net))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<nf_udp_net>())).timeouts as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(nf_udp_net),
                "::",
                stringify!(timeouts)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<nf_udp_net>())).offload_timeout as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(nf_udp_net),
                "::",
                stringify!(offload_timeout)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nf_icmp_net {
        pub timeout: ::cty::c_uint,
    }
    #[test]
    fn bindgen_test_layout_nf_icmp_net() {
        assert_eq!(
            ::core::mem::size_of::<nf_icmp_net>(),
            4usize,
            concat!("Size of: ", stringify!(nf_icmp_net))
        );
        assert_eq!(
            ::core::mem::align_of::<nf_icmp_net>(),
            4usize,
            concat!("Alignment of ", stringify!(nf_icmp_net))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<nf_icmp_net>())).timeout as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(nf_icmp_net),
                "::",
                stringify!(timeout)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nf_dccp_net {
        pub dccp_loose: _cargo_bpf_u8,
        pub dccp_timeout: [::cty::c_uint; 10usize],
    }
    #[test]
    fn bindgen_test_layout_nf_dccp_net() {
        assert_eq!(
            ::core::mem::size_of::<nf_dccp_net>(),
            44usize,
            concat!("Size of: ", stringify!(nf_dccp_net))
        );
        assert_eq!(
            ::core::mem::align_of::<nf_dccp_net>(),
            4usize,
            concat!("Alignment of ", stringify!(nf_dccp_net))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<nf_dccp_net>())).dccp_loose as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(nf_dccp_net),
                "::",
                stringify!(dccp_loose)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<nf_dccp_net>())).dccp_timeout as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(nf_dccp_net),
                "::",
                stringify!(dccp_timeout)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nf_sctp_net {
        pub timeouts: [::cty::c_uint; 10usize],
    }
    #[test]
    fn bindgen_test_layout_nf_sctp_net() {
        assert_eq!(
            ::core::mem::size_of::<nf_sctp_net>(),
            40usize,
            concat!("Size of: ", stringify!(nf_sctp_net))
        );
        assert_eq!(
            ::core::mem::align_of::<nf_sctp_net>(),
            4usize,
            concat!("Alignment of ", stringify!(nf_sctp_net))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<nf_sctp_net>())).timeouts as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(nf_sctp_net),
                "::",
                stringify!(timeouts)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nf_gre_net {
        pub keymap_list: list_head,
        pub timeouts: [::cty::c_uint; 2usize],
    }
    #[test]
    fn bindgen_test_layout_nf_gre_net() {
        assert_eq!(
            ::core::mem::size_of::<nf_gre_net>(),
            24usize,
            concat!("Size of: ", stringify!(nf_gre_net))
        );
        assert_eq!(
            ::core::mem::align_of::<nf_gre_net>(),
            8usize,
            concat!("Alignment of ", stringify!(nf_gre_net))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<nf_gre_net>())).keymap_list as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(nf_gre_net),
                "::",
                stringify!(keymap_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<nf_gre_net>())).timeouts as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(nf_gre_net),
                "::",
                stringify!(timeouts)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nf_ip_net {
        pub generic: nf_generic_net,
        pub tcp: nf_tcp_net,
        pub udp: nf_udp_net,
        pub icmp: nf_icmp_net,
        pub icmpv6: nf_icmp_net,
        pub dccp: nf_dccp_net,
        pub sctp: nf_sctp_net,
        pub gre: nf_gre_net,
    }
    #[test]
    fn bindgen_test_layout_nf_ip_net() {
        assert_eq!(
            ::core::mem::size_of::<nf_ip_net>(),
            200usize,
            concat!("Size of: ", stringify!(nf_ip_net))
        );
        assert_eq!(
            ::core::mem::align_of::<nf_ip_net>(),
            8usize,
            concat!("Alignment of ", stringify!(nf_ip_net))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<nf_ip_net>())).generic as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(nf_ip_net),
                "::",
                stringify!(generic)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<nf_ip_net>())).tcp as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(nf_ip_net),
                "::",
                stringify!(tcp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<nf_ip_net>())).udp as *const _ as usize },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(nf_ip_net),
                "::",
                stringify!(udp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<nf_ip_net>())).icmp as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(nf_ip_net),
                "::",
                stringify!(icmp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<nf_ip_net>())).icmpv6 as *const _ as usize },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(nf_ip_net),
                "::",
                stringify!(icmpv6)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<nf_ip_net>())).dccp as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(nf_ip_net),
                "::",
                stringify!(dccp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<nf_ip_net>())).sctp as *const _ as usize },
            132usize,
            concat!(
                "Offset of field: ",
                stringify!(nf_ip_net),
                "::",
                stringify!(sctp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<nf_ip_net>())).gre as *const _ as usize },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(nf_ip_net),
                "::",
                stringify!(gre)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct netns_ct {
        pub ecache_dwork_pending: bool_,
        pub sysctl_log_invalid: _cargo_bpf_u8,
        pub sysctl_events: _cargo_bpf_u8,
        pub sysctl_acct: _cargo_bpf_u8,
        pub sysctl_tstamp: _cargo_bpf_u8,
        pub sysctl_checksum: _cargo_bpf_u8,
        pub stat: *mut ip_conntrack_stat,
        pub nf_conntrack_event_cb: *mut nf_ct_event_notifier,
        pub nf_ct_proto: nf_ip_net,
        pub labels_used: ::cty::c_uint,
    }
    #[test]
    fn bindgen_test_layout_netns_ct() {
        assert_eq!(
            ::core::mem::size_of::<netns_ct>(),
            232usize,
            concat!("Size of: ", stringify!(netns_ct))
        );
        assert_eq!(
            ::core::mem::align_of::<netns_ct>(),
            8usize,
            concat!("Alignment of ", stringify!(netns_ct))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ct>())).ecache_dwork_pending as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ct),
                "::",
                stringify!(ecache_dwork_pending)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ct>())).sysctl_log_invalid as *const _ as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ct),
                "::",
                stringify!(sysctl_log_invalid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ct>())).sysctl_events as *const _ as usize },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ct),
                "::",
                stringify!(sysctl_events)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ct>())).sysctl_acct as *const _ as usize },
            3usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ct),
                "::",
                stringify!(sysctl_acct)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ct>())).sysctl_tstamp as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ct),
                "::",
                stringify!(sysctl_tstamp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ct>())).sysctl_checksum as *const _ as usize },
            5usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ct),
                "::",
                stringify!(sysctl_checksum)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ct>())).stat as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ct),
                "::",
                stringify!(stat)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_ct>())).nf_conntrack_event_cb as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ct),
                "::",
                stringify!(nf_conntrack_event_cb)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ct>())).nf_ct_proto as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ct),
                "::",
                stringify!(nf_ct_proto)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ct>())).labels_used as *const _ as usize },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ct),
                "::",
                stringify!(labels_used)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nf_flow_table_stat {
        pub count_wq_add: ::cty::c_uint,
        pub count_wq_del: ::cty::c_uint,
        pub count_wq_stats: ::cty::c_uint,
    }
    #[test]
    fn bindgen_test_layout_nf_flow_table_stat() {
        assert_eq!(
            ::core::mem::size_of::<nf_flow_table_stat>(),
            12usize,
            concat!("Size of: ", stringify!(nf_flow_table_stat))
        );
        assert_eq!(
            ::core::mem::align_of::<nf_flow_table_stat>(),
            4usize,
            concat!("Alignment of ", stringify!(nf_flow_table_stat))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<nf_flow_table_stat>())).count_wq_add as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(nf_flow_table_stat),
                "::",
                stringify!(count_wq_add)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<nf_flow_table_stat>())).count_wq_del as *const _ as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(nf_flow_table_stat),
                "::",
                stringify!(count_wq_del)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<nf_flow_table_stat>())).count_wq_stats as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(nf_flow_table_stat),
                "::",
                stringify!(count_wq_stats)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct netns_ft {
        pub stat: *mut nf_flow_table_stat,
    }
    #[test]
    fn bindgen_test_layout_netns_ft() {
        assert_eq!(
            ::core::mem::size_of::<netns_ft>(),
            8usize,
            concat!("Size of: ", stringify!(netns_ft))
        );
        assert_eq!(
            ::core::mem::align_of::<netns_ft>(),
            8usize,
            concat!("Alignment of ", stringify!(netns_ft))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_ft>())).stat as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_ft),
                "::",
                stringify!(stat)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct netns_nftables {
        pub gencursor: _cargo_bpf_u8,
    }
    #[test]
    fn bindgen_test_layout_netns_nftables() {
        assert_eq!(
            ::core::mem::size_of::<netns_nftables>(),
            1usize,
            concat!("Size of: ", stringify!(netns_nftables))
        );
        assert_eq!(
            ::core::mem::align_of::<netns_nftables>(),
            1usize,
            concat!("Alignment of ", stringify!(netns_nftables))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_nftables>())).gencursor as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_nftables),
                "::",
                stringify!(gencursor)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct xfrm_policy_hash {
        pub table: *mut hlist_head,
        pub hmask: ::cty::c_uint,
        pub dbits4: _cargo_bpf_u8,
        pub sbits4: _cargo_bpf_u8,
        pub dbits6: _cargo_bpf_u8,
        pub sbits6: _cargo_bpf_u8,
    }
    #[test]
    fn bindgen_test_layout_xfrm_policy_hash() {
        assert_eq!(
            ::core::mem::size_of::<xfrm_policy_hash>(),
            16usize,
            concat!("Size of: ", stringify!(xfrm_policy_hash))
        );
        assert_eq!(
            ::core::mem::align_of::<xfrm_policy_hash>(),
            8usize,
            concat!("Alignment of ", stringify!(xfrm_policy_hash))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xfrm_policy_hash>())).table as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(xfrm_policy_hash),
                "::",
                stringify!(table)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xfrm_policy_hash>())).hmask as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(xfrm_policy_hash),
                "::",
                stringify!(hmask)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xfrm_policy_hash>())).dbits4 as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(xfrm_policy_hash),
                "::",
                stringify!(dbits4)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xfrm_policy_hash>())).sbits4 as *const _ as usize },
            13usize,
            concat!(
                "Offset of field: ",
                stringify!(xfrm_policy_hash),
                "::",
                stringify!(sbits4)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xfrm_policy_hash>())).dbits6 as *const _ as usize },
            14usize,
            concat!(
                "Offset of field: ",
                stringify!(xfrm_policy_hash),
                "::",
                stringify!(dbits6)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xfrm_policy_hash>())).sbits6 as *const _ as usize },
            15usize,
            concat!(
                "Offset of field: ",
                stringify!(xfrm_policy_hash),
                "::",
                stringify!(sbits6)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct xfrm_policy_hthresh {
        pub work: work_struct,
        pub lock: seqlock_t,
        pub lbits4: _cargo_bpf_u8,
        pub rbits4: _cargo_bpf_u8,
        pub lbits6: _cargo_bpf_u8,
        pub rbits6: _cargo_bpf_u8,
    }
    #[test]
    fn bindgen_test_layout_xfrm_policy_hthresh() {
        assert_eq!(
            ::core::mem::size_of::<xfrm_policy_hthresh>(),
            48usize,
            concat!("Size of: ", stringify!(xfrm_policy_hthresh))
        );
        assert_eq!(
            ::core::mem::align_of::<xfrm_policy_hthresh>(),
            8usize,
            concat!("Alignment of ", stringify!(xfrm_policy_hthresh))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xfrm_policy_hthresh>())).work as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(xfrm_policy_hthresh),
                "::",
                stringify!(work)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xfrm_policy_hthresh>())).lock as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(xfrm_policy_hthresh),
                "::",
                stringify!(lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xfrm_policy_hthresh>())).lbits4 as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(xfrm_policy_hthresh),
                "::",
                stringify!(lbits4)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xfrm_policy_hthresh>())).rbits4 as *const _ as usize },
            41usize,
            concat!(
                "Offset of field: ",
                stringify!(xfrm_policy_hthresh),
                "::",
                stringify!(rbits4)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xfrm_policy_hthresh>())).lbits6 as *const _ as usize },
            42usize,
            concat!(
                "Offset of field: ",
                stringify!(xfrm_policy_hthresh),
                "::",
                stringify!(lbits6)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xfrm_policy_hthresh>())).rbits6 as *const _ as usize },
            43usize,
            concat!(
                "Offset of field: ",
                stringify!(xfrm_policy_hthresh),
                "::",
                stringify!(rbits6)
            )
        );
    }
    #[repr(C)]
    #[repr(align(64))]
    #[derive(Copy, Clone)]
    pub struct netns_xfrm {
        pub state_all: list_head,
        pub state_bydst: *mut hlist_head,
        pub state_bysrc: *mut hlist_head,
        pub state_byspi: *mut hlist_head,
        pub state_byseq: *mut hlist_head,
        pub state_hmask: ::cty::c_uint,
        pub state_num: ::cty::c_uint,
        pub state_hash_work: work_struct,
        pub policy_all: list_head,
        pub policy_byidx: *mut hlist_head,
        pub policy_idx_hmask: ::cty::c_uint,
        pub policy_inexact: [hlist_head; 3usize],
        pub policy_bydst: [xfrm_policy_hash; 3usize],
        pub policy_count: [::cty::c_uint; 6usize],
        pub policy_hash_work: work_struct,
        pub policy_hthresh: xfrm_policy_hthresh,
        pub inexact_bins: list_head,
        pub nlsk: *mut sock,
        pub nlsk_stash: *mut sock,
        pub sysctl_aevent_etime: _cargo_bpf_u32,
        pub sysctl_aevent_rseqth: _cargo_bpf_u32,
        pub sysctl_larval_drop: ::cty::c_int,
        pub sysctl_acq_expires: _cargo_bpf_u32,
        pub policy_default: [_cargo_bpf_u8; 3usize],
        pub sysctl_hdr: *mut ctl_table_header,
        pub __bindgen_padding_0: [u64; 3usize],
        pub xfrm4_dst_ops: dst_ops,
        pub xfrm6_dst_ops: dst_ops,
        pub xfrm_state_lock: spinlock_t,
        pub xfrm_state_hash_generation: seqcount_spinlock_t,
        pub xfrm_policy_hash_generation: seqcount_spinlock_t,
        pub xfrm_policy_lock: spinlock_t,
        pub xfrm_cfg_mutex: mutex,
    }
    #[test]
    fn bindgen_test_layout_netns_xfrm() {
        assert_eq!(
            ::core::mem::size_of::<netns_xfrm>(),
            832usize,
            concat!("Size of: ", stringify!(netns_xfrm))
        );
        assert_eq!(
            ::core::mem::align_of::<netns_xfrm>(),
            64usize,
            concat!("Alignment of ", stringify!(netns_xfrm))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_xfrm>())).state_all as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_xfrm),
                "::",
                stringify!(state_all)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_xfrm>())).state_bydst as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_xfrm),
                "::",
                stringify!(state_bydst)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_xfrm>())).state_bysrc as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_xfrm),
                "::",
                stringify!(state_bysrc)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_xfrm>())).state_byspi as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_xfrm),
                "::",
                stringify!(state_byspi)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_xfrm>())).state_byseq as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_xfrm),
                "::",
                stringify!(state_byseq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_xfrm>())).state_hmask as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_xfrm),
                "::",
                stringify!(state_hmask)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_xfrm>())).state_num as *const _ as usize },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_xfrm),
                "::",
                stringify!(state_num)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_xfrm>())).state_hash_work as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_xfrm),
                "::",
                stringify!(state_hash_work)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_xfrm>())).policy_all as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_xfrm),
                "::",
                stringify!(policy_all)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_xfrm>())).policy_byidx as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_xfrm),
                "::",
                stringify!(policy_byidx)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_xfrm>())).policy_idx_hmask as *const _ as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_xfrm),
                "::",
                stringify!(policy_idx_hmask)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_xfrm>())).policy_inexact as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_xfrm),
                "::",
                stringify!(policy_inexact)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_xfrm>())).policy_bydst as *const _ as usize },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_xfrm),
                "::",
                stringify!(policy_bydst)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_xfrm>())).policy_count as *const _ as usize },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_xfrm),
                "::",
                stringify!(policy_count)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_xfrm>())).policy_hash_work as *const _ as usize
            },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_xfrm),
                "::",
                stringify!(policy_hash_work)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_xfrm>())).policy_hthresh as *const _ as usize },
            248usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_xfrm),
                "::",
                stringify!(policy_hthresh)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_xfrm>())).inexact_bins as *const _ as usize },
            296usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_xfrm),
                "::",
                stringify!(inexact_bins)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_xfrm>())).nlsk as *const _ as usize },
            312usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_xfrm),
                "::",
                stringify!(nlsk)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_xfrm>())).nlsk_stash as *const _ as usize },
            320usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_xfrm),
                "::",
                stringify!(nlsk_stash)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_xfrm>())).sysctl_aevent_etime as *const _ as usize
            },
            328usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_xfrm),
                "::",
                stringify!(sysctl_aevent_etime)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_xfrm>())).sysctl_aevent_rseqth as *const _ as usize
            },
            332usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_xfrm),
                "::",
                stringify!(sysctl_aevent_rseqth)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_xfrm>())).sysctl_larval_drop as *const _ as usize
            },
            336usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_xfrm),
                "::",
                stringify!(sysctl_larval_drop)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_xfrm>())).sysctl_acq_expires as *const _ as usize
            },
            340usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_xfrm),
                "::",
                stringify!(sysctl_acq_expires)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_xfrm>())).policy_default as *const _ as usize },
            344usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_xfrm),
                "::",
                stringify!(policy_default)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_xfrm>())).sysctl_hdr as *const _ as usize },
            352usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_xfrm),
                "::",
                stringify!(sysctl_hdr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_xfrm>())).xfrm4_dst_ops as *const _ as usize },
            384usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_xfrm),
                "::",
                stringify!(xfrm4_dst_ops)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_xfrm>())).xfrm6_dst_ops as *const _ as usize },
            576usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_xfrm),
                "::",
                stringify!(xfrm6_dst_ops)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_xfrm>())).xfrm_state_lock as *const _ as usize },
            768usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_xfrm),
                "::",
                stringify!(xfrm_state_lock)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_xfrm>())).xfrm_state_hash_generation as *const _
                    as usize
            },
            772usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_xfrm),
                "::",
                stringify!(xfrm_state_hash_generation)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_xfrm>())).xfrm_policy_hash_generation as *const _
                    as usize
            },
            776usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_xfrm),
                "::",
                stringify!(xfrm_policy_hash_generation)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_xfrm>())).xfrm_policy_lock as *const _ as usize
            },
            780usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_xfrm),
                "::",
                stringify!(xfrm_policy_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_xfrm>())).xfrm_cfg_mutex as *const _ as usize },
            784usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_xfrm),
                "::",
                stringify!(xfrm_cfg_mutex)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct mpls_route {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct netns_mpls {
        pub ip_ttl_propagate: ::cty::c_int,
        pub default_ttl: ::cty::c_int,
        pub platform_labels: size_t,
        pub platform_label: *mut *mut mpls_route,
        pub ctl: *mut ctl_table_header,
    }
    #[test]
    fn bindgen_test_layout_netns_mpls() {
        assert_eq!(
            ::core::mem::size_of::<netns_mpls>(),
            32usize,
            concat!("Size of: ", stringify!(netns_mpls))
        );
        assert_eq!(
            ::core::mem::align_of::<netns_mpls>(),
            8usize,
            concat!("Alignment of ", stringify!(netns_mpls))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_mpls>())).ip_ttl_propagate as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_mpls),
                "::",
                stringify!(ip_ttl_propagate)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_mpls>())).default_ttl as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_mpls),
                "::",
                stringify!(default_ttl)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_mpls>())).platform_labels as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_mpls),
                "::",
                stringify!(platform_labels)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_mpls>())).platform_label as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_mpls),
                "::",
                stringify!(platform_label)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_mpls>())).ctl as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_mpls),
                "::",
                stringify!(ctl)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct can_dev_rcv_lists {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct can_pkg_stats {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct can_rcv_lists_stats {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct netns_can {
        pub proc_dir: *mut proc_dir_entry,
        pub pde_stats: *mut proc_dir_entry,
        pub pde_reset_stats: *mut proc_dir_entry,
        pub pde_rcvlist_all: *mut proc_dir_entry,
        pub pde_rcvlist_fil: *mut proc_dir_entry,
        pub pde_rcvlist_inv: *mut proc_dir_entry,
        pub pde_rcvlist_sff: *mut proc_dir_entry,
        pub pde_rcvlist_eff: *mut proc_dir_entry,
        pub pde_rcvlist_err: *mut proc_dir_entry,
        pub bcmproc_dir: *mut proc_dir_entry,
        pub rx_alldev_list: *mut can_dev_rcv_lists,
        pub rcvlists_lock: spinlock_t,
        pub stattimer: timer_list,
        pub pkg_stats: *mut can_pkg_stats,
        pub rcv_lists_stats: *mut can_rcv_lists_stats,
        pub cgw_list: hlist_head,
    }
    #[test]
    fn bindgen_test_layout_netns_can() {
        assert_eq!(
            ::core::mem::size_of::<netns_can>(),
            160usize,
            concat!("Size of: ", stringify!(netns_can))
        );
        assert_eq!(
            ::core::mem::align_of::<netns_can>(),
            8usize,
            concat!("Alignment of ", stringify!(netns_can))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_can>())).proc_dir as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_can),
                "::",
                stringify!(proc_dir)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_can>())).pde_stats as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_can),
                "::",
                stringify!(pde_stats)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_can>())).pde_reset_stats as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_can),
                "::",
                stringify!(pde_reset_stats)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_can>())).pde_rcvlist_all as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_can),
                "::",
                stringify!(pde_rcvlist_all)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_can>())).pde_rcvlist_fil as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_can),
                "::",
                stringify!(pde_rcvlist_fil)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_can>())).pde_rcvlist_inv as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_can),
                "::",
                stringify!(pde_rcvlist_inv)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_can>())).pde_rcvlist_sff as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_can),
                "::",
                stringify!(pde_rcvlist_sff)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_can>())).pde_rcvlist_eff as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_can),
                "::",
                stringify!(pde_rcvlist_eff)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_can>())).pde_rcvlist_err as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_can),
                "::",
                stringify!(pde_rcvlist_err)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_can>())).bcmproc_dir as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_can),
                "::",
                stringify!(bcmproc_dir)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_can>())).rx_alldev_list as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_can),
                "::",
                stringify!(rx_alldev_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_can>())).rcvlists_lock as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_can),
                "::",
                stringify!(rcvlists_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_can>())).stattimer as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_can),
                "::",
                stringify!(stattimer)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_can>())).pkg_stats as *const _ as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_can),
                "::",
                stringify!(pkg_stats)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_can>())).rcv_lists_stats as *const _ as usize },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_can),
                "::",
                stringify!(rcv_lists_stats)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_can>())).cgw_list as *const _ as usize },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_can),
                "::",
                stringify!(cgw_list)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct netns_xdp {
        pub lock: mutex,
        pub list: hlist_head,
    }
    #[test]
    fn bindgen_test_layout_netns_xdp() {
        assert_eq!(
            ::core::mem::size_of::<netns_xdp>(),
            40usize,
            concat!("Size of: ", stringify!(netns_xdp))
        );
        assert_eq!(
            ::core::mem::align_of::<netns_xdp>(),
            8usize,
            concat!("Alignment of ", stringify!(netns_xdp))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_xdp>())).lock as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_xdp),
                "::",
                stringify!(lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_xdp>())).list as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_xdp),
                "::",
                stringify!(list)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct smc_stats_rsn {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct smc_stats {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct netns_smc {
        pub smc_stats: *mut smc_stats,
        pub mutex_fback_rsn: mutex,
        pub fback_rsn: *mut smc_stats_rsn,
        pub limit_smc_hs: bool_,
        pub smc_hdr: *mut ctl_table_header,
        pub sysctl_autocorking_size: ::cty::c_uint,
        pub sysctl_smcr_buf_type: ::cty::c_uint,
        pub sysctl_smcr_testlink_time: ::cty::c_int,
        pub sysctl_wmem: ::cty::c_int,
        pub sysctl_rmem: ::cty::c_int,
    }
    #[test]
    fn bindgen_test_layout_netns_smc() {
        assert_eq!(
            ::core::mem::size_of::<netns_smc>(),
            88usize,
            concat!("Size of: ", stringify!(netns_smc))
        );
        assert_eq!(
            ::core::mem::align_of::<netns_smc>(),
            8usize,
            concat!("Alignment of ", stringify!(netns_smc))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_smc>())).smc_stats as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_smc),
                "::",
                stringify!(smc_stats)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_smc>())).mutex_fback_rsn as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_smc),
                "::",
                stringify!(mutex_fback_rsn)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_smc>())).fback_rsn as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_smc),
                "::",
                stringify!(fback_rsn)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_smc>())).limit_smc_hs as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_smc),
                "::",
                stringify!(limit_smc_hs)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_smc>())).smc_hdr as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_smc),
                "::",
                stringify!(smc_hdr)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_smc>())).sysctl_autocorking_size as *const _ as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_smc),
                "::",
                stringify!(sysctl_autocorking_size)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_smc>())).sysctl_smcr_buf_type as *const _ as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_smc),
                "::",
                stringify!(sysctl_smcr_buf_type)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netns_smc>())).sysctl_smcr_testlink_time as *const _
                    as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_smc),
                "::",
                stringify!(sysctl_smcr_testlink_time)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_smc>())).sysctl_wmem as *const _ as usize },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_smc),
                "::",
                stringify!(sysctl_wmem)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_smc>())).sysctl_rmem as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_smc),
                "::",
                stringify!(sysctl_rmem)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_prog {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_prog_array {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct netns_bpf {
        pub run_array: [*mut bpf_prog_array; 2usize],
        pub progs: [*mut bpf_prog; 2usize],
        pub links: [list_head; 2usize],
    }
    #[test]
    fn bindgen_test_layout_netns_bpf() {
        assert_eq!(
            ::core::mem::size_of::<netns_bpf>(),
            64usize,
            concat!("Size of: ", stringify!(netns_bpf))
        );
        assert_eq!(
            ::core::mem::align_of::<netns_bpf>(),
            8usize,
            concat!("Alignment of ", stringify!(netns_bpf))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_bpf>())).run_array as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_bpf),
                "::",
                stringify!(run_array)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_bpf>())).progs as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_bpf),
                "::",
                stringify!(progs)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_bpf>())).links as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_bpf),
                "::",
                stringify!(links)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct netns_mctp {
        pub routes: list_head,
        pub bind_lock: mutex,
        pub binds: hlist_head,
        pub keys_lock: spinlock_t,
        pub keys: hlist_head,
        pub default_net: ::cty::c_uint,
        pub neigh_lock: mutex,
        pub neighbours: list_head,
    }
    #[test]
    fn bindgen_test_layout_netns_mctp() {
        assert_eq!(
            ::core::mem::size_of::<netns_mctp>(),
            128usize,
            concat!("Size of: ", stringify!(netns_mctp))
        );
        assert_eq!(
            ::core::mem::align_of::<netns_mctp>(),
            8usize,
            concat!("Alignment of ", stringify!(netns_mctp))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_mctp>())).routes as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_mctp),
                "::",
                stringify!(routes)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_mctp>())).bind_lock as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_mctp),
                "::",
                stringify!(bind_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_mctp>())).binds as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_mctp),
                "::",
                stringify!(binds)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_mctp>())).keys_lock as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_mctp),
                "::",
                stringify!(keys_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_mctp>())).keys as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_mctp),
                "::",
                stringify!(keys)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_mctp>())).default_net as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_mctp),
                "::",
                stringify!(default_net)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_mctp>())).neigh_lock as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_mctp),
                "::",
                stringify!(neigh_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netns_mctp>())).neighbours as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(netns_mctp),
                "::",
                stringify!(neighbours)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct free_area {
        pub free_list: [list_head; 5usize],
        pub nr_free: ::cty::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_free_area() {
        assert_eq!(
            ::core::mem::size_of::<free_area>(),
            88usize,
            concat!("Size of: ", stringify!(free_area))
        );
        assert_eq!(
            ::core::mem::align_of::<free_area>(),
            8usize,
            concat!("Alignment of ", stringify!(free_area))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<free_area>())).free_list as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(free_area),
                "::",
                stringify!(free_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<free_area>())).nr_free as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(free_area),
                "::",
                stringify!(nr_free)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct lru_gen_folio {
        pub max_seq: ::cty::c_ulong,
        pub min_seq: [::cty::c_ulong; 2usize],
        pub timestamps: [::cty::c_ulong; 4usize],
        pub folios: [[[list_head; 5usize]; 2usize]; 4usize],
        pub nr_pages: [[[::cty::c_long; 5usize]; 2usize]; 4usize],
        pub avg_refaulted: [[::cty::c_ulong; 4usize]; 2usize],
        pub avg_total: [[::cty::c_ulong; 4usize]; 2usize],
        pub protected: [[[::cty::c_ulong; 3usize]; 2usize]; 1usize],
        pub evicted: [[[atomic_long_t; 4usize]; 2usize]; 1usize],
        pub refaulted: [[[atomic_long_t; 4usize]; 2usize]; 1usize],
        pub enabled: bool_,
        pub gen: _cargo_bpf_u8,
        pub seg: _cargo_bpf_u8,
        pub list: hlist_nulls_node,
    }
    #[test]
    fn bindgen_test_layout_lru_gen_folio() {
        assert_eq!(
            ::core::mem::size_of::<lru_gen_folio>(),
            1344usize,
            concat!("Size of: ", stringify!(lru_gen_folio))
        );
        assert_eq!(
            ::core::mem::align_of::<lru_gen_folio>(),
            8usize,
            concat!("Alignment of ", stringify!(lru_gen_folio))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<lru_gen_folio>())).max_seq as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(lru_gen_folio),
                "::",
                stringify!(max_seq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<lru_gen_folio>())).min_seq as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(lru_gen_folio),
                "::",
                stringify!(min_seq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<lru_gen_folio>())).timestamps as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(lru_gen_folio),
                "::",
                stringify!(timestamps)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<lru_gen_folio>())).folios as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(lru_gen_folio),
                "::",
                stringify!(folios)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<lru_gen_folio>())).nr_pages as *const _ as usize },
            696usize,
            concat!(
                "Offset of field: ",
                stringify!(lru_gen_folio),
                "::",
                stringify!(nr_pages)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<lru_gen_folio>())).avg_refaulted as *const _ as usize
            },
            1016usize,
            concat!(
                "Offset of field: ",
                stringify!(lru_gen_folio),
                "::",
                stringify!(avg_refaulted)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<lru_gen_folio>())).avg_total as *const _ as usize },
            1080usize,
            concat!(
                "Offset of field: ",
                stringify!(lru_gen_folio),
                "::",
                stringify!(avg_total)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<lru_gen_folio>())).protected as *const _ as usize },
            1144usize,
            concat!(
                "Offset of field: ",
                stringify!(lru_gen_folio),
                "::",
                stringify!(protected)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<lru_gen_folio>())).evicted as *const _ as usize },
            1192usize,
            concat!(
                "Offset of field: ",
                stringify!(lru_gen_folio),
                "::",
                stringify!(evicted)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<lru_gen_folio>())).refaulted as *const _ as usize },
            1256usize,
            concat!(
                "Offset of field: ",
                stringify!(lru_gen_folio),
                "::",
                stringify!(refaulted)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<lru_gen_folio>())).enabled as *const _ as usize },
            1320usize,
            concat!(
                "Offset of field: ",
                stringify!(lru_gen_folio),
                "::",
                stringify!(enabled)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<lru_gen_folio>())).gen as *const _ as usize },
            1321usize,
            concat!(
                "Offset of field: ",
                stringify!(lru_gen_folio),
                "::",
                stringify!(gen)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<lru_gen_folio>())).seg as *const _ as usize },
            1322usize,
            concat!(
                "Offset of field: ",
                stringify!(lru_gen_folio),
                "::",
                stringify!(seg)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<lru_gen_folio>())).list as *const _ as usize },
            1328usize,
            concat!(
                "Offset of field: ",
                stringify!(lru_gen_folio),
                "::",
                stringify!(list)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct lru_gen_mm_state {
        pub seq: ::cty::c_ulong,
        pub head: *mut list_head,
        pub tail: *mut list_head,
        pub filters: [*mut ::cty::c_ulong; 2usize],
        pub stats: [[::cty::c_ulong; 6usize]; 1usize],
    }
    #[test]
    fn bindgen_test_layout_lru_gen_mm_state() {
        assert_eq!(
            ::core::mem::size_of::<lru_gen_mm_state>(),
            88usize,
            concat!("Size of: ", stringify!(lru_gen_mm_state))
        );
        assert_eq!(
            ::core::mem::align_of::<lru_gen_mm_state>(),
            8usize,
            concat!("Alignment of ", stringify!(lru_gen_mm_state))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<lru_gen_mm_state>())).seq as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(lru_gen_mm_state),
                "::",
                stringify!(seq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<lru_gen_mm_state>())).head as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(lru_gen_mm_state),
                "::",
                stringify!(head)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<lru_gen_mm_state>())).tail as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(lru_gen_mm_state),
                "::",
                stringify!(tail)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<lru_gen_mm_state>())).filters as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(lru_gen_mm_state),
                "::",
                stringify!(filters)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<lru_gen_mm_state>())).stats as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(lru_gen_mm_state),
                "::",
                stringify!(stats)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct lru_gen_mm_walk {
        pub lruvec: *mut lruvec,
        pub max_seq: ::cty::c_ulong,
        pub next_addr: ::cty::c_ulong,
        pub nr_pages: [[[::cty::c_int; 5usize]; 2usize]; 4usize],
        pub mm_stats: [::cty::c_int; 6usize],
        pub batched: ::cty::c_int,
        pub can_swap: bool_,
        pub force_scan: bool_,
    }
    #[test]
    fn bindgen_test_layout_lru_gen_mm_walk() {
        assert_eq!(
            ::core::mem::size_of::<lru_gen_mm_walk>(),
            216usize,
            concat!("Size of: ", stringify!(lru_gen_mm_walk))
        );
        assert_eq!(
            ::core::mem::align_of::<lru_gen_mm_walk>(),
            8usize,
            concat!("Alignment of ", stringify!(lru_gen_mm_walk))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<lru_gen_mm_walk>())).lruvec as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(lru_gen_mm_walk),
                "::",
                stringify!(lruvec)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<lru_gen_mm_walk>())).max_seq as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(lru_gen_mm_walk),
                "::",
                stringify!(max_seq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<lru_gen_mm_walk>())).next_addr as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(lru_gen_mm_walk),
                "::",
                stringify!(next_addr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<lru_gen_mm_walk>())).nr_pages as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(lru_gen_mm_walk),
                "::",
                stringify!(nr_pages)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<lru_gen_mm_walk>())).mm_stats as *const _ as usize },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(lru_gen_mm_walk),
                "::",
                stringify!(mm_stats)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<lru_gen_mm_walk>())).batched as *const _ as usize },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(lru_gen_mm_walk),
                "::",
                stringify!(batched)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<lru_gen_mm_walk>())).can_swap as *const _ as usize },
            212usize,
            concat!(
                "Offset of field: ",
                stringify!(lru_gen_mm_walk),
                "::",
                stringify!(can_swap)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<lru_gen_mm_walk>())).force_scan as *const _ as usize },
            213usize,
            concat!(
                "Offset of field: ",
                stringify!(lru_gen_mm_walk),
                "::",
                stringify!(force_scan)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct lru_gen_memcg {
        pub seq: ::cty::c_ulong,
        pub nr_memcgs: [::cty::c_ulong; 2usize],
        pub fifo: [[hlist_nulls_head; 8usize]; 2usize],
        pub lock: spinlock_t,
    }
    #[test]
    fn bindgen_test_layout_lru_gen_memcg() {
        assert_eq!(
            ::core::mem::size_of::<lru_gen_memcg>(),
            160usize,
            concat!("Size of: ", stringify!(lru_gen_memcg))
        );
        assert_eq!(
            ::core::mem::align_of::<lru_gen_memcg>(),
            8usize,
            concat!("Alignment of ", stringify!(lru_gen_memcg))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<lru_gen_memcg>())).seq as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(lru_gen_memcg),
                "::",
                stringify!(seq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<lru_gen_memcg>())).nr_memcgs as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(lru_gen_memcg),
                "::",
                stringify!(nr_memcgs)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<lru_gen_memcg>())).fifo as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(lru_gen_memcg),
                "::",
                stringify!(fifo)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<lru_gen_memcg>())).lock as *const _ as usize },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(lru_gen_memcg),
                "::",
                stringify!(lock)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct lruvec {
        pub lists: [list_head; 5usize],
        pub lru_lock: spinlock_t,
        pub anon_cost: ::cty::c_ulong,
        pub file_cost: ::cty::c_ulong,
        pub nonresident_age: atomic_long_t,
        pub refaults: [::cty::c_ulong; 2usize],
        pub flags: ::cty::c_ulong,
        pub lrugen: lru_gen_folio,
        pub mm_state: lru_gen_mm_state,
        pub pgdat: *mut pglist_data,
    }
    #[test]
    fn bindgen_test_layout_lruvec() {
        assert_eq!(
            ::core::mem::size_of::<lruvec>(),
            1576usize,
            concat!("Size of: ", stringify!(lruvec))
        );
        assert_eq!(
            ::core::mem::align_of::<lruvec>(),
            8usize,
            concat!("Alignment of ", stringify!(lruvec))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<lruvec>())).lists as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(lruvec),
                "::",
                stringify!(lists)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<lruvec>())).lru_lock as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(lruvec),
                "::",
                stringify!(lru_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<lruvec>())).anon_cost as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(lruvec),
                "::",
                stringify!(anon_cost)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<lruvec>())).file_cost as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(lruvec),
                "::",
                stringify!(file_cost)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<lruvec>())).nonresident_age as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(lruvec),
                "::",
                stringify!(nonresident_age)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<lruvec>())).refaults as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(lruvec),
                "::",
                stringify!(refaults)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<lruvec>())).flags as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(lruvec),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<lruvec>())).lrugen as *const _ as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(lruvec),
                "::",
                stringify!(lrugen)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<lruvec>())).mm_state as *const _ as usize },
            1480usize,
            concat!(
                "Offset of field: ",
                stringify!(lruvec),
                "::",
                stringify!(mm_state)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<lruvec>())).pgdat as *const _ as usize },
            1568usize,
            concat!(
                "Offset of field: ",
                stringify!(lruvec),
                "::",
                stringify!(pgdat)
            )
        );
    }
    #[repr(C)]
    #[repr(align(64))]
    #[derive(Copy, Clone)]
    pub struct per_cpu_pages {
        pub lock: spinlock_t,
        pub count: ::cty::c_int,
        pub high: ::cty::c_int,
        pub batch: ::cty::c_int,
        pub free_factor: ::cty::c_short,
        pub expire: ::cty::c_short,
        pub lists: [list_head; 13usize],
    }
    #[test]
    fn bindgen_test_layout_per_cpu_pages() {
        assert_eq!(
            ::core::mem::size_of::<per_cpu_pages>(),
            256usize,
            concat!("Size of: ", stringify!(per_cpu_pages))
        );
        assert_eq!(
            ::core::mem::align_of::<per_cpu_pages>(),
            64usize,
            concat!("Alignment of ", stringify!(per_cpu_pages))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<per_cpu_pages>())).lock as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(per_cpu_pages),
                "::",
                stringify!(lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<per_cpu_pages>())).count as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(per_cpu_pages),
                "::",
                stringify!(count)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<per_cpu_pages>())).high as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(per_cpu_pages),
                "::",
                stringify!(high)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<per_cpu_pages>())).batch as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(per_cpu_pages),
                "::",
                stringify!(batch)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<per_cpu_pages>())).free_factor as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(per_cpu_pages),
                "::",
                stringify!(free_factor)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<per_cpu_pages>())).expire as *const _ as usize },
            18usize,
            concat!(
                "Offset of field: ",
                stringify!(per_cpu_pages),
                "::",
                stringify!(expire)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<per_cpu_pages>())).lists as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(per_cpu_pages),
                "::",
                stringify!(lists)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct per_cpu_zonestat {
        pub vm_stat_diff: [s8; 12usize],
        pub stat_threshold: s8,
        pub vm_numa_event: [::cty::c_ulong; 6usize],
    }
    #[test]
    fn bindgen_test_layout_per_cpu_zonestat() {
        assert_eq!(
            ::core::mem::size_of::<per_cpu_zonestat>(),
            64usize,
            concat!("Size of: ", stringify!(per_cpu_zonestat))
        );
        assert_eq!(
            ::core::mem::align_of::<per_cpu_zonestat>(),
            8usize,
            concat!("Alignment of ", stringify!(per_cpu_zonestat))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<per_cpu_zonestat>())).vm_stat_diff as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(per_cpu_zonestat),
                "::",
                stringify!(vm_stat_diff)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<per_cpu_zonestat>())).stat_threshold as *const _ as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(per_cpu_zonestat),
                "::",
                stringify!(stat_threshold)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<per_cpu_zonestat>())).vm_numa_event as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(per_cpu_zonestat),
                "::",
                stringify!(vm_numa_event)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct per_cpu_nodestat {
        pub stat_threshold: s8,
        pub vm_node_stat_diff: [s8; 43usize],
    }
    #[test]
    fn bindgen_test_layout_per_cpu_nodestat() {
        assert_eq!(
            ::core::mem::size_of::<per_cpu_nodestat>(),
            44usize,
            concat!("Size of: ", stringify!(per_cpu_nodestat))
        );
        assert_eq!(
            ::core::mem::align_of::<per_cpu_nodestat>(),
            1usize,
            concat!("Alignment of ", stringify!(per_cpu_nodestat))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<per_cpu_nodestat>())).stat_threshold as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(per_cpu_nodestat),
                "::",
                stringify!(stat_threshold)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<per_cpu_nodestat>())).vm_node_stat_diff as *const _ as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(per_cpu_nodestat),
                "::",
                stringify!(vm_node_stat_diff)
            )
        );
    }
    pub const zone_type_ZONE_DMA: zone_type = 0;
    pub const zone_type_ZONE_DMA32: zone_type = 1;
    pub const zone_type_ZONE_NORMAL: zone_type = 2;
    pub const zone_type_ZONE_MOVABLE: zone_type = 3;
    pub const zone_type_ZONE_DEVICE: zone_type = 4;
    pub const zone_type___MAX_NR_ZONES: zone_type = 5;
    pub type zone_type = ::cty::c_uint;
    #[repr(C)]
    #[repr(align(64))]
    pub struct zone {
        pub _watermark: [::cty::c_ulong; 4usize],
        pub watermark_boost: ::cty::c_ulong,
        pub nr_reserved_highatomic: ::cty::c_ulong,
        pub lowmem_reserve: [::cty::c_long; 5usize],
        pub node: ::cty::c_int,
        pub zone_pgdat: *mut pglist_data,
        pub per_cpu_pageset: *mut per_cpu_pages,
        pub per_cpu_zonestats: *mut per_cpu_zonestat,
        pub pageset_high: ::cty::c_int,
        pub pageset_batch: ::cty::c_int,
        pub zone_start_pfn: ::cty::c_ulong,
        pub managed_pages: atomic_long_t,
        pub spanned_pages: ::cty::c_ulong,
        pub present_pages: ::cty::c_ulong,
        pub present_early_pages: ::cty::c_ulong,
        pub name: *const ::cty::c_char,
        pub nr_isolate_pageblock: ::cty::c_ulong,
        pub span_seqlock: seqlock_t,
        pub initialized: ::cty::c_int,
        pub __bindgen_padding_0: [u64; 7usize],
        pub _pad1_: cacheline_padding,
        pub free_area: [free_area; 11usize],
        pub unaccepted_pages: list_head,
        pub flags: ::cty::c_ulong,
        pub lock: spinlock_t,
        pub __bindgen_padding_1: [u64; 3usize],
        pub _pad2_: cacheline_padding,
        pub percpu_drift_mark: ::cty::c_ulong,
        pub compact_cached_free_pfn: ::cty::c_ulong,
        pub compact_cached_migrate_pfn: [::cty::c_ulong; 2usize],
        pub compact_init_migrate_pfn: ::cty::c_ulong,
        pub compact_init_free_pfn: ::cty::c_ulong,
        pub compact_considered: ::cty::c_uint,
        pub compact_defer_shift: ::cty::c_uint,
        pub compact_order_failed: ::cty::c_int,
        pub compact_blockskip_flush: bool_,
        pub contiguous: bool_,
        pub __bindgen_padding_2: [u64; 0usize],
        pub _pad3_: cacheline_padding,
        pub vm_stat: [atomic_long_t; 12usize],
        pub vm_numa_event: [atomic_long_t; 6usize],
    }
    #[test]
    fn bindgen_test_layout_zone() {
        assert_eq!(
            ::core::mem::size_of::<zone>(),
            1536usize,
            concat!("Size of: ", stringify!(zone))
        );
        assert_eq!(
            ::core::mem::align_of::<zone>(),
            64usize,
            concat!("Alignment of ", stringify!(zone))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<zone>()))._watermark as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(zone),
                "::",
                stringify!(_watermark)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<zone>())).watermark_boost as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(zone),
                "::",
                stringify!(watermark_boost)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<zone>())).nr_reserved_highatomic as *const _ as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(zone),
                "::",
                stringify!(nr_reserved_highatomic)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<zone>())).lowmem_reserve as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(zone),
                "::",
                stringify!(lowmem_reserve)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<zone>())).node as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(zone),
                "::",
                stringify!(node)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<zone>())).zone_pgdat as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(zone),
                "::",
                stringify!(zone_pgdat)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<zone>())).per_cpu_pageset as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(zone),
                "::",
                stringify!(per_cpu_pageset)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<zone>())).per_cpu_zonestats as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(zone),
                "::",
                stringify!(per_cpu_zonestats)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<zone>())).pageset_high as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(zone),
                "::",
                stringify!(pageset_high)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<zone>())).pageset_batch as *const _ as usize },
            124usize,
            concat!(
                "Offset of field: ",
                stringify!(zone),
                "::",
                stringify!(pageset_batch)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<zone>())).zone_start_pfn as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(zone),
                "::",
                stringify!(zone_start_pfn)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<zone>())).managed_pages as *const _ as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(zone),
                "::",
                stringify!(managed_pages)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<zone>())).spanned_pages as *const _ as usize },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(zone),
                "::",
                stringify!(spanned_pages)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<zone>())).present_pages as *const _ as usize },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(zone),
                "::",
                stringify!(present_pages)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<zone>())).present_early_pages as *const _ as usize },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(zone),
                "::",
                stringify!(present_early_pages)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<zone>())).name as *const _ as usize },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(zone),
                "::",
                stringify!(name)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<zone>())).nr_isolate_pageblock as *const _ as usize },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(zone),
                "::",
                stringify!(nr_isolate_pageblock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<zone>())).span_seqlock as *const _ as usize },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(zone),
                "::",
                stringify!(span_seqlock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<zone>())).initialized as *const _ as usize },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(zone),
                "::",
                stringify!(initialized)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<zone>()))._pad1_ as *const _ as usize },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(zone),
                "::",
                stringify!(_pad1_)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<zone>())).free_area as *const _ as usize },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(zone),
                "::",
                stringify!(free_area)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<zone>())).unaccepted_pages as *const _ as usize },
            1224usize,
            concat!(
                "Offset of field: ",
                stringify!(zone),
                "::",
                stringify!(unaccepted_pages)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<zone>())).flags as *const _ as usize },
            1240usize,
            concat!(
                "Offset of field: ",
                stringify!(zone),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<zone>())).lock as *const _ as usize },
            1248usize,
            concat!(
                "Offset of field: ",
                stringify!(zone),
                "::",
                stringify!(lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<zone>()))._pad2_ as *const _ as usize },
            1280usize,
            concat!(
                "Offset of field: ",
                stringify!(zone),
                "::",
                stringify!(_pad2_)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<zone>())).percpu_drift_mark as *const _ as usize },
            1280usize,
            concat!(
                "Offset of field: ",
                stringify!(zone),
                "::",
                stringify!(percpu_drift_mark)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<zone>())).compact_cached_free_pfn as *const _ as usize
            },
            1288usize,
            concat!(
                "Offset of field: ",
                stringify!(zone),
                "::",
                stringify!(compact_cached_free_pfn)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<zone>())).compact_cached_migrate_pfn as *const _ as usize
            },
            1296usize,
            concat!(
                "Offset of field: ",
                stringify!(zone),
                "::",
                stringify!(compact_cached_migrate_pfn)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<zone>())).compact_init_migrate_pfn as *const _ as usize
            },
            1312usize,
            concat!(
                "Offset of field: ",
                stringify!(zone),
                "::",
                stringify!(compact_init_migrate_pfn)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<zone>())).compact_init_free_pfn as *const _ as usize },
            1320usize,
            concat!(
                "Offset of field: ",
                stringify!(zone),
                "::",
                stringify!(compact_init_free_pfn)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<zone>())).compact_considered as *const _ as usize },
            1328usize,
            concat!(
                "Offset of field: ",
                stringify!(zone),
                "::",
                stringify!(compact_considered)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<zone>())).compact_defer_shift as *const _ as usize },
            1332usize,
            concat!(
                "Offset of field: ",
                stringify!(zone),
                "::",
                stringify!(compact_defer_shift)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<zone>())).compact_order_failed as *const _ as usize },
            1336usize,
            concat!(
                "Offset of field: ",
                stringify!(zone),
                "::",
                stringify!(compact_order_failed)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<zone>())).compact_blockskip_flush as *const _ as usize
            },
            1340usize,
            concat!(
                "Offset of field: ",
                stringify!(zone),
                "::",
                stringify!(compact_blockskip_flush)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<zone>())).contiguous as *const _ as usize },
            1341usize,
            concat!(
                "Offset of field: ",
                stringify!(zone),
                "::",
                stringify!(contiguous)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<zone>()))._pad3_ as *const _ as usize },
            1344usize,
            concat!(
                "Offset of field: ",
                stringify!(zone),
                "::",
                stringify!(_pad3_)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<zone>())).vm_stat as *const _ as usize },
            1344usize,
            concat!(
                "Offset of field: ",
                stringify!(zone),
                "::",
                stringify!(vm_stat)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<zone>())).vm_numa_event as *const _ as usize },
            1440usize,
            concat!(
                "Offset of field: ",
                stringify!(zone),
                "::",
                stringify!(vm_numa_event)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct zoneref {
        pub zone: *mut zone,
        pub zone_idx: ::cty::c_int,
    }
    #[test]
    fn bindgen_test_layout_zoneref() {
        assert_eq!(
            ::core::mem::size_of::<zoneref>(),
            16usize,
            concat!("Size of: ", stringify!(zoneref))
        );
        assert_eq!(
            ::core::mem::align_of::<zoneref>(),
            8usize,
            concat!("Alignment of ", stringify!(zoneref))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<zoneref>())).zone as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(zoneref),
                "::",
                stringify!(zone)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<zoneref>())).zone_idx as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(zoneref),
                "::",
                stringify!(zone_idx)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct zonelist {
        pub _zonerefs: [zoneref; 5121usize],
    }
    #[test]
    fn bindgen_test_layout_zonelist() {
        assert_eq!(
            ::core::mem::size_of::<zonelist>(),
            81936usize,
            concat!("Size of: ", stringify!(zonelist))
        );
        assert_eq!(
            ::core::mem::align_of::<zonelist>(),
            8usize,
            concat!("Alignment of ", stringify!(zonelist))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<zonelist>()))._zonerefs as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(zonelist),
                "::",
                stringify!(_zonerefs)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct deferred_split {
        pub split_queue_lock: spinlock_t,
        pub split_queue: list_head,
        pub split_queue_len: ::cty::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_deferred_split() {
        assert_eq!(
            ::core::mem::size_of::<deferred_split>(),
            32usize,
            concat!("Size of: ", stringify!(deferred_split))
        );
        assert_eq!(
            ::core::mem::align_of::<deferred_split>(),
            8usize,
            concat!("Alignment of ", stringify!(deferred_split))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<deferred_split>())).split_queue_lock as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(deferred_split),
                "::",
                stringify!(split_queue_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<deferred_split>())).split_queue as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(deferred_split),
                "::",
                stringify!(split_queue)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<deferred_split>())).split_queue_len as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(deferred_split),
                "::",
                stringify!(split_queue_len)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct memory_failure_stats {
        pub total: ::cty::c_ulong,
        pub ignored: ::cty::c_ulong,
        pub failed: ::cty::c_ulong,
        pub delayed: ::cty::c_ulong,
        pub recovered: ::cty::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_memory_failure_stats() {
        assert_eq!(
            ::core::mem::size_of::<memory_failure_stats>(),
            40usize,
            concat!("Size of: ", stringify!(memory_failure_stats))
        );
        assert_eq!(
            ::core::mem::align_of::<memory_failure_stats>(),
            8usize,
            concat!("Alignment of ", stringify!(memory_failure_stats))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<memory_failure_stats>())).total as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(memory_failure_stats),
                "::",
                stringify!(total)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<memory_failure_stats>())).ignored as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(memory_failure_stats),
                "::",
                stringify!(ignored)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<memory_failure_stats>())).failed as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(memory_failure_stats),
                "::",
                stringify!(failed)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<memory_failure_stats>())).delayed as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(memory_failure_stats),
                "::",
                stringify!(delayed)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<memory_failure_stats>())).recovered as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(memory_failure_stats),
                "::",
                stringify!(recovered)
            )
        );
    }
    #[repr(C)]
    #[repr(align(64))]
    pub struct pglist_data {
        pub node_zones: [zone; 5usize],
        pub node_zonelists: [zonelist; 2usize],
        pub nr_zones: ::cty::c_int,
        pub node_size_lock: spinlock_t,
        pub node_start_pfn: ::cty::c_ulong,
        pub node_present_pages: ::cty::c_ulong,
        pub node_spanned_pages: ::cty::c_ulong,
        pub node_id: ::cty::c_int,
        pub kswapd_wait: wait_queue_head_t,
        pub pfmemalloc_wait: wait_queue_head_t,
        pub reclaim_wait: [wait_queue_head_t; 4usize],
        pub nr_writeback_throttled: atomic_t,
        pub nr_reclaim_start: ::cty::c_ulong,
        pub kswapd_lock: mutex,
        pub kswapd: *mut task_struct,
        pub kswapd_order: ::cty::c_int,
        pub kswapd_highest_zoneidx: zone_type,
        pub kswapd_failures: ::cty::c_int,
        pub kcompactd_max_order: ::cty::c_int,
        pub kcompactd_highest_zoneidx: zone_type,
        pub kcompactd_wait: wait_queue_head_t,
        pub kcompactd: *mut task_struct,
        pub proactive_compact_trigger: bool_,
        pub totalreserve_pages: ::cty::c_ulong,
        pub min_unmapped_pages: ::cty::c_ulong,
        pub min_slab_pages: ::cty::c_ulong,
        pub __bindgen_padding_0: [u64; 3usize],
        pub _pad1_: cacheline_padding,
        pub deferred_split_queue: deferred_split,
        pub nbp_rl_start: ::cty::c_uint,
        pub nbp_rl_nr_cand: ::cty::c_ulong,
        pub nbp_threshold: ::cty::c_uint,
        pub nbp_th_start: ::cty::c_uint,
        pub nbp_th_nr_cand: ::cty::c_ulong,
        pub __lruvec: lruvec,
        pub flags: ::cty::c_ulong,
        pub mm_walk: lru_gen_mm_walk,
        pub memcg_lru: lru_gen_memcg,
        pub __bindgen_padding_1: [u64; 3usize],
        pub _pad2_: cacheline_padding,
        pub per_cpu_nodestats: *mut per_cpu_nodestat,
        pub vm_stat: [atomic_long_t; 43usize],
        pub memtier: *mut memory_tier,
        pub mf_stats: memory_failure_stats,
    }
    #[test]
    fn bindgen_test_layout_pglist_data() {
        assert_eq!(
            ::core::mem::size_of::<pglist_data>(),
            174400usize,
            concat!("Size of: ", stringify!(pglist_data))
        );
        assert_eq!(
            ::core::mem::align_of::<pglist_data>(),
            64usize,
            concat!("Alignment of ", stringify!(pglist_data))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pglist_data>())).node_zones as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pglist_data),
                "::",
                stringify!(node_zones)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pglist_data>())).node_zonelists as *const _ as usize },
            7680usize,
            concat!(
                "Offset of field: ",
                stringify!(pglist_data),
                "::",
                stringify!(node_zonelists)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pglist_data>())).nr_zones as *const _ as usize },
            171552usize,
            concat!(
                "Offset of field: ",
                stringify!(pglist_data),
                "::",
                stringify!(nr_zones)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pglist_data>())).node_size_lock as *const _ as usize },
            171556usize,
            concat!(
                "Offset of field: ",
                stringify!(pglist_data),
                "::",
                stringify!(node_size_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pglist_data>())).node_start_pfn as *const _ as usize },
            171560usize,
            concat!(
                "Offset of field: ",
                stringify!(pglist_data),
                "::",
                stringify!(node_start_pfn)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<pglist_data>())).node_present_pages as *const _ as usize
            },
            171568usize,
            concat!(
                "Offset of field: ",
                stringify!(pglist_data),
                "::",
                stringify!(node_present_pages)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<pglist_data>())).node_spanned_pages as *const _ as usize
            },
            171576usize,
            concat!(
                "Offset of field: ",
                stringify!(pglist_data),
                "::",
                stringify!(node_spanned_pages)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pglist_data>())).node_id as *const _ as usize },
            171584usize,
            concat!(
                "Offset of field: ",
                stringify!(pglist_data),
                "::",
                stringify!(node_id)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pglist_data>())).kswapd_wait as *const _ as usize },
            171592usize,
            concat!(
                "Offset of field: ",
                stringify!(pglist_data),
                "::",
                stringify!(kswapd_wait)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<pglist_data>())).pfmemalloc_wait as *const _ as usize
            },
            171616usize,
            concat!(
                "Offset of field: ",
                stringify!(pglist_data),
                "::",
                stringify!(pfmemalloc_wait)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pglist_data>())).reclaim_wait as *const _ as usize },
            171640usize,
            concat!(
                "Offset of field: ",
                stringify!(pglist_data),
                "::",
                stringify!(reclaim_wait)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<pglist_data>())).nr_writeback_throttled as *const _ as usize
            },
            171736usize,
            concat!(
                "Offset of field: ",
                stringify!(pglist_data),
                "::",
                stringify!(nr_writeback_throttled)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<pglist_data>())).nr_reclaim_start as *const _ as usize
            },
            171744usize,
            concat!(
                "Offset of field: ",
                stringify!(pglist_data),
                "::",
                stringify!(nr_reclaim_start)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pglist_data>())).kswapd_lock as *const _ as usize },
            171752usize,
            concat!(
                "Offset of field: ",
                stringify!(pglist_data),
                "::",
                stringify!(kswapd_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pglist_data>())).kswapd as *const _ as usize },
            171784usize,
            concat!(
                "Offset of field: ",
                stringify!(pglist_data),
                "::",
                stringify!(kswapd)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pglist_data>())).kswapd_order as *const _ as usize },
            171792usize,
            concat!(
                "Offset of field: ",
                stringify!(pglist_data),
                "::",
                stringify!(kswapd_order)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<pglist_data>())).kswapd_highest_zoneidx as *const _ as usize
            },
            171796usize,
            concat!(
                "Offset of field: ",
                stringify!(pglist_data),
                "::",
                stringify!(kswapd_highest_zoneidx)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<pglist_data>())).kswapd_failures as *const _ as usize
            },
            171800usize,
            concat!(
                "Offset of field: ",
                stringify!(pglist_data),
                "::",
                stringify!(kswapd_failures)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<pglist_data>())).kcompactd_max_order as *const _ as usize
            },
            171804usize,
            concat!(
                "Offset of field: ",
                stringify!(pglist_data),
                "::",
                stringify!(kcompactd_max_order)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<pglist_data>())).kcompactd_highest_zoneidx as *const _
                    as usize
            },
            171808usize,
            concat!(
                "Offset of field: ",
                stringify!(pglist_data),
                "::",
                stringify!(kcompactd_highest_zoneidx)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pglist_data>())).kcompactd_wait as *const _ as usize },
            171816usize,
            concat!(
                "Offset of field: ",
                stringify!(pglist_data),
                "::",
                stringify!(kcompactd_wait)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pglist_data>())).kcompactd as *const _ as usize },
            171840usize,
            concat!(
                "Offset of field: ",
                stringify!(pglist_data),
                "::",
                stringify!(kcompactd)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<pglist_data>())).proactive_compact_trigger as *const _
                    as usize
            },
            171848usize,
            concat!(
                "Offset of field: ",
                stringify!(pglist_data),
                "::",
                stringify!(proactive_compact_trigger)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<pglist_data>())).totalreserve_pages as *const _ as usize
            },
            171856usize,
            concat!(
                "Offset of field: ",
                stringify!(pglist_data),
                "::",
                stringify!(totalreserve_pages)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<pglist_data>())).min_unmapped_pages as *const _ as usize
            },
            171864usize,
            concat!(
                "Offset of field: ",
                stringify!(pglist_data),
                "::",
                stringify!(min_unmapped_pages)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pglist_data>())).min_slab_pages as *const _ as usize },
            171872usize,
            concat!(
                "Offset of field: ",
                stringify!(pglist_data),
                "::",
                stringify!(min_slab_pages)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pglist_data>()))._pad1_ as *const _ as usize },
            171904usize,
            concat!(
                "Offset of field: ",
                stringify!(pglist_data),
                "::",
                stringify!(_pad1_)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<pglist_data>())).deferred_split_queue as *const _ as usize
            },
            171904usize,
            concat!(
                "Offset of field: ",
                stringify!(pglist_data),
                "::",
                stringify!(deferred_split_queue)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pglist_data>())).nbp_rl_start as *const _ as usize },
            171936usize,
            concat!(
                "Offset of field: ",
                stringify!(pglist_data),
                "::",
                stringify!(nbp_rl_start)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pglist_data>())).nbp_rl_nr_cand as *const _ as usize },
            171944usize,
            concat!(
                "Offset of field: ",
                stringify!(pglist_data),
                "::",
                stringify!(nbp_rl_nr_cand)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pglist_data>())).nbp_threshold as *const _ as usize },
            171952usize,
            concat!(
                "Offset of field: ",
                stringify!(pglist_data),
                "::",
                stringify!(nbp_threshold)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pglist_data>())).nbp_th_start as *const _ as usize },
            171956usize,
            concat!(
                "Offset of field: ",
                stringify!(pglist_data),
                "::",
                stringify!(nbp_th_start)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pglist_data>())).nbp_th_nr_cand as *const _ as usize },
            171960usize,
            concat!(
                "Offset of field: ",
                stringify!(pglist_data),
                "::",
                stringify!(nbp_th_nr_cand)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pglist_data>())).__lruvec as *const _ as usize },
            171968usize,
            concat!(
                "Offset of field: ",
                stringify!(pglist_data),
                "::",
                stringify!(__lruvec)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pglist_data>())).flags as *const _ as usize },
            173544usize,
            concat!(
                "Offset of field: ",
                stringify!(pglist_data),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pglist_data>())).mm_walk as *const _ as usize },
            173552usize,
            concat!(
                "Offset of field: ",
                stringify!(pglist_data),
                "::",
                stringify!(mm_walk)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pglist_data>())).memcg_lru as *const _ as usize },
            173768usize,
            concat!(
                "Offset of field: ",
                stringify!(pglist_data),
                "::",
                stringify!(memcg_lru)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pglist_data>()))._pad2_ as *const _ as usize },
            173952usize,
            concat!(
                "Offset of field: ",
                stringify!(pglist_data),
                "::",
                stringify!(_pad2_)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<pglist_data>())).per_cpu_nodestats as *const _ as usize
            },
            173952usize,
            concat!(
                "Offset of field: ",
                stringify!(pglist_data),
                "::",
                stringify!(per_cpu_nodestats)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pglist_data>())).vm_stat as *const _ as usize },
            173960usize,
            concat!(
                "Offset of field: ",
                stringify!(pglist_data),
                "::",
                stringify!(vm_stat)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pglist_data>())).memtier as *const _ as usize },
            174304usize,
            concat!(
                "Offset of field: ",
                stringify!(pglist_data),
                "::",
                stringify!(memtier)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pglist_data>())).mf_stats as *const _ as usize },
            174312usize,
            concat!(
                "Offset of field: ",
                stringify!(pglist_data),
                "::",
                stringify!(mf_stats)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct device_node {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct irq_domain {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ref_tracker_dir {}
    #[test]
    fn bindgen_test_layout_ref_tracker_dir() {
        assert_eq!(
            ::core::mem::size_of::<ref_tracker_dir>(),
            0usize,
            concat!("Size of: ", stringify!(ref_tracker_dir))
        );
        assert_eq!(
            ::core::mem::align_of::<ref_tracker_dir>(),
            1usize,
            concat!("Alignment of ", stringify!(ref_tracker_dir))
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct netdevice_tracker {}
    #[test]
    fn bindgen_test_layout_netdevice_tracker() {
        assert_eq!(
            ::core::mem::size_of::<netdevice_tracker>(),
            0usize,
            concat!("Size of: ", stringify!(netdevice_tracker))
        );
        assert_eq!(
            ::core::mem::align_of::<netdevice_tracker>(),
            1usize,
            concat!("Alignment of ", stringify!(netdevice_tracker))
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct netns_tracker {}
    #[test]
    fn bindgen_test_layout_netns_tracker() {
        assert_eq!(
            ::core::mem::size_of::<netns_tracker>(),
            0usize,
            concat!("Size of: ", stringify!(netns_tracker))
        );
        assert_eq!(
            ::core::mem::align_of::<netns_tracker>(),
            1usize,
            concat!("Alignment of ", stringify!(netns_tracker))
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct proc_ns_operations {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ns_common {
        pub stashed: atomic_long_t,
        pub ops: *const proc_ns_operations,
        pub inum: ::cty::c_uint,
        pub count: refcount_t,
    }
    #[test]
    fn bindgen_test_layout_ns_common() {
        assert_eq!(
            ::core::mem::size_of::<ns_common>(),
            24usize,
            concat!("Size of: ", stringify!(ns_common))
        );
        assert_eq!(
            ::core::mem::align_of::<ns_common>(),
            8usize,
            concat!("Alignment of ", stringify!(ns_common))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ns_common>())).stashed as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ns_common),
                "::",
                stringify!(stashed)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ns_common>())).ops as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ns_common),
                "::",
                stringify!(ops)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ns_common>())).inum as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ns_common),
                "::",
                stringify!(inum)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ns_common>())).count as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(ns_common),
                "::",
                stringify!(count)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct xarray {
        pub xa_lock: spinlock_t,
        pub xa_flags: gfp_t,
        pub xa_head: *mut ::cty::c_void,
    }
    #[test]
    fn bindgen_test_layout_xarray() {
        assert_eq!(
            ::core::mem::size_of::<xarray>(),
            16usize,
            concat!("Size of: ", stringify!(xarray))
        );
        assert_eq!(
            ::core::mem::align_of::<xarray>(),
            8usize,
            concat!("Alignment of ", stringify!(xarray))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xarray>())).xa_lock as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(xarray),
                "::",
                stringify!(xa_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xarray>())).xa_flags as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(xarray),
                "::",
                stringify!(xa_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xarray>())).xa_head as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(xarray),
                "::",
                stringify!(xa_head)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct idr {
        pub idr_rt: xarray,
        pub idr_base: ::cty::c_uint,
        pub idr_next: ::cty::c_uint,
    }
    #[test]
    fn bindgen_test_layout_idr() {
        assert_eq!(
            ::core::mem::size_of::<idr>(),
            24usize,
            concat!("Size of: ", stringify!(idr))
        );
        assert_eq!(
            ::core::mem::align_of::<idr>(),
            8usize,
            concat!("Alignment of ", stringify!(idr))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<idr>())).idr_rt as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(idr),
                "::",
                stringify!(idr_rt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<idr>())).idr_base as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(idr),
                "::",
                stringify!(idr_base)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<idr>())).idr_next as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(idr),
                "::",
                stringify!(idr_next)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct hlist_bl_head {
        pub first: *mut hlist_bl_node,
    }
    #[test]
    fn bindgen_test_layout_hlist_bl_head() {
        assert_eq!(
            ::core::mem::size_of::<hlist_bl_head>(),
            8usize,
            concat!("Size of: ", stringify!(hlist_bl_head))
        );
        assert_eq!(
            ::core::mem::align_of::<hlist_bl_head>(),
            8usize,
            concat!("Alignment of ", stringify!(hlist_bl_head))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<hlist_bl_head>())).first as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(hlist_bl_head),
                "::",
                stringify!(first)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct hlist_bl_node {
        pub next: *mut hlist_bl_node,
        pub pprev: *mut *mut hlist_bl_node,
    }
    #[test]
    fn bindgen_test_layout_hlist_bl_node() {
        assert_eq!(
            ::core::mem::size_of::<hlist_bl_node>(),
            16usize,
            concat!("Size of: ", stringify!(hlist_bl_node))
        );
        assert_eq!(
            ::core::mem::align_of::<hlist_bl_node>(),
            8usize,
            concat!("Alignment of ", stringify!(hlist_bl_node))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<hlist_bl_node>())).next as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(hlist_bl_node),
                "::",
                stringify!(next)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<hlist_bl_node>())).pprev as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(hlist_bl_node),
                "::",
                stringify!(pprev)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct lockref {
        pub __bindgen_anon_1: lockref__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union lockref__bindgen_ty_1 {
        pub lock_count: __u64,
        pub __bindgen_anon_1: lockref__bindgen_ty_1__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct lockref__bindgen_ty_1__bindgen_ty_1 {
        pub lock: spinlock_t,
        pub count: ::cty::c_int,
    }
    #[test]
    fn bindgen_test_layout_lockref__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<lockref__bindgen_ty_1__bindgen_ty_1>(),
            8usize,
            concat!("Size of: ", stringify!(lockref__bindgen_ty_1__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<lockref__bindgen_ty_1__bindgen_ty_1>(),
            4usize,
            concat!(
                "Alignment of ",
                stringify!(lockref__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<lockref__bindgen_ty_1__bindgen_ty_1>())).lock as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(lockref__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(lock)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<lockref__bindgen_ty_1__bindgen_ty_1>())).count as *const _
                    as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(lockref__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(count)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_lockref__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<lockref__bindgen_ty_1>(),
            8usize,
            concat!("Size of: ", stringify!(lockref__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<lockref__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(lockref__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<lockref__bindgen_ty_1>())).lock_count as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(lockref__bindgen_ty_1),
                "::",
                stringify!(lock_count)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_lockref() {
        assert_eq!(
            ::core::mem::size_of::<lockref>(),
            8usize,
            concat!("Size of: ", stringify!(lockref))
        );
        assert_eq!(
            ::core::mem::align_of::<lockref>(),
            8usize,
            concat!("Alignment of ", stringify!(lockref))
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct qstr {
        pub __bindgen_anon_1: qstr__bindgen_ty_1,
        pub name: *const ::cty::c_uchar,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union qstr__bindgen_ty_1 {
        pub __bindgen_anon_1: qstr__bindgen_ty_1__bindgen_ty_1,
        pub hash_len: _cargo_bpf_u64,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct qstr__bindgen_ty_1__bindgen_ty_1 {
        pub hash: _cargo_bpf_u32,
        pub len: _cargo_bpf_u32,
    }
    #[test]
    fn bindgen_test_layout_qstr__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<qstr__bindgen_ty_1__bindgen_ty_1>(),
            8usize,
            concat!("Size of: ", stringify!(qstr__bindgen_ty_1__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<qstr__bindgen_ty_1__bindgen_ty_1>(),
            4usize,
            concat!(
                "Alignment of ",
                stringify!(qstr__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<qstr__bindgen_ty_1__bindgen_ty_1>())).hash as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(qstr__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(hash)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<qstr__bindgen_ty_1__bindgen_ty_1>())).len as *const _
                    as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(qstr__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(len)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_qstr__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<qstr__bindgen_ty_1>(),
            8usize,
            concat!("Size of: ", stringify!(qstr__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<qstr__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(qstr__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<qstr__bindgen_ty_1>())).hash_len as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(qstr__bindgen_ty_1),
                "::",
                stringify!(hash_len)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_qstr() {
        assert_eq!(
            ::core::mem::size_of::<qstr>(),
            16usize,
            concat!("Size of: ", stringify!(qstr))
        );
        assert_eq!(
            ::core::mem::align_of::<qstr>(),
            8usize,
            concat!("Alignment of ", stringify!(qstr))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<qstr>())).name as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(qstr),
                "::",
                stringify!(name)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct dentry {
        pub d_flags: ::cty::c_uint,
        pub d_seq: seqcount_spinlock_t,
        pub d_hash: hlist_bl_node,
        pub d_parent: *mut dentry,
        pub d_name: qstr,
        pub d_inode: *mut inode,
        pub d_iname: [::cty::c_uchar; 32usize],
        pub d_lockref: lockref,
        pub d_op: *const dentry_operations,
        pub d_sb: *mut super_block,
        pub d_time: ::cty::c_ulong,
        pub d_fsdata: *mut ::cty::c_void,
        pub __bindgen_anon_1: dentry__bindgen_ty_1,
        pub d_child: list_head,
        pub d_subdirs: list_head,
        pub d_u: dentry__bindgen_ty_2,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union dentry__bindgen_ty_1 {
        pub d_lru: list_head,
        pub d_wait: *mut wait_queue_head_t,
    }
    #[test]
    fn bindgen_test_layout_dentry__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<dentry__bindgen_ty_1>(),
            16usize,
            concat!("Size of: ", stringify!(dentry__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<dentry__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(dentry__bindgen_ty_1))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dentry__bindgen_ty_1>())).d_lru as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(dentry__bindgen_ty_1),
                "::",
                stringify!(d_lru)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<dentry__bindgen_ty_1>())).d_wait as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(dentry__bindgen_ty_1),
                "::",
                stringify!(d_wait)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union dentry__bindgen_ty_2 {
        pub d_alias: hlist_node,
        pub d_in_lookup_hash: hlist_bl_node,
        pub d_rcu: callback_head,
    }
    #[test]
    fn bindgen_test_layout_dentry__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<dentry__bindgen_ty_2>(),
            16usize,
            concat!("Size of: ", stringify!(dentry__bindgen_ty_2))
        );
        assert_eq!(
            ::core::mem::align_of::<dentry__bindgen_ty_2>(),
            8usize,
            concat!("Alignment of ", stringify!(dentry__bindgen_ty_2))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<dentry__bindgen_ty_2>())).d_alias as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(dentry__bindgen_ty_2),
                "::",
                stringify!(d_alias)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<dentry__bindgen_ty_2>())).d_in_lookup_hash as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(dentry__bindgen_ty_2),
                "::",
                stringify!(d_in_lookup_hash)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dentry__bindgen_ty_2>())).d_rcu as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(dentry__bindgen_ty_2),
                "::",
                stringify!(d_rcu)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_dentry() {
        assert_eq!(
            ::core::mem::size_of::<dentry>(),
            192usize,
            concat!("Size of: ", stringify!(dentry))
        );
        assert_eq!(
            ::core::mem::align_of::<dentry>(),
            8usize,
            concat!("Alignment of ", stringify!(dentry))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dentry>())).d_flags as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(dentry),
                "::",
                stringify!(d_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dentry>())).d_seq as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(dentry),
                "::",
                stringify!(d_seq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dentry>())).d_hash as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(dentry),
                "::",
                stringify!(d_hash)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dentry>())).d_parent as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(dentry),
                "::",
                stringify!(d_parent)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dentry>())).d_name as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(dentry),
                "::",
                stringify!(d_name)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dentry>())).d_inode as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(dentry),
                "::",
                stringify!(d_inode)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dentry>())).d_iname as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(dentry),
                "::",
                stringify!(d_iname)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dentry>())).d_lockref as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(dentry),
                "::",
                stringify!(d_lockref)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dentry>())).d_op as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(dentry),
                "::",
                stringify!(d_op)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dentry>())).d_sb as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(dentry),
                "::",
                stringify!(d_sb)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dentry>())).d_time as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(dentry),
                "::",
                stringify!(d_time)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dentry>())).d_fsdata as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(dentry),
                "::",
                stringify!(d_fsdata)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dentry>())).d_child as *const _ as usize },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(dentry),
                "::",
                stringify!(d_child)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dentry>())).d_subdirs as *const _ as usize },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(dentry),
                "::",
                stringify!(d_subdirs)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dentry>())).d_u as *const _ as usize },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(dentry),
                "::",
                stringify!(d_u)
            )
        );
    }
    #[repr(C)]
    #[repr(align(64))]
    #[derive(Debug, Copy, Clone)]
    pub struct dentry_operations {
        pub d_revalidate: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut dentry, arg2: ::cty::c_uint) -> ::cty::c_int,
        >,
        pub d_weak_revalidate: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut dentry, arg2: ::cty::c_uint) -> ::cty::c_int,
        >,
        pub d_hash: ::core::option::Option<
            unsafe extern "C" fn(arg1: *const dentry, arg2: *mut qstr) -> ::cty::c_int,
        >,
        pub d_compare: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const dentry,
                arg2: ::cty::c_uint,
                arg3: *const ::cty::c_char,
                arg4: *const qstr,
            ) -> ::cty::c_int,
        >,
        pub d_delete:
            ::core::option::Option<unsafe extern "C" fn(arg1: *const dentry) -> ::cty::c_int>,
        pub d_init: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry) -> ::cty::c_int>,
        pub d_release: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry)>,
        pub d_prune: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry)>,
        pub d_iput:
            ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry, arg2: *mut inode)>,
        pub d_dname: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dentry,
                arg2: *mut ::cty::c_char,
                arg3: ::cty::c_int,
            ) -> *mut ::cty::c_char,
        >,
        pub d_automount:
            ::core::option::Option<unsafe extern "C" fn(arg1: *mut path) -> *mut vfsmount>,
        pub d_manage: ::core::option::Option<
            unsafe extern "C" fn(arg1: *const path, arg2: bool_) -> ::cty::c_int,
        >,
        pub d_real: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut dentry, arg2: *const inode) -> *mut dentry,
        >,
    }
    #[test]
    fn bindgen_test_layout_dentry_operations() {
        assert_eq!(
            ::core::mem::size_of::<dentry_operations>(),
            128usize,
            concat!("Size of: ", stringify!(dentry_operations))
        );
        assert_eq!(
            ::core::mem::align_of::<dentry_operations>(),
            64usize,
            concat!("Alignment of ", stringify!(dentry_operations))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<dentry_operations>())).d_revalidate as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(dentry_operations),
                "::",
                stringify!(d_revalidate)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<dentry_operations>())).d_weak_revalidate as *const _
                    as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(dentry_operations),
                "::",
                stringify!(d_weak_revalidate)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dentry_operations>())).d_hash as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(dentry_operations),
                "::",
                stringify!(d_hash)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<dentry_operations>())).d_compare as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(dentry_operations),
                "::",
                stringify!(d_compare)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dentry_operations>())).d_delete as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(dentry_operations),
                "::",
                stringify!(d_delete)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dentry_operations>())).d_init as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(dentry_operations),
                "::",
                stringify!(d_init)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<dentry_operations>())).d_release as *const _ as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(dentry_operations),
                "::",
                stringify!(d_release)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dentry_operations>())).d_prune as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(dentry_operations),
                "::",
                stringify!(d_prune)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dentry_operations>())).d_iput as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(dentry_operations),
                "::",
                stringify!(d_iput)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dentry_operations>())).d_dname as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(dentry_operations),
                "::",
                stringify!(d_dname)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<dentry_operations>())).d_automount as *const _ as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(dentry_operations),
                "::",
                stringify!(d_automount)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dentry_operations>())).d_manage as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(dentry_operations),
                "::",
                stringify!(d_manage)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dentry_operations>())).d_real as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(dentry_operations),
                "::",
                stringify!(d_real)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct path {
        pub mnt: *mut vfsmount,
        pub dentry: *mut dentry,
    }
    #[test]
    fn bindgen_test_layout_path() {
        assert_eq!(
            ::core::mem::size_of::<path>(),
            16usize,
            concat!("Size of: ", stringify!(path))
        );
        assert_eq!(
            ::core::mem::align_of::<path>(),
            8usize,
            concat!("Alignment of ", stringify!(path))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<path>())).mnt as *const _ as usize },
            0usize,
            concat!("Offset of field: ", stringify!(path), "::", stringify!(mnt))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<path>())).dentry as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(path),
                "::",
                stringify!(dentry)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct kstat {
        pub result_mask: _cargo_bpf_u32,
        pub mode: umode_t,
        pub nlink: ::cty::c_uint,
        pub blksize: u32,
        pub attributes: _cargo_bpf_u64,
        pub attributes_mask: _cargo_bpf_u64,
        pub ino: _cargo_bpf_u64,
        pub dev: dev_t,
        pub rdev: dev_t,
        pub uid: kuid_t,
        pub gid: kgid_t,
        pub size: loff_t,
        pub atime: timespec64,
        pub mtime: timespec64,
        pub ctime: timespec64,
        pub btime: timespec64,
        pub blocks: _cargo_bpf_u64,
        pub mnt_id: _cargo_bpf_u64,
        pub dio_mem_align: _cargo_bpf_u32,
        pub dio_offset_align: _cargo_bpf_u32,
        pub change_cookie: _cargo_bpf_u64,
    }
    #[test]
    fn bindgen_test_layout_kstat() {
        assert_eq!(
            ::core::mem::size_of::<kstat>(),
            160usize,
            concat!("Size of: ", stringify!(kstat))
        );
        assert_eq!(
            ::core::mem::align_of::<kstat>(),
            8usize,
            concat!("Alignment of ", stringify!(kstat))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kstat>())).result_mask as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(kstat),
                "::",
                stringify!(result_mask)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kstat>())).mode as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(kstat),
                "::",
                stringify!(mode)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kstat>())).nlink as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(kstat),
                "::",
                stringify!(nlink)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kstat>())).blksize as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(kstat),
                "::",
                stringify!(blksize)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kstat>())).attributes as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(kstat),
                "::",
                stringify!(attributes)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kstat>())).attributes_mask as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(kstat),
                "::",
                stringify!(attributes_mask)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kstat>())).ino as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(kstat),
                "::",
                stringify!(ino)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kstat>())).dev as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(kstat),
                "::",
                stringify!(dev)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kstat>())).rdev as *const _ as usize },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(kstat),
                "::",
                stringify!(rdev)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kstat>())).uid as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(kstat),
                "::",
                stringify!(uid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kstat>())).gid as *const _ as usize },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(kstat),
                "::",
                stringify!(gid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kstat>())).size as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(kstat),
                "::",
                stringify!(size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kstat>())).atime as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(kstat),
                "::",
                stringify!(atime)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kstat>())).mtime as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(kstat),
                "::",
                stringify!(mtime)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kstat>())).ctime as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(kstat),
                "::",
                stringify!(ctime)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kstat>())).btime as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(kstat),
                "::",
                stringify!(btime)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kstat>())).blocks as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(kstat),
                "::",
                stringify!(blocks)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kstat>())).mnt_id as *const _ as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(kstat),
                "::",
                stringify!(mnt_id)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kstat>())).dio_mem_align as *const _ as usize },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(kstat),
                "::",
                stringify!(dio_mem_align)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kstat>())).dio_offset_align as *const _ as usize },
            148usize,
            concat!(
                "Offset of field: ",
                stringify!(kstat),
                "::",
                stringify!(dio_offset_align)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kstat>())).change_cookie as *const _ as usize },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(kstat),
                "::",
                stringify!(change_cookie)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct shrink_control {
        pub gfp_mask: gfp_t,
        pub nid: ::cty::c_int,
        pub nr_to_scan: ::cty::c_ulong,
        pub nr_scanned: ::cty::c_ulong,
        pub memcg: *mut mem_cgroup,
    }
    #[test]
    fn bindgen_test_layout_shrink_control() {
        assert_eq!(
            ::core::mem::size_of::<shrink_control>(),
            32usize,
            concat!("Size of: ", stringify!(shrink_control))
        );
        assert_eq!(
            ::core::mem::align_of::<shrink_control>(),
            8usize,
            concat!("Alignment of ", stringify!(shrink_control))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<shrink_control>())).gfp_mask as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(shrink_control),
                "::",
                stringify!(gfp_mask)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<shrink_control>())).nid as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(shrink_control),
                "::",
                stringify!(nid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<shrink_control>())).nr_to_scan as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(shrink_control),
                "::",
                stringify!(nr_to_scan)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<shrink_control>())).nr_scanned as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(shrink_control),
                "::",
                stringify!(nr_scanned)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<shrink_control>())).memcg as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(shrink_control),
                "::",
                stringify!(memcg)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct shrinker {
        pub count_objects: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut shrinker, sc: *mut shrink_control) -> ::cty::c_ulong,
        >,
        pub scan_objects: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut shrinker, sc: *mut shrink_control) -> ::cty::c_ulong,
        >,
        pub batch: ::cty::c_long,
        pub seeks: ::cty::c_int,
        pub flags: ::cty::c_uint,
        pub list: list_head,
        pub id: ::cty::c_int,
        pub nr_deferred: *mut atomic_long_t,
    }
    #[test]
    fn bindgen_test_layout_shrinker() {
        assert_eq!(
            ::core::mem::size_of::<shrinker>(),
            64usize,
            concat!("Size of: ", stringify!(shrinker))
        );
        assert_eq!(
            ::core::mem::align_of::<shrinker>(),
            8usize,
            concat!("Alignment of ", stringify!(shrinker))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<shrinker>())).count_objects as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(shrinker),
                "::",
                stringify!(count_objects)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<shrinker>())).scan_objects as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(shrinker),
                "::",
                stringify!(scan_objects)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<shrinker>())).batch as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(shrinker),
                "::",
                stringify!(batch)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<shrinker>())).seeks as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(shrinker),
                "::",
                stringify!(seeks)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<shrinker>())).flags as *const _ as usize },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(shrinker),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<shrinker>())).list as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(shrinker),
                "::",
                stringify!(list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<shrinker>())).id as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(shrinker),
                "::",
                stringify!(id)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<shrinker>())).nr_deferred as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(shrinker),
                "::",
                stringify!(nr_deferred)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct list_lru_one {
        pub list: list_head,
        pub nr_items: ::cty::c_long,
    }
    #[test]
    fn bindgen_test_layout_list_lru_one() {
        assert_eq!(
            ::core::mem::size_of::<list_lru_one>(),
            24usize,
            concat!("Size of: ", stringify!(list_lru_one))
        );
        assert_eq!(
            ::core::mem::align_of::<list_lru_one>(),
            8usize,
            concat!("Alignment of ", stringify!(list_lru_one))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<list_lru_one>())).list as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(list_lru_one),
                "::",
                stringify!(list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<list_lru_one>())).nr_items as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(list_lru_one),
                "::",
                stringify!(nr_items)
            )
        );
    }
    #[repr(C)]
    #[repr(align(64))]
    #[derive(Copy, Clone)]
    pub struct list_lru_node {
        pub lock: spinlock_t,
        pub lru: list_lru_one,
        pub nr_items: ::cty::c_long,
    }
    #[test]
    fn bindgen_test_layout_list_lru_node() {
        assert_eq!(
            ::core::mem::size_of::<list_lru_node>(),
            64usize,
            concat!("Size of: ", stringify!(list_lru_node))
        );
        assert_eq!(
            ::core::mem::align_of::<list_lru_node>(),
            64usize,
            concat!("Alignment of ", stringify!(list_lru_node))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<list_lru_node>())).lock as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(list_lru_node),
                "::",
                stringify!(lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<list_lru_node>())).lru as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(list_lru_node),
                "::",
                stringify!(lru)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<list_lru_node>())).nr_items as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(list_lru_node),
                "::",
                stringify!(nr_items)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct list_lru {
        pub node: *mut list_lru_node,
        pub list: list_head,
        pub shrinker_id: ::cty::c_int,
        pub memcg_aware: bool_,
        pub xa: xarray,
    }
    #[test]
    fn bindgen_test_layout_list_lru() {
        assert_eq!(
            ::core::mem::size_of::<list_lru>(),
            48usize,
            concat!("Size of: ", stringify!(list_lru))
        );
        assert_eq!(
            ::core::mem::align_of::<list_lru>(),
            8usize,
            concat!("Alignment of ", stringify!(list_lru))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<list_lru>())).node as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(list_lru),
                "::",
                stringify!(node)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<list_lru>())).list as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(list_lru),
                "::",
                stringify!(list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<list_lru>())).shrinker_id as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(list_lru),
                "::",
                stringify!(shrinker_id)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<list_lru>())).memcg_aware as *const _ as usize },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(list_lru),
                "::",
                stringify!(memcg_aware)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<list_lru>())).xa as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(list_lru),
                "::",
                stringify!(xa)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct kernel_cap_t {
        pub val: _cargo_bpf_u64,
    }
    #[test]
    fn bindgen_test_layout_kernel_cap_t() {
        assert_eq!(
            ::core::mem::size_of::<kernel_cap_t>(),
            8usize,
            concat!("Size of: ", stringify!(kernel_cap_t))
        );
        assert_eq!(
            ::core::mem::align_of::<kernel_cap_t>(),
            8usize,
            concat!("Alignment of ", stringify!(kernel_cap_t))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kernel_cap_t>())).val as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(kernel_cap_t),
                "::",
                stringify!(val)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct mnt_idmap {
        _unused: [u8; 0],
    }
    pub const migrate_mode_MIGRATE_ASYNC: migrate_mode = 0;
    pub const migrate_mode_MIGRATE_SYNC_LIGHT: migrate_mode = 1;
    pub const migrate_mode_MIGRATE_SYNC: migrate_mode = 2;
    pub const migrate_mode_MIGRATE_SYNC_NO_COPY: migrate_mode = 3;
    pub type migrate_mode = ::cty::c_uint;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct exception_table_entry {
        pub insn: ::cty::c_int,
        pub fixup: ::cty::c_int,
        pub data: ::cty::c_int,
    }
    #[test]
    fn bindgen_test_layout_exception_table_entry() {
        assert_eq!(
            ::core::mem::size_of::<exception_table_entry>(),
            12usize,
            concat!("Size of: ", stringify!(exception_table_entry))
        );
        assert_eq!(
            ::core::mem::align_of::<exception_table_entry>(),
            4usize,
            concat!("Alignment of ", stringify!(exception_table_entry))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<exception_table_entry>())).insn as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(exception_table_entry),
                "::",
                stringify!(insn)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<exception_table_entry>())).fixup as *const _ as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(exception_table_entry),
                "::",
                stringify!(fixup)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<exception_table_entry>())).data as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(exception_table_entry),
                "::",
                stringify!(data)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct assoc_array {
        pub root: *mut assoc_array_ptr,
        pub nr_leaves_on_tree: ::cty::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_assoc_array() {
        assert_eq!(
            ::core::mem::size_of::<assoc_array>(),
            16usize,
            concat!("Size of: ", stringify!(assoc_array))
        );
        assert_eq!(
            ::core::mem::align_of::<assoc_array>(),
            8usize,
            concat!("Alignment of ", stringify!(assoc_array))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<assoc_array>())).root as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(assoc_array),
                "::",
                stringify!(root)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<assoc_array>())).nr_leaves_on_tree as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(assoc_array),
                "::",
                stringify!(nr_leaves_on_tree)
            )
        );
    }
    pub type key_serial_t = i32;
    pub type key_perm_t = u32;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct key_type {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct key_tag {
        pub rcu: callback_head,
        pub usage: refcount_t,
        pub removed: bool_,
    }
    #[test]
    fn bindgen_test_layout_key_tag() {
        assert_eq!(
            ::core::mem::size_of::<key_tag>(),
            24usize,
            concat!("Size of: ", stringify!(key_tag))
        );
        assert_eq!(
            ::core::mem::align_of::<key_tag>(),
            8usize,
            concat!("Alignment of ", stringify!(key_tag))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<key_tag>())).rcu as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(key_tag),
                "::",
                stringify!(rcu)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<key_tag>())).usage as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(key_tag),
                "::",
                stringify!(usage)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<key_tag>())).removed as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(key_tag),
                "::",
                stringify!(removed)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct keyring_index_key {
        pub hash: ::cty::c_ulong,
        pub __bindgen_anon_1: keyring_index_key__bindgen_ty_1,
        pub type_: *mut key_type,
        pub domain_tag: *mut key_tag,
        pub description: *const ::cty::c_char,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union keyring_index_key__bindgen_ty_1 {
        pub __bindgen_anon_1: keyring_index_key__bindgen_ty_1__bindgen_ty_1,
        pub x: ::cty::c_ulong,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct keyring_index_key__bindgen_ty_1__bindgen_ty_1 {
        pub desc_len: _cargo_bpf_u16,
        pub desc: [::cty::c_char; 6usize],
    }
    #[test]
    fn bindgen_test_layout_keyring_index_key__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<keyring_index_key__bindgen_ty_1__bindgen_ty_1>(),
            8usize,
            concat!(
                "Size of: ",
                stringify!(keyring_index_key__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<keyring_index_key__bindgen_ty_1__bindgen_ty_1>(),
            2usize,
            concat!(
                "Alignment of ",
                stringify!(keyring_index_key__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<keyring_index_key__bindgen_ty_1__bindgen_ty_1>())).desc_len
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(keyring_index_key__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(desc_len)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<keyring_index_key__bindgen_ty_1__bindgen_ty_1>())).desc
                    as *const _ as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(keyring_index_key__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(desc)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_keyring_index_key__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<keyring_index_key__bindgen_ty_1>(),
            8usize,
            concat!("Size of: ", stringify!(keyring_index_key__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<keyring_index_key__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(keyring_index_key__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<keyring_index_key__bindgen_ty_1>())).x as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(keyring_index_key__bindgen_ty_1),
                "::",
                stringify!(x)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_keyring_index_key() {
        assert_eq!(
            ::core::mem::size_of::<keyring_index_key>(),
            40usize,
            concat!("Size of: ", stringify!(keyring_index_key))
        );
        assert_eq!(
            ::core::mem::align_of::<keyring_index_key>(),
            8usize,
            concat!("Alignment of ", stringify!(keyring_index_key))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<keyring_index_key>())).hash as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(keyring_index_key),
                "::",
                stringify!(hash)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<keyring_index_key>())).type_ as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(keyring_index_key),
                "::",
                stringify!(type_)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<keyring_index_key>())).domain_tag as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(keyring_index_key),
                "::",
                stringify!(domain_tag)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<keyring_index_key>())).description as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(keyring_index_key),
                "::",
                stringify!(description)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union key_payload {
        pub rcu_data0: *mut ::cty::c_void,
        pub data: [*mut ::cty::c_void; 4usize],
    }
    #[test]
    fn bindgen_test_layout_key_payload() {
        assert_eq!(
            ::core::mem::size_of::<key_payload>(),
            32usize,
            concat!("Size of: ", stringify!(key_payload))
        );
        assert_eq!(
            ::core::mem::align_of::<key_payload>(),
            8usize,
            concat!("Alignment of ", stringify!(key_payload))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<key_payload>())).rcu_data0 as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(key_payload),
                "::",
                stringify!(rcu_data0)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<key_payload>())).data as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(key_payload),
                "::",
                stringify!(data)
            )
        );
    }
    pub type key_restrict_link_func_t = ::core::option::Option<
        unsafe extern "C" fn(
            dest_keyring: *mut key,
            type_: *const key_type,
            payload: *const key_payload,
            restriction_key: *mut key,
        ) -> ::cty::c_int,
    >;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct key_restriction {
        pub check: key_restrict_link_func_t,
        pub key: *mut key,
        pub keytype: *mut key_type,
    }
    #[test]
    fn bindgen_test_layout_key_restriction() {
        assert_eq!(
            ::core::mem::size_of::<key_restriction>(),
            24usize,
            concat!("Size of: ", stringify!(key_restriction))
        );
        assert_eq!(
            ::core::mem::align_of::<key_restriction>(),
            8usize,
            concat!("Alignment of ", stringify!(key_restriction))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<key_restriction>())).check as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(key_restriction),
                "::",
                stringify!(check)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<key_restriction>())).key as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(key_restriction),
                "::",
                stringify!(key)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<key_restriction>())).keytype as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(key_restriction),
                "::",
                stringify!(keytype)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct key {
        pub usage: refcount_t,
        pub serial: key_serial_t,
        pub __bindgen_anon_1: key__bindgen_ty_1,
        pub watchers: *mut watch_list,
        pub sem: rw_semaphore,
        pub user: *mut key_user,
        pub security: *mut ::cty::c_void,
        pub __bindgen_anon_2: key__bindgen_ty_2,
        pub last_used_at: time64_t,
        pub uid: kuid_t,
        pub gid: kgid_t,
        pub perm: key_perm_t,
        pub quotalen: ::cty::c_ushort,
        pub datalen: ::cty::c_ushort,
        pub state: ::cty::c_short,
        pub flags: ::cty::c_ulong,
        pub __bindgen_anon_3: key__bindgen_ty_3,
        pub __bindgen_anon_4: key__bindgen_ty_4,
        pub restrict_link: *mut key_restriction,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union key__bindgen_ty_1 {
        pub graveyard_link: list_head,
        pub serial_node: rb_node,
    }
    #[test]
    fn bindgen_test_layout_key__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<key__bindgen_ty_1>(),
            24usize,
            concat!("Size of: ", stringify!(key__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<key__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(key__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<key__bindgen_ty_1>())).graveyard_link as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(key__bindgen_ty_1),
                "::",
                stringify!(graveyard_link)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<key__bindgen_ty_1>())).serial_node as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(key__bindgen_ty_1),
                "::",
                stringify!(serial_node)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union key__bindgen_ty_2 {
        pub expiry: time64_t,
        pub revoked_at: time64_t,
    }
    #[test]
    fn bindgen_test_layout_key__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<key__bindgen_ty_2>(),
            8usize,
            concat!("Size of: ", stringify!(key__bindgen_ty_2))
        );
        assert_eq!(
            ::core::mem::align_of::<key__bindgen_ty_2>(),
            8usize,
            concat!("Alignment of ", stringify!(key__bindgen_ty_2))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<key__bindgen_ty_2>())).expiry as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(key__bindgen_ty_2),
                "::",
                stringify!(expiry)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<key__bindgen_ty_2>())).revoked_at as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(key__bindgen_ty_2),
                "::",
                stringify!(revoked_at)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union key__bindgen_ty_3 {
        pub index_key: keyring_index_key,
        pub __bindgen_anon_1: key__bindgen_ty_3__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct key__bindgen_ty_3__bindgen_ty_1 {
        pub hash: ::cty::c_ulong,
        pub len_desc: ::cty::c_ulong,
        pub type_: *mut key_type,
        pub domain_tag: *mut key_tag,
        pub description: *mut ::cty::c_char,
    }
    #[test]
    fn bindgen_test_layout_key__bindgen_ty_3__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<key__bindgen_ty_3__bindgen_ty_1>(),
            40usize,
            concat!("Size of: ", stringify!(key__bindgen_ty_3__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<key__bindgen_ty_3__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(key__bindgen_ty_3__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<key__bindgen_ty_3__bindgen_ty_1>())).hash as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(key__bindgen_ty_3__bindgen_ty_1),
                "::",
                stringify!(hash)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<key__bindgen_ty_3__bindgen_ty_1>())).len_desc as *const _
                    as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(key__bindgen_ty_3__bindgen_ty_1),
                "::",
                stringify!(len_desc)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<key__bindgen_ty_3__bindgen_ty_1>())).type_ as *const _
                    as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(key__bindgen_ty_3__bindgen_ty_1),
                "::",
                stringify!(type_)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<key__bindgen_ty_3__bindgen_ty_1>())).domain_tag as *const _
                    as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(key__bindgen_ty_3__bindgen_ty_1),
                "::",
                stringify!(domain_tag)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<key__bindgen_ty_3__bindgen_ty_1>())).description as *const _
                    as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(key__bindgen_ty_3__bindgen_ty_1),
                "::",
                stringify!(description)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_key__bindgen_ty_3() {
        assert_eq!(
            ::core::mem::size_of::<key__bindgen_ty_3>(),
            40usize,
            concat!("Size of: ", stringify!(key__bindgen_ty_3))
        );
        assert_eq!(
            ::core::mem::align_of::<key__bindgen_ty_3>(),
            8usize,
            concat!("Alignment of ", stringify!(key__bindgen_ty_3))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<key__bindgen_ty_3>())).index_key as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(key__bindgen_ty_3),
                "::",
                stringify!(index_key)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union key__bindgen_ty_4 {
        pub payload: key_payload,
        pub __bindgen_anon_1: key__bindgen_ty_4__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct key__bindgen_ty_4__bindgen_ty_1 {
        pub name_link: list_head,
        pub keys: assoc_array,
    }
    #[test]
    fn bindgen_test_layout_key__bindgen_ty_4__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<key__bindgen_ty_4__bindgen_ty_1>(),
            32usize,
            concat!("Size of: ", stringify!(key__bindgen_ty_4__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<key__bindgen_ty_4__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(key__bindgen_ty_4__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<key__bindgen_ty_4__bindgen_ty_1>())).name_link as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(key__bindgen_ty_4__bindgen_ty_1),
                "::",
                stringify!(name_link)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<key__bindgen_ty_4__bindgen_ty_1>())).keys as *const _
                    as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(key__bindgen_ty_4__bindgen_ty_1),
                "::",
                stringify!(keys)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_key__bindgen_ty_4() {
        assert_eq!(
            ::core::mem::size_of::<key__bindgen_ty_4>(),
            32usize,
            concat!("Size of: ", stringify!(key__bindgen_ty_4))
        );
        assert_eq!(
            ::core::mem::align_of::<key__bindgen_ty_4>(),
            8usize,
            concat!("Alignment of ", stringify!(key__bindgen_ty_4))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<key__bindgen_ty_4>())).payload as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(key__bindgen_ty_4),
                "::",
                stringify!(payload)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_key() {
        assert_eq!(
            ::core::mem::size_of::<key>(),
            224usize,
            concat!("Size of: ", stringify!(key))
        );
        assert_eq!(
            ::core::mem::align_of::<key>(),
            8usize,
            concat!("Alignment of ", stringify!(key))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<key>())).usage as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(key),
                "::",
                stringify!(usage)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<key>())).serial as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(key),
                "::",
                stringify!(serial)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<key>())).watchers as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(key),
                "::",
                stringify!(watchers)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<key>())).sem as *const _ as usize },
            40usize,
            concat!("Offset of field: ", stringify!(key), "::", stringify!(sem))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<key>())).user as *const _ as usize },
            80usize,
            concat!("Offset of field: ", stringify!(key), "::", stringify!(user))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<key>())).security as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(key),
                "::",
                stringify!(security)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<key>())).last_used_at as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(key),
                "::",
                stringify!(last_used_at)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<key>())).uid as *const _ as usize },
            112usize,
            concat!("Offset of field: ", stringify!(key), "::", stringify!(uid))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<key>())).gid as *const _ as usize },
            116usize,
            concat!("Offset of field: ", stringify!(key), "::", stringify!(gid))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<key>())).perm as *const _ as usize },
            120usize,
            concat!("Offset of field: ", stringify!(key), "::", stringify!(perm))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<key>())).quotalen as *const _ as usize },
            124usize,
            concat!(
                "Offset of field: ",
                stringify!(key),
                "::",
                stringify!(quotalen)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<key>())).datalen as *const _ as usize },
            126usize,
            concat!(
                "Offset of field: ",
                stringify!(key),
                "::",
                stringify!(datalen)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<key>())).state as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(key),
                "::",
                stringify!(state)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<key>())).flags as *const _ as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(key),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<key>())).restrict_link as *const _ as usize },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(key),
                "::",
                stringify!(restrict_link)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct user_struct {
        pub __count: refcount_t,
        pub epoll_watches: percpu_counter,
        pub unix_inflight: ::cty::c_ulong,
        pub pipe_bufs: atomic_long_t,
        pub uidhash_node: hlist_node,
        pub uid: kuid_t,
        pub locked_vm: atomic_long_t,
        pub nr_watches: atomic_t,
        pub ratelimit: ratelimit_state,
    }
    #[test]
    fn bindgen_test_layout_user_struct() {
        assert_eq!(
            ::core::mem::size_of::<user_struct>(),
            144usize,
            concat!("Size of: ", stringify!(user_struct))
        );
        assert_eq!(
            ::core::mem::align_of::<user_struct>(),
            8usize,
            concat!("Alignment of ", stringify!(user_struct))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<user_struct>())).__count as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(user_struct),
                "::",
                stringify!(__count)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<user_struct>())).epoll_watches as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(user_struct),
                "::",
                stringify!(epoll_watches)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<user_struct>())).unix_inflight as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(user_struct),
                "::",
                stringify!(unix_inflight)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<user_struct>())).pipe_bufs as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(user_struct),
                "::",
                stringify!(pipe_bufs)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<user_struct>())).uidhash_node as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(user_struct),
                "::",
                stringify!(uidhash_node)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<user_struct>())).uid as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(user_struct),
                "::",
                stringify!(uid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<user_struct>())).locked_vm as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(user_struct),
                "::",
                stringify!(locked_vm)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<user_struct>())).nr_watches as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(user_struct),
                "::",
                stringify!(nr_watches)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<user_struct>())).ratelimit as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(user_struct),
                "::",
                stringify!(ratelimit)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct group_info {
        pub usage: atomic_t,
        pub ngroups: ::cty::c_int,
        pub gid: __IncompleteArrayField<kgid_t>,
    }
    #[test]
    fn bindgen_test_layout_group_info() {
        assert_eq!(
            ::core::mem::size_of::<group_info>(),
            8usize,
            concat!("Size of: ", stringify!(group_info))
        );
        assert_eq!(
            ::core::mem::align_of::<group_info>(),
            4usize,
            concat!("Alignment of ", stringify!(group_info))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<group_info>())).usage as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(group_info),
                "::",
                stringify!(usage)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<group_info>())).ngroups as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(group_info),
                "::",
                stringify!(ngroups)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<group_info>())).gid as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(group_info),
                "::",
                stringify!(gid)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct cred {
        pub usage: atomic_t,
        pub uid: kuid_t,
        pub gid: kgid_t,
        pub suid: kuid_t,
        pub sgid: kgid_t,
        pub euid: kuid_t,
        pub egid: kgid_t,
        pub fsuid: kuid_t,
        pub fsgid: kgid_t,
        pub securebits: ::cty::c_uint,
        pub cap_inheritable: kernel_cap_t,
        pub cap_permitted: kernel_cap_t,
        pub cap_effective: kernel_cap_t,
        pub cap_bset: kernel_cap_t,
        pub cap_ambient: kernel_cap_t,
        pub jit_keyring: ::cty::c_uchar,
        pub session_keyring: *mut key,
        pub process_keyring: *mut key,
        pub thread_keyring: *mut key,
        pub request_key_auth: *mut key,
        pub security: *mut ::cty::c_void,
        pub user: *mut user_struct,
        pub user_ns: *mut user_namespace,
        pub ucounts: *mut ucounts,
        pub group_info: *mut group_info,
        pub __bindgen_anon_1: cred__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union cred__bindgen_ty_1 {
        pub non_rcu: ::cty::c_int,
        pub rcu: callback_head,
    }
    #[test]
    fn bindgen_test_layout_cred__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<cred__bindgen_ty_1>(),
            16usize,
            concat!("Size of: ", stringify!(cred__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<cred__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(cred__bindgen_ty_1))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cred__bindgen_ty_1>())).non_rcu as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cred__bindgen_ty_1),
                "::",
                stringify!(non_rcu)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cred__bindgen_ty_1>())).rcu as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cred__bindgen_ty_1),
                "::",
                stringify!(rcu)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_cred() {
        assert_eq!(
            ::core::mem::size_of::<cred>(),
            176usize,
            concat!("Size of: ", stringify!(cred))
        );
        assert_eq!(
            ::core::mem::align_of::<cred>(),
            8usize,
            concat!("Alignment of ", stringify!(cred))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cred>())).usage as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cred),
                "::",
                stringify!(usage)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cred>())).uid as *const _ as usize },
            4usize,
            concat!("Offset of field: ", stringify!(cred), "::", stringify!(uid))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cred>())).gid as *const _ as usize },
            8usize,
            concat!("Offset of field: ", stringify!(cred), "::", stringify!(gid))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cred>())).suid as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(cred),
                "::",
                stringify!(suid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cred>())).sgid as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cred),
                "::",
                stringify!(sgid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cred>())).euid as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(cred),
                "::",
                stringify!(euid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cred>())).egid as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(cred),
                "::",
                stringify!(egid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cred>())).fsuid as *const _ as usize },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(cred),
                "::",
                stringify!(fsuid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cred>())).fsgid as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(cred),
                "::",
                stringify!(fsgid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cred>())).securebits as *const _ as usize },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(cred),
                "::",
                stringify!(securebits)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cred>())).cap_inheritable as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(cred),
                "::",
                stringify!(cap_inheritable)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cred>())).cap_permitted as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(cred),
                "::",
                stringify!(cap_permitted)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cred>())).cap_effective as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(cred),
                "::",
                stringify!(cap_effective)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cred>())).cap_bset as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(cred),
                "::",
                stringify!(cap_bset)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cred>())).cap_ambient as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(cred),
                "::",
                stringify!(cap_ambient)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cred>())).jit_keyring as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(cred),
                "::",
                stringify!(jit_keyring)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cred>())).session_keyring as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(cred),
                "::",
                stringify!(session_keyring)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cred>())).process_keyring as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(cred),
                "::",
                stringify!(process_keyring)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cred>())).thread_keyring as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(cred),
                "::",
                stringify!(thread_keyring)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cred>())).request_key_auth as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(cred),
                "::",
                stringify!(request_key_auth)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cred>())).security as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(cred),
                "::",
                stringify!(security)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cred>())).user as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(cred),
                "::",
                stringify!(user)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cred>())).user_ns as *const _ as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(cred),
                "::",
                stringify!(user_ns)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cred>())).ucounts as *const _ as usize },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(cred),
                "::",
                stringify!(ucounts)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cred>())).group_info as *const _ as usize },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(cred),
                "::",
                stringify!(group_info)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct sighand_struct {
        pub siglock: spinlock_t,
        pub count: refcount_t,
        pub signalfd_wqh: wait_queue_head_t,
        pub action: [k_sigaction; 64usize],
    }
    #[test]
    fn bindgen_test_layout_sighand_struct() {
        assert_eq!(
            ::core::mem::size_of::<sighand_struct>(),
            2080usize,
            concat!("Size of: ", stringify!(sighand_struct))
        );
        assert_eq!(
            ::core::mem::align_of::<sighand_struct>(),
            8usize,
            concat!("Alignment of ", stringify!(sighand_struct))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sighand_struct>())).siglock as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sighand_struct),
                "::",
                stringify!(siglock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sighand_struct>())).count as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(sighand_struct),
                "::",
                stringify!(count)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sighand_struct>())).signalfd_wqh as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sighand_struct),
                "::",
                stringify!(signalfd_wqh)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sighand_struct>())).action as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(sighand_struct),
                "::",
                stringify!(action)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct pacct_struct {
        pub ac_flag: ::cty::c_int,
        pub ac_exitcode: ::cty::c_long,
        pub ac_mem: ::cty::c_ulong,
        pub ac_utime: _cargo_bpf_u64,
        pub ac_stime: _cargo_bpf_u64,
        pub ac_minflt: ::cty::c_ulong,
        pub ac_majflt: ::cty::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_pacct_struct() {
        assert_eq!(
            ::core::mem::size_of::<pacct_struct>(),
            56usize,
            concat!("Size of: ", stringify!(pacct_struct))
        );
        assert_eq!(
            ::core::mem::align_of::<pacct_struct>(),
            8usize,
            concat!("Alignment of ", stringify!(pacct_struct))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pacct_struct>())).ac_flag as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pacct_struct),
                "::",
                stringify!(ac_flag)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pacct_struct>())).ac_exitcode as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(pacct_struct),
                "::",
                stringify!(ac_exitcode)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pacct_struct>())).ac_mem as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(pacct_struct),
                "::",
                stringify!(ac_mem)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pacct_struct>())).ac_utime as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(pacct_struct),
                "::",
                stringify!(ac_utime)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pacct_struct>())).ac_stime as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(pacct_struct),
                "::",
                stringify!(ac_stime)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pacct_struct>())).ac_minflt as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(pacct_struct),
                "::",
                stringify!(ac_minflt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pacct_struct>())).ac_majflt as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(pacct_struct),
                "::",
                stringify!(ac_majflt)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cpu_itimer {
        pub expires: _cargo_bpf_u64,
        pub incr: _cargo_bpf_u64,
    }
    #[test]
    fn bindgen_test_layout_cpu_itimer() {
        assert_eq!(
            ::core::mem::size_of::<cpu_itimer>(),
            16usize,
            concat!("Size of: ", stringify!(cpu_itimer))
        );
        assert_eq!(
            ::core::mem::align_of::<cpu_itimer>(),
            8usize,
            concat!("Alignment of ", stringify!(cpu_itimer))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cpu_itimer>())).expires as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cpu_itimer),
                "::",
                stringify!(expires)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cpu_itimer>())).incr as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cpu_itimer),
                "::",
                stringify!(incr)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct task_cputime_atomic {
        pub utime: atomic64_t,
        pub stime: atomic64_t,
        pub sum_exec_runtime: atomic64_t,
    }
    #[test]
    fn bindgen_test_layout_task_cputime_atomic() {
        assert_eq!(
            ::core::mem::size_of::<task_cputime_atomic>(),
            24usize,
            concat!("Size of: ", stringify!(task_cputime_atomic))
        );
        assert_eq!(
            ::core::mem::align_of::<task_cputime_atomic>(),
            8usize,
            concat!("Alignment of ", stringify!(task_cputime_atomic))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_cputime_atomic>())).utime as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(task_cputime_atomic),
                "::",
                stringify!(utime)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<task_cputime_atomic>())).stime as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(task_cputime_atomic),
                "::",
                stringify!(stime)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<task_cputime_atomic>())).sum_exec_runtime as *const _
                    as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(task_cputime_atomic),
                "::",
                stringify!(sum_exec_runtime)
            )
        );
    }
    #[doc = " struct thread_group_cputimer - thread group interval timer counts"]
    #[doc = " @cputime_atomic:\tatomic thread group interval timers."]
    #[doc = ""]
    #[doc = " This structure contains the version of task_cputime, above, that is"]
    #[doc = " used for thread group CPU timer calculations."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct thread_group_cputimer {
        pub cputime_atomic: task_cputime_atomic,
    }
    #[test]
    fn bindgen_test_layout_thread_group_cputimer() {
        assert_eq!(
            ::core::mem::size_of::<thread_group_cputimer>(),
            24usize,
            concat!("Size of: ", stringify!(thread_group_cputimer))
        );
        assert_eq!(
            ::core::mem::align_of::<thread_group_cputimer>(),
            8usize,
            concat!("Alignment of ", stringify!(thread_group_cputimer))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<thread_group_cputimer>())).cputime_atomic as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(thread_group_cputimer),
                "::",
                stringify!(cputime_atomic)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct core_thread {
        pub task: *mut task_struct,
        pub next: *mut core_thread,
    }
    #[test]
    fn bindgen_test_layout_core_thread() {
        assert_eq!(
            ::core::mem::size_of::<core_thread>(),
            16usize,
            concat!("Size of: ", stringify!(core_thread))
        );
        assert_eq!(
            ::core::mem::align_of::<core_thread>(),
            8usize,
            concat!("Alignment of ", stringify!(core_thread))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<core_thread>())).task as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(core_thread),
                "::",
                stringify!(task)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<core_thread>())).next as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(core_thread),
                "::",
                stringify!(next)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct core_state {
        pub nr_threads: atomic_t,
        pub dumper: core_thread,
        pub startup: completion,
    }
    #[test]
    fn bindgen_test_layout_core_state() {
        assert_eq!(
            ::core::mem::size_of::<core_state>(),
            56usize,
            concat!("Size of: ", stringify!(core_state))
        );
        assert_eq!(
            ::core::mem::align_of::<core_state>(),
            8usize,
            concat!("Alignment of ", stringify!(core_state))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<core_state>())).nr_threads as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(core_state),
                "::",
                stringify!(nr_threads)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<core_state>())).dumper as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(core_state),
                "::",
                stringify!(dumper)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<core_state>())).startup as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(core_state),
                "::",
                stringify!(startup)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct signal_struct {
        pub sigcnt: refcount_t,
        pub live: atomic_t,
        pub nr_threads: ::cty::c_int,
        pub quick_threads: ::cty::c_int,
        pub thread_head: list_head,
        pub wait_chldexit: wait_queue_head_t,
        pub curr_target: *mut task_struct,
        pub shared_pending: sigpending,
        pub multiprocess: hlist_head,
        pub group_exit_code: ::cty::c_int,
        pub notify_count: ::cty::c_int,
        pub group_exec_task: *mut task_struct,
        pub group_stop_count: ::cty::c_int,
        pub flags: ::cty::c_uint,
        pub core_state: *mut core_state,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
        pub next_posix_timer_id: ::cty::c_uint,
        pub posix_timers: list_head,
        pub real_timer: hrtimer,
        pub it_real_incr: ktime_t,
        pub it: [cpu_itimer; 2usize],
        pub cputimer: thread_group_cputimer,
        pub posix_cputimers: posix_cputimers,
        pub pids: [*mut pid; 4usize],
        pub tty_old_pgrp: *mut pid,
        pub leader: ::cty::c_int,
        pub tty: *mut tty_struct,
        pub autogroup: *mut autogroup,
        pub stats_lock: seqlock_t,
        pub utime: _cargo_bpf_u64,
        pub stime: _cargo_bpf_u64,
        pub cutime: _cargo_bpf_u64,
        pub cstime: _cargo_bpf_u64,
        pub gtime: _cargo_bpf_u64,
        pub cgtime: _cargo_bpf_u64,
        pub prev_cputime: prev_cputime,
        pub nvcsw: ::cty::c_ulong,
        pub nivcsw: ::cty::c_ulong,
        pub cnvcsw: ::cty::c_ulong,
        pub cnivcsw: ::cty::c_ulong,
        pub min_flt: ::cty::c_ulong,
        pub maj_flt: ::cty::c_ulong,
        pub cmin_flt: ::cty::c_ulong,
        pub cmaj_flt: ::cty::c_ulong,
        pub inblock: ::cty::c_ulong,
        pub oublock: ::cty::c_ulong,
        pub cinblock: ::cty::c_ulong,
        pub coublock: ::cty::c_ulong,
        pub maxrss: ::cty::c_ulong,
        pub cmaxrss: ::cty::c_ulong,
        pub ioac: task_io_accounting,
        pub sum_sched_runtime: ::cty::c_ulonglong,
        pub rlim: [rlimit; 16usize],
        pub pacct: pacct_struct,
        pub stats: *mut taskstats,
        pub audit_tty: ::cty::c_uint,
        pub tty_audit_buf: *mut tty_audit_buf,
        pub oom_flag_origin: bool_,
        pub oom_score_adj: ::cty::c_short,
        pub oom_score_adj_min: ::cty::c_short,
        pub oom_mm: *mut mm_struct,
        pub cred_guard_mutex: mutex,
        pub exec_update_lock: rw_semaphore,
    }
    #[test]
    fn bindgen_test_layout_signal_struct() {
        assert_eq!(
            ::core::mem::size_of::<signal_struct>(),
            1104usize,
            concat!("Size of: ", stringify!(signal_struct))
        );
        assert_eq!(
            ::core::mem::align_of::<signal_struct>(),
            8usize,
            concat!("Alignment of ", stringify!(signal_struct))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<signal_struct>())).sigcnt as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(sigcnt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<signal_struct>())).live as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(live)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<signal_struct>())).nr_threads as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(nr_threads)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<signal_struct>())).quick_threads as *const _ as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(quick_threads)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<signal_struct>())).thread_head as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(thread_head)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<signal_struct>())).wait_chldexit as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(wait_chldexit)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<signal_struct>())).curr_target as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(curr_target)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<signal_struct>())).shared_pending as *const _ as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(shared_pending)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<signal_struct>())).multiprocess as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(multiprocess)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<signal_struct>())).group_exit_code as *const _ as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(group_exit_code)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<signal_struct>())).notify_count as *const _ as usize },
            100usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(notify_count)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<signal_struct>())).group_exec_task as *const _ as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(group_exec_task)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<signal_struct>())).group_stop_count as *const _ as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(group_stop_count)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<signal_struct>())).flags as *const _ as usize },
            116usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<signal_struct>())).core_state as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(core_state)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<signal_struct>())).next_posix_timer_id as *const _ as usize
            },
            132usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(next_posix_timer_id)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<signal_struct>())).posix_timers as *const _ as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(posix_timers)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<signal_struct>())).real_timer as *const _ as usize },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(real_timer)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<signal_struct>())).it_real_incr as *const _ as usize },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(it_real_incr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<signal_struct>())).it as *const _ as usize },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(it)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<signal_struct>())).cputimer as *const _ as usize },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(cputimer)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<signal_struct>())).posix_cputimers as *const _ as usize
            },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(posix_cputimers)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<signal_struct>())).pids as *const _ as usize },
            360usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(pids)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<signal_struct>())).tty_old_pgrp as *const _ as usize },
            392usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(tty_old_pgrp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<signal_struct>())).leader as *const _ as usize },
            400usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(leader)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<signal_struct>())).tty as *const _ as usize },
            408usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(tty)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<signal_struct>())).autogroup as *const _ as usize },
            416usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(autogroup)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<signal_struct>())).stats_lock as *const _ as usize },
            424usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(stats_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<signal_struct>())).utime as *const _ as usize },
            432usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(utime)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<signal_struct>())).stime as *const _ as usize },
            440usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(stime)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<signal_struct>())).cutime as *const _ as usize },
            448usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(cutime)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<signal_struct>())).cstime as *const _ as usize },
            456usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(cstime)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<signal_struct>())).gtime as *const _ as usize },
            464usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(gtime)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<signal_struct>())).cgtime as *const _ as usize },
            472usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(cgtime)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<signal_struct>())).prev_cputime as *const _ as usize },
            480usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(prev_cputime)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<signal_struct>())).nvcsw as *const _ as usize },
            504usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(nvcsw)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<signal_struct>())).nivcsw as *const _ as usize },
            512usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(nivcsw)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<signal_struct>())).cnvcsw as *const _ as usize },
            520usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(cnvcsw)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<signal_struct>())).cnivcsw as *const _ as usize },
            528usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(cnivcsw)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<signal_struct>())).min_flt as *const _ as usize },
            536usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(min_flt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<signal_struct>())).maj_flt as *const _ as usize },
            544usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(maj_flt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<signal_struct>())).cmin_flt as *const _ as usize },
            552usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(cmin_flt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<signal_struct>())).cmaj_flt as *const _ as usize },
            560usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(cmaj_flt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<signal_struct>())).inblock as *const _ as usize },
            568usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(inblock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<signal_struct>())).oublock as *const _ as usize },
            576usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(oublock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<signal_struct>())).cinblock as *const _ as usize },
            584usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(cinblock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<signal_struct>())).coublock as *const _ as usize },
            592usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(coublock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<signal_struct>())).maxrss as *const _ as usize },
            600usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(maxrss)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<signal_struct>())).cmaxrss as *const _ as usize },
            608usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(cmaxrss)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<signal_struct>())).ioac as *const _ as usize },
            616usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(ioac)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<signal_struct>())).sum_sched_runtime as *const _ as usize
            },
            672usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(sum_sched_runtime)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<signal_struct>())).rlim as *const _ as usize },
            680usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(rlim)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<signal_struct>())).pacct as *const _ as usize },
            936usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(pacct)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<signal_struct>())).stats as *const _ as usize },
            992usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(stats)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<signal_struct>())).audit_tty as *const _ as usize },
            1000usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(audit_tty)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<signal_struct>())).tty_audit_buf as *const _ as usize
            },
            1008usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(tty_audit_buf)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<signal_struct>())).oom_flag_origin as *const _ as usize
            },
            1016usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(oom_flag_origin)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<signal_struct>())).oom_score_adj as *const _ as usize
            },
            1018usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(oom_score_adj)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<signal_struct>())).oom_score_adj_min as *const _ as usize
            },
            1020usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(oom_score_adj_min)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<signal_struct>())).oom_mm as *const _ as usize },
            1024usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(oom_mm)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<signal_struct>())).cred_guard_mutex as *const _ as usize
            },
            1032usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(cred_guard_mutex)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<signal_struct>())).exec_update_lock as *const _ as usize
            },
            1064usize,
            concat!(
                "Offset of field: ",
                stringify!(signal_struct),
                "::",
                stringify!(exec_update_lock)
            )
        );
    }
    impl signal_struct {
        #[inline]
        pub fn is_child_subreaper(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_is_child_subreaper(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn has_child_subreaper(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_has_child_subreaper(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(1usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            is_child_subreaper: ::cty::c_uint,
            has_child_subreaper: ::cty::c_uint,
        ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 1u8, {
                let is_child_subreaper: u32 = unsafe { ::core::mem::transmute(is_child_subreaper) };
                is_child_subreaper as u64
            });
            __bindgen_bitfield_unit.set(1usize, 1u8, {
                let has_child_subreaper: u32 =
                    unsafe { ::core::mem::transmute(has_child_subreaper) };
                has_child_subreaper as u64
            });
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct rcuwait {
        pub task: *mut task_struct,
    }
    #[test]
    fn bindgen_test_layout_rcuwait() {
        assert_eq!(
            ::core::mem::size_of::<rcuwait>(),
            8usize,
            concat!("Size of: ", stringify!(rcuwait))
        );
        assert_eq!(
            ::core::mem::align_of::<rcuwait>(),
            8usize,
            concat!("Alignment of ", stringify!(rcuwait))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rcuwait>())).task as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcuwait),
                "::",
                stringify!(task)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct rcu_sync {
        pub gp_state: ::cty::c_int,
        pub gp_count: ::cty::c_int,
        pub gp_wait: wait_queue_head_t,
        pub cb_head: callback_head,
    }
    #[test]
    fn bindgen_test_layout_rcu_sync() {
        assert_eq!(
            ::core::mem::size_of::<rcu_sync>(),
            48usize,
            concat!("Size of: ", stringify!(rcu_sync))
        );
        assert_eq!(
            ::core::mem::align_of::<rcu_sync>(),
            8usize,
            concat!("Alignment of ", stringify!(rcu_sync))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rcu_sync>())).gp_state as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rcu_sync),
                "::",
                stringify!(gp_state)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rcu_sync>())).gp_count as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(rcu_sync),
                "::",
                stringify!(gp_count)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rcu_sync>())).gp_wait as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rcu_sync),
                "::",
                stringify!(gp_wait)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rcu_sync>())).cb_head as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(rcu_sync),
                "::",
                stringify!(cb_head)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct percpu_rw_semaphore {
        pub rss: rcu_sync,
        pub read_count: *mut ::cty::c_uint,
        pub writer: rcuwait,
        pub waiters: wait_queue_head_t,
        pub block: atomic_t,
    }
    #[test]
    fn bindgen_test_layout_percpu_rw_semaphore() {
        assert_eq!(
            ::core::mem::size_of::<percpu_rw_semaphore>(),
            96usize,
            concat!("Size of: ", stringify!(percpu_rw_semaphore))
        );
        assert_eq!(
            ::core::mem::align_of::<percpu_rw_semaphore>(),
            8usize,
            concat!("Alignment of ", stringify!(percpu_rw_semaphore))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<percpu_rw_semaphore>())).rss as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(percpu_rw_semaphore),
                "::",
                stringify!(rss)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<percpu_rw_semaphore>())).read_count as *const _ as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(percpu_rw_semaphore),
                "::",
                stringify!(read_count)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<percpu_rw_semaphore>())).writer as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(percpu_rw_semaphore),
                "::",
                stringify!(writer)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<percpu_rw_semaphore>())).waiters as *const _ as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(percpu_rw_semaphore),
                "::",
                stringify!(waiters)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<percpu_rw_semaphore>())).block as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(percpu_rw_semaphore),
                "::",
                stringify!(block)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct delayed_call {
        pub fn_: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::cty::c_void)>,
        pub arg: *mut ::cty::c_void,
    }
    #[test]
    fn bindgen_test_layout_delayed_call() {
        assert_eq!(
            ::core::mem::size_of::<delayed_call>(),
            16usize,
            concat!("Size of: ", stringify!(delayed_call))
        );
        assert_eq!(
            ::core::mem::align_of::<delayed_call>(),
            8usize,
            concat!("Alignment of ", stringify!(delayed_call))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<delayed_call>())).fn_ as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(delayed_call),
                "::",
                stringify!(fn_)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<delayed_call>())).arg as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(delayed_call),
                "::",
                stringify!(arg)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct uuid_t {
        pub b: [__u8; 16usize],
    }
    #[test]
    fn bindgen_test_layout_uuid_t() {
        assert_eq!(
            ::core::mem::size_of::<uuid_t>(),
            16usize,
            concat!("Size of: ", stringify!(uuid_t))
        );
        assert_eq!(
            ::core::mem::align_of::<uuid_t>(),
            1usize,
            concat!("Alignment of ", stringify!(uuid_t))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<uuid_t>())).b as *const _ as usize },
            0usize,
            concat!("Offset of field: ", stringify!(uuid_t), "::", stringify!(b))
        );
    }
    pub type errseq_t = _cargo_bpf_u32;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct io_cq {
        pub q: *mut request_queue,
        pub ioc: *mut io_context,
        pub __bindgen_anon_1: io_cq__bindgen_ty_1,
        pub __bindgen_anon_2: io_cq__bindgen_ty_2,
        pub flags: ::cty::c_uint,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union io_cq__bindgen_ty_1 {
        pub q_node: list_head,
        pub __rcu_icq_cache: *mut kmem_cache,
    }
    #[test]
    fn bindgen_test_layout_io_cq__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<io_cq__bindgen_ty_1>(),
            16usize,
            concat!("Size of: ", stringify!(io_cq__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<io_cq__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(io_cq__bindgen_ty_1))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<io_cq__bindgen_ty_1>())).q_node as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(io_cq__bindgen_ty_1),
                "::",
                stringify!(q_node)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<io_cq__bindgen_ty_1>())).__rcu_icq_cache as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(io_cq__bindgen_ty_1),
                "::",
                stringify!(__rcu_icq_cache)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union io_cq__bindgen_ty_2 {
        pub ioc_node: hlist_node,
        pub __rcu_head: callback_head,
    }
    #[test]
    fn bindgen_test_layout_io_cq__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<io_cq__bindgen_ty_2>(),
            16usize,
            concat!("Size of: ", stringify!(io_cq__bindgen_ty_2))
        );
        assert_eq!(
            ::core::mem::align_of::<io_cq__bindgen_ty_2>(),
            8usize,
            concat!("Alignment of ", stringify!(io_cq__bindgen_ty_2))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<io_cq__bindgen_ty_2>())).ioc_node as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(io_cq__bindgen_ty_2),
                "::",
                stringify!(ioc_node)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<io_cq__bindgen_ty_2>())).__rcu_head as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(io_cq__bindgen_ty_2),
                "::",
                stringify!(__rcu_head)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_io_cq() {
        assert_eq!(
            ::core::mem::size_of::<io_cq>(),
            56usize,
            concat!("Size of: ", stringify!(io_cq))
        );
        assert_eq!(
            ::core::mem::align_of::<io_cq>(),
            8usize,
            concat!("Alignment of ", stringify!(io_cq))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<io_cq>())).q as *const _ as usize },
            0usize,
            concat!("Offset of field: ", stringify!(io_cq), "::", stringify!(q))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<io_cq>())).ioc as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(io_cq),
                "::",
                stringify!(ioc)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<io_cq>())).flags as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(io_cq),
                "::",
                stringify!(flags)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct io_context {
        pub refcount: atomic_long_t,
        pub active_ref: atomic_t,
        pub ioprio: ::cty::c_ushort,
        pub lock: spinlock_t,
        pub icq_tree: xarray,
        pub icq_hint: *mut io_cq,
        pub icq_list: hlist_head,
        pub release_work: work_struct,
    }
    #[test]
    fn bindgen_test_layout_io_context() {
        assert_eq!(
            ::core::mem::size_of::<io_context>(),
            88usize,
            concat!("Size of: ", stringify!(io_context))
        );
        assert_eq!(
            ::core::mem::align_of::<io_context>(),
            8usize,
            concat!("Alignment of ", stringify!(io_context))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<io_context>())).refcount as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(io_context),
                "::",
                stringify!(refcount)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<io_context>())).active_ref as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(io_context),
                "::",
                stringify!(active_ref)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<io_context>())).ioprio as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(io_context),
                "::",
                stringify!(ioprio)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<io_context>())).lock as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(io_context),
                "::",
                stringify!(lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<io_context>())).icq_tree as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(io_context),
                "::",
                stringify!(icq_tree)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<io_context>())).icq_hint as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(io_context),
                "::",
                stringify!(icq_hint)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<io_context>())).icq_list as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(io_context),
                "::",
                stringify!(icq_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<io_context>())).release_work as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(io_context),
                "::",
                stringify!(release_work)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct fs_context {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct vfsmount {
        pub mnt_root: *mut dentry,
        pub mnt_sb: *mut super_block,
        pub mnt_flags: ::cty::c_int,
        pub mnt_idmap: *mut mnt_idmap,
    }
    #[test]
    fn bindgen_test_layout_vfsmount() {
        assert_eq!(
            ::core::mem::size_of::<vfsmount>(),
            32usize,
            concat!("Size of: ", stringify!(vfsmount))
        );
        assert_eq!(
            ::core::mem::align_of::<vfsmount>(),
            8usize,
            concat!("Alignment of ", stringify!(vfsmount))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vfsmount>())).mnt_root as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(vfsmount),
                "::",
                stringify!(mnt_root)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vfsmount>())).mnt_sb as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(vfsmount),
                "::",
                stringify!(mnt_sb)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vfsmount>())).mnt_flags as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(vfsmount),
                "::",
                stringify!(mnt_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vfsmount>())).mnt_idmap as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(vfsmount),
                "::",
                stringify!(mnt_idmap)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct vfsuid_t {
        pub val: uid_t,
    }
    #[test]
    fn bindgen_test_layout_vfsuid_t() {
        assert_eq!(
            ::core::mem::size_of::<vfsuid_t>(),
            4usize,
            concat!("Size of: ", stringify!(vfsuid_t))
        );
        assert_eq!(
            ::core::mem::align_of::<vfsuid_t>(),
            4usize,
            concat!("Alignment of ", stringify!(vfsuid_t))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vfsuid_t>())).val as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(vfsuid_t),
                "::",
                stringify!(val)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct vfsgid_t {
        pub val: gid_t,
    }
    #[test]
    fn bindgen_test_layout_vfsgid_t() {
        assert_eq!(
            ::core::mem::size_of::<vfsgid_t>(),
            4usize,
            concat!("Size of: ", stringify!(vfsgid_t))
        );
        assert_eq!(
            ::core::mem::align_of::<vfsgid_t>(),
            4usize,
            concat!("Alignment of ", stringify!(vfsgid_t))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vfsgid_t>())).val as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(vfsgid_t),
                "::",
                stringify!(val)
            )
        );
    }
    pub type percpu_ref_func_t =
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut percpu_ref)>;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct percpu_ref_data {
        pub count: atomic_long_t,
        pub release: percpu_ref_func_t,
        pub confirm_switch: percpu_ref_func_t,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
        pub rcu: callback_head,
        pub ref_: *mut percpu_ref,
    }
    #[test]
    fn bindgen_test_layout_percpu_ref_data() {
        assert_eq!(
            ::core::mem::size_of::<percpu_ref_data>(),
            56usize,
            concat!("Size of: ", stringify!(percpu_ref_data))
        );
        assert_eq!(
            ::core::mem::align_of::<percpu_ref_data>(),
            8usize,
            concat!("Alignment of ", stringify!(percpu_ref_data))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<percpu_ref_data>())).count as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(percpu_ref_data),
                "::",
                stringify!(count)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<percpu_ref_data>())).release as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(percpu_ref_data),
                "::",
                stringify!(release)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<percpu_ref_data>())).confirm_switch as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(percpu_ref_data),
                "::",
                stringify!(confirm_switch)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<percpu_ref_data>())).rcu as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(percpu_ref_data),
                "::",
                stringify!(rcu)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<percpu_ref_data>())).ref_ as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(percpu_ref_data),
                "::",
                stringify!(ref_)
            )
        );
    }
    impl percpu_ref_data {
        #[inline]
        pub fn force_atomic(&self) -> bool_ {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_force_atomic(&mut self, val: bool_) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn allow_reinit(&self) -> bool_ {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_allow_reinit(&mut self, val: bool_) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(1usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            force_atomic: bool_,
            allow_reinit: bool_,
        ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 1u8, {
                let force_atomic: u8 = unsafe { ::core::mem::transmute(force_atomic) };
                force_atomic as u64
            });
            __bindgen_bitfield_unit.set(1usize, 1u8, {
                let allow_reinit: u8 = unsafe { ::core::mem::transmute(allow_reinit) };
                allow_reinit as u64
            });
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct percpu_ref {
        pub percpu_count_ptr: ::cty::c_ulong,
        pub data: *mut percpu_ref_data,
    }
    #[test]
    fn bindgen_test_layout_percpu_ref() {
        assert_eq!(
            ::core::mem::size_of::<percpu_ref>(),
            16usize,
            concat!("Size of: ", stringify!(percpu_ref))
        );
        assert_eq!(
            ::core::mem::align_of::<percpu_ref>(),
            8usize,
            concat!("Alignment of ", stringify!(percpu_ref))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<percpu_ref>())).percpu_count_ptr as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(percpu_ref),
                "::",
                stringify!(percpu_count_ptr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<percpu_ref>())).data as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(percpu_ref),
                "::",
                stringify!(data)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct kmem_cache {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct io_comp_batch {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct export_operations {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct fiemap_extent_info {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct kstatfs {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct swap_info_struct {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct fscrypt_info {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct fscrypt_operations {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct fsverity_info {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct fsverity_operations {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct fs_parameter_spec {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct fileattr {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct iattr {
        pub ia_valid: ::cty::c_uint,
        pub ia_mode: umode_t,
        pub __bindgen_anon_1: iattr__bindgen_ty_1,
        pub __bindgen_anon_2: iattr__bindgen_ty_2,
        pub ia_size: loff_t,
        pub ia_atime: timespec64,
        pub ia_mtime: timespec64,
        pub ia_ctime: timespec64,
        pub ia_file: *mut file,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union iattr__bindgen_ty_1 {
        pub ia_uid: kuid_t,
        pub ia_vfsuid: vfsuid_t,
    }
    #[test]
    fn bindgen_test_layout_iattr__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<iattr__bindgen_ty_1>(),
            4usize,
            concat!("Size of: ", stringify!(iattr__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<iattr__bindgen_ty_1>(),
            4usize,
            concat!("Alignment of ", stringify!(iattr__bindgen_ty_1))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<iattr__bindgen_ty_1>())).ia_uid as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(iattr__bindgen_ty_1),
                "::",
                stringify!(ia_uid)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<iattr__bindgen_ty_1>())).ia_vfsuid as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(iattr__bindgen_ty_1),
                "::",
                stringify!(ia_vfsuid)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union iattr__bindgen_ty_2 {
        pub ia_gid: kgid_t,
        pub ia_vfsgid: vfsgid_t,
    }
    #[test]
    fn bindgen_test_layout_iattr__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<iattr__bindgen_ty_2>(),
            4usize,
            concat!("Size of: ", stringify!(iattr__bindgen_ty_2))
        );
        assert_eq!(
            ::core::mem::align_of::<iattr__bindgen_ty_2>(),
            4usize,
            concat!("Alignment of ", stringify!(iattr__bindgen_ty_2))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<iattr__bindgen_ty_2>())).ia_gid as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(iattr__bindgen_ty_2),
                "::",
                stringify!(ia_gid)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<iattr__bindgen_ty_2>())).ia_vfsgid as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(iattr__bindgen_ty_2),
                "::",
                stringify!(ia_vfsgid)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_iattr() {
        assert_eq!(
            ::core::mem::size_of::<iattr>(),
            80usize,
            concat!("Size of: ", stringify!(iattr))
        );
        assert_eq!(
            ::core::mem::align_of::<iattr>(),
            8usize,
            concat!("Alignment of ", stringify!(iattr))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<iattr>())).ia_valid as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(iattr),
                "::",
                stringify!(ia_valid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<iattr>())).ia_mode as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(iattr),
                "::",
                stringify!(ia_mode)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<iattr>())).ia_size as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(iattr),
                "::",
                stringify!(ia_size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<iattr>())).ia_atime as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(iattr),
                "::",
                stringify!(ia_atime)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<iattr>())).ia_mtime as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(iattr),
                "::",
                stringify!(ia_mtime)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<iattr>())).ia_ctime as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(iattr),
                "::",
                stringify!(ia_ctime)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<iattr>())).ia_file as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(iattr),
                "::",
                stringify!(ia_file)
            )
        );
    }
    pub type projid_t = __kernel_uid32_t;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct kprojid_t {
        pub val: projid_t,
    }
    #[test]
    fn bindgen_test_layout_kprojid_t() {
        assert_eq!(
            ::core::mem::size_of::<kprojid_t>(),
            4usize,
            concat!("Size of: ", stringify!(kprojid_t))
        );
        assert_eq!(
            ::core::mem::align_of::<kprojid_t>(),
            4usize,
            concat!("Alignment of ", stringify!(kprojid_t))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kprojid_t>())).val as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(kprojid_t),
                "::",
                stringify!(val)
            )
        );
    }
    pub const quota_type_USRQUOTA: quota_type = 0;
    pub const quota_type_GRPQUOTA: quota_type = 1;
    pub const quota_type_PRJQUOTA: quota_type = 2;
    pub type quota_type = ::cty::c_uint;
    pub type qsize_t = ::cty::c_longlong;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct kqid {
        pub __bindgen_anon_1: kqid__bindgen_ty_1,
        pub type_: quota_type,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union kqid__bindgen_ty_1 {
        pub uid: kuid_t,
        pub gid: kgid_t,
        pub projid: kprojid_t,
    }
    #[test]
    fn bindgen_test_layout_kqid__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<kqid__bindgen_ty_1>(),
            4usize,
            concat!("Size of: ", stringify!(kqid__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<kqid__bindgen_ty_1>(),
            4usize,
            concat!("Alignment of ", stringify!(kqid__bindgen_ty_1))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kqid__bindgen_ty_1>())).uid as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(kqid__bindgen_ty_1),
                "::",
                stringify!(uid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kqid__bindgen_ty_1>())).gid as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(kqid__bindgen_ty_1),
                "::",
                stringify!(gid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kqid__bindgen_ty_1>())).projid as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(kqid__bindgen_ty_1),
                "::",
                stringify!(projid)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_kqid() {
        assert_eq!(
            ::core::mem::size_of::<kqid>(),
            8usize,
            concat!("Size of: ", stringify!(kqid))
        );
        assert_eq!(
            ::core::mem::align_of::<kqid>(),
            4usize,
            concat!("Alignment of ", stringify!(kqid))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kqid>())).type_ as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(kqid),
                "::",
                stringify!(type_)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct mem_dqblk {
        pub dqb_bhardlimit: qsize_t,
        pub dqb_bsoftlimit: qsize_t,
        pub dqb_curspace: qsize_t,
        pub dqb_rsvspace: qsize_t,
        pub dqb_ihardlimit: qsize_t,
        pub dqb_isoftlimit: qsize_t,
        pub dqb_curinodes: qsize_t,
        pub dqb_btime: time64_t,
        pub dqb_itime: time64_t,
    }
    #[test]
    fn bindgen_test_layout_mem_dqblk() {
        assert_eq!(
            ::core::mem::size_of::<mem_dqblk>(),
            72usize,
            concat!("Size of: ", stringify!(mem_dqblk))
        );
        assert_eq!(
            ::core::mem::align_of::<mem_dqblk>(),
            8usize,
            concat!("Alignment of ", stringify!(mem_dqblk))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_dqblk>())).dqb_bhardlimit as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_dqblk),
                "::",
                stringify!(dqb_bhardlimit)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_dqblk>())).dqb_bsoftlimit as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_dqblk),
                "::",
                stringify!(dqb_bsoftlimit)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_dqblk>())).dqb_curspace as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_dqblk),
                "::",
                stringify!(dqb_curspace)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_dqblk>())).dqb_rsvspace as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_dqblk),
                "::",
                stringify!(dqb_rsvspace)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_dqblk>())).dqb_ihardlimit as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_dqblk),
                "::",
                stringify!(dqb_ihardlimit)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_dqblk>())).dqb_isoftlimit as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_dqblk),
                "::",
                stringify!(dqb_isoftlimit)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_dqblk>())).dqb_curinodes as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_dqblk),
                "::",
                stringify!(dqb_curinodes)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_dqblk>())).dqb_btime as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_dqblk),
                "::",
                stringify!(dqb_btime)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_dqblk>())).dqb_itime as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_dqblk),
                "::",
                stringify!(dqb_itime)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct mem_dqinfo {
        pub dqi_format: *mut quota_format_type,
        pub dqi_fmt_id: ::cty::c_int,
        pub dqi_dirty_list: list_head,
        pub dqi_flags: ::cty::c_ulong,
        pub dqi_bgrace: ::cty::c_uint,
        pub dqi_igrace: ::cty::c_uint,
        pub dqi_max_spc_limit: qsize_t,
        pub dqi_max_ino_limit: qsize_t,
        pub dqi_priv: *mut ::cty::c_void,
    }
    #[test]
    fn bindgen_test_layout_mem_dqinfo() {
        assert_eq!(
            ::core::mem::size_of::<mem_dqinfo>(),
            72usize,
            concat!("Size of: ", stringify!(mem_dqinfo))
        );
        assert_eq!(
            ::core::mem::align_of::<mem_dqinfo>(),
            8usize,
            concat!("Alignment of ", stringify!(mem_dqinfo))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_dqinfo>())).dqi_format as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_dqinfo),
                "::",
                stringify!(dqi_format)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_dqinfo>())).dqi_fmt_id as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_dqinfo),
                "::",
                stringify!(dqi_fmt_id)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_dqinfo>())).dqi_dirty_list as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_dqinfo),
                "::",
                stringify!(dqi_dirty_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_dqinfo>())).dqi_flags as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_dqinfo),
                "::",
                stringify!(dqi_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_dqinfo>())).dqi_bgrace as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_dqinfo),
                "::",
                stringify!(dqi_bgrace)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_dqinfo>())).dqi_igrace as *const _ as usize },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_dqinfo),
                "::",
                stringify!(dqi_igrace)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mem_dqinfo>())).dqi_max_spc_limit as *const _ as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_dqinfo),
                "::",
                stringify!(dqi_max_spc_limit)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mem_dqinfo>())).dqi_max_ino_limit as *const _ as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_dqinfo),
                "::",
                stringify!(dqi_max_ino_limit)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_dqinfo>())).dqi_priv as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_dqinfo),
                "::",
                stringify!(dqi_priv)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct dquot {
        pub dq_hash: hlist_node,
        pub dq_inuse: list_head,
        pub dq_free: list_head,
        pub dq_dirty: list_head,
        pub dq_lock: mutex,
        pub dq_dqb_lock: spinlock_t,
        pub dq_count: atomic_t,
        pub dq_sb: *mut super_block,
        pub dq_id: kqid,
        pub dq_off: loff_t,
        pub dq_flags: ::cty::c_ulong,
        pub dq_dqb: mem_dqblk,
    }
    #[test]
    fn bindgen_test_layout_dquot() {
        assert_eq!(
            ::core::mem::size_of::<dquot>(),
            208usize,
            concat!("Size of: ", stringify!(dquot))
        );
        assert_eq!(
            ::core::mem::align_of::<dquot>(),
            8usize,
            concat!("Alignment of ", stringify!(dquot))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dquot>())).dq_hash as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(dquot),
                "::",
                stringify!(dq_hash)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dquot>())).dq_inuse as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(dquot),
                "::",
                stringify!(dq_inuse)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dquot>())).dq_free as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(dquot),
                "::",
                stringify!(dq_free)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dquot>())).dq_dirty as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(dquot),
                "::",
                stringify!(dq_dirty)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dquot>())).dq_lock as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(dquot),
                "::",
                stringify!(dq_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dquot>())).dq_dqb_lock as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(dquot),
                "::",
                stringify!(dq_dqb_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dquot>())).dq_count as *const _ as usize },
            100usize,
            concat!(
                "Offset of field: ",
                stringify!(dquot),
                "::",
                stringify!(dq_count)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dquot>())).dq_sb as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(dquot),
                "::",
                stringify!(dq_sb)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dquot>())).dq_id as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(dquot),
                "::",
                stringify!(dq_id)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dquot>())).dq_off as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(dquot),
                "::",
                stringify!(dq_off)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dquot>())).dq_flags as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(dquot),
                "::",
                stringify!(dq_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dquot>())).dq_dqb as *const _ as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(dquot),
                "::",
                stringify!(dq_dqb)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct quota_format_ops {
        pub check_quota_file: ::core::option::Option<
            unsafe extern "C" fn(sb: *mut super_block, type_: ::cty::c_int) -> ::cty::c_int,
        >,
        pub read_file_info: ::core::option::Option<
            unsafe extern "C" fn(sb: *mut super_block, type_: ::cty::c_int) -> ::cty::c_int,
        >,
        pub write_file_info: ::core::option::Option<
            unsafe extern "C" fn(sb: *mut super_block, type_: ::cty::c_int) -> ::cty::c_int,
        >,
        pub free_file_info: ::core::option::Option<
            unsafe extern "C" fn(sb: *mut super_block, type_: ::cty::c_int) -> ::cty::c_int,
        >,
        pub read_dqblk:
            ::core::option::Option<unsafe extern "C" fn(dquot: *mut dquot) -> ::cty::c_int>,
        pub commit_dqblk:
            ::core::option::Option<unsafe extern "C" fn(dquot: *mut dquot) -> ::cty::c_int>,
        pub release_dqblk:
            ::core::option::Option<unsafe extern "C" fn(dquot: *mut dquot) -> ::cty::c_int>,
        pub get_next_id: ::core::option::Option<
            unsafe extern "C" fn(sb: *mut super_block, qid: *mut kqid) -> ::cty::c_int,
        >,
    }
    #[test]
    fn bindgen_test_layout_quota_format_ops() {
        assert_eq!(
            ::core::mem::size_of::<quota_format_ops>(),
            64usize,
            concat!("Size of: ", stringify!(quota_format_ops))
        );
        assert_eq!(
            ::core::mem::align_of::<quota_format_ops>(),
            8usize,
            concat!("Alignment of ", stringify!(quota_format_ops))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<quota_format_ops>())).check_quota_file as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(quota_format_ops),
                "::",
                stringify!(check_quota_file)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<quota_format_ops>())).read_file_info as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(quota_format_ops),
                "::",
                stringify!(read_file_info)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<quota_format_ops>())).write_file_info as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(quota_format_ops),
                "::",
                stringify!(write_file_info)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<quota_format_ops>())).free_file_info as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(quota_format_ops),
                "::",
                stringify!(free_file_info)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<quota_format_ops>())).read_dqblk as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(quota_format_ops),
                "::",
                stringify!(read_dqblk)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<quota_format_ops>())).commit_dqblk as *const _ as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(quota_format_ops),
                "::",
                stringify!(commit_dqblk)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<quota_format_ops>())).release_dqblk as *const _ as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(quota_format_ops),
                "::",
                stringify!(release_dqblk)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<quota_format_ops>())).get_next_id as *const _ as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(quota_format_ops),
                "::",
                stringify!(get_next_id)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dquot_operations {
        pub write_dquot:
            ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> ::cty::c_int>,
        pub alloc_dquot: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut super_block, arg2: ::cty::c_int) -> *mut dquot,
        >,
        pub destroy_dquot: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot)>,
        pub acquire_dquot:
            ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> ::cty::c_int>,
        pub release_dquot:
            ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> ::cty::c_int>,
        pub mark_dirty:
            ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> ::cty::c_int>,
        pub write_info: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut super_block, arg2: ::cty::c_int) -> ::cty::c_int,
        >,
        pub get_reserved_space:
            ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode) -> *mut qsize_t>,
        pub get_projid: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut inode, arg2: *mut kprojid_t) -> ::cty::c_int,
        >,
        pub get_inode_usage: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut inode, arg2: *mut qsize_t) -> ::cty::c_int,
        >,
        pub get_next_id: ::core::option::Option<
            unsafe extern "C" fn(sb: *mut super_block, qid: *mut kqid) -> ::cty::c_int,
        >,
    }
    #[test]
    fn bindgen_test_layout_dquot_operations() {
        assert_eq!(
            ::core::mem::size_of::<dquot_operations>(),
            88usize,
            concat!("Size of: ", stringify!(dquot_operations))
        );
        assert_eq!(
            ::core::mem::align_of::<dquot_operations>(),
            8usize,
            concat!("Alignment of ", stringify!(dquot_operations))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<dquot_operations>())).write_dquot as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(dquot_operations),
                "::",
                stringify!(write_dquot)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<dquot_operations>())).alloc_dquot as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(dquot_operations),
                "::",
                stringify!(alloc_dquot)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<dquot_operations>())).destroy_dquot as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(dquot_operations),
                "::",
                stringify!(destroy_dquot)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<dquot_operations>())).acquire_dquot as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(dquot_operations),
                "::",
                stringify!(acquire_dquot)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<dquot_operations>())).release_dquot as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(dquot_operations),
                "::",
                stringify!(release_dquot)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<dquot_operations>())).mark_dirty as *const _ as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(dquot_operations),
                "::",
                stringify!(mark_dirty)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<dquot_operations>())).write_info as *const _ as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(dquot_operations),
                "::",
                stringify!(write_info)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<dquot_operations>())).get_reserved_space as *const _
                    as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(dquot_operations),
                "::",
                stringify!(get_reserved_space)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<dquot_operations>())).get_projid as *const _ as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(dquot_operations),
                "::",
                stringify!(get_projid)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<dquot_operations>())).get_inode_usage as *const _ as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(dquot_operations),
                "::",
                stringify!(get_inode_usage)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<dquot_operations>())).get_next_id as *const _ as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(dquot_operations),
                "::",
                stringify!(get_next_id)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct qc_dqblk {
        pub d_fieldmask: ::cty::c_int,
        pub d_spc_hardlimit: _cargo_bpf_u64,
        pub d_spc_softlimit: _cargo_bpf_u64,
        pub d_ino_hardlimit: _cargo_bpf_u64,
        pub d_ino_softlimit: _cargo_bpf_u64,
        pub d_space: _cargo_bpf_u64,
        pub d_ino_count: _cargo_bpf_u64,
        pub d_ino_timer: s64,
        pub d_spc_timer: s64,
        pub d_ino_warns: ::cty::c_int,
        pub d_spc_warns: ::cty::c_int,
        pub d_rt_spc_hardlimit: _cargo_bpf_u64,
        pub d_rt_spc_softlimit: _cargo_bpf_u64,
        pub d_rt_space: _cargo_bpf_u64,
        pub d_rt_spc_timer: s64,
        pub d_rt_spc_warns: ::cty::c_int,
    }
    #[test]
    fn bindgen_test_layout_qc_dqblk() {
        assert_eq!(
            ::core::mem::size_of::<qc_dqblk>(),
            120usize,
            concat!("Size of: ", stringify!(qc_dqblk))
        );
        assert_eq!(
            ::core::mem::align_of::<qc_dqblk>(),
            8usize,
            concat!("Alignment of ", stringify!(qc_dqblk))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_fieldmask as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(qc_dqblk),
                "::",
                stringify!(d_fieldmask)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_spc_hardlimit as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(qc_dqblk),
                "::",
                stringify!(d_spc_hardlimit)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_spc_softlimit as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(qc_dqblk),
                "::",
                stringify!(d_spc_softlimit)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_ino_hardlimit as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(qc_dqblk),
                "::",
                stringify!(d_ino_hardlimit)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_ino_softlimit as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(qc_dqblk),
                "::",
                stringify!(d_ino_softlimit)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_space as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(qc_dqblk),
                "::",
                stringify!(d_space)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_ino_count as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(qc_dqblk),
                "::",
                stringify!(d_ino_count)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_ino_timer as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(qc_dqblk),
                "::",
                stringify!(d_ino_timer)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_spc_timer as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(qc_dqblk),
                "::",
                stringify!(d_spc_timer)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_ino_warns as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(qc_dqblk),
                "::",
                stringify!(d_ino_warns)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_spc_warns as *const _ as usize },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(qc_dqblk),
                "::",
                stringify!(d_spc_warns)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<qc_dqblk>())).d_rt_spc_hardlimit as *const _ as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(qc_dqblk),
                "::",
                stringify!(d_rt_spc_hardlimit)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<qc_dqblk>())).d_rt_spc_softlimit as *const _ as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(qc_dqblk),
                "::",
                stringify!(d_rt_spc_softlimit)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_rt_space as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(qc_dqblk),
                "::",
                stringify!(d_rt_space)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_rt_spc_timer as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(qc_dqblk),
                "::",
                stringify!(d_rt_spc_timer)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<qc_dqblk>())).d_rt_spc_warns as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(qc_dqblk),
                "::",
                stringify!(d_rt_spc_warns)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct qc_type_state {
        pub flags: ::cty::c_uint,
        pub spc_timelimit: ::cty::c_uint,
        pub ino_timelimit: ::cty::c_uint,
        pub rt_spc_timelimit: ::cty::c_uint,
        pub spc_warnlimit: ::cty::c_uint,
        pub ino_warnlimit: ::cty::c_uint,
        pub rt_spc_warnlimit: ::cty::c_uint,
        pub ino: ::cty::c_ulonglong,
        pub blocks: blkcnt_t,
        pub nextents: blkcnt_t,
    }
    #[test]
    fn bindgen_test_layout_qc_type_state() {
        assert_eq!(
            ::core::mem::size_of::<qc_type_state>(),
            56usize,
            concat!("Size of: ", stringify!(qc_type_state))
        );
        assert_eq!(
            ::core::mem::align_of::<qc_type_state>(),
            8usize,
            concat!("Alignment of ", stringify!(qc_type_state))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<qc_type_state>())).flags as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(qc_type_state),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<qc_type_state>())).spc_timelimit as *const _ as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(qc_type_state),
                "::",
                stringify!(spc_timelimit)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<qc_type_state>())).ino_timelimit as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(qc_type_state),
                "::",
                stringify!(ino_timelimit)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<qc_type_state>())).rt_spc_timelimit as *const _ as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(qc_type_state),
                "::",
                stringify!(rt_spc_timelimit)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<qc_type_state>())).spc_warnlimit as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(qc_type_state),
                "::",
                stringify!(spc_warnlimit)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<qc_type_state>())).ino_warnlimit as *const _ as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(qc_type_state),
                "::",
                stringify!(ino_warnlimit)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<qc_type_state>())).rt_spc_warnlimit as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(qc_type_state),
                "::",
                stringify!(rt_spc_warnlimit)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<qc_type_state>())).ino as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(qc_type_state),
                "::",
                stringify!(ino)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<qc_type_state>())).blocks as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(qc_type_state),
                "::",
                stringify!(blocks)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<qc_type_state>())).nextents as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(qc_type_state),
                "::",
                stringify!(nextents)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct qc_state {
        pub s_incoredqs: ::cty::c_uint,
        pub s_state: [qc_type_state; 3usize],
    }
    #[test]
    fn bindgen_test_layout_qc_state() {
        assert_eq!(
            ::core::mem::size_of::<qc_state>(),
            176usize,
            concat!("Size of: ", stringify!(qc_state))
        );
        assert_eq!(
            ::core::mem::align_of::<qc_state>(),
            8usize,
            concat!("Alignment of ", stringify!(qc_state))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<qc_state>())).s_incoredqs as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(qc_state),
                "::",
                stringify!(s_incoredqs)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<qc_state>())).s_state as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(qc_state),
                "::",
                stringify!(s_state)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct qc_info {
        pub i_fieldmask: ::cty::c_int,
        pub i_flags: ::cty::c_uint,
        pub i_spc_timelimit: ::cty::c_uint,
        pub i_ino_timelimit: ::cty::c_uint,
        pub i_rt_spc_timelimit: ::cty::c_uint,
        pub i_spc_warnlimit: ::cty::c_uint,
        pub i_ino_warnlimit: ::cty::c_uint,
        pub i_rt_spc_warnlimit: ::cty::c_uint,
    }
    #[test]
    fn bindgen_test_layout_qc_info() {
        assert_eq!(
            ::core::mem::size_of::<qc_info>(),
            32usize,
            concat!("Size of: ", stringify!(qc_info))
        );
        assert_eq!(
            ::core::mem::align_of::<qc_info>(),
            4usize,
            concat!("Alignment of ", stringify!(qc_info))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<qc_info>())).i_fieldmask as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(qc_info),
                "::",
                stringify!(i_fieldmask)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<qc_info>())).i_flags as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(qc_info),
                "::",
                stringify!(i_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<qc_info>())).i_spc_timelimit as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(qc_info),
                "::",
                stringify!(i_spc_timelimit)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<qc_info>())).i_ino_timelimit as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(qc_info),
                "::",
                stringify!(i_ino_timelimit)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<qc_info>())).i_rt_spc_timelimit as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(qc_info),
                "::",
                stringify!(i_rt_spc_timelimit)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<qc_info>())).i_spc_warnlimit as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(qc_info),
                "::",
                stringify!(i_spc_warnlimit)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<qc_info>())).i_ino_warnlimit as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(qc_info),
                "::",
                stringify!(i_ino_warnlimit)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<qc_info>())).i_rt_spc_warnlimit as *const _ as usize },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(qc_info),
                "::",
                stringify!(i_rt_spc_warnlimit)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct quotactl_ops {
        pub quota_on: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: ::cty::c_int,
                arg3: ::cty::c_int,
                arg4: *const path,
            ) -> ::cty::c_int,
        >,
        pub quota_off: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut super_block, arg2: ::cty::c_int) -> ::cty::c_int,
        >,
        pub quota_enable: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut super_block, arg2: ::cty::c_uint) -> ::cty::c_int,
        >,
        pub quota_disable: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut super_block, arg2: ::cty::c_uint) -> ::cty::c_int,
        >,
        pub quota_sync: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut super_block, arg2: ::cty::c_int) -> ::cty::c_int,
        >,
        pub set_info: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: ::cty::c_int,
                arg3: *mut qc_info,
            ) -> ::cty::c_int,
        >,
        pub get_dqblk: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: kqid,
                arg3: *mut qc_dqblk,
            ) -> ::cty::c_int,
        >,
        pub get_nextdqblk: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: *mut kqid,
                arg3: *mut qc_dqblk,
            ) -> ::cty::c_int,
        >,
        pub set_dqblk: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: kqid,
                arg3: *mut qc_dqblk,
            ) -> ::cty::c_int,
        >,
        pub get_state: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut super_block, arg2: *mut qc_state) -> ::cty::c_int,
        >,
        pub rm_xquota: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut super_block, arg2: ::cty::c_uint) -> ::cty::c_int,
        >,
    }
    #[test]
    fn bindgen_test_layout_quotactl_ops() {
        assert_eq!(
            ::core::mem::size_of::<quotactl_ops>(),
            88usize,
            concat!("Size of: ", stringify!(quotactl_ops))
        );
        assert_eq!(
            ::core::mem::align_of::<quotactl_ops>(),
            8usize,
            concat!("Alignment of ", stringify!(quotactl_ops))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<quotactl_ops>())).quota_on as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(quotactl_ops),
                "::",
                stringify!(quota_on)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<quotactl_ops>())).quota_off as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(quotactl_ops),
                "::",
                stringify!(quota_off)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<quotactl_ops>())).quota_enable as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(quotactl_ops),
                "::",
                stringify!(quota_enable)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<quotactl_ops>())).quota_disable as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(quotactl_ops),
                "::",
                stringify!(quota_disable)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<quotactl_ops>())).quota_sync as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(quotactl_ops),
                "::",
                stringify!(quota_sync)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<quotactl_ops>())).set_info as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(quotactl_ops),
                "::",
                stringify!(set_info)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<quotactl_ops>())).get_dqblk as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(quotactl_ops),
                "::",
                stringify!(get_dqblk)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<quotactl_ops>())).get_nextdqblk as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(quotactl_ops),
                "::",
                stringify!(get_nextdqblk)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<quotactl_ops>())).set_dqblk as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(quotactl_ops),
                "::",
                stringify!(set_dqblk)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<quotactl_ops>())).get_state as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(quotactl_ops),
                "::",
                stringify!(get_state)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<quotactl_ops>())).rm_xquota as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(quotactl_ops),
                "::",
                stringify!(rm_xquota)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct quota_format_type {
        pub qf_fmt_id: ::cty::c_int,
        pub qf_ops: *const quota_format_ops,
        pub qf_owner: *mut module,
        pub qf_next: *mut quota_format_type,
    }
    #[test]
    fn bindgen_test_layout_quota_format_type() {
        assert_eq!(
            ::core::mem::size_of::<quota_format_type>(),
            32usize,
            concat!("Size of: ", stringify!(quota_format_type))
        );
        assert_eq!(
            ::core::mem::align_of::<quota_format_type>(),
            8usize,
            concat!("Alignment of ", stringify!(quota_format_type))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<quota_format_type>())).qf_fmt_id as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(quota_format_type),
                "::",
                stringify!(qf_fmt_id)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<quota_format_type>())).qf_ops as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(quota_format_type),
                "::",
                stringify!(qf_ops)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<quota_format_type>())).qf_owner as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(quota_format_type),
                "::",
                stringify!(qf_owner)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<quota_format_type>())).qf_next as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(quota_format_type),
                "::",
                stringify!(qf_next)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct quota_info {
        pub flags: ::cty::c_uint,
        pub dqio_sem: rw_semaphore,
        pub files: [*mut inode; 3usize],
        pub info: [mem_dqinfo; 3usize],
        pub ops: [*const quota_format_ops; 3usize],
    }
    #[test]
    fn bindgen_test_layout_quota_info() {
        assert_eq!(
            ::core::mem::size_of::<quota_info>(),
            312usize,
            concat!("Size of: ", stringify!(quota_info))
        );
        assert_eq!(
            ::core::mem::align_of::<quota_info>(),
            8usize,
            concat!("Alignment of ", stringify!(quota_info))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<quota_info>())).flags as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(quota_info),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<quota_info>())).dqio_sem as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(quota_info),
                "::",
                stringify!(dqio_sem)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<quota_info>())).files as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(quota_info),
                "::",
                stringify!(files)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<quota_info>())).info as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(quota_info),
                "::",
                stringify!(info)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<quota_info>())).ops as *const _ as usize },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(quota_info),
                "::",
                stringify!(ops)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct readahead_control {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct kiocb {
        pub ki_filp: *mut file,
        pub ki_pos: loff_t,
        pub ki_complete:
            ::core::option::Option<unsafe extern "C" fn(iocb: *mut kiocb, ret: ::cty::c_long)>,
        pub private: *mut ::cty::c_void,
        pub ki_flags: ::cty::c_int,
        pub ki_ioprio: _cargo_bpf_u16,
        pub __bindgen_anon_1: kiocb__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union kiocb__bindgen_ty_1 {
        pub ki_waitq: *mut wait_page_queue,
        pub dio_complete:
            ::core::option::Option<unsafe extern "C" fn(data: *mut ::cty::c_void) -> ssize_t>,
    }
    #[test]
    fn bindgen_test_layout_kiocb__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<kiocb__bindgen_ty_1>(),
            8usize,
            concat!("Size of: ", stringify!(kiocb__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<kiocb__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(kiocb__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<kiocb__bindgen_ty_1>())).ki_waitq as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(kiocb__bindgen_ty_1),
                "::",
                stringify!(ki_waitq)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<kiocb__bindgen_ty_1>())).dio_complete as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(kiocb__bindgen_ty_1),
                "::",
                stringify!(dio_complete)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_kiocb() {
        assert_eq!(
            ::core::mem::size_of::<kiocb>(),
            48usize,
            concat!("Size of: ", stringify!(kiocb))
        );
        assert_eq!(
            ::core::mem::align_of::<kiocb>(),
            8usize,
            concat!("Alignment of ", stringify!(kiocb))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kiocb>())).ki_filp as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(kiocb),
                "::",
                stringify!(ki_filp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kiocb>())).ki_pos as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(kiocb),
                "::",
                stringify!(ki_pos)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kiocb>())).ki_complete as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(kiocb),
                "::",
                stringify!(ki_complete)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kiocb>())).private as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(kiocb),
                "::",
                stringify!(private)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kiocb>())).ki_flags as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(kiocb),
                "::",
                stringify!(ki_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kiocb>())).ki_ioprio as *const _ as usize },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(kiocb),
                "::",
                stringify!(ki_ioprio)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct address_space_operations {
        pub writepage: ::core::option::Option<
            unsafe extern "C" fn(page: *mut page, wbc: *mut writeback_control) -> ::cty::c_int,
        >,
        pub read_folio: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut file, arg2: *mut folio) -> ::cty::c_int,
        >,
        pub writepages: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut address_space,
                arg2: *mut writeback_control,
            ) -> ::cty::c_int,
        >,
        pub dirty_folio: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut address_space, arg2: *mut folio) -> bool_,
        >,
        pub readahead: ::core::option::Option<unsafe extern "C" fn(arg1: *mut readahead_control)>,
        pub write_begin: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                mapping: *mut address_space,
                pos: loff_t,
                len: ::cty::c_uint,
                pagep: *mut *mut page,
                fsdata: *mut *mut ::cty::c_void,
            ) -> ::cty::c_int,
        >,
        pub write_end: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                mapping: *mut address_space,
                pos: loff_t,
                len: ::cty::c_uint,
                copied: ::cty::c_uint,
                page: *mut page,
                fsdata: *mut ::cty::c_void,
            ) -> ::cty::c_int,
        >,
        pub bmap: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut address_space, arg2: sector_t) -> sector_t,
        >,
        pub invalidate_folio: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut folio, offset: size_t, len: size_t),
        >,
        pub release_folio:
            ::core::option::Option<unsafe extern "C" fn(arg1: *mut folio, arg2: gfp_t) -> bool_>,
        pub free_folio: ::core::option::Option<unsafe extern "C" fn(folio: *mut folio)>,
        pub direct_IO: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut kiocb, iter: *mut iov_iter) -> ssize_t,
        >,
        pub migrate_folio: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut address_space,
                dst: *mut folio,
                src: *mut folio,
                arg2: migrate_mode,
            ) -> ::cty::c_int,
        >,
        pub launder_folio:
            ::core::option::Option<unsafe extern "C" fn(arg1: *mut folio) -> ::cty::c_int>,
        pub is_partially_uptodate: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut folio, from: size_t, count: size_t) -> bool_,
        >,
        pub is_dirty_writeback: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut folio, dirty: *mut bool_, wb: *mut bool_),
        >,
        pub error_remove_page: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut address_space, arg2: *mut page) -> ::cty::c_int,
        >,
        pub swap_activate: ::core::option::Option<
            unsafe extern "C" fn(
                sis: *mut swap_info_struct,
                file: *mut file,
                span: *mut sector_t,
            ) -> ::cty::c_int,
        >,
        pub swap_deactivate: ::core::option::Option<unsafe extern "C" fn(file: *mut file)>,
        pub swap_rw: ::core::option::Option<
            unsafe extern "C" fn(iocb: *mut kiocb, iter: *mut iov_iter) -> ::cty::c_int,
        >,
    }
    #[test]
    fn bindgen_test_layout_address_space_operations() {
        assert_eq!(
            ::core::mem::size_of::<address_space_operations>(),
            160usize,
            concat!("Size of: ", stringify!(address_space_operations))
        );
        assert_eq!(
            ::core::mem::align_of::<address_space_operations>(),
            8usize,
            concat!("Alignment of ", stringify!(address_space_operations))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<address_space_operations>())).writepage as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(address_space_operations),
                "::",
                stringify!(writepage)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<address_space_operations>())).read_folio as *const _
                    as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(address_space_operations),
                "::",
                stringify!(read_folio)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<address_space_operations>())).writepages as *const _
                    as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(address_space_operations),
                "::",
                stringify!(writepages)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<address_space_operations>())).dirty_folio as *const _
                    as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(address_space_operations),
                "::",
                stringify!(dirty_folio)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<address_space_operations>())).readahead as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(address_space_operations),
                "::",
                stringify!(readahead)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<address_space_operations>())).write_begin as *const _
                    as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(address_space_operations),
                "::",
                stringify!(write_begin)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<address_space_operations>())).write_end as *const _ as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(address_space_operations),
                "::",
                stringify!(write_end)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<address_space_operations>())).bmap as *const _ as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(address_space_operations),
                "::",
                stringify!(bmap)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<address_space_operations>())).invalidate_folio as *const _
                    as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(address_space_operations),
                "::",
                stringify!(invalidate_folio)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<address_space_operations>())).release_folio as *const _
                    as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(address_space_operations),
                "::",
                stringify!(release_folio)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<address_space_operations>())).free_folio as *const _
                    as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(address_space_operations),
                "::",
                stringify!(free_folio)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<address_space_operations>())).direct_IO as *const _ as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(address_space_operations),
                "::",
                stringify!(direct_IO)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<address_space_operations>())).migrate_folio as *const _
                    as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(address_space_operations),
                "::",
                stringify!(migrate_folio)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<address_space_operations>())).launder_folio as *const _
                    as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(address_space_operations),
                "::",
                stringify!(launder_folio)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<address_space_operations>())).is_partially_uptodate
                    as *const _ as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(address_space_operations),
                "::",
                stringify!(is_partially_uptodate)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<address_space_operations>())).is_dirty_writeback as *const _
                    as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(address_space_operations),
                "::",
                stringify!(is_dirty_writeback)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<address_space_operations>())).error_remove_page as *const _
                    as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(address_space_operations),
                "::",
                stringify!(error_remove_page)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<address_space_operations>())).swap_activate as *const _
                    as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(address_space_operations),
                "::",
                stringify!(swap_activate)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<address_space_operations>())).swap_deactivate as *const _
                    as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(address_space_operations),
                "::",
                stringify!(swap_deactivate)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<address_space_operations>())).swap_rw as *const _ as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(address_space_operations),
                "::",
                stringify!(swap_rw)
            )
        );
    }
    #[doc = " struct address_space - Contents of a cacheable, mappable object."]
    #[doc = " @host: Owner, either the inode or the block_device."]
    #[doc = " @i_pages: Cached pages."]
    #[doc = " @invalidate_lock: Guards coherency between page cache contents and"]
    #[doc = "   file offset->disk block mappings in the filesystem during invalidates."]
    #[doc = "   It is also used to block modification of page cache contents through"]
    #[doc = "   memory mappings."]
    #[doc = " @gfp_mask: Memory allocation flags to use for allocating pages."]
    #[doc = " @i_mmap_writable: Number of VM_SHARED mappings."]
    #[doc = " @nr_thps: Number of THPs in the pagecache (non-shmem only)."]
    #[doc = " @i_mmap: Tree of private and shared mappings."]
    #[doc = " @i_mmap_rwsem: Protects @i_mmap and @i_mmap_writable."]
    #[doc = " @nrpages: Number of page entries, protected by the i_pages lock."]
    #[doc = " @writeback_index: Writeback starts here."]
    #[doc = " @a_ops: Methods."]
    #[doc = " @flags: Error bits and flags (AS_*)."]
    #[doc = " @wb_err: The most recent error which has occurred."]
    #[doc = " @private_lock: For use by the owner of the address_space."]
    #[doc = " @private_list: For use by the owner of the address_space."]
    #[doc = " @private_data: For use by the owner of the address_space."]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct address_space {
        pub host: *mut inode,
        pub i_pages: xarray,
        pub invalidate_lock: rw_semaphore,
        pub gfp_mask: gfp_t,
        pub i_mmap_writable: atomic_t,
        pub i_mmap: rb_root_cached,
        pub nrpages: ::cty::c_ulong,
        pub writeback_index: ::cty::c_ulong,
        pub a_ops: *const address_space_operations,
        pub flags: ::cty::c_ulong,
        pub i_mmap_rwsem: rw_semaphore,
        pub wb_err: errseq_t,
        pub private_lock: spinlock_t,
        pub private_list: list_head,
        pub private_data: *mut ::cty::c_void,
    }
    #[test]
    fn bindgen_test_layout_address_space() {
        assert_eq!(
            ::core::mem::size_of::<address_space>(),
            192usize,
            concat!("Size of: ", stringify!(address_space))
        );
        assert_eq!(
            ::core::mem::align_of::<address_space>(),
            8usize,
            concat!("Alignment of ", stringify!(address_space))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<address_space>())).host as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(address_space),
                "::",
                stringify!(host)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<address_space>())).i_pages as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(address_space),
                "::",
                stringify!(i_pages)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<address_space>())).invalidate_lock as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(address_space),
                "::",
                stringify!(invalidate_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<address_space>())).gfp_mask as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(address_space),
                "::",
                stringify!(gfp_mask)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<address_space>())).i_mmap_writable as *const _ as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(address_space),
                "::",
                stringify!(i_mmap_writable)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<address_space>())).i_mmap as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(address_space),
                "::",
                stringify!(i_mmap)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<address_space>())).nrpages as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(address_space),
                "::",
                stringify!(nrpages)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<address_space>())).writeback_index as *const _ as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(address_space),
                "::",
                stringify!(writeback_index)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<address_space>())).a_ops as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(address_space),
                "::",
                stringify!(a_ops)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<address_space>())).flags as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(address_space),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<address_space>())).i_mmap_rwsem as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(address_space),
                "::",
                stringify!(i_mmap_rwsem)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<address_space>())).wb_err as *const _ as usize },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(address_space),
                "::",
                stringify!(wb_err)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<address_space>())).private_lock as *const _ as usize },
            164usize,
            concat!(
                "Offset of field: ",
                stringify!(address_space),
                "::",
                stringify!(private_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<address_space>())).private_list as *const _ as usize },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(address_space),
                "::",
                stringify!(private_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<address_space>())).private_data as *const _ as usize },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(address_space),
                "::",
                stringify!(private_data)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct posix_acl {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct fsnotify_mark_connector {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct inode {
        pub i_mode: umode_t,
        pub i_opflags: ::cty::c_ushort,
        pub i_uid: kuid_t,
        pub i_gid: kgid_t,
        pub i_flags: ::cty::c_uint,
        pub i_acl: *mut posix_acl,
        pub i_default_acl: *mut posix_acl,
        pub i_op: *const inode_operations,
        pub i_sb: *mut super_block,
        pub i_mapping: *mut address_space,
        pub i_security: *mut ::cty::c_void,
        pub i_ino: ::cty::c_ulong,
        pub __bindgen_anon_1: inode__bindgen_ty_1,
        pub i_rdev: dev_t,
        pub i_size: loff_t,
        pub i_atime: timespec64,
        pub i_mtime: timespec64,
        pub i_ctime: timespec64,
        pub i_lock: spinlock_t,
        pub i_bytes: ::cty::c_ushort,
        pub i_blkbits: _cargo_bpf_u8,
        pub i_write_hint: _cargo_bpf_u8,
        pub i_blocks: blkcnt_t,
        pub i_state: ::cty::c_ulong,
        pub i_rwsem: rw_semaphore,
        pub dirtied_when: ::cty::c_ulong,
        pub dirtied_time_when: ::cty::c_ulong,
        pub i_hash: hlist_node,
        pub i_io_list: list_head,
        pub i_wb: *mut bdi_writeback,
        pub i_wb_frn_winner: ::cty::c_int,
        pub i_wb_frn_avg_time: _cargo_bpf_u16,
        pub i_wb_frn_history: _cargo_bpf_u16,
        pub i_lru: list_head,
        pub i_sb_list: list_head,
        pub i_wb_list: list_head,
        pub __bindgen_anon_2: inode__bindgen_ty_2,
        pub i_version: atomic64_t,
        pub i_sequence: atomic64_t,
        pub i_count: atomic_t,
        pub i_dio_count: atomic_t,
        pub i_writecount: atomic_t,
        pub i_readcount: atomic_t,
        pub __bindgen_anon_3: inode__bindgen_ty_3,
        pub i_flctx: *mut file_lock_context,
        pub i_data: address_space,
        pub i_devices: list_head,
        pub __bindgen_anon_4: inode__bindgen_ty_4,
        pub i_generation: __u32,
        pub i_fsnotify_mask: __u32,
        pub i_fsnotify_marks: *mut fsnotify_mark_connector,
        pub i_crypt_info: *mut fscrypt_info,
        pub i_verity_info: *mut fsverity_info,
        pub i_private: *mut ::cty::c_void,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union inode__bindgen_ty_1 {
        pub i_nlink: ::cty::c_uint,
        pub __i_nlink: ::cty::c_uint,
    }
    #[test]
    fn bindgen_test_layout_inode__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<inode__bindgen_ty_1>(),
            4usize,
            concat!("Size of: ", stringify!(inode__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<inode__bindgen_ty_1>(),
            4usize,
            concat!("Alignment of ", stringify!(inode__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inode__bindgen_ty_1>())).i_nlink as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(inode__bindgen_ty_1),
                "::",
                stringify!(i_nlink)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inode__bindgen_ty_1>())).__i_nlink as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(inode__bindgen_ty_1),
                "::",
                stringify!(__i_nlink)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union inode__bindgen_ty_2 {
        pub i_dentry: hlist_head,
        pub i_rcu: callback_head,
    }
    #[test]
    fn bindgen_test_layout_inode__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<inode__bindgen_ty_2>(),
            16usize,
            concat!("Size of: ", stringify!(inode__bindgen_ty_2))
        );
        assert_eq!(
            ::core::mem::align_of::<inode__bindgen_ty_2>(),
            8usize,
            concat!("Alignment of ", stringify!(inode__bindgen_ty_2))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inode__bindgen_ty_2>())).i_dentry as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(inode__bindgen_ty_2),
                "::",
                stringify!(i_dentry)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode__bindgen_ty_2>())).i_rcu as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(inode__bindgen_ty_2),
                "::",
                stringify!(i_rcu)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union inode__bindgen_ty_3 {
        pub i_fop: *const file_operations,
        pub free_inode: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode)>,
    }
    #[test]
    fn bindgen_test_layout_inode__bindgen_ty_3() {
        assert_eq!(
            ::core::mem::size_of::<inode__bindgen_ty_3>(),
            8usize,
            concat!("Size of: ", stringify!(inode__bindgen_ty_3))
        );
        assert_eq!(
            ::core::mem::align_of::<inode__bindgen_ty_3>(),
            8usize,
            concat!("Alignment of ", stringify!(inode__bindgen_ty_3))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode__bindgen_ty_3>())).i_fop as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(inode__bindgen_ty_3),
                "::",
                stringify!(i_fop)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inode__bindgen_ty_3>())).free_inode as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(inode__bindgen_ty_3),
                "::",
                stringify!(free_inode)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union inode__bindgen_ty_4 {
        pub i_pipe: *mut pipe_inode_info,
        pub i_cdev: *mut cdev,
        pub i_link: *mut ::cty::c_char,
        pub i_dir_seq: ::cty::c_uint,
    }
    #[test]
    fn bindgen_test_layout_inode__bindgen_ty_4() {
        assert_eq!(
            ::core::mem::size_of::<inode__bindgen_ty_4>(),
            8usize,
            concat!("Size of: ", stringify!(inode__bindgen_ty_4))
        );
        assert_eq!(
            ::core::mem::align_of::<inode__bindgen_ty_4>(),
            8usize,
            concat!("Alignment of ", stringify!(inode__bindgen_ty_4))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode__bindgen_ty_4>())).i_pipe as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(inode__bindgen_ty_4),
                "::",
                stringify!(i_pipe)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode__bindgen_ty_4>())).i_cdev as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(inode__bindgen_ty_4),
                "::",
                stringify!(i_cdev)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode__bindgen_ty_4>())).i_link as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(inode__bindgen_ty_4),
                "::",
                stringify!(i_link)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inode__bindgen_ty_4>())).i_dir_seq as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(inode__bindgen_ty_4),
                "::",
                stringify!(i_dir_seq)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_inode() {
        assert_eq!(
            ::core::mem::size_of::<inode>(),
            632usize,
            concat!("Size of: ", stringify!(inode))
        );
        assert_eq!(
            ::core::mem::align_of::<inode>(),
            8usize,
            concat!("Alignment of ", stringify!(inode))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode>())).i_mode as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(inode),
                "::",
                stringify!(i_mode)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode>())).i_opflags as *const _ as usize },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(inode),
                "::",
                stringify!(i_opflags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode>())).i_uid as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(inode),
                "::",
                stringify!(i_uid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode>())).i_gid as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(inode),
                "::",
                stringify!(i_gid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode>())).i_flags as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(inode),
                "::",
                stringify!(i_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode>())).i_acl as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(inode),
                "::",
                stringify!(i_acl)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode>())).i_default_acl as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(inode),
                "::",
                stringify!(i_default_acl)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode>())).i_op as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(inode),
                "::",
                stringify!(i_op)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode>())).i_sb as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(inode),
                "::",
                stringify!(i_sb)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode>())).i_mapping as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(inode),
                "::",
                stringify!(i_mapping)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode>())).i_security as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(inode),
                "::",
                stringify!(i_security)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode>())).i_ino as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(inode),
                "::",
                stringify!(i_ino)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode>())).i_rdev as *const _ as usize },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(inode),
                "::",
                stringify!(i_rdev)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode>())).i_size as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(inode),
                "::",
                stringify!(i_size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode>())).i_atime as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(inode),
                "::",
                stringify!(i_atime)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode>())).i_mtime as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(inode),
                "::",
                stringify!(i_mtime)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode>())).i_ctime as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(inode),
                "::",
                stringify!(i_ctime)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode>())).i_lock as *const _ as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(inode),
                "::",
                stringify!(i_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode>())).i_bytes as *const _ as usize },
            140usize,
            concat!(
                "Offset of field: ",
                stringify!(inode),
                "::",
                stringify!(i_bytes)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode>())).i_blkbits as *const _ as usize },
            142usize,
            concat!(
                "Offset of field: ",
                stringify!(inode),
                "::",
                stringify!(i_blkbits)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode>())).i_write_hint as *const _ as usize },
            143usize,
            concat!(
                "Offset of field: ",
                stringify!(inode),
                "::",
                stringify!(i_write_hint)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode>())).i_blocks as *const _ as usize },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(inode),
                "::",
                stringify!(i_blocks)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode>())).i_state as *const _ as usize },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(inode),
                "::",
                stringify!(i_state)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode>())).i_rwsem as *const _ as usize },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(inode),
                "::",
                stringify!(i_rwsem)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode>())).dirtied_when as *const _ as usize },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(inode),
                "::",
                stringify!(dirtied_when)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode>())).dirtied_time_when as *const _ as usize },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(inode),
                "::",
                stringify!(dirtied_time_when)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode>())).i_hash as *const _ as usize },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(inode),
                "::",
                stringify!(i_hash)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode>())).i_io_list as *const _ as usize },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(inode),
                "::",
                stringify!(i_io_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode>())).i_wb as *const _ as usize },
            248usize,
            concat!(
                "Offset of field: ",
                stringify!(inode),
                "::",
                stringify!(i_wb)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode>())).i_wb_frn_winner as *const _ as usize },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(inode),
                "::",
                stringify!(i_wb_frn_winner)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode>())).i_wb_frn_avg_time as *const _ as usize },
            260usize,
            concat!(
                "Offset of field: ",
                stringify!(inode),
                "::",
                stringify!(i_wb_frn_avg_time)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode>())).i_wb_frn_history as *const _ as usize },
            262usize,
            concat!(
                "Offset of field: ",
                stringify!(inode),
                "::",
                stringify!(i_wb_frn_history)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode>())).i_lru as *const _ as usize },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(inode),
                "::",
                stringify!(i_lru)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode>())).i_sb_list as *const _ as usize },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(inode),
                "::",
                stringify!(i_sb_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode>())).i_wb_list as *const _ as usize },
            296usize,
            concat!(
                "Offset of field: ",
                stringify!(inode),
                "::",
                stringify!(i_wb_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode>())).i_version as *const _ as usize },
            328usize,
            concat!(
                "Offset of field: ",
                stringify!(inode),
                "::",
                stringify!(i_version)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode>())).i_sequence as *const _ as usize },
            336usize,
            concat!(
                "Offset of field: ",
                stringify!(inode),
                "::",
                stringify!(i_sequence)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode>())).i_count as *const _ as usize },
            344usize,
            concat!(
                "Offset of field: ",
                stringify!(inode),
                "::",
                stringify!(i_count)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode>())).i_dio_count as *const _ as usize },
            348usize,
            concat!(
                "Offset of field: ",
                stringify!(inode),
                "::",
                stringify!(i_dio_count)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode>())).i_writecount as *const _ as usize },
            352usize,
            concat!(
                "Offset of field: ",
                stringify!(inode),
                "::",
                stringify!(i_writecount)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode>())).i_readcount as *const _ as usize },
            356usize,
            concat!(
                "Offset of field: ",
                stringify!(inode),
                "::",
                stringify!(i_readcount)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode>())).i_flctx as *const _ as usize },
            368usize,
            concat!(
                "Offset of field: ",
                stringify!(inode),
                "::",
                stringify!(i_flctx)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode>())).i_data as *const _ as usize },
            376usize,
            concat!(
                "Offset of field: ",
                stringify!(inode),
                "::",
                stringify!(i_data)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode>())).i_devices as *const _ as usize },
            568usize,
            concat!(
                "Offset of field: ",
                stringify!(inode),
                "::",
                stringify!(i_devices)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode>())).i_generation as *const _ as usize },
            592usize,
            concat!(
                "Offset of field: ",
                stringify!(inode),
                "::",
                stringify!(i_generation)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode>())).i_fsnotify_mask as *const _ as usize },
            596usize,
            concat!(
                "Offset of field: ",
                stringify!(inode),
                "::",
                stringify!(i_fsnotify_mask)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode>())).i_fsnotify_marks as *const _ as usize },
            600usize,
            concat!(
                "Offset of field: ",
                stringify!(inode),
                "::",
                stringify!(i_fsnotify_marks)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode>())).i_crypt_info as *const _ as usize },
            608usize,
            concat!(
                "Offset of field: ",
                stringify!(inode),
                "::",
                stringify!(i_crypt_info)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode>())).i_verity_info as *const _ as usize },
            616usize,
            concat!(
                "Offset of field: ",
                stringify!(inode),
                "::",
                stringify!(i_verity_info)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode>())).i_private as *const _ as usize },
            624usize,
            concat!(
                "Offset of field: ",
                stringify!(inode),
                "::",
                stringify!(i_private)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct fown_struct {
        pub lock: rwlock_t,
        pub pid: *mut pid,
        pub pid_type: pid_type,
        pub uid: kuid_t,
        pub euid: kuid_t,
        pub signum: ::cty::c_int,
    }
    #[test]
    fn bindgen_test_layout_fown_struct() {
        assert_eq!(
            ::core::mem::size_of::<fown_struct>(),
            32usize,
            concat!("Size of: ", stringify!(fown_struct))
        );
        assert_eq!(
            ::core::mem::align_of::<fown_struct>(),
            8usize,
            concat!("Alignment of ", stringify!(fown_struct))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fown_struct>())).lock as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fown_struct),
                "::",
                stringify!(lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fown_struct>())).pid as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fown_struct),
                "::",
                stringify!(pid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fown_struct>())).pid_type as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fown_struct),
                "::",
                stringify!(pid_type)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fown_struct>())).uid as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(fown_struct),
                "::",
                stringify!(uid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fown_struct>())).euid as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(fown_struct),
                "::",
                stringify!(euid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fown_struct>())).signum as *const _ as usize },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(fown_struct),
                "::",
                stringify!(signum)
            )
        );
    }
    #[doc = " struct file_ra_state - Track a file's readahead state."]
    #[doc = " @start: Where the most recent readahead started."]
    #[doc = " @size: Number of pages read in the most recent readahead."]
    #[doc = " @async_size: Numer of pages that were/are not needed immediately"]
    #[doc = "      and so were/are genuinely \"ahead\".  Start next readahead when"]
    #[doc = "      the first of these pages is accessed."]
    #[doc = " @ra_pages: Maximum size of a readahead request, copied from the bdi."]
    #[doc = " @mmap_miss: How many mmap accesses missed in the page cache."]
    #[doc = " @prev_pos: The last byte in the most recent read request."]
    #[doc = ""]
    #[doc = " When this structure is passed to ->readahead(), the \"most recent\""]
    #[doc = " readahead means the current readahead."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct file_ra_state {
        pub start: ::cty::c_ulong,
        pub size: ::cty::c_uint,
        pub async_size: ::cty::c_uint,
        pub ra_pages: ::cty::c_uint,
        pub mmap_miss: ::cty::c_uint,
        pub prev_pos: loff_t,
    }
    #[test]
    fn bindgen_test_layout_file_ra_state() {
        assert_eq!(
            ::core::mem::size_of::<file_ra_state>(),
            32usize,
            concat!("Size of: ", stringify!(file_ra_state))
        );
        assert_eq!(
            ::core::mem::align_of::<file_ra_state>(),
            8usize,
            concat!("Alignment of ", stringify!(file_ra_state))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file_ra_state>())).start as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(file_ra_state),
                "::",
                stringify!(start)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file_ra_state>())).size as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(file_ra_state),
                "::",
                stringify!(size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file_ra_state>())).async_size as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(file_ra_state),
                "::",
                stringify!(async_size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file_ra_state>())).ra_pages as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(file_ra_state),
                "::",
                stringify!(ra_pages)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file_ra_state>())).mmap_miss as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(file_ra_state),
                "::",
                stringify!(mmap_miss)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file_ra_state>())).prev_pos as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(file_ra_state),
                "::",
                stringify!(prev_pos)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct file {
        pub __bindgen_anon_1: file__bindgen_ty_1,
        pub f_lock: spinlock_t,
        pub f_mode: fmode_t,
        pub f_count: atomic_long_t,
        pub f_pos_lock: mutex,
        pub f_pos: loff_t,
        pub f_flags: ::cty::c_uint,
        pub f_owner: fown_struct,
        pub f_cred: *const cred,
        pub f_ra: file_ra_state,
        pub f_path: path,
        pub f_inode: *mut inode,
        pub f_op: *const file_operations,
        pub f_version: _cargo_bpf_u64,
        pub f_security: *mut ::cty::c_void,
        pub private_data: *mut ::cty::c_void,
        pub f_ep: *mut hlist_head,
        pub f_mapping: *mut address_space,
        pub f_wb_err: errseq_t,
        pub f_sb_err: errseq_t,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union file__bindgen_ty_1 {
        pub f_llist: llist_node,
        pub f_rcuhead: callback_head,
        pub f_iocb_flags: ::cty::c_uint,
    }
    #[test]
    fn bindgen_test_layout_file__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<file__bindgen_ty_1>(),
            16usize,
            concat!("Size of: ", stringify!(file__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<file__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(file__bindgen_ty_1))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file__bindgen_ty_1>())).f_llist as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(file__bindgen_ty_1),
                "::",
                stringify!(f_llist)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<file__bindgen_ty_1>())).f_rcuhead as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(file__bindgen_ty_1),
                "::",
                stringify!(f_rcuhead)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<file__bindgen_ty_1>())).f_iocb_flags as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(file__bindgen_ty_1),
                "::",
                stringify!(f_iocb_flags)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_file() {
        assert_eq!(
            ::core::mem::size_of::<file>(),
            232usize,
            concat!("Size of: ", stringify!(file))
        );
        assert_eq!(
            ::core::mem::align_of::<file>(),
            8usize,
            concat!("Alignment of ", stringify!(file))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file>())).f_lock as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(file),
                "::",
                stringify!(f_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file>())).f_mode as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(file),
                "::",
                stringify!(f_mode)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file>())).f_count as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(file),
                "::",
                stringify!(f_count)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file>())).f_pos_lock as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(file),
                "::",
                stringify!(f_pos_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file>())).f_pos as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(file),
                "::",
                stringify!(f_pos)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file>())).f_flags as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(file),
                "::",
                stringify!(f_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file>())).f_owner as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(file),
                "::",
                stringify!(f_owner)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file>())).f_cred as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(file),
                "::",
                stringify!(f_cred)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file>())).f_ra as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(file),
                "::",
                stringify!(f_ra)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file>())).f_path as *const _ as usize },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(file),
                "::",
                stringify!(f_path)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file>())).f_inode as *const _ as usize },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(file),
                "::",
                stringify!(f_inode)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file>())).f_op as *const _ as usize },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(file),
                "::",
                stringify!(f_op)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file>())).f_version as *const _ as usize },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(file),
                "::",
                stringify!(f_version)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file>())).f_security as *const _ as usize },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(file),
                "::",
                stringify!(f_security)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file>())).private_data as *const _ as usize },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(file),
                "::",
                stringify!(private_data)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file>())).f_ep as *const _ as usize },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(file),
                "::",
                stringify!(f_ep)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file>())).f_mapping as *const _ as usize },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(file),
                "::",
                stringify!(f_mapping)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file>())).f_wb_err as *const _ as usize },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(file),
                "::",
                stringify!(f_wb_err)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<file>())).f_sb_err as *const _ as usize },
            228usize,
            concat!(
                "Offset of field: ",
                stringify!(file),
                "::",
                stringify!(f_sb_err)
            )
        );
    }
    pub type fl_owner_t = *mut ::cty::c_void;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct file_lock {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct fasync_struct {
        pub fa_lock: rwlock_t,
        pub magic: ::cty::c_int,
        pub fa_fd: ::cty::c_int,
        pub fa_next: *mut fasync_struct,
        pub fa_file: *mut file,
        pub fa_rcu: callback_head,
    }
    #[test]
    fn bindgen_test_layout_fasync_struct() {
        assert_eq!(
            ::core::mem::size_of::<fasync_struct>(),
            48usize,
            concat!("Size of: ", stringify!(fasync_struct))
        );
        assert_eq!(
            ::core::mem::align_of::<fasync_struct>(),
            8usize,
            concat!("Alignment of ", stringify!(fasync_struct))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fasync_struct>())).fa_lock as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fasync_struct),
                "::",
                stringify!(fa_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fasync_struct>())).magic as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fasync_struct),
                "::",
                stringify!(magic)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fasync_struct>())).fa_fd as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(fasync_struct),
                "::",
                stringify!(fa_fd)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fasync_struct>())).fa_next as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fasync_struct),
                "::",
                stringify!(fa_next)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fasync_struct>())).fa_file as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(fasync_struct),
                "::",
                stringify!(fa_file)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fasync_struct>())).fa_rcu as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(fasync_struct),
                "::",
                stringify!(fa_rcu)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct sb_writers {
        pub frozen: ::cty::c_int,
        pub rw_sem: [percpu_rw_semaphore; 3usize],
    }
    #[test]
    fn bindgen_test_layout_sb_writers() {
        assert_eq!(
            ::core::mem::size_of::<sb_writers>(),
            296usize,
            concat!("Size of: ", stringify!(sb_writers))
        );
        assert_eq!(
            ::core::mem::align_of::<sb_writers>(),
            8usize,
            concat!("Alignment of ", stringify!(sb_writers))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sb_writers>())).frozen as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sb_writers),
                "::",
                stringify!(frozen)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sb_writers>())).rw_sem as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sb_writers),
                "::",
                stringify!(rw_sem)
            )
        );
    }
    #[repr(C)]
    #[repr(align(64))]
    #[derive(Copy, Clone)]
    pub struct super_block {
        pub s_list: list_head,
        pub s_dev: dev_t,
        pub s_blocksize_bits: ::cty::c_uchar,
        pub s_blocksize: ::cty::c_ulong,
        pub s_maxbytes: loff_t,
        pub s_type: *mut file_system_type,
        pub s_op: *const super_operations,
        pub dq_op: *const dquot_operations,
        pub s_qcop: *const quotactl_ops,
        pub s_export_op: *const export_operations,
        pub s_flags: ::cty::c_ulong,
        pub s_iflags: ::cty::c_ulong,
        pub s_magic: ::cty::c_ulong,
        pub s_root: *mut dentry,
        pub s_umount: rw_semaphore,
        pub s_count: ::cty::c_int,
        pub s_active: atomic_t,
        pub s_security: *mut ::cty::c_void,
        pub s_xattr: *mut *mut xattr_handler,
        pub s_cop: *const fscrypt_operations,
        pub s_master_keys: *mut fscrypt_keyring,
        pub s_vop: *const fsverity_operations,
        pub s_encoding: *mut unicode_map,
        pub s_encoding_flags: __u16,
        pub s_roots: hlist_bl_head,
        pub s_mounts: list_head,
        pub s_bdev: *mut block_device,
        pub s_bdi: *mut backing_dev_info,
        pub s_mtd: *mut mtd_info,
        pub s_instances: hlist_node,
        pub s_quota_types: ::cty::c_uint,
        pub s_dquot: quota_info,
        pub s_writers: sb_writers,
        pub s_fs_info: *mut ::cty::c_void,
        pub s_time_gran: _cargo_bpf_u32,
        pub s_time_min: time64_t,
        pub s_time_max: time64_t,
        pub s_fsnotify_mask: __u32,
        pub s_fsnotify_marks: *mut fsnotify_mark_connector,
        pub s_id: [::cty::c_char; 32usize],
        pub s_uuid: uuid_t,
        pub s_max_links: ::cty::c_uint,
        pub s_vfs_rename_mutex: mutex,
        pub s_subtype: *const ::cty::c_char,
        pub s_d_op: *const dentry_operations,
        pub s_shrink: shrinker,
        pub s_remove_count: atomic_long_t,
        pub s_fsnotify_connectors: atomic_long_t,
        pub s_readonly_remount: ::cty::c_int,
        pub s_wb_err: errseq_t,
        pub s_dio_done_wq: *mut workqueue_struct,
        pub s_pins: hlist_head,
        pub s_user_ns: *mut user_namespace,
        pub s_dentry_lru: list_lru,
        pub s_inode_lru: list_lru,
        pub rcu: callback_head,
        pub destroy_work: work_struct,
        pub s_sync_lock: mutex,
        pub s_stack_depth: ::cty::c_int,
        pub __bindgen_padding_0: u32,
        pub s_inode_list_lock: spinlock_t,
        pub s_inodes: list_head,
        pub s_inode_wblist_lock: spinlock_t,
        pub s_inodes_wb: list_head,
    }
    #[test]
    fn bindgen_test_layout_super_block() {
        assert_eq!(
            ::core::mem::size_of::<super_block>(),
            1408usize,
            concat!("Size of: ", stringify!(super_block))
        );
        assert_eq!(
            ::core::mem::align_of::<super_block>(),
            64usize,
            concat!("Alignment of ", stringify!(super_block))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).s_list as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).s_dev as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_dev)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<super_block>())).s_blocksize_bits as *const _ as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_blocksize_bits)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).s_blocksize as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_blocksize)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).s_maxbytes as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_maxbytes)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).s_type as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_type)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).s_op as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_op)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).dq_op as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(dq_op)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).s_qcop as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_qcop)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).s_export_op as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_export_op)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).s_flags as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).s_iflags as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_iflags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).s_magic as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_magic)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).s_root as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_root)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).s_umount as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_umount)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).s_count as *const _ as usize },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_count)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).s_active as *const _ as usize },
            156usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_active)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).s_security as *const _ as usize },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_security)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).s_xattr as *const _ as usize },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_xattr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).s_cop as *const _ as usize },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_cop)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).s_master_keys as *const _ as usize },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_master_keys)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).s_vop as *const _ as usize },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_vop)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).s_encoding as *const _ as usize },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_encoding)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<super_block>())).s_encoding_flags as *const _ as usize
            },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_encoding_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).s_roots as *const _ as usize },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_roots)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).s_mounts as *const _ as usize },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_mounts)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).s_bdev as *const _ as usize },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_bdev)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).s_bdi as *const _ as usize },
            248usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_bdi)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).s_mtd as *const _ as usize },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_mtd)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).s_instances as *const _ as usize },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_instances)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).s_quota_types as *const _ as usize },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_quota_types)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).s_dquot as *const _ as usize },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_dquot)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).s_writers as *const _ as usize },
            600usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_writers)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).s_fs_info as *const _ as usize },
            896usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_fs_info)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).s_time_gran as *const _ as usize },
            904usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_time_gran)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).s_time_min as *const _ as usize },
            912usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_time_min)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).s_time_max as *const _ as usize },
            920usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_time_max)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<super_block>())).s_fsnotify_mask as *const _ as usize
            },
            928usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_fsnotify_mask)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<super_block>())).s_fsnotify_marks as *const _ as usize
            },
            936usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_fsnotify_marks)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).s_id as *const _ as usize },
            944usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_id)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).s_uuid as *const _ as usize },
            976usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_uuid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).s_max_links as *const _ as usize },
            992usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_max_links)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<super_block>())).s_vfs_rename_mutex as *const _ as usize
            },
            1000usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_vfs_rename_mutex)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).s_subtype as *const _ as usize },
            1032usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_subtype)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).s_d_op as *const _ as usize },
            1040usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_d_op)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).s_shrink as *const _ as usize },
            1048usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_shrink)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).s_remove_count as *const _ as usize },
            1112usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_remove_count)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<super_block>())).s_fsnotify_connectors as *const _ as usize
            },
            1120usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_fsnotify_connectors)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<super_block>())).s_readonly_remount as *const _ as usize
            },
            1128usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_readonly_remount)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).s_wb_err as *const _ as usize },
            1132usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_wb_err)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).s_dio_done_wq as *const _ as usize },
            1136usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_dio_done_wq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).s_pins as *const _ as usize },
            1144usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_pins)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).s_user_ns as *const _ as usize },
            1152usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_user_ns)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).s_dentry_lru as *const _ as usize },
            1160usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_dentry_lru)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).s_inode_lru as *const _ as usize },
            1208usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_inode_lru)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).rcu as *const _ as usize },
            1256usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(rcu)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).destroy_work as *const _ as usize },
            1272usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(destroy_work)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).s_sync_lock as *const _ as usize },
            1304usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_sync_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).s_stack_depth as *const _ as usize },
            1336usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_stack_depth)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<super_block>())).s_inode_list_lock as *const _ as usize
            },
            1344usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_inode_list_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).s_inodes as *const _ as usize },
            1352usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_inodes)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<super_block>())).s_inode_wblist_lock as *const _ as usize
            },
            1368usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_inode_wblist_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_block>())).s_inodes_wb as *const _ as usize },
            1376usize,
            concat!(
                "Offset of field: ",
                stringify!(super_block),
                "::",
                stringify!(s_inodes_wb)
            )
        );
    }
    pub type filldir_t = ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dir_context,
            arg2: *const ::cty::c_char,
            arg3: ::cty::c_int,
            arg4: loff_t,
            arg5: _cargo_bpf_u64,
            arg6: ::cty::c_uint,
        ) -> bool_,
    >;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dir_context {
        pub actor: filldir_t,
        pub pos: loff_t,
    }
    #[test]
    fn bindgen_test_layout_dir_context() {
        assert_eq!(
            ::core::mem::size_of::<dir_context>(),
            16usize,
            concat!("Size of: ", stringify!(dir_context))
        );
        assert_eq!(
            ::core::mem::align_of::<dir_context>(),
            8usize,
            concat!("Alignment of ", stringify!(dir_context))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dir_context>())).actor as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(dir_context),
                "::",
                stringify!(actor)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dir_context>())).pos as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(dir_context),
                "::",
                stringify!(pos)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct io_uring_cmd {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[repr(align(64))]
    #[derive(Debug, Copy, Clone)]
    pub struct inode_operations {
        pub lookup: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: *mut dentry,
                arg3: ::cty::c_uint,
            ) -> *mut dentry,
        >,
        pub get_link: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dentry,
                arg2: *mut inode,
                arg3: *mut delayed_call,
            ) -> *const ::cty::c_char,
        >,
        pub permission: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut mnt_idmap,
                arg2: *mut inode,
                arg3: ::cty::c_int,
            ) -> ::cty::c_int,
        >,
        pub get_inode_acl: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: ::cty::c_int,
                arg3: bool_,
            ) -> *mut posix_acl,
        >,
        pub readlink: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dentry,
                arg2: *mut ::cty::c_char,
                arg3: ::cty::c_int,
            ) -> ::cty::c_int,
        >,
        pub create: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut mnt_idmap,
                arg2: *mut inode,
                arg3: *mut dentry,
                arg4: umode_t,
                arg5: bool_,
            ) -> ::cty::c_int,
        >,
        pub link: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dentry,
                arg2: *mut inode,
                arg3: *mut dentry,
            ) -> ::cty::c_int,
        >,
        pub unlink: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut inode, arg2: *mut dentry) -> ::cty::c_int,
        >,
        pub symlink: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut mnt_idmap,
                arg2: *mut inode,
                arg3: *mut dentry,
                arg4: *const ::cty::c_char,
            ) -> ::cty::c_int,
        >,
        pub mkdir: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut mnt_idmap,
                arg2: *mut inode,
                arg3: *mut dentry,
                arg4: umode_t,
            ) -> ::cty::c_int,
        >,
        pub rmdir: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut inode, arg2: *mut dentry) -> ::cty::c_int,
        >,
        pub mknod: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut mnt_idmap,
                arg2: *mut inode,
                arg3: *mut dentry,
                arg4: umode_t,
                arg5: dev_t,
            ) -> ::cty::c_int,
        >,
        pub rename: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut mnt_idmap,
                arg2: *mut inode,
                arg3: *mut dentry,
                arg4: *mut inode,
                arg5: *mut dentry,
                arg6: ::cty::c_uint,
            ) -> ::cty::c_int,
        >,
        pub setattr: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut mnt_idmap,
                arg2: *mut dentry,
                arg3: *mut iattr,
            ) -> ::cty::c_int,
        >,
        pub getattr: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut mnt_idmap,
                arg2: *const path,
                arg3: *mut kstat,
                arg4: _cargo_bpf_u32,
                arg5: ::cty::c_uint,
            ) -> ::cty::c_int,
        >,
        pub listxattr: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dentry,
                arg2: *mut ::cty::c_char,
                arg3: size_t,
            ) -> ssize_t,
        >,
        pub fiemap: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: *mut fiemap_extent_info,
                start: _cargo_bpf_u64,
                len: _cargo_bpf_u64,
            ) -> ::cty::c_int,
        >,
        pub update_time: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: *mut timespec64,
                arg3: ::cty::c_int,
            ) -> ::cty::c_int,
        >,
        pub atomic_open: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: *mut dentry,
                arg3: *mut file,
                open_flag: ::cty::c_uint,
                create_mode: umode_t,
            ) -> ::cty::c_int,
        >,
        pub tmpfile: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut mnt_idmap,
                arg2: *mut inode,
                arg3: *mut file,
                arg4: umode_t,
            ) -> ::cty::c_int,
        >,
        pub get_acl: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut mnt_idmap,
                arg2: *mut dentry,
                arg3: ::cty::c_int,
            ) -> *mut posix_acl,
        >,
        pub set_acl: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut mnt_idmap,
                arg2: *mut dentry,
                arg3: *mut posix_acl,
                arg4: ::cty::c_int,
            ) -> ::cty::c_int,
        >,
        pub fileattr_set: ::core::option::Option<
            unsafe extern "C" fn(
                idmap: *mut mnt_idmap,
                dentry: *mut dentry,
                fa: *mut fileattr,
            ) -> ::cty::c_int,
        >,
        pub fileattr_get: ::core::option::Option<
            unsafe extern "C" fn(dentry: *mut dentry, fa: *mut fileattr) -> ::cty::c_int,
        >,
    }
    #[test]
    fn bindgen_test_layout_inode_operations() {
        assert_eq!(
            ::core::mem::size_of::<inode_operations>(),
            192usize,
            concat!("Size of: ", stringify!(inode_operations))
        );
        assert_eq!(
            ::core::mem::align_of::<inode_operations>(),
            64usize,
            concat!("Alignment of ", stringify!(inode_operations))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode_operations>())).lookup as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(inode_operations),
                "::",
                stringify!(lookup)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode_operations>())).get_link as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(inode_operations),
                "::",
                stringify!(get_link)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inode_operations>())).permission as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(inode_operations),
                "::",
                stringify!(permission)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inode_operations>())).get_inode_acl as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(inode_operations),
                "::",
                stringify!(get_inode_acl)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode_operations>())).readlink as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(inode_operations),
                "::",
                stringify!(readlink)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode_operations>())).create as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(inode_operations),
                "::",
                stringify!(create)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode_operations>())).link as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(inode_operations),
                "::",
                stringify!(link)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode_operations>())).unlink as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(inode_operations),
                "::",
                stringify!(unlink)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode_operations>())).symlink as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(inode_operations),
                "::",
                stringify!(symlink)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode_operations>())).mkdir as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(inode_operations),
                "::",
                stringify!(mkdir)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode_operations>())).rmdir as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(inode_operations),
                "::",
                stringify!(rmdir)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode_operations>())).mknod as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(inode_operations),
                "::",
                stringify!(mknod)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode_operations>())).rename as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(inode_operations),
                "::",
                stringify!(rename)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode_operations>())).setattr as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(inode_operations),
                "::",
                stringify!(setattr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode_operations>())).getattr as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(inode_operations),
                "::",
                stringify!(getattr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode_operations>())).listxattr as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(inode_operations),
                "::",
                stringify!(listxattr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode_operations>())).fiemap as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(inode_operations),
                "::",
                stringify!(fiemap)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inode_operations>())).update_time as *const _ as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(inode_operations),
                "::",
                stringify!(update_time)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inode_operations>())).atomic_open as *const _ as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(inode_operations),
                "::",
                stringify!(atomic_open)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode_operations>())).tmpfile as *const _ as usize },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(inode_operations),
                "::",
                stringify!(tmpfile)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode_operations>())).get_acl as *const _ as usize },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(inode_operations),
                "::",
                stringify!(get_acl)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inode_operations>())).set_acl as *const _ as usize },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(inode_operations),
                "::",
                stringify!(set_acl)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inode_operations>())).fileattr_set as *const _ as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(inode_operations),
                "::",
                stringify!(fileattr_set)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inode_operations>())).fileattr_get as *const _ as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(inode_operations),
                "::",
                stringify!(fileattr_get)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct super_operations {
        pub alloc_inode:
            ::core::option::Option<unsafe extern "C" fn(sb: *mut super_block) -> *mut inode>,
        pub destroy_inode: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode)>,
        pub free_inode: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode)>,
        pub dirty_inode:
            ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode, flags: ::cty::c_int)>,
        pub write_inode: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut inode, wbc: *mut writeback_control) -> ::cty::c_int,
        >,
        pub drop_inode:
            ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode) -> ::cty::c_int>,
        pub evict_inode: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode)>,
        pub put_super: ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block)>,
        pub sync_fs: ::core::option::Option<
            unsafe extern "C" fn(sb: *mut super_block, wait: ::cty::c_int) -> ::cty::c_int,
        >,
        pub freeze_super:
            ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block) -> ::cty::c_int>,
        pub freeze_fs:
            ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block) -> ::cty::c_int>,
        pub thaw_super:
            ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block) -> ::cty::c_int>,
        pub unfreeze_fs:
            ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block) -> ::cty::c_int>,
        pub statfs: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut dentry, arg2: *mut kstatfs) -> ::cty::c_int,
        >,
        pub remount_fs: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: *mut ::cty::c_int,
                arg3: *mut ::cty::c_char,
            ) -> ::cty::c_int,
        >,
        pub umount_begin: ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block)>,
        pub show_options: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut dentry) -> ::cty::c_int,
        >,
        pub show_devname: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut dentry) -> ::cty::c_int,
        >,
        pub show_path: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut dentry) -> ::cty::c_int,
        >,
        pub show_stats: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut dentry) -> ::cty::c_int,
        >,
        pub quota_read: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: ::cty::c_int,
                arg3: *mut ::cty::c_char,
                arg4: size_t,
                arg5: loff_t,
            ) -> ssize_t,
        >,
        pub quota_write: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: ::cty::c_int,
                arg3: *const ::cty::c_char,
                arg4: size_t,
                arg5: loff_t,
            ) -> ssize_t,
        >,
        pub get_dquots:
            ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode) -> *mut *mut dquot>,
        pub nr_cached_objects: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: *mut shrink_control,
            ) -> ::cty::c_long,
        >,
        pub free_cached_objects: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: *mut shrink_control,
            ) -> ::cty::c_long,
        >,
        pub shutdown: ::core::option::Option<unsafe extern "C" fn(sb: *mut super_block)>,
    }
    #[test]
    fn bindgen_test_layout_super_operations() {
        assert_eq!(
            ::core::mem::size_of::<super_operations>(),
            208usize,
            concat!("Size of: ", stringify!(super_operations))
        );
        assert_eq!(
            ::core::mem::align_of::<super_operations>(),
            8usize,
            concat!("Alignment of ", stringify!(super_operations))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<super_operations>())).alloc_inode as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(super_operations),
                "::",
                stringify!(alloc_inode)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<super_operations>())).destroy_inode as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(super_operations),
                "::",
                stringify!(destroy_inode)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<super_operations>())).free_inode as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(super_operations),
                "::",
                stringify!(free_inode)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<super_operations>())).dirty_inode as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(super_operations),
                "::",
                stringify!(dirty_inode)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<super_operations>())).write_inode as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(super_operations),
                "::",
                stringify!(write_inode)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<super_operations>())).drop_inode as *const _ as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(super_operations),
                "::",
                stringify!(drop_inode)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<super_operations>())).evict_inode as *const _ as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(super_operations),
                "::",
                stringify!(evict_inode)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_operations>())).put_super as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(super_operations),
                "::",
                stringify!(put_super)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_operations>())).sync_fs as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(super_operations),
                "::",
                stringify!(sync_fs)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<super_operations>())).freeze_super as *const _ as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(super_operations),
                "::",
                stringify!(freeze_super)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_operations>())).freeze_fs as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(super_operations),
                "::",
                stringify!(freeze_fs)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<super_operations>())).thaw_super as *const _ as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(super_operations),
                "::",
                stringify!(thaw_super)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<super_operations>())).unfreeze_fs as *const _ as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(super_operations),
                "::",
                stringify!(unfreeze_fs)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_operations>())).statfs as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(super_operations),
                "::",
                stringify!(statfs)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<super_operations>())).remount_fs as *const _ as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(super_operations),
                "::",
                stringify!(remount_fs)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<super_operations>())).umount_begin as *const _ as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(super_operations),
                "::",
                stringify!(umount_begin)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<super_operations>())).show_options as *const _ as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(super_operations),
                "::",
                stringify!(show_options)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<super_operations>())).show_devname as *const _ as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(super_operations),
                "::",
                stringify!(show_devname)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_operations>())).show_path as *const _ as usize },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(super_operations),
                "::",
                stringify!(show_path)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<super_operations>())).show_stats as *const _ as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(super_operations),
                "::",
                stringify!(show_stats)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<super_operations>())).quota_read as *const _ as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(super_operations),
                "::",
                stringify!(quota_read)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<super_operations>())).quota_write as *const _ as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(super_operations),
                "::",
                stringify!(quota_write)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<super_operations>())).get_dquots as *const _ as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(super_operations),
                "::",
                stringify!(get_dquots)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<super_operations>())).nr_cached_objects as *const _ as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(super_operations),
                "::",
                stringify!(nr_cached_objects)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<super_operations>())).free_cached_objects as *const _
                    as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(super_operations),
                "::",
                stringify!(free_cached_objects)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<super_operations>())).shutdown as *const _ as usize },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(super_operations),
                "::",
                stringify!(shutdown)
            )
        );
    }
    #[doc = " struct vmem_altmap - pre-allocated storage for vmemmap_populate"]
    #[doc = " @base_pfn: base of the entire dev_pagemap mapping"]
    #[doc = " @reserve: pages mapped, but reserved for driver use (relative to @base)"]
    #[doc = " @free: free pages set aside in the mapping for memmap storage"]
    #[doc = " @align: pages reserved to meet allocation alignments"]
    #[doc = " @alloc: track pages consumed, private to vmemmap_populate()"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct vmem_altmap {
        pub base_pfn: ::cty::c_ulong,
        pub end_pfn: ::cty::c_ulong,
        pub reserve: ::cty::c_ulong,
        pub free: ::cty::c_ulong,
        pub align: ::cty::c_ulong,
        pub alloc: ::cty::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_vmem_altmap() {
        assert_eq!(
            ::core::mem::size_of::<vmem_altmap>(),
            48usize,
            concat!("Size of: ", stringify!(vmem_altmap))
        );
        assert_eq!(
            ::core::mem::align_of::<vmem_altmap>(),
            8usize,
            concat!("Alignment of ", stringify!(vmem_altmap))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vmem_altmap>())).base_pfn as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(vmem_altmap),
                "::",
                stringify!(base_pfn)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vmem_altmap>())).end_pfn as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(vmem_altmap),
                "::",
                stringify!(end_pfn)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vmem_altmap>())).reserve as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(vmem_altmap),
                "::",
                stringify!(reserve)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vmem_altmap>())).free as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(vmem_altmap),
                "::",
                stringify!(free)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vmem_altmap>())).align as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(vmem_altmap),
                "::",
                stringify!(align)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vmem_altmap>())).alloc as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(vmem_altmap),
                "::",
                stringify!(alloc)
            )
        );
    }
    pub const memory_type_MEMORY_DEVICE_PRIVATE: memory_type = 1;
    pub const memory_type_MEMORY_DEVICE_COHERENT: memory_type = 2;
    pub const memory_type_MEMORY_DEVICE_FS_DAX: memory_type = 3;
    pub const memory_type_MEMORY_DEVICE_GENERIC: memory_type = 4;
    pub const memory_type_MEMORY_DEVICE_PCI_P2PDMA: memory_type = 5;
    pub type memory_type = ::cty::c_uint;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dev_pagemap_ops {
        pub page_free: ::core::option::Option<unsafe extern "C" fn(page: *mut page)>,
        pub migrate_to_ram:
            ::core::option::Option<unsafe extern "C" fn(vmf: *mut vm_fault) -> vm_fault_t>,
        pub memory_failure: ::core::option::Option<
            unsafe extern "C" fn(
                pgmap: *mut dev_pagemap,
                pfn: ::cty::c_ulong,
                nr_pages: ::cty::c_ulong,
                mf_flags: ::cty::c_int,
            ) -> ::cty::c_int,
        >,
    }
    #[test]
    fn bindgen_test_layout_dev_pagemap_ops() {
        assert_eq!(
            ::core::mem::size_of::<dev_pagemap_ops>(),
            24usize,
            concat!("Size of: ", stringify!(dev_pagemap_ops))
        );
        assert_eq!(
            ::core::mem::align_of::<dev_pagemap_ops>(),
            8usize,
            concat!("Alignment of ", stringify!(dev_pagemap_ops))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pagemap_ops>())).page_free as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pagemap_ops),
                "::",
                stringify!(page_free)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<dev_pagemap_ops>())).migrate_to_ram as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pagemap_ops),
                "::",
                stringify!(migrate_to_ram)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<dev_pagemap_ops>())).memory_failure as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pagemap_ops),
                "::",
                stringify!(memory_failure)
            )
        );
    }
    #[doc = " struct dev_pagemap - metadata for ZONE_DEVICE mappings"]
    #[doc = " @altmap: pre-allocated/reserved memory for vmemmap allocations"]
    #[doc = " @ref: reference count that pins the devm_memremap_pages() mapping"]
    #[doc = " @done: completion for @ref"]
    #[doc = " @type: memory type: see MEMORY_* in memory_hotplug.h"]
    #[doc = " @flags: PGMAP_* flags to specify defailed behavior"]
    #[doc = " @vmemmap_shift: structural definition of how the vmemmap page metadata"]
    #[doc = "      is populated, specifically the metadata page order."]
    #[doc = "\tA zero value (default) uses base pages as the vmemmap metadata"]
    #[doc = "\trepresentation. A bigger value will set up compound struct pages"]
    #[doc = "\tof the requested order value."]
    #[doc = " @ops: method table"]
    #[doc = " @owner: an opaque pointer identifying the entity that manages this"]
    #[doc = "\tinstance.  Used by various helpers to make sure that no"]
    #[doc = "\tforeign ZONE_DEVICE memory is accessed."]
    #[doc = " @nr_range: number of ranges to be mapped"]
    #[doc = " @range: range to be mapped when nr_range == 1"]
    #[doc = " @ranges: array of ranges to be mapped when nr_range > 1"]
    #[repr(C)]
    pub struct dev_pagemap {
        pub altmap: vmem_altmap,
        pub ref_: percpu_ref,
        pub done: completion,
        pub type_: memory_type,
        pub flags: ::cty::c_uint,
        pub vmemmap_shift: ::cty::c_ulong,
        pub ops: *const dev_pagemap_ops,
        pub owner: *mut ::cty::c_void,
        pub nr_range: ::cty::c_int,
        pub __bindgen_anon_1: dev_pagemap__bindgen_ty_1,
    }
    #[repr(C)]
    pub struct dev_pagemap__bindgen_ty_1 {
        pub range: __BindgenUnionField<range>,
        pub __bindgen_anon_1: __BindgenUnionField<dev_pagemap__bindgen_ty_1__bindgen_ty_1>,
        pub bindgen_union_field: [u64; 2usize],
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct dev_pagemap__bindgen_ty_1__bindgen_ty_1 {
        pub __empty_ranges: dev_pagemap__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
        pub ranges: __IncompleteArrayField<range>,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dev_pagemap__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {}
    #[test]
    fn bindgen_test_layout_dev_pagemap__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<dev_pagemap__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
            0usize,
            concat!(
                "Size of: ",
                stringify!(dev_pagemap__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<dev_pagemap__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
            1usize,
            concat!(
                "Alignment of ",
                stringify!(dev_pagemap__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_dev_pagemap__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<dev_pagemap__bindgen_ty_1__bindgen_ty_1>(),
            0usize,
            concat!(
                "Size of: ",
                stringify!(dev_pagemap__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<dev_pagemap__bindgen_ty_1__bindgen_ty_1>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(dev_pagemap__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<dev_pagemap__bindgen_ty_1__bindgen_ty_1>())).__empty_ranges
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pagemap__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(__empty_ranges)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<dev_pagemap__bindgen_ty_1__bindgen_ty_1>())).ranges
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pagemap__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(ranges)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_dev_pagemap__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<dev_pagemap__bindgen_ty_1>(),
            16usize,
            concat!("Size of: ", stringify!(dev_pagemap__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<dev_pagemap__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(dev_pagemap__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<dev_pagemap__bindgen_ty_1>())).range as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pagemap__bindgen_ty_1),
                "::",
                stringify!(range)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_dev_pagemap() {
        assert_eq!(
            ::core::mem::size_of::<dev_pagemap>(),
            152usize,
            concat!("Size of: ", stringify!(dev_pagemap))
        );
        assert_eq!(
            ::core::mem::align_of::<dev_pagemap>(),
            8usize,
            concat!("Alignment of ", stringify!(dev_pagemap))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pagemap>())).altmap as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pagemap),
                "::",
                stringify!(altmap)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pagemap>())).ref_ as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pagemap),
                "::",
                stringify!(ref_)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pagemap>())).done as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pagemap),
                "::",
                stringify!(done)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pagemap>())).type_ as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pagemap),
                "::",
                stringify!(type_)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pagemap>())).flags as *const _ as usize },
            100usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pagemap),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pagemap>())).vmemmap_shift as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pagemap),
                "::",
                stringify!(vmemmap_shift)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pagemap>())).ops as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pagemap),
                "::",
                stringify!(ops)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pagemap>())).owner as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pagemap),
                "::",
                stringify!(owner)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pagemap>())).nr_range as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pagemap),
                "::",
                stringify!(nr_range)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct anon_vma {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct vm_fault {
        pub __bindgen_anon_1: vm_fault__bindgen_ty_1,
        pub flags: fault_flag,
        pub pmd: *mut pmd_t,
        pub pud: *mut pud_t,
        pub __bindgen_anon_2: vm_fault__bindgen_ty_2,
        pub cow_page: *mut page,
        pub page: *mut page,
        pub pte: *mut pte_t,
        pub ptl: *mut spinlock_t,
        pub prealloc_pte: pgtable_t,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct vm_fault__bindgen_ty_1 {
        pub vma: *mut vm_area_struct,
        pub gfp_mask: gfp_t,
        pub pgoff: ::cty::c_ulong,
        pub address: ::cty::c_ulong,
        pub real_address: ::cty::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_vm_fault__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<vm_fault__bindgen_ty_1>(),
            40usize,
            concat!("Size of: ", stringify!(vm_fault__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<vm_fault__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(vm_fault__bindgen_ty_1))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vm_fault__bindgen_ty_1>())).vma as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_fault__bindgen_ty_1),
                "::",
                stringify!(vma)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<vm_fault__bindgen_ty_1>())).gfp_mask as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_fault__bindgen_ty_1),
                "::",
                stringify!(gfp_mask)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<vm_fault__bindgen_ty_1>())).pgoff as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_fault__bindgen_ty_1),
                "::",
                stringify!(pgoff)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<vm_fault__bindgen_ty_1>())).address as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_fault__bindgen_ty_1),
                "::",
                stringify!(address)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<vm_fault__bindgen_ty_1>())).real_address as *const _
                    as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_fault__bindgen_ty_1),
                "::",
                stringify!(real_address)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union vm_fault__bindgen_ty_2 {
        pub orig_pte: pte_t,
        pub orig_pmd: pmd_t,
    }
    #[test]
    fn bindgen_test_layout_vm_fault__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<vm_fault__bindgen_ty_2>(),
            8usize,
            concat!("Size of: ", stringify!(vm_fault__bindgen_ty_2))
        );
        assert_eq!(
            ::core::mem::align_of::<vm_fault__bindgen_ty_2>(),
            8usize,
            concat!("Alignment of ", stringify!(vm_fault__bindgen_ty_2))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<vm_fault__bindgen_ty_2>())).orig_pte as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_fault__bindgen_ty_2),
                "::",
                stringify!(orig_pte)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<vm_fault__bindgen_ty_2>())).orig_pmd as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_fault__bindgen_ty_2),
                "::",
                stringify!(orig_pmd)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_vm_fault() {
        assert_eq!(
            ::core::mem::size_of::<vm_fault>(),
            112usize,
            concat!("Size of: ", stringify!(vm_fault))
        );
        assert_eq!(
            ::core::mem::align_of::<vm_fault>(),
            8usize,
            concat!("Alignment of ", stringify!(vm_fault))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vm_fault>())).flags as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_fault),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vm_fault>())).pmd as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_fault),
                "::",
                stringify!(pmd)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vm_fault>())).pud as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_fault),
                "::",
                stringify!(pud)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vm_fault>())).cow_page as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_fault),
                "::",
                stringify!(cow_page)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vm_fault>())).page as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_fault),
                "::",
                stringify!(page)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vm_fault>())).pte as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_fault),
                "::",
                stringify!(pte)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vm_fault>())).ptl as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_fault),
                "::",
                stringify!(ptl)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vm_fault>())).prealloc_pte as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_fault),
                "::",
                stringify!(prealloc_pte)
            )
        );
    }
    pub const page_entry_size_PE_SIZE_PTE: page_entry_size = 0;
    pub const page_entry_size_PE_SIZE_PMD: page_entry_size = 1;
    pub const page_entry_size_PE_SIZE_PUD: page_entry_size = 2;
    pub type page_entry_size = ::cty::c_uint;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct vm_operations_struct {
        pub open: ::core::option::Option<unsafe extern "C" fn(area: *mut vm_area_struct)>,
        #[doc = " @close: Called when the VMA is being removed from the MM."]
        #[doc = " Context: User context.  May sleep.  Caller holds mmap_lock."]
        pub close: ::core::option::Option<unsafe extern "C" fn(area: *mut vm_area_struct)>,
        pub may_split: ::core::option::Option<
            unsafe extern "C" fn(area: *mut vm_area_struct, addr: ::cty::c_ulong) -> ::cty::c_int,
        >,
        pub mremap:
            ::core::option::Option<unsafe extern "C" fn(area: *mut vm_area_struct) -> ::cty::c_int>,
        pub mprotect: ::core::option::Option<
            unsafe extern "C" fn(
                vma: *mut vm_area_struct,
                start: ::cty::c_ulong,
                end: ::cty::c_ulong,
                newflags: ::cty::c_ulong,
            ) -> ::cty::c_int,
        >,
        pub fault: ::core::option::Option<unsafe extern "C" fn(vmf: *mut vm_fault) -> vm_fault_t>,
        pub huge_fault: ::core::option::Option<
            unsafe extern "C" fn(vmf: *mut vm_fault, pe_size: page_entry_size) -> vm_fault_t,
        >,
        pub map_pages: ::core::option::Option<
            unsafe extern "C" fn(
                vmf: *mut vm_fault,
                start_pgoff: ::cty::c_ulong,
                end_pgoff: ::cty::c_ulong,
            ) -> vm_fault_t,
        >,
        pub pagesize: ::core::option::Option<
            unsafe extern "C" fn(area: *mut vm_area_struct) -> ::cty::c_ulong,
        >,
        pub page_mkwrite:
            ::core::option::Option<unsafe extern "C" fn(vmf: *mut vm_fault) -> vm_fault_t>,
        pub pfn_mkwrite:
            ::core::option::Option<unsafe extern "C" fn(vmf: *mut vm_fault) -> vm_fault_t>,
        pub access: ::core::option::Option<
            unsafe extern "C" fn(
                vma: *mut vm_area_struct,
                addr: ::cty::c_ulong,
                buf: *mut ::cty::c_void,
                len: ::cty::c_int,
                write: ::cty::c_int,
            ) -> ::cty::c_int,
        >,
        pub name: ::core::option::Option<
            unsafe extern "C" fn(vma: *mut vm_area_struct) -> *const ::cty::c_char,
        >,
        pub set_policy: ::core::option::Option<
            unsafe extern "C" fn(vma: *mut vm_area_struct, new: *mut mempolicy) -> ::cty::c_int,
        >,
        pub get_policy: ::core::option::Option<
            unsafe extern "C" fn(vma: *mut vm_area_struct, addr: ::cty::c_ulong) -> *mut mempolicy,
        >,
        pub find_special_page: ::core::option::Option<
            unsafe extern "C" fn(vma: *mut vm_area_struct, addr: ::cty::c_ulong) -> *mut page,
        >,
    }
    #[test]
    fn bindgen_test_layout_vm_operations_struct() {
        assert_eq!(
            ::core::mem::size_of::<vm_operations_struct>(),
            128usize,
            concat!("Size of: ", stringify!(vm_operations_struct))
        );
        assert_eq!(
            ::core::mem::align_of::<vm_operations_struct>(),
            8usize,
            concat!("Alignment of ", stringify!(vm_operations_struct))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vm_operations_struct>())).open as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_operations_struct),
                "::",
                stringify!(open)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vm_operations_struct>())).close as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_operations_struct),
                "::",
                stringify!(close)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<vm_operations_struct>())).may_split as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_operations_struct),
                "::",
                stringify!(may_split)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<vm_operations_struct>())).mremap as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_operations_struct),
                "::",
                stringify!(mremap)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<vm_operations_struct>())).mprotect as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_operations_struct),
                "::",
                stringify!(mprotect)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vm_operations_struct>())).fault as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_operations_struct),
                "::",
                stringify!(fault)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<vm_operations_struct>())).huge_fault as *const _ as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_operations_struct),
                "::",
                stringify!(huge_fault)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<vm_operations_struct>())).map_pages as *const _ as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_operations_struct),
                "::",
                stringify!(map_pages)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<vm_operations_struct>())).pagesize as *const _ as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_operations_struct),
                "::",
                stringify!(pagesize)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<vm_operations_struct>())).page_mkwrite as *const _ as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_operations_struct),
                "::",
                stringify!(page_mkwrite)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<vm_operations_struct>())).pfn_mkwrite as *const _ as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_operations_struct),
                "::",
                stringify!(pfn_mkwrite)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<vm_operations_struct>())).access as *const _ as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_operations_struct),
                "::",
                stringify!(access)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vm_operations_struct>())).name as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_operations_struct),
                "::",
                stringify!(name)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<vm_operations_struct>())).set_policy as *const _ as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_operations_struct),
                "::",
                stringify!(set_policy)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<vm_operations_struct>())).get_policy as *const _ as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_operations_struct),
                "::",
                stringify!(get_policy)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<vm_operations_struct>())).find_special_page as *const _
                    as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_operations_struct),
                "::",
                stringify!(find_special_page)
            )
        );
    }
    pub const dma_data_direction_DMA_BIDIRECTIONAL: dma_data_direction = 0;
    pub const dma_data_direction_DMA_TO_DEVICE: dma_data_direction = 1;
    pub const dma_data_direction_DMA_FROM_DEVICE: dma_data_direction = 2;
    pub const dma_data_direction_DMA_NONE: dma_data_direction = 3;
    pub type dma_data_direction = ::cty::c_uint;
    #[doc = " struct bio_vec - a contiguous range of physical memory addresses"]
    #[doc = " @bv_page:   First page associated with the address range."]
    #[doc = " @bv_len:    Number of bytes in the address range."]
    #[doc = " @bv_offset: Start of the address range relative to the start of @bv_page."]
    #[doc = ""]
    #[doc = " The following holds for a bvec if n * PAGE_SIZE < bv_offset + bv_len:"]
    #[doc = ""]
    #[doc = "   nth_page(@bv_page, n) == @bv_page + n"]
    #[doc = ""]
    #[doc = " This holds because page_is_mergeable() checks the above property."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bio_vec {
        pub bv_page: *mut page,
        pub bv_len: ::cty::c_uint,
        pub bv_offset: ::cty::c_uint,
    }
    #[test]
    fn bindgen_test_layout_bio_vec() {
        assert_eq!(
            ::core::mem::size_of::<bio_vec>(),
            16usize,
            concat!("Size of: ", stringify!(bio_vec))
        );
        assert_eq!(
            ::core::mem::align_of::<bio_vec>(),
            8usize,
            concat!("Alignment of ", stringify!(bio_vec))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bio_vec>())).bv_page as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bio_vec),
                "::",
                stringify!(bv_page)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bio_vec>())).bv_len as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bio_vec),
                "::",
                stringify!(bv_len)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bio_vec>())).bv_offset as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(bio_vec),
                "::",
                stringify!(bv_offset)
            )
        );
    }
    #[repr(C, packed)]
    #[derive(Debug, Copy, Clone)]
    pub struct bvec_iter {
        pub bi_sector: sector_t,
        pub bi_size: ::cty::c_uint,
        pub bi_idx: ::cty::c_uint,
        pub bi_bvec_done: ::cty::c_uint,
    }
    #[test]
    fn bindgen_test_layout_bvec_iter() {
        assert_eq!(
            ::core::mem::size_of::<bvec_iter>(),
            20usize,
            concat!("Size of: ", stringify!(bvec_iter))
        );
        assert_eq!(
            ::core::mem::align_of::<bvec_iter>(),
            1usize,
            concat!("Alignment of ", stringify!(bvec_iter))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bvec_iter>())).bi_sector as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bvec_iter),
                "::",
                stringify!(bi_sector)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bvec_iter>())).bi_size as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bvec_iter),
                "::",
                stringify!(bi_size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bvec_iter>())).bi_idx as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(bvec_iter),
                "::",
                stringify!(bi_idx)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bvec_iter>())).bi_bvec_done as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(bvec_iter),
                "::",
                stringify!(bi_bvec_done)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct kernfs_open_node {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct kernfs_iattrs {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct kernfs_elem_dir {
        pub subdirs: ::cty::c_ulong,
        pub children: rb_root,
        pub root: *mut kernfs_root,
        pub rev: ::cty::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_kernfs_elem_dir() {
        assert_eq!(
            ::core::mem::size_of::<kernfs_elem_dir>(),
            32usize,
            concat!("Size of: ", stringify!(kernfs_elem_dir))
        );
        assert_eq!(
            ::core::mem::align_of::<kernfs_elem_dir>(),
            8usize,
            concat!("Alignment of ", stringify!(kernfs_elem_dir))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kernfs_elem_dir>())).subdirs as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(kernfs_elem_dir),
                "::",
                stringify!(subdirs)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kernfs_elem_dir>())).children as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(kernfs_elem_dir),
                "::",
                stringify!(children)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kernfs_elem_dir>())).root as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(kernfs_elem_dir),
                "::",
                stringify!(root)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kernfs_elem_dir>())).rev as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(kernfs_elem_dir),
                "::",
                stringify!(rev)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct kernfs_elem_symlink {
        pub target_kn: *mut kernfs_node,
    }
    #[test]
    fn bindgen_test_layout_kernfs_elem_symlink() {
        assert_eq!(
            ::core::mem::size_of::<kernfs_elem_symlink>(),
            8usize,
            concat!("Size of: ", stringify!(kernfs_elem_symlink))
        );
        assert_eq!(
            ::core::mem::align_of::<kernfs_elem_symlink>(),
            8usize,
            concat!("Alignment of ", stringify!(kernfs_elem_symlink))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<kernfs_elem_symlink>())).target_kn as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(kernfs_elem_symlink),
                "::",
                stringify!(target_kn)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct kernfs_elem_attr {
        pub ops: *const kernfs_ops,
        pub open: *mut kernfs_open_node,
        pub size: loff_t,
        pub notify_next: *mut kernfs_node,
    }
    #[test]
    fn bindgen_test_layout_kernfs_elem_attr() {
        assert_eq!(
            ::core::mem::size_of::<kernfs_elem_attr>(),
            32usize,
            concat!("Size of: ", stringify!(kernfs_elem_attr))
        );
        assert_eq!(
            ::core::mem::align_of::<kernfs_elem_attr>(),
            8usize,
            concat!("Alignment of ", stringify!(kernfs_elem_attr))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kernfs_elem_attr>())).ops as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(kernfs_elem_attr),
                "::",
                stringify!(ops)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kernfs_elem_attr>())).open as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(kernfs_elem_attr),
                "::",
                stringify!(open)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kernfs_elem_attr>())).size as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(kernfs_elem_attr),
                "::",
                stringify!(size)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<kernfs_elem_attr>())).notify_next as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(kernfs_elem_attr),
                "::",
                stringify!(notify_next)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct kernfs_node {
        pub count: atomic_t,
        pub active: atomic_t,
        pub parent: *mut kernfs_node,
        pub name: *const ::cty::c_char,
        pub rb: rb_node,
        pub ns: *const ::cty::c_void,
        pub hash: ::cty::c_uint,
        pub __bindgen_anon_1: kernfs_node__bindgen_ty_1,
        pub priv_: *mut ::cty::c_void,
        pub id: _cargo_bpf_u64,
        pub flags: ::cty::c_ushort,
        pub mode: umode_t,
        pub iattr: *mut kernfs_iattrs,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union kernfs_node__bindgen_ty_1 {
        pub dir: kernfs_elem_dir,
        pub symlink: kernfs_elem_symlink,
        pub attr: kernfs_elem_attr,
    }
    #[test]
    fn bindgen_test_layout_kernfs_node__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<kernfs_node__bindgen_ty_1>(),
            32usize,
            concat!("Size of: ", stringify!(kernfs_node__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<kernfs_node__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(kernfs_node__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<kernfs_node__bindgen_ty_1>())).dir as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(kernfs_node__bindgen_ty_1),
                "::",
                stringify!(dir)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<kernfs_node__bindgen_ty_1>())).symlink as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(kernfs_node__bindgen_ty_1),
                "::",
                stringify!(symlink)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<kernfs_node__bindgen_ty_1>())).attr as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(kernfs_node__bindgen_ty_1),
                "::",
                stringify!(attr)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_kernfs_node() {
        assert_eq!(
            ::core::mem::size_of::<kernfs_node>(),
            128usize,
            concat!("Size of: ", stringify!(kernfs_node))
        );
        assert_eq!(
            ::core::mem::align_of::<kernfs_node>(),
            8usize,
            concat!("Alignment of ", stringify!(kernfs_node))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kernfs_node>())).count as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(kernfs_node),
                "::",
                stringify!(count)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kernfs_node>())).active as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(kernfs_node),
                "::",
                stringify!(active)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kernfs_node>())).parent as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(kernfs_node),
                "::",
                stringify!(parent)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kernfs_node>())).name as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(kernfs_node),
                "::",
                stringify!(name)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kernfs_node>())).rb as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(kernfs_node),
                "::",
                stringify!(rb)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kernfs_node>())).ns as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(kernfs_node),
                "::",
                stringify!(ns)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kernfs_node>())).hash as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(kernfs_node),
                "::",
                stringify!(hash)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kernfs_node>())).priv_ as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(kernfs_node),
                "::",
                stringify!(priv_)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kernfs_node>())).id as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(kernfs_node),
                "::",
                stringify!(id)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kernfs_node>())).flags as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(kernfs_node),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kernfs_node>())).mode as *const _ as usize },
            114usize,
            concat!(
                "Offset of field: ",
                stringify!(kernfs_node),
                "::",
                stringify!(mode)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kernfs_node>())).iattr as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(kernfs_node),
                "::",
                stringify!(iattr)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct kernfs_open_file {
        pub kn: *mut kernfs_node,
        pub file: *mut file,
        pub seq_file: *mut seq_file,
        pub priv_: *mut ::cty::c_void,
        pub mutex: mutex,
        pub prealloc_mutex: mutex,
        pub event: ::cty::c_int,
        pub list: list_head,
        pub prealloc_buf: *mut ::cty::c_char,
        pub atomic_write_len: size_t,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
        pub vm_ops: *const vm_operations_struct,
    }
    #[test]
    fn bindgen_test_layout_kernfs_open_file() {
        assert_eq!(
            ::core::mem::size_of::<kernfs_open_file>(),
            152usize,
            concat!("Size of: ", stringify!(kernfs_open_file))
        );
        assert_eq!(
            ::core::mem::align_of::<kernfs_open_file>(),
            8usize,
            concat!("Alignment of ", stringify!(kernfs_open_file))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kernfs_open_file>())).kn as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(kernfs_open_file),
                "::",
                stringify!(kn)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kernfs_open_file>())).file as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(kernfs_open_file),
                "::",
                stringify!(file)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kernfs_open_file>())).seq_file as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(kernfs_open_file),
                "::",
                stringify!(seq_file)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kernfs_open_file>())).priv_ as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(kernfs_open_file),
                "::",
                stringify!(priv_)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kernfs_open_file>())).mutex as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(kernfs_open_file),
                "::",
                stringify!(mutex)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<kernfs_open_file>())).prealloc_mutex as *const _ as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(kernfs_open_file),
                "::",
                stringify!(prealloc_mutex)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kernfs_open_file>())).event as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(kernfs_open_file),
                "::",
                stringify!(event)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kernfs_open_file>())).list as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(kernfs_open_file),
                "::",
                stringify!(list)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<kernfs_open_file>())).prealloc_buf as *const _ as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(kernfs_open_file),
                "::",
                stringify!(prealloc_buf)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<kernfs_open_file>())).atomic_write_len as *const _ as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(kernfs_open_file),
                "::",
                stringify!(atomic_write_len)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kernfs_open_file>())).vm_ops as *const _ as usize },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(kernfs_open_file),
                "::",
                stringify!(vm_ops)
            )
        );
    }
    impl kernfs_open_file {
        #[inline]
        pub fn mmapped(&self) -> bool_ {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_mmapped(&mut self, val: bool_) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn released(&self) -> bool_ {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_released(&mut self, val: bool_) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(1usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            mmapped: bool_,
            released: bool_,
        ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 1u8, {
                let mmapped: u8 = unsafe { ::core::mem::transmute(mmapped) };
                mmapped as u64
            });
            __bindgen_bitfield_unit.set(1usize, 1u8, {
                let released: u8 = unsafe { ::core::mem::transmute(released) };
                released as u64
            });
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct kernfs_ops {
        pub open:
            ::core::option::Option<unsafe extern "C" fn(of: *mut kernfs_open_file) -> ::cty::c_int>,
        pub release: ::core::option::Option<unsafe extern "C" fn(of: *mut kernfs_open_file)>,
        pub seq_show: ::core::option::Option<
            unsafe extern "C" fn(sf: *mut seq_file, v: *mut ::cty::c_void) -> ::cty::c_int,
        >,
        pub seq_start: ::core::option::Option<
            unsafe extern "C" fn(sf: *mut seq_file, ppos: *mut loff_t) -> *mut ::cty::c_void,
        >,
        pub seq_next: ::core::option::Option<
            unsafe extern "C" fn(
                sf: *mut seq_file,
                v: *mut ::cty::c_void,
                ppos: *mut loff_t,
            ) -> *mut ::cty::c_void,
        >,
        pub seq_stop:
            ::core::option::Option<unsafe extern "C" fn(sf: *mut seq_file, v: *mut ::cty::c_void)>,
        pub read: ::core::option::Option<
            unsafe extern "C" fn(
                of: *mut kernfs_open_file,
                buf: *mut ::cty::c_char,
                bytes: size_t,
                off: loff_t,
            ) -> ssize_t,
        >,
        pub atomic_write_len: size_t,
        pub prealloc: bool_,
        pub write: ::core::option::Option<
            unsafe extern "C" fn(
                of: *mut kernfs_open_file,
                buf: *mut ::cty::c_char,
                bytes: size_t,
                off: loff_t,
            ) -> ssize_t,
        >,
        pub poll: ::core::option::Option<
            unsafe extern "C" fn(of: *mut kernfs_open_file, pt: *mut poll_table_struct) -> __poll_t,
        >,
        pub mmap: ::core::option::Option<
            unsafe extern "C" fn(
                of: *mut kernfs_open_file,
                vma: *mut vm_area_struct,
            ) -> ::cty::c_int,
        >,
    }
    #[test]
    fn bindgen_test_layout_kernfs_ops() {
        assert_eq!(
            ::core::mem::size_of::<kernfs_ops>(),
            96usize,
            concat!("Size of: ", stringify!(kernfs_ops))
        );
        assert_eq!(
            ::core::mem::align_of::<kernfs_ops>(),
            8usize,
            concat!("Alignment of ", stringify!(kernfs_ops))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kernfs_ops>())).open as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(kernfs_ops),
                "::",
                stringify!(open)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kernfs_ops>())).release as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(kernfs_ops),
                "::",
                stringify!(release)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kernfs_ops>())).seq_show as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(kernfs_ops),
                "::",
                stringify!(seq_show)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kernfs_ops>())).seq_start as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(kernfs_ops),
                "::",
                stringify!(seq_start)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kernfs_ops>())).seq_next as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(kernfs_ops),
                "::",
                stringify!(seq_next)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kernfs_ops>())).seq_stop as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(kernfs_ops),
                "::",
                stringify!(seq_stop)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kernfs_ops>())).read as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(kernfs_ops),
                "::",
                stringify!(read)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<kernfs_ops>())).atomic_write_len as *const _ as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(kernfs_ops),
                "::",
                stringify!(atomic_write_len)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kernfs_ops>())).prealloc as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(kernfs_ops),
                "::",
                stringify!(prealloc)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kernfs_ops>())).write as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(kernfs_ops),
                "::",
                stringify!(write)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kernfs_ops>())).poll as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(kernfs_ops),
                "::",
                stringify!(poll)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kernfs_ops>())).mmap as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(kernfs_ops),
                "::",
                stringify!(mmap)
            )
        );
    }
    pub const kobj_ns_type_KOBJ_NS_TYPE_NONE: kobj_ns_type = 0;
    pub const kobj_ns_type_KOBJ_NS_TYPE_NET: kobj_ns_type = 1;
    pub const kobj_ns_type_KOBJ_NS_TYPES: kobj_ns_type = 2;
    pub type kobj_ns_type = ::cty::c_uint;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct kobj_ns_type_operations {
        pub type_: kobj_ns_type,
        pub current_may_mount: ::core::option::Option<unsafe extern "C" fn() -> bool_>,
        pub grab_current_ns: ::core::option::Option<unsafe extern "C" fn() -> *mut ::cty::c_void>,
        pub netlink_ns:
            ::core::option::Option<unsafe extern "C" fn(sk: *mut sock) -> *const ::cty::c_void>,
        pub initial_ns: ::core::option::Option<unsafe extern "C" fn() -> *const ::cty::c_void>,
        pub drop_ns: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::cty::c_void)>,
    }
    #[test]
    fn bindgen_test_layout_kobj_ns_type_operations() {
        assert_eq!(
            ::core::mem::size_of::<kobj_ns_type_operations>(),
            48usize,
            concat!("Size of: ", stringify!(kobj_ns_type_operations))
        );
        assert_eq!(
            ::core::mem::align_of::<kobj_ns_type_operations>(),
            8usize,
            concat!("Alignment of ", stringify!(kobj_ns_type_operations))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<kobj_ns_type_operations>())).type_ as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(kobj_ns_type_operations),
                "::",
                stringify!(type_)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<kobj_ns_type_operations>())).current_may_mount as *const _
                    as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(kobj_ns_type_operations),
                "::",
                stringify!(current_may_mount)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<kobj_ns_type_operations>())).grab_current_ns as *const _
                    as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(kobj_ns_type_operations),
                "::",
                stringify!(grab_current_ns)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<kobj_ns_type_operations>())).netlink_ns as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(kobj_ns_type_operations),
                "::",
                stringify!(netlink_ns)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<kobj_ns_type_operations>())).initial_ns as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(kobj_ns_type_operations),
                "::",
                stringify!(initial_ns)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<kobj_ns_type_operations>())).drop_ns as *const _ as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(kobj_ns_type_operations),
                "::",
                stringify!(drop_ns)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct attribute {
        pub name: *const ::cty::c_char,
        pub mode: umode_t,
    }
    #[test]
    fn bindgen_test_layout_attribute() {
        assert_eq!(
            ::core::mem::size_of::<attribute>(),
            16usize,
            concat!("Size of: ", stringify!(attribute))
        );
        assert_eq!(
            ::core::mem::align_of::<attribute>(),
            8usize,
            concat!("Alignment of ", stringify!(attribute))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<attribute>())).name as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(attribute),
                "::",
                stringify!(name)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<attribute>())).mode as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(attribute),
                "::",
                stringify!(mode)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bin_attribute {
        pub attr: attribute,
        pub size: size_t,
        pub private: *mut ::cty::c_void,
        pub f_mapping: ::core::option::Option<unsafe extern "C" fn() -> *mut address_space>,
        pub read: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                arg2: *mut kobject,
                arg3: *mut bin_attribute,
                arg4: *mut ::cty::c_char,
                arg5: loff_t,
                arg6: size_t,
            ) -> ssize_t,
        >,
        pub write: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                arg2: *mut kobject,
                arg3: *mut bin_attribute,
                arg4: *mut ::cty::c_char,
                arg5: loff_t,
                arg6: size_t,
            ) -> ssize_t,
        >,
        pub mmap: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut file,
                arg2: *mut kobject,
                attr: *mut bin_attribute,
                vma: *mut vm_area_struct,
            ) -> ::cty::c_int,
        >,
    }
    #[test]
    fn bindgen_test_layout_bin_attribute() {
        assert_eq!(
            ::core::mem::size_of::<bin_attribute>(),
            64usize,
            concat!("Size of: ", stringify!(bin_attribute))
        );
        assert_eq!(
            ::core::mem::align_of::<bin_attribute>(),
            8usize,
            concat!("Alignment of ", stringify!(bin_attribute))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bin_attribute>())).attr as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bin_attribute),
                "::",
                stringify!(attr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bin_attribute>())).size as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(bin_attribute),
                "::",
                stringify!(size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bin_attribute>())).private as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(bin_attribute),
                "::",
                stringify!(private)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bin_attribute>())).f_mapping as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(bin_attribute),
                "::",
                stringify!(f_mapping)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bin_attribute>())).read as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(bin_attribute),
                "::",
                stringify!(read)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bin_attribute>())).write as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(bin_attribute),
                "::",
                stringify!(write)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bin_attribute>())).mmap as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(bin_attribute),
                "::",
                stringify!(mmap)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct sysfs_ops {
        pub show: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut kobject,
                arg2: *mut attribute,
                arg3: *mut ::cty::c_char,
            ) -> ssize_t,
        >,
        pub store: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut kobject,
                arg2: *mut attribute,
                arg3: *const ::cty::c_char,
                arg4: size_t,
            ) -> ssize_t,
        >,
    }
    #[test]
    fn bindgen_test_layout_sysfs_ops() {
        assert_eq!(
            ::core::mem::size_of::<sysfs_ops>(),
            16usize,
            concat!("Size of: ", stringify!(sysfs_ops))
        );
        assert_eq!(
            ::core::mem::align_of::<sysfs_ops>(),
            8usize,
            concat!("Alignment of ", stringify!(sysfs_ops))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sysfs_ops>())).show as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sysfs_ops),
                "::",
                stringify!(show)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sysfs_ops>())).store as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sysfs_ops),
                "::",
                stringify!(store)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct kobject {
        pub name: *const ::cty::c_char,
        pub entry: list_head,
        pub parent: *mut kobject,
        pub kset: *mut kset,
        pub ktype: *const kobj_type,
        pub sd: *mut kernfs_node,
        pub kref: kref,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
        pub __bindgen_padding_0: [u8; 3usize],
    }
    #[test]
    fn bindgen_test_layout_kobject() {
        assert_eq!(
            ::core::mem::size_of::<kobject>(),
            64usize,
            concat!("Size of: ", stringify!(kobject))
        );
        assert_eq!(
            ::core::mem::align_of::<kobject>(),
            8usize,
            concat!("Alignment of ", stringify!(kobject))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kobject>())).name as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(kobject),
                "::",
                stringify!(name)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kobject>())).entry as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(kobject),
                "::",
                stringify!(entry)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kobject>())).parent as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(kobject),
                "::",
                stringify!(parent)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kobject>())).kset as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(kobject),
                "::",
                stringify!(kset)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kobject>())).ktype as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(kobject),
                "::",
                stringify!(ktype)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kobject>())).sd as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(kobject),
                "::",
                stringify!(sd)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kobject>())).kref as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(kobject),
                "::",
                stringify!(kref)
            )
        );
    }
    impl kobject {
        #[inline]
        pub fn state_initialized(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_state_initialized(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn state_in_sysfs(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_state_in_sysfs(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(1usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn state_add_uevent_sent(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_state_add_uevent_sent(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(2usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn state_remove_uevent_sent(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_state_remove_uevent_sent(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(3usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn uevent_suppress(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_uevent_suppress(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(4usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            state_initialized: ::cty::c_uint,
            state_in_sysfs: ::cty::c_uint,
            state_add_uevent_sent: ::cty::c_uint,
            state_remove_uevent_sent: ::cty::c_uint,
            uevent_suppress: ::cty::c_uint,
        ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 1u8, {
                let state_initialized: u32 = unsafe { ::core::mem::transmute(state_initialized) };
                state_initialized as u64
            });
            __bindgen_bitfield_unit.set(1usize, 1u8, {
                let state_in_sysfs: u32 = unsafe { ::core::mem::transmute(state_in_sysfs) };
                state_in_sysfs as u64
            });
            __bindgen_bitfield_unit.set(2usize, 1u8, {
                let state_add_uevent_sent: u32 =
                    unsafe { ::core::mem::transmute(state_add_uevent_sent) };
                state_add_uevent_sent as u64
            });
            __bindgen_bitfield_unit.set(3usize, 1u8, {
                let state_remove_uevent_sent: u32 =
                    unsafe { ::core::mem::transmute(state_remove_uevent_sent) };
                state_remove_uevent_sent as u64
            });
            __bindgen_bitfield_unit.set(4usize, 1u8, {
                let uevent_suppress: u32 = unsafe { ::core::mem::transmute(uevent_suppress) };
                uevent_suppress as u64
            });
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct kobj_type {
        pub release: ::core::option::Option<unsafe extern "C" fn(kobj: *mut kobject)>,
        pub sysfs_ops: *const sysfs_ops,
        pub default_groups: *mut *const attribute_group,
        pub child_ns_type: ::core::option::Option<
            unsafe extern "C" fn(kobj: *const kobject) -> *const kobj_ns_type_operations,
        >,
        pub namespace: ::core::option::Option<
            unsafe extern "C" fn(kobj: *const kobject) -> *const ::cty::c_void,
        >,
        pub get_ownership: ::core::option::Option<
            unsafe extern "C" fn(kobj: *const kobject, uid: *mut kuid_t, gid: *mut kgid_t),
        >,
    }
    #[test]
    fn bindgen_test_layout_kobj_type() {
        assert_eq!(
            ::core::mem::size_of::<kobj_type>(),
            48usize,
            concat!("Size of: ", stringify!(kobj_type))
        );
        assert_eq!(
            ::core::mem::align_of::<kobj_type>(),
            8usize,
            concat!("Alignment of ", stringify!(kobj_type))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kobj_type>())).release as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(kobj_type),
                "::",
                stringify!(release)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kobj_type>())).sysfs_ops as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(kobj_type),
                "::",
                stringify!(sysfs_ops)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kobj_type>())).default_groups as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(kobj_type),
                "::",
                stringify!(default_groups)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kobj_type>())).child_ns_type as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(kobj_type),
                "::",
                stringify!(child_ns_type)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kobj_type>())).namespace as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(kobj_type),
                "::",
                stringify!(namespace)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kobj_type>())).get_ownership as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(kobj_type),
                "::",
                stringify!(get_ownership)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct kobj_uevent_env {
        pub argv: [*mut ::cty::c_char; 3usize],
        pub envp: [*mut ::cty::c_char; 64usize],
        pub envp_idx: ::cty::c_int,
        pub buf: [::cty::c_char; 2048usize],
        pub buflen: ::cty::c_int,
    }
    #[test]
    fn bindgen_test_layout_kobj_uevent_env() {
        assert_eq!(
            ::core::mem::size_of::<kobj_uevent_env>(),
            2592usize,
            concat!("Size of: ", stringify!(kobj_uevent_env))
        );
        assert_eq!(
            ::core::mem::align_of::<kobj_uevent_env>(),
            8usize,
            concat!("Alignment of ", stringify!(kobj_uevent_env))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kobj_uevent_env>())).argv as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(kobj_uevent_env),
                "::",
                stringify!(argv)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kobj_uevent_env>())).envp as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(kobj_uevent_env),
                "::",
                stringify!(envp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kobj_uevent_env>())).envp_idx as *const _ as usize },
            536usize,
            concat!(
                "Offset of field: ",
                stringify!(kobj_uevent_env),
                "::",
                stringify!(envp_idx)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kobj_uevent_env>())).buf as *const _ as usize },
            540usize,
            concat!(
                "Offset of field: ",
                stringify!(kobj_uevent_env),
                "::",
                stringify!(buf)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kobj_uevent_env>())).buflen as *const _ as usize },
            2588usize,
            concat!(
                "Offset of field: ",
                stringify!(kobj_uevent_env),
                "::",
                stringify!(buflen)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct kset_uevent_ops {
        pub filter:
            ::core::option::Option<unsafe extern "C" fn(kobj: *const kobject) -> ::cty::c_int>,
        pub name: ::core::option::Option<
            unsafe extern "C" fn(kobj: *const kobject) -> *const ::cty::c_char,
        >,
        pub uevent: ::core::option::Option<
            unsafe extern "C" fn(kobj: *const kobject, env: *mut kobj_uevent_env) -> ::cty::c_int,
        >,
    }
    #[test]
    fn bindgen_test_layout_kset_uevent_ops() {
        assert_eq!(
            ::core::mem::size_of::<kset_uevent_ops>(),
            24usize,
            concat!("Size of: ", stringify!(kset_uevent_ops))
        );
        assert_eq!(
            ::core::mem::align_of::<kset_uevent_ops>(),
            8usize,
            concat!("Alignment of ", stringify!(kset_uevent_ops))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kset_uevent_ops>())).filter as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(kset_uevent_ops),
                "::",
                stringify!(filter)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kset_uevent_ops>())).name as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(kset_uevent_ops),
                "::",
                stringify!(name)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kset_uevent_ops>())).uevent as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(kset_uevent_ops),
                "::",
                stringify!(uevent)
            )
        );
    }
    #[doc = " struct kset - a set of kobjects of a specific type, belonging to a specific subsystem."]
    #[doc = ""]
    #[doc = " A kset defines a group of kobjects.  They can be individually"]
    #[doc = " different \"types\" but overall these kobjects all want to be grouped"]
    #[doc = " together and operated on in the same manner.  ksets are used to"]
    #[doc = " define the attribute callbacks and other common events that happen to"]
    #[doc = " a kobject."]
    #[doc = ""]
    #[doc = " @list: the list of all kobjects for this kset"]
    #[doc = " @list_lock: a lock for iterating over the kobjects"]
    #[doc = " @kobj: the embedded kobject for this kset (recursion, isn't it fun...)"]
    #[doc = " @uevent_ops: the set of uevent operations for this kset.  These are"]
    #[doc = " called whenever a kobject has something happen to it so that the kset"]
    #[doc = " can add new environment variables, or filter out the uevents if so"]
    #[doc = " desired."]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct kset {
        pub list: list_head,
        pub list_lock: spinlock_t,
        pub kobj: kobject,
        pub uevent_ops: *const kset_uevent_ops,
    }
    #[test]
    fn bindgen_test_layout_kset() {
        assert_eq!(
            ::core::mem::size_of::<kset>(),
            96usize,
            concat!("Size of: ", stringify!(kset))
        );
        assert_eq!(
            ::core::mem::align_of::<kset>(),
            8usize,
            concat!("Alignment of ", stringify!(kset))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kset>())).list as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(kset),
                "::",
                stringify!(list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kset>())).list_lock as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(kset),
                "::",
                stringify!(list_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kset>())).kobj as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(kset),
                "::",
                stringify!(kobj)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kset>())).uevent_ops as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(kset),
                "::",
                stringify!(uevent_ops)
            )
        );
    }
    #[doc = " struct em_perf_state - Performance state of a performance domain"]
    #[doc = " @frequency:\tThe frequency in KHz, for consistency with CPUFreq"]
    #[doc = " @power:\tThe power consumed at this level (by 1 CPU or by a registered"]
    #[doc = "\t\tdevice). It can be a total power: static and dynamic."]
    #[doc = " @cost:\tThe cost coefficient associated with this level, used during"]
    #[doc = "\t\tenergy calculation. Equal to: power * max_frequency / frequency"]
    #[doc = " @flags:\tsee \"em_perf_state flags\" description below."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct em_perf_state {
        pub frequency: ::cty::c_ulong,
        pub power: ::cty::c_ulong,
        pub cost: ::cty::c_ulong,
        pub flags: ::cty::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_em_perf_state() {
        assert_eq!(
            ::core::mem::size_of::<em_perf_state>(),
            32usize,
            concat!("Size of: ", stringify!(em_perf_state))
        );
        assert_eq!(
            ::core::mem::align_of::<em_perf_state>(),
            8usize,
            concat!("Alignment of ", stringify!(em_perf_state))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<em_perf_state>())).frequency as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(em_perf_state),
                "::",
                stringify!(frequency)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<em_perf_state>())).power as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(em_perf_state),
                "::",
                stringify!(power)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<em_perf_state>())).cost as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(em_perf_state),
                "::",
                stringify!(cost)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<em_perf_state>())).flags as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(em_perf_state),
                "::",
                stringify!(flags)
            )
        );
    }
    #[doc = " struct em_perf_domain - Performance domain"]
    #[doc = " @table:\t\tList of performance states, in ascending order"]
    #[doc = " @nr_perf_states:\tNumber of performance states"]
    #[doc = " @flags:\t\tSee \"em_perf_domain flags\""]
    #[doc = " @cpus:\t\tCpumask covering the CPUs of the domain. It's here"]
    #[doc = "\t\t\tfor performance reasons to avoid potential cache"]
    #[doc = "\t\t\tmisses during energy calculations in the scheduler"]
    #[doc = "\t\t\tand simplifies allocating/freeing that memory region."]
    #[doc = ""]
    #[doc = " In case of CPU device, a \"performance domain\" represents a group of CPUs"]
    #[doc = " whose performance is scaled together. All CPUs of a performance domain"]
    #[doc = " must have the same micro-architecture. Performance domains often have"]
    #[doc = " a 1-to-1 mapping with CPUFreq policies. In case of other devices the @cpus"]
    #[doc = " field is unused."]
    #[repr(C)]
    #[derive(Debug)]
    pub struct em_perf_domain {
        pub table: *mut em_perf_state,
        pub nr_perf_states: ::cty::c_int,
        pub flags: ::cty::c_ulong,
        pub cpus: __IncompleteArrayField<::cty::c_ulong>,
    }
    #[test]
    fn bindgen_test_layout_em_perf_domain() {
        assert_eq!(
            ::core::mem::size_of::<em_perf_domain>(),
            24usize,
            concat!("Size of: ", stringify!(em_perf_domain))
        );
        assert_eq!(
            ::core::mem::align_of::<em_perf_domain>(),
            8usize,
            concat!("Alignment of ", stringify!(em_perf_domain))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<em_perf_domain>())).table as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(em_perf_domain),
                "::",
                stringify!(table)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<em_perf_domain>())).nr_perf_states as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(em_perf_domain),
                "::",
                stringify!(nr_perf_states)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<em_perf_domain>())).flags as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(em_perf_domain),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<em_perf_domain>())).cpus as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(em_perf_domain),
                "::",
                stringify!(cpus)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct pm_message {
        pub event: ::cty::c_int,
    }
    #[test]
    fn bindgen_test_layout_pm_message() {
        assert_eq!(
            ::core::mem::size_of::<pm_message>(),
            4usize,
            concat!("Size of: ", stringify!(pm_message))
        );
        assert_eq!(
            ::core::mem::align_of::<pm_message>(),
            4usize,
            concat!("Alignment of ", stringify!(pm_message))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pm_message>())).event as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pm_message),
                "::",
                stringify!(event)
            )
        );
    }
    pub type pm_message_t = pm_message;
    #[doc = " struct dev_pm_ops - device PM callbacks."]
    #[doc = ""]
    #[doc = " @prepare: The principal role of this callback is to prevent new children of"]
    #[doc = "\tthe device from being registered after it has returned (the driver's"]
    #[doc = "\tsubsystem and generally the rest of the kernel is supposed to prevent"]
    #[doc = "\tnew calls to the probe method from being made too once @prepare() has"]
    #[doc = "\tsucceeded).  If @prepare() detects a situation it cannot handle (e.g."]
    #[doc = "\tregistration of a child already in progress), it may return -EAGAIN, so"]
    #[doc = "\tthat the PM core can execute it once again (e.g. after a new child has"]
    #[doc = "\tbeen registered) to recover from the race condition."]
    #[doc = "\tThis method is executed for all kinds of suspend transitions and is"]
    #[doc = "\tfollowed by one of the suspend callbacks: @suspend(), @freeze(), or"]
    #[doc = "\t@poweroff().  If the transition is a suspend to memory or standby (that"]
    #[doc = "\tis, not related to hibernation), the return value of @prepare() may be"]
    #[doc = "\tused to indicate to the PM core to leave the device in runtime suspend"]
    #[doc = "\tif applicable.  Namely, if @prepare() returns a positive number, the PM"]
    #[doc = "\tcore will understand that as a declaration that the device appears to be"]
    #[doc = "\truntime-suspended and it may be left in that state during the entire"]
    #[doc = "\ttransition and during the subsequent resume if all of its descendants"]
    #[doc = "\tare left in runtime suspend too.  If that happens, @complete() will be"]
    #[doc = "\texecuted directly after @prepare() and it must ensure the proper"]
    #[doc = "\tfunctioning of the device after the system resume."]
    #[doc = "\tThe PM core executes subsystem-level @prepare() for all devices before"]
    #[doc = "\tstarting to invoke suspend callbacks for any of them, so generally"]
    #[doc = "\tdevices may be assumed to be functional or to respond to runtime resume"]
    #[doc = "\trequests while @prepare() is being executed.  However, device drivers"]
    #[doc = "\tmay NOT assume anything about the availability of user space at that"]
    #[doc = "\ttime and it is NOT valid to request firmware from within @prepare()"]
    #[doc = "\t(it's too late to do that).  It also is NOT valid to allocate"]
    #[doc = "\tsubstantial amounts of memory from @prepare() in the GFP_KERNEL mode."]
    #[doc = "\t[To work around these limitations, drivers may register suspend and"]
    #[doc = "\thibernation notifiers to be executed before the freezing of tasks.]"]
    #[doc = ""]
    #[doc = " @complete: Undo the changes made by @prepare().  This method is executed for"]
    #[doc = "\tall kinds of resume transitions, following one of the resume callbacks:"]
    #[doc = "\t@resume(), @thaw(), @restore().  Also called if the state transition"]
    #[doc = "\tfails before the driver's suspend callback: @suspend(), @freeze() or"]
    #[doc = "\t@poweroff(), can be executed (e.g. if the suspend callback fails for one"]
    #[doc = "\tof the other devices that the PM core has unsuccessfully attempted to"]
    #[doc = "\tsuspend earlier)."]
    #[doc = "\tThe PM core executes subsystem-level @complete() after it has executed"]
    #[doc = "\tthe appropriate resume callbacks for all devices.  If the corresponding"]
    #[doc = "\t@prepare() at the beginning of the suspend transition returned a"]
    #[doc = "\tpositive number and the device was left in runtime suspend (without"]
    #[doc = "\texecuting any suspend and resume callbacks for it), @complete() will be"]
    #[doc = "\tthe only callback executed for the device during resume.  In that case,"]
    #[doc = "\t@complete() must be prepared to do whatever is necessary to ensure the"]
    #[doc = "\tproper functioning of the device after the system resume.  To this end,"]
    #[doc = "\t@complete() can check the power.direct_complete flag of the device to"]
    #[doc = "\tlearn whether (unset) or not (set) the previous suspend and resume"]
    #[doc = "\tcallbacks have been executed for it."]
    #[doc = ""]
    #[doc = " @suspend: Executed before putting the system into a sleep state in which the"]
    #[doc = "\tcontents of main memory are preserved.  The exact action to perform"]
    #[doc = "\tdepends on the device's subsystem (PM domain, device type, class or bus"]
    #[doc = "\ttype), but generally the device must be quiescent after subsystem-level"]
    #[doc = "\t@suspend() has returned, so that it doesn't do any I/O or DMA."]
    #[doc = "\tSubsystem-level @suspend() is executed for all devices after invoking"]
    #[doc = "\tsubsystem-level @prepare() for all of them."]
    #[doc = ""]
    #[doc = " @suspend_late: Continue operations started by @suspend().  For a number of"]
    #[doc = "\tdevices @suspend_late() may point to the same callback routine as the"]
    #[doc = "\truntime suspend callback."]
    #[doc = ""]
    #[doc = " @resume: Executed after waking the system up from a sleep state in which the"]
    #[doc = "\tcontents of main memory were preserved.  The exact action to perform"]
    #[doc = "\tdepends on the device's subsystem, but generally the driver is expected"]
    #[doc = "\tto start working again, responding to hardware events and software"]
    #[doc = "\trequests (the device itself may be left in a low-power state, waiting"]
    #[doc = "\tfor a runtime resume to occur).  The state of the device at the time its"]
    #[doc = "\tdriver's @resume() callback is run depends on the platform and subsystem"]
    #[doc = "\tthe device belongs to.  On most platforms, there are no restrictions on"]
    #[doc = "\tavailability of resources like clocks during @resume()."]
    #[doc = "\tSubsystem-level @resume() is executed for all devices after invoking"]
    #[doc = "\tsubsystem-level @resume_noirq() for all of them."]
    #[doc = ""]
    #[doc = " @resume_early: Prepare to execute @resume().  For a number of devices"]
    #[doc = "\t@resume_early() may point to the same callback routine as the runtime"]
    #[doc = "\tresume callback."]
    #[doc = ""]
    #[doc = " @freeze: Hibernation-specific, executed before creating a hibernation image."]
    #[doc = "\tAnalogous to @suspend(), but it should not enable the device to signal"]
    #[doc = "\twakeup events or change its power state.  The majority of subsystems"]
    #[doc = "\t(with the notable exception of the PCI bus type) expect the driver-level"]
    #[doc = "\t@freeze() to save the device settings in memory to be used by @restore()"]
    #[doc = "\tduring the subsequent resume from hibernation."]
    #[doc = "\tSubsystem-level @freeze() is executed for all devices after invoking"]
    #[doc = "\tsubsystem-level @prepare() for all of them."]
    #[doc = ""]
    #[doc = " @freeze_late: Continue operations started by @freeze().  Analogous to"]
    #[doc = "\t@suspend_late(), but it should not enable the device to signal wakeup"]
    #[doc = "\tevents or change its power state."]
    #[doc = ""]
    #[doc = " @thaw: Hibernation-specific, executed after creating a hibernation image OR"]
    #[doc = "\tif the creation of an image has failed.  Also executed after a failing"]
    #[doc = "\tattempt to restore the contents of main memory from such an image."]
    #[doc = "\tUndo the changes made by the preceding @freeze(), so the device can be"]
    #[doc = "\toperated in the same way as immediately before the call to @freeze()."]
    #[doc = "\tSubsystem-level @thaw() is executed for all devices after invoking"]
    #[doc = "\tsubsystem-level @thaw_noirq() for all of them.  It also may be executed"]
    #[doc = "\tdirectly after @freeze() in case of a transition error."]
    #[doc = ""]
    #[doc = " @thaw_early: Prepare to execute @thaw().  Undo the changes made by the"]
    #[doc = "\tpreceding @freeze_late()."]
    #[doc = ""]
    #[doc = " @poweroff: Hibernation-specific, executed after saving a hibernation image."]
    #[doc = "\tAnalogous to @suspend(), but it need not save the device's settings in"]
    #[doc = "\tmemory."]
    #[doc = "\tSubsystem-level @poweroff() is executed for all devices after invoking"]
    #[doc = "\tsubsystem-level @prepare() for all of them."]
    #[doc = ""]
    #[doc = " @poweroff_late: Continue operations started by @poweroff().  Analogous to"]
    #[doc = "\t@suspend_late(), but it need not save the device's settings in memory."]
    #[doc = ""]
    #[doc = " @restore: Hibernation-specific, executed after restoring the contents of main"]
    #[doc = "\tmemory from a hibernation image, analogous to @resume()."]
    #[doc = ""]
    #[doc = " @restore_early: Prepare to execute @restore(), analogous to @resume_early()."]
    #[doc = ""]
    #[doc = " @suspend_noirq: Complete the actions started by @suspend().  Carry out any"]
    #[doc = "\tadditional operations required for suspending the device that might be"]
    #[doc = "\tracing with its driver's interrupt handler, which is guaranteed not to"]
    #[doc = "\trun while @suspend_noirq() is being executed."]
    #[doc = "\tIt generally is expected that the device will be in a low-power state"]
    #[doc = "\t(appropriate for the target system sleep state) after subsystem-level"]
    #[doc = "\t@suspend_noirq() has returned successfully.  If the device can generate"]
    #[doc = "\tsystem wakeup signals and is enabled to wake up the system, it should be"]
    #[doc = "\tconfigured to do so at that time.  However, depending on the platform"]
    #[doc = "\tand device's subsystem, @suspend() or @suspend_late() may be allowed to"]
    #[doc = "\tput the device into the low-power state and configure it to generate"]
    #[doc = "\twakeup signals, in which case it generally is not necessary to define"]
    #[doc = "\t@suspend_noirq()."]
    #[doc = ""]
    #[doc = " @resume_noirq: Prepare for the execution of @resume() by carrying out any"]
    #[doc = "\toperations required for resuming the device that might be racing with"]
    #[doc = "\tits driver's interrupt handler, which is guaranteed not to run while"]
    #[doc = "\t@resume_noirq() is being executed."]
    #[doc = ""]
    #[doc = " @freeze_noirq: Complete the actions started by @freeze().  Carry out any"]
    #[doc = "\tadditional operations required for freezing the device that might be"]
    #[doc = "\tracing with its driver's interrupt handler, which is guaranteed not to"]
    #[doc = "\trun while @freeze_noirq() is being executed."]
    #[doc = "\tThe power state of the device should not be changed by either @freeze(),"]
    #[doc = "\tor @freeze_late(), or @freeze_noirq() and it should not be configured to"]
    #[doc = "\tsignal system wakeup by any of these callbacks."]
    #[doc = ""]
    #[doc = " @thaw_noirq: Prepare for the execution of @thaw() by carrying out any"]
    #[doc = "\toperations required for thawing the device that might be racing with its"]
    #[doc = "\tdriver's interrupt handler, which is guaranteed not to run while"]
    #[doc = "\t@thaw_noirq() is being executed."]
    #[doc = ""]
    #[doc = " @poweroff_noirq: Complete the actions started by @poweroff().  Analogous to"]
    #[doc = "\t@suspend_noirq(), but it need not save the device's settings in memory."]
    #[doc = ""]
    #[doc = " @restore_noirq: Prepare for the execution of @restore() by carrying out any"]
    #[doc = "\toperations required for thawing the device that might be racing with its"]
    #[doc = "\tdriver's interrupt handler, which is guaranteed not to run while"]
    #[doc = "\t@restore_noirq() is being executed.  Analogous to @resume_noirq()."]
    #[doc = ""]
    #[doc = " @runtime_suspend: Prepare the device for a condition in which it won't be"]
    #[doc = "\table to communicate with the CPU(s) and RAM due to power management."]
    #[doc = "\tThis need not mean that the device should be put into a low-power state."]
    #[doc = "\tFor example, if the device is behind a link which is about to be turned"]
    #[doc = "\toff, the device may remain at full power.  If the device does go to low"]
    #[doc = "\tpower and is capable of generating runtime wakeup events, remote wakeup"]
    #[doc = "\t(i.e., a hardware mechanism allowing the device to request a change of"]
    #[doc = "\tits power state via an interrupt) should be enabled for it."]
    #[doc = ""]
    #[doc = " @runtime_resume: Put the device into the fully active state in response to a"]
    #[doc = "\twakeup event generated by hardware or at the request of software.  If"]
    #[doc = "\tnecessary, put the device into the full-power state and restore its"]
    #[doc = "\tregisters, so that it is fully operational."]
    #[doc = ""]
    #[doc = " @runtime_idle: Device appears to be inactive and it might be put into a"]
    #[doc = "\tlow-power state if all of the necessary conditions are satisfied."]
    #[doc = "\tCheck these conditions, and return 0 if it's appropriate to let the PM"]
    #[doc = "\tcore queue a suspend request for the device."]
    #[doc = ""]
    #[doc = " Several device power state transitions are externally visible, affecting"]
    #[doc = " the state of pending I/O queues and (for drivers that touch hardware)"]
    #[doc = " interrupts, wakeups, DMA, and other hardware state.  There may also be"]
    #[doc = " internal transitions to various low-power modes which are transparent"]
    #[doc = " to the rest of the driver stack (such as a driver that's ON gating off"]
    #[doc = " clocks which are not in active use)."]
    #[doc = ""]
    #[doc = " The externally visible transitions are handled with the help of callbacks"]
    #[doc = " included in this structure in such a way that, typically, two levels of"]
    #[doc = " callbacks are involved.  First, the PM core executes callbacks provided by PM"]
    #[doc = " domains, device types, classes and bus types.  They are the subsystem-level"]
    #[doc = " callbacks expected to execute callbacks provided by device drivers, although"]
    #[doc = " they may choose not to do that.  If the driver callbacks are executed, they"]
    #[doc = " have to collaborate with the subsystem-level callbacks to achieve the goals"]
    #[doc = " appropriate for the given system transition, given transition phase and the"]
    #[doc = " subsystem the device belongs to."]
    #[doc = ""]
    #[doc = " All of the above callbacks, except for @complete(), return error codes."]
    #[doc = " However, the error codes returned by @resume(), @thaw(), @restore(),"]
    #[doc = " @resume_noirq(), @thaw_noirq(), and @restore_noirq(), do not cause the PM"]
    #[doc = " core to abort the resume transition during which they are returned.  The"]
    #[doc = " error codes returned in those cases are only printed to the system logs for"]
    #[doc = " debugging purposes.  Still, it is recommended that drivers only return error"]
    #[doc = " codes from their resume methods in case of an unrecoverable failure (i.e."]
    #[doc = " when the device being handled refuses to resume and becomes unusable) to"]
    #[doc = " allow the PM core to be modified in the future, so that it can avoid"]
    #[doc = " attempting to handle devices that failed to resume and their children."]
    #[doc = ""]
    #[doc = " It is allowed to unregister devices while the above callbacks are being"]
    #[doc = " executed.  However, a callback routine MUST NOT try to unregister the device"]
    #[doc = " it was called for, although it may unregister children of that device (for"]
    #[doc = " example, if it detects that a child was unplugged while the system was"]
    #[doc = " asleep)."]
    #[doc = ""]
    #[doc = " There also are callbacks related to runtime power management of devices."]
    #[doc = " Again, as a rule these callbacks are executed by the PM core for subsystems"]
    #[doc = " (PM domains, device types, classes and bus types) and the subsystem-level"]
    #[doc = " callbacks are expected to invoke the driver callbacks.  Moreover, the exact"]
    #[doc = " actions to be performed by a device driver's callbacks generally depend on"]
    #[doc = " the platform and subsystem the device belongs to."]
    #[doc = ""]
    #[doc = " Refer to Documentation/power/runtime_pm.rst for more information about the"]
    #[doc = " role of the @runtime_suspend(), @runtime_resume() and @runtime_idle()"]
    #[doc = " callbacks in device runtime power management."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dev_pm_ops {
        pub prepare: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ::cty::c_int>,
        pub complete: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
        pub suspend: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ::cty::c_int>,
        pub resume: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ::cty::c_int>,
        pub freeze: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ::cty::c_int>,
        pub thaw: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ::cty::c_int>,
        pub poweroff:
            ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ::cty::c_int>,
        pub restore: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ::cty::c_int>,
        pub suspend_late:
            ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ::cty::c_int>,
        pub resume_early:
            ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ::cty::c_int>,
        pub freeze_late:
            ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ::cty::c_int>,
        pub thaw_early:
            ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ::cty::c_int>,
        pub poweroff_late:
            ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ::cty::c_int>,
        pub restore_early:
            ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ::cty::c_int>,
        pub suspend_noirq:
            ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ::cty::c_int>,
        pub resume_noirq:
            ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ::cty::c_int>,
        pub freeze_noirq:
            ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ::cty::c_int>,
        pub thaw_noirq:
            ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ::cty::c_int>,
        pub poweroff_noirq:
            ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ::cty::c_int>,
        pub restore_noirq:
            ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ::cty::c_int>,
        pub runtime_suspend:
            ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ::cty::c_int>,
        pub runtime_resume:
            ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ::cty::c_int>,
        pub runtime_idle:
            ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ::cty::c_int>,
    }
    #[test]
    fn bindgen_test_layout_dev_pm_ops() {
        assert_eq!(
            ::core::mem::size_of::<dev_pm_ops>(),
            184usize,
            concat!("Size of: ", stringify!(dev_pm_ops))
        );
        assert_eq!(
            ::core::mem::align_of::<dev_pm_ops>(),
            8usize,
            concat!("Alignment of ", stringify!(dev_pm_ops))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).prepare as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_ops),
                "::",
                stringify!(prepare)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).complete as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_ops),
                "::",
                stringify!(complete)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).suspend as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_ops),
                "::",
                stringify!(suspend)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).resume as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_ops),
                "::",
                stringify!(resume)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).freeze as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_ops),
                "::",
                stringify!(freeze)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).thaw as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_ops),
                "::",
                stringify!(thaw)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).poweroff as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_ops),
                "::",
                stringify!(poweroff)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).restore as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_ops),
                "::",
                stringify!(restore)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).suspend_late as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_ops),
                "::",
                stringify!(suspend_late)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).resume_early as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_ops),
                "::",
                stringify!(resume_early)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).freeze_late as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_ops),
                "::",
                stringify!(freeze_late)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).thaw_early as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_ops),
                "::",
                stringify!(thaw_early)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).poweroff_late as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_ops),
                "::",
                stringify!(poweroff_late)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).restore_early as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_ops),
                "::",
                stringify!(restore_early)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).suspend_noirq as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_ops),
                "::",
                stringify!(suspend_noirq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).resume_noirq as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_ops),
                "::",
                stringify!(resume_noirq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).freeze_noirq as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_ops),
                "::",
                stringify!(freeze_noirq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).thaw_noirq as *const _ as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_ops),
                "::",
                stringify!(thaw_noirq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).poweroff_noirq as *const _ as usize },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_ops),
                "::",
                stringify!(poweroff_noirq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).restore_noirq as *const _ as usize },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_ops),
                "::",
                stringify!(restore_noirq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).runtime_suspend as *const _ as usize },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_ops),
                "::",
                stringify!(runtime_suspend)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).runtime_resume as *const _ as usize },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_ops),
                "::",
                stringify!(runtime_resume)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pm_ops>())).runtime_idle as *const _ as usize },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_ops),
                "::",
                stringify!(runtime_idle)
            )
        );
    }
    pub const rpm_status_RPM_INVALID: rpm_status = -1;
    pub const rpm_status_RPM_ACTIVE: rpm_status = 0;
    pub const rpm_status_RPM_RESUMING: rpm_status = 1;
    pub const rpm_status_RPM_SUSPENDED: rpm_status = 2;
    pub const rpm_status_RPM_SUSPENDING: rpm_status = 3;
    pub type rpm_status = ::cty::c_int;
    pub const rpm_request_RPM_REQ_NONE: rpm_request = 0;
    pub const rpm_request_RPM_REQ_IDLE: rpm_request = 1;
    pub const rpm_request_RPM_REQ_SUSPEND: rpm_request = 2;
    pub const rpm_request_RPM_REQ_AUTOSUSPEND: rpm_request = 3;
    pub const rpm_request_RPM_REQ_RESUME: rpm_request = 4;
    pub type rpm_request = ::cty::c_uint;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct wake_irq {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct pm_domain_data {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct pm_subsys_data {
        pub lock: spinlock_t,
        pub refcount: ::cty::c_uint,
        pub clock_op_might_sleep: ::cty::c_uint,
        pub clock_mutex: mutex,
        pub clock_list: list_head,
        pub domain_data: *mut pm_domain_data,
    }
    #[test]
    fn bindgen_test_layout_pm_subsys_data() {
        assert_eq!(
            ::core::mem::size_of::<pm_subsys_data>(),
            72usize,
            concat!("Size of: ", stringify!(pm_subsys_data))
        );
        assert_eq!(
            ::core::mem::align_of::<pm_subsys_data>(),
            8usize,
            concat!("Alignment of ", stringify!(pm_subsys_data))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pm_subsys_data>())).lock as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pm_subsys_data),
                "::",
                stringify!(lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pm_subsys_data>())).refcount as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(pm_subsys_data),
                "::",
                stringify!(refcount)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<pm_subsys_data>())).clock_op_might_sleep as *const _
                    as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(pm_subsys_data),
                "::",
                stringify!(clock_op_might_sleep)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pm_subsys_data>())).clock_mutex as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(pm_subsys_data),
                "::",
                stringify!(clock_mutex)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pm_subsys_data>())).clock_list as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(pm_subsys_data),
                "::",
                stringify!(clock_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pm_subsys_data>())).domain_data as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(pm_subsys_data),
                "::",
                stringify!(domain_data)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct dev_pm_info {
        pub power_state: pm_message_t,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
        pub driver_flags: _cargo_bpf_u32,
        pub lock: spinlock_t,
        pub entry: list_head,
        pub completion: completion,
        pub wakeup: *mut wakeup_source,
        pub _bitfield_align_2: [u8; 0],
        pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
        pub suspend_timer: hrtimer,
        pub timer_expires: _cargo_bpf_u64,
        pub work: work_struct,
        pub wait_queue: wait_queue_head_t,
        pub wakeirq: *mut wake_irq,
        pub usage_count: atomic_t,
        pub child_count: atomic_t,
        pub _bitfield_align_3: [u8; 0],
        pub _bitfield_3: __BindgenBitfieldUnit<[u8; 2usize]>,
        pub links_count: ::cty::c_uint,
        pub request: rpm_request,
        pub runtime_status: rpm_status,
        pub last_status: rpm_status,
        pub runtime_error: ::cty::c_int,
        pub autosuspend_delay: ::cty::c_int,
        pub last_busy: _cargo_bpf_u64,
        pub active_time: _cargo_bpf_u64,
        pub suspended_time: _cargo_bpf_u64,
        pub accounting_timestamp: _cargo_bpf_u64,
        pub subsys_data: *mut pm_subsys_data,
        pub set_latency_tolerance:
            ::core::option::Option<unsafe extern "C" fn(arg1: *mut device, arg2: s32)>,
        pub qos: *mut dev_pm_qos,
    }
    #[test]
    fn bindgen_test_layout_dev_pm_info() {
        assert_eq!(
            ::core::mem::size_of::<dev_pm_info>(),
            312usize,
            concat!("Size of: ", stringify!(dev_pm_info))
        );
        assert_eq!(
            ::core::mem::align_of::<dev_pm_info>(),
            8usize,
            concat!("Alignment of ", stringify!(dev_pm_info))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pm_info>())).power_state as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_info),
                "::",
                stringify!(power_state)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pm_info>())).driver_flags as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_info),
                "::",
                stringify!(driver_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pm_info>())).lock as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_info),
                "::",
                stringify!(lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pm_info>())).entry as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_info),
                "::",
                stringify!(entry)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pm_info>())).completion as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_info),
                "::",
                stringify!(completion)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pm_info>())).wakeup as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_info),
                "::",
                stringify!(wakeup)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pm_info>())).suspend_timer as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_info),
                "::",
                stringify!(suspend_timer)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pm_info>())).timer_expires as *const _ as usize },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_info),
                "::",
                stringify!(timer_expires)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pm_info>())).work as *const _ as usize },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_info),
                "::",
                stringify!(work)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pm_info>())).wait_queue as *const _ as usize },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_info),
                "::",
                stringify!(wait_queue)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pm_info>())).wakeirq as *const _ as usize },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_info),
                "::",
                stringify!(wakeirq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pm_info>())).usage_count as *const _ as usize },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_info),
                "::",
                stringify!(usage_count)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pm_info>())).child_count as *const _ as usize },
            220usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_info),
                "::",
                stringify!(child_count)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pm_info>())).links_count as *const _ as usize },
            228usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_info),
                "::",
                stringify!(links_count)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pm_info>())).request as *const _ as usize },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_info),
                "::",
                stringify!(request)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pm_info>())).runtime_status as *const _ as usize },
            236usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_info),
                "::",
                stringify!(runtime_status)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pm_info>())).last_status as *const _ as usize },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_info),
                "::",
                stringify!(last_status)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pm_info>())).runtime_error as *const _ as usize },
            244usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_info),
                "::",
                stringify!(runtime_error)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<dev_pm_info>())).autosuspend_delay as *const _ as usize
            },
            248usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_info),
                "::",
                stringify!(autosuspend_delay)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pm_info>())).last_busy as *const _ as usize },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_info),
                "::",
                stringify!(last_busy)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pm_info>())).active_time as *const _ as usize },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_info),
                "::",
                stringify!(active_time)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pm_info>())).suspended_time as *const _ as usize },
            272usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_info),
                "::",
                stringify!(suspended_time)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<dev_pm_info>())).accounting_timestamp as *const _ as usize
            },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_info),
                "::",
                stringify!(accounting_timestamp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pm_info>())).subsys_data as *const _ as usize },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_info),
                "::",
                stringify!(subsys_data)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<dev_pm_info>())).set_latency_tolerance as *const _ as usize
            },
            296usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_info),
                "::",
                stringify!(set_latency_tolerance)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pm_info>())).qos as *const _ as usize },
            304usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_info),
                "::",
                stringify!(qos)
            )
        );
    }
    impl dev_pm_info {
        #[inline]
        pub fn can_wakeup(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_can_wakeup(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn async_suspend(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_async_suspend(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(1usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn in_dpm_list(&self) -> bool_ {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_in_dpm_list(&mut self, val: bool_) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(2usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn is_prepared(&self) -> bool_ {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_is_prepared(&mut self, val: bool_) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(3usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn is_suspended(&self) -> bool_ {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_is_suspended(&mut self, val: bool_) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(4usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn is_noirq_suspended(&self) -> bool_ {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_is_noirq_suspended(&mut self, val: bool_) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(5usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn is_late_suspended(&self) -> bool_ {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_is_late_suspended(&mut self, val: bool_) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(6usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn no_pm(&self) -> bool_ {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_no_pm(&mut self, val: bool_) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(7usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn early_init(&self) -> bool_ {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_early_init(&mut self, val: bool_) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(8usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn direct_complete(&self) -> bool_ {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_direct_complete(&mut self, val: bool_) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(9usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            can_wakeup: ::cty::c_uint,
            async_suspend: ::cty::c_uint,
            in_dpm_list: bool_,
            is_prepared: bool_,
            is_suspended: bool_,
            is_noirq_suspended: bool_,
            is_late_suspended: bool_,
            no_pm: bool_,
            early_init: bool_,
            direct_complete: bool_,
        ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 1u8, {
                let can_wakeup: u32 = unsafe { ::core::mem::transmute(can_wakeup) };
                can_wakeup as u64
            });
            __bindgen_bitfield_unit.set(1usize, 1u8, {
                let async_suspend: u32 = unsafe { ::core::mem::transmute(async_suspend) };
                async_suspend as u64
            });
            __bindgen_bitfield_unit.set(2usize, 1u8, {
                let in_dpm_list: u8 = unsafe { ::core::mem::transmute(in_dpm_list) };
                in_dpm_list as u64
            });
            __bindgen_bitfield_unit.set(3usize, 1u8, {
                let is_prepared: u8 = unsafe { ::core::mem::transmute(is_prepared) };
                is_prepared as u64
            });
            __bindgen_bitfield_unit.set(4usize, 1u8, {
                let is_suspended: u8 = unsafe { ::core::mem::transmute(is_suspended) };
                is_suspended as u64
            });
            __bindgen_bitfield_unit.set(5usize, 1u8, {
                let is_noirq_suspended: u8 = unsafe { ::core::mem::transmute(is_noirq_suspended) };
                is_noirq_suspended as u64
            });
            __bindgen_bitfield_unit.set(6usize, 1u8, {
                let is_late_suspended: u8 = unsafe { ::core::mem::transmute(is_late_suspended) };
                is_late_suspended as u64
            });
            __bindgen_bitfield_unit.set(7usize, 1u8, {
                let no_pm: u8 = unsafe { ::core::mem::transmute(no_pm) };
                no_pm as u64
            });
            __bindgen_bitfield_unit.set(8usize, 1u8, {
                let early_init: u8 = unsafe { ::core::mem::transmute(early_init) };
                early_init as u64
            });
            __bindgen_bitfield_unit.set(9usize, 1u8, {
                let direct_complete: u8 = unsafe { ::core::mem::transmute(direct_complete) };
                direct_complete as u64
            });
            __bindgen_bitfield_unit
        }
        #[inline]
        pub fn wakeup_path(&self) -> bool_ {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_wakeup_path(&mut self, val: bool_) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(0usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn syscore(&self) -> bool_ {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_syscore(&mut self, val: bool_) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(1usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn no_pm_callbacks(&self) -> bool_ {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(2usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_no_pm_callbacks(&mut self, val: bool_) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(2usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn must_resume(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(3usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_must_resume(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_2.set(3usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn may_skip_resume(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(4usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_may_skip_resume(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_2.set(4usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_2(
            wakeup_path: bool_,
            syscore: bool_,
            no_pm_callbacks: bool_,
            must_resume: ::cty::c_uint,
            may_skip_resume: ::cty::c_uint,
        ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 1u8, {
                let wakeup_path: u8 = unsafe { ::core::mem::transmute(wakeup_path) };
                wakeup_path as u64
            });
            __bindgen_bitfield_unit.set(1usize, 1u8, {
                let syscore: u8 = unsafe { ::core::mem::transmute(syscore) };
                syscore as u64
            });
            __bindgen_bitfield_unit.set(2usize, 1u8, {
                let no_pm_callbacks: u8 = unsafe { ::core::mem::transmute(no_pm_callbacks) };
                no_pm_callbacks as u64
            });
            __bindgen_bitfield_unit.set(3usize, 1u8, {
                let must_resume: u32 = unsafe { ::core::mem::transmute(must_resume) };
                must_resume as u64
            });
            __bindgen_bitfield_unit.set(4usize, 1u8, {
                let may_skip_resume: u32 = unsafe { ::core::mem::transmute(may_skip_resume) };
                may_skip_resume as u64
            });
            __bindgen_bitfield_unit
        }
        #[inline]
        pub fn disable_depth(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_3.get(0usize, 3u8) as u32) }
        }
        #[inline]
        pub fn set_disable_depth(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_3.set(0usize, 3u8, val as u64)
            }
        }
        #[inline]
        pub fn idle_notification(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_3.get(3usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_idle_notification(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_3.set(3usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn request_pending(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_3.get(4usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_request_pending(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_3.set(4usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn deferred_resume(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_3.get(5usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_deferred_resume(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_3.set(5usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn needs_force_resume(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_3.get(6usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_needs_force_resume(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_3.set(6usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn runtime_auto(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_3.get(7usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_runtime_auto(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_3.set(7usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn ignore_children(&self) -> bool_ {
            unsafe { ::core::mem::transmute(self._bitfield_3.get(8usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_ignore_children(&mut self, val: bool_) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_3.set(8usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn no_callbacks(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_3.get(9usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_no_callbacks(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_3.set(9usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn irq_safe(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_3.get(10usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_irq_safe(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_3.set(10usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn use_autosuspend(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_3.get(11usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_use_autosuspend(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_3.set(11usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn timer_autosuspends(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_3.get(12usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_timer_autosuspends(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_3.set(12usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn memalloc_noio(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_3.get(13usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_memalloc_noio(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_3.set(13usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_3(
            disable_depth: ::cty::c_uint,
            idle_notification: ::cty::c_uint,
            request_pending: ::cty::c_uint,
            deferred_resume: ::cty::c_uint,
            needs_force_resume: ::cty::c_uint,
            runtime_auto: ::cty::c_uint,
            ignore_children: bool_,
            no_callbacks: ::cty::c_uint,
            irq_safe: ::cty::c_uint,
            use_autosuspend: ::cty::c_uint,
            timer_autosuspends: ::cty::c_uint,
            memalloc_noio: ::cty::c_uint,
        ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 3u8, {
                let disable_depth: u32 = unsafe { ::core::mem::transmute(disable_depth) };
                disable_depth as u64
            });
            __bindgen_bitfield_unit.set(3usize, 1u8, {
                let idle_notification: u32 = unsafe { ::core::mem::transmute(idle_notification) };
                idle_notification as u64
            });
            __bindgen_bitfield_unit.set(4usize, 1u8, {
                let request_pending: u32 = unsafe { ::core::mem::transmute(request_pending) };
                request_pending as u64
            });
            __bindgen_bitfield_unit.set(5usize, 1u8, {
                let deferred_resume: u32 = unsafe { ::core::mem::transmute(deferred_resume) };
                deferred_resume as u64
            });
            __bindgen_bitfield_unit.set(6usize, 1u8, {
                let needs_force_resume: u32 = unsafe { ::core::mem::transmute(needs_force_resume) };
                needs_force_resume as u64
            });
            __bindgen_bitfield_unit.set(7usize, 1u8, {
                let runtime_auto: u32 = unsafe { ::core::mem::transmute(runtime_auto) };
                runtime_auto as u64
            });
            __bindgen_bitfield_unit.set(8usize, 1u8, {
                let ignore_children: u8 = unsafe { ::core::mem::transmute(ignore_children) };
                ignore_children as u64
            });
            __bindgen_bitfield_unit.set(9usize, 1u8, {
                let no_callbacks: u32 = unsafe { ::core::mem::transmute(no_callbacks) };
                no_callbacks as u64
            });
            __bindgen_bitfield_unit.set(10usize, 1u8, {
                let irq_safe: u32 = unsafe { ::core::mem::transmute(irq_safe) };
                irq_safe as u64
            });
            __bindgen_bitfield_unit.set(11usize, 1u8, {
                let use_autosuspend: u32 = unsafe { ::core::mem::transmute(use_autosuspend) };
                use_autosuspend as u64
            });
            __bindgen_bitfield_unit.set(12usize, 1u8, {
                let timer_autosuspends: u32 = unsafe { ::core::mem::transmute(timer_autosuspends) };
                timer_autosuspends as u64
            });
            __bindgen_bitfield_unit.set(13usize, 1u8, {
                let memalloc_noio: u32 = unsafe { ::core::mem::transmute(memalloc_noio) };
                memalloc_noio as u64
            });
            __bindgen_bitfield_unit
        }
    }
    #[doc = " struct dev_pm_domain - power management domain representation."]
    #[doc = ""]
    #[doc = " @ops: Power management operations associated with this domain."]
    #[doc = " @start: Called when a user needs to start the device via the domain."]
    #[doc = " @detach: Called when removing a device from the domain."]
    #[doc = " @activate: Called before executing probe routines for bus types and drivers."]
    #[doc = " @sync: Called after successful driver probe."]
    #[doc = " @dismiss: Called after unsuccessful driver probe and after driver removal."]
    #[doc = ""]
    #[doc = " Power domains provide callbacks that are executed during system suspend,"]
    #[doc = " hibernation, system resume and during runtime PM transitions instead of"]
    #[doc = " subsystem-level and driver-level callbacks."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dev_pm_domain {
        pub ops: dev_pm_ops,
        pub start: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ::cty::c_int>,
        pub detach:
            ::core::option::Option<unsafe extern "C" fn(dev: *mut device, power_off: bool_)>,
        pub activate:
            ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ::cty::c_int>,
        pub sync: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
        pub dismiss: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    }
    #[test]
    fn bindgen_test_layout_dev_pm_domain() {
        assert_eq!(
            ::core::mem::size_of::<dev_pm_domain>(),
            224usize,
            concat!("Size of: ", stringify!(dev_pm_domain))
        );
        assert_eq!(
            ::core::mem::align_of::<dev_pm_domain>(),
            8usize,
            concat!("Alignment of ", stringify!(dev_pm_domain))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pm_domain>())).ops as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_domain),
                "::",
                stringify!(ops)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pm_domain>())).start as *const _ as usize },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_domain),
                "::",
                stringify!(start)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pm_domain>())).detach as *const _ as usize },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_domain),
                "::",
                stringify!(detach)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pm_domain>())).activate as *const _ as usize },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_domain),
                "::",
                stringify!(activate)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pm_domain>())).sync as *const _ as usize },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_domain),
                "::",
                stringify!(sync)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_pm_domain>())).dismiss as *const _ as usize },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_pm_domain),
                "::",
                stringify!(dismiss)
            )
        );
    }
    #[doc = " struct bus_type - The bus type of the device"]
    #[doc = ""]
    #[doc = " @name:\tThe name of the bus."]
    #[doc = " @dev_name:\tUsed for subsystems to enumerate devices like (\"foo%u\", dev->id)."]
    #[doc = " @bus_groups:\tDefault attributes of the bus."]
    #[doc = " @dev_groups:\tDefault attributes of the devices on the bus."]
    #[doc = " @drv_groups: Default attributes of the device drivers on the bus."]
    #[doc = " @match:\tCalled, perhaps multiple times, whenever a new device or driver"]
    #[doc = "\t\tis added for this bus. It should return a positive value if the"]
    #[doc = "\t\tgiven device can be handled by the given driver and zero"]
    #[doc = "\t\totherwise. It may also return error code if determining that"]
    #[doc = "\t\tthe driver supports the device is not possible. In case of"]
    #[doc = "\t\t-EPROBE_DEFER it will queue the device for deferred probing."]
    #[doc = " @uevent:\tCalled when a device is added, removed, or a few other things"]
    #[doc = "\t\tthat generate uevents to add the environment variables."]
    #[doc = " @probe:\tCalled when a new device or driver add to this bus, and callback"]
    #[doc = "\t\tthe specific driver's probe to initial the matched device."]
    #[doc = " @sync_state:\tCalled to sync device state to software state after all the"]
    #[doc = "\t\tstate tracking consumers linked to this device (present at"]
    #[doc = "\t\tthe time of late_initcall) have successfully bound to a"]
    #[doc = "\t\tdriver. If the device has no consumers, this function will"]
    #[doc = "\t\tbe called at late_initcall_sync level. If the device has"]
    #[doc = "\t\tconsumers that are never bound to a driver, this function"]
    #[doc = "\t\twill never get called until they do."]
    #[doc = " @remove:\tCalled when a device removed from this bus."]
    #[doc = " @shutdown:\tCalled at shut-down time to quiesce the device."]
    #[doc = ""]
    #[doc = " @online:\tCalled to put the device back online (after offlining it)."]
    #[doc = " @offline:\tCalled to put the device offline for hot-removal. May fail."]
    #[doc = ""]
    #[doc = " @suspend:\tCalled when a device on this bus wants to go to sleep mode."]
    #[doc = " @resume:\tCalled to bring a device on this bus out of sleep mode."]
    #[doc = " @num_vf:\tCalled to find out how many virtual functions a device on this"]
    #[doc = "\t\tbus supports."]
    #[doc = " @dma_configure:\tCalled to setup DMA configuration on a device on"]
    #[doc = "\t\t\tthis bus."]
    #[doc = " @dma_cleanup:\tCalled to cleanup DMA configuration on a device on"]
    #[doc = "\t\t\tthis bus."]
    #[doc = " @pm:\t\tPower management operations of this bus, callback the specific"]
    #[doc = "\t\tdevice driver's pm-ops."]
    #[doc = " @iommu_ops:  IOMMU specific operations for this bus, used to attach IOMMU"]
    #[doc = "              driver implementations to a bus and allow the driver to do"]
    #[doc = "              bus-specific setup"]
    #[doc = " @need_parent_lock:\tWhen probing or removing a device on this bus, the"]
    #[doc = "\t\t\tdevice core should lock the device's parent."]
    #[doc = ""]
    #[doc = " A bus is a channel between the processor and one or more devices. For the"]
    #[doc = " purposes of the device model, all devices are connected via a bus, even if"]
    #[doc = " it is an internal, virtual, \"platform\" bus. Buses can plug into each other."]
    #[doc = " A USB controller is usually a PCI device, for example. The device model"]
    #[doc = " represents the actual connections between buses and the devices they control."]
    #[doc = " A bus is represented by the bus_type structure. It contains the name, the"]
    #[doc = " default attributes, the bus' methods, PM operations, and the driver core's"]
    #[doc = " private data."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bus_type {
        pub name: *const ::cty::c_char,
        pub dev_name: *const ::cty::c_char,
        pub bus_groups: *mut *const attribute_group,
        pub dev_groups: *mut *const attribute_group,
        pub drv_groups: *mut *const attribute_group,
        pub match_: ::core::option::Option<
            unsafe extern "C" fn(dev: *mut device, drv: *mut device_driver) -> ::cty::c_int,
        >,
        pub uevent: ::core::option::Option<
            unsafe extern "C" fn(dev: *const device, env: *mut kobj_uevent_env) -> ::cty::c_int,
        >,
        pub probe: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ::cty::c_int>,
        pub sync_state: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
        pub remove: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
        pub shutdown: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
        pub online: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ::cty::c_int>,
        pub offline: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ::cty::c_int>,
        pub suspend: ::core::option::Option<
            unsafe extern "C" fn(dev: *mut device, state: pm_message_t) -> ::cty::c_int,
        >,
        pub resume: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ::cty::c_int>,
        pub num_vf: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ::cty::c_int>,
        pub dma_configure:
            ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ::cty::c_int>,
        pub dma_cleanup: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
        pub pm: *const dev_pm_ops,
        pub iommu_ops: *const iommu_ops,
        pub need_parent_lock: bool_,
    }
    #[test]
    fn bindgen_test_layout_bus_type() {
        assert_eq!(
            ::core::mem::size_of::<bus_type>(),
            168usize,
            concat!("Size of: ", stringify!(bus_type))
        );
        assert_eq!(
            ::core::mem::align_of::<bus_type>(),
            8usize,
            concat!("Alignment of ", stringify!(bus_type))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bus_type>())).name as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bus_type),
                "::",
                stringify!(name)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bus_type>())).dev_name as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bus_type),
                "::",
                stringify!(dev_name)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bus_type>())).bus_groups as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(bus_type),
                "::",
                stringify!(bus_groups)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bus_type>())).dev_groups as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(bus_type),
                "::",
                stringify!(dev_groups)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bus_type>())).drv_groups as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(bus_type),
                "::",
                stringify!(drv_groups)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bus_type>())).match_ as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(bus_type),
                "::",
                stringify!(match_)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bus_type>())).uevent as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(bus_type),
                "::",
                stringify!(uevent)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bus_type>())).probe as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(bus_type),
                "::",
                stringify!(probe)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bus_type>())).sync_state as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(bus_type),
                "::",
                stringify!(sync_state)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bus_type>())).remove as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(bus_type),
                "::",
                stringify!(remove)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bus_type>())).shutdown as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(bus_type),
                "::",
                stringify!(shutdown)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bus_type>())).online as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(bus_type),
                "::",
                stringify!(online)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bus_type>())).offline as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(bus_type),
                "::",
                stringify!(offline)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bus_type>())).suspend as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(bus_type),
                "::",
                stringify!(suspend)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bus_type>())).resume as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(bus_type),
                "::",
                stringify!(resume)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bus_type>())).num_vf as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(bus_type),
                "::",
                stringify!(num_vf)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bus_type>())).dma_configure as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(bus_type),
                "::",
                stringify!(dma_configure)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bus_type>())).dma_cleanup as *const _ as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(bus_type),
                "::",
                stringify!(dma_cleanup)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bus_type>())).pm as *const _ as usize },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(bus_type),
                "::",
                stringify!(pm)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bus_type>())).iommu_ops as *const _ as usize },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(bus_type),
                "::",
                stringify!(iommu_ops)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bus_type>())).need_parent_lock as *const _ as usize },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(bus_type),
                "::",
                stringify!(need_parent_lock)
            )
        );
    }
    #[doc = " struct class - device classes"]
    #[doc = " @name:\tName of the class."]
    #[doc = " @class_groups: Default attributes of this class."]
    #[doc = " @dev_groups:\tDefault attributes of the devices that belong to the class."]
    #[doc = " @dev_uevent:\tCalled when a device is added, removed from this class, or a"]
    #[doc = "\t\tfew other things that generate uevents to add the environment"]
    #[doc = "\t\tvariables."]
    #[doc = " @devnode:\tCallback to provide the devtmpfs."]
    #[doc = " @class_release: Called to release this class."]
    #[doc = " @dev_release: Called to release the device."]
    #[doc = " @shutdown_pre: Called at shut-down time before driver shutdown."]
    #[doc = " @ns_type:\tCallbacks so sysfs can detemine namespaces."]
    #[doc = " @namespace:\tNamespace of the device belongs to this class."]
    #[doc = " @get_ownership: Allows class to specify uid/gid of the sysfs directories"]
    #[doc = "\t\tfor the devices belonging to the class. Usually tied to"]
    #[doc = "\t\tdevice's namespace."]
    #[doc = " @pm:\t\tThe default device power management operations of this class."]
    #[doc = " @p:\t\tThe private data of the driver core, no one other than the"]
    #[doc = "\t\tdriver core can touch this."]
    #[doc = ""]
    #[doc = " A class is a higher-level view of a device that abstracts out low-level"]
    #[doc = " implementation details. Drivers may see a SCSI disk or an ATA disk, but,"]
    #[doc = " at the class level, they are all simply disks. Classes allow user space"]
    #[doc = " to work with devices based on what they do, rather than how they are"]
    #[doc = " connected or how they work."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct class {
        pub name: *const ::cty::c_char,
        pub class_groups: *mut *const attribute_group,
        pub dev_groups: *mut *const attribute_group,
        pub dev_uevent: ::core::option::Option<
            unsafe extern "C" fn(dev: *const device, env: *mut kobj_uevent_env) -> ::cty::c_int,
        >,
        pub devnode: ::core::option::Option<
            unsafe extern "C" fn(dev: *const device, mode: *mut umode_t) -> *mut ::cty::c_char,
        >,
        pub class_release: ::core::option::Option<unsafe extern "C" fn(class: *const class)>,
        pub dev_release: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
        pub shutdown_pre:
            ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ::cty::c_int>,
        pub ns_type: *const kobj_ns_type_operations,
        pub namespace: ::core::option::Option<
            unsafe extern "C" fn(dev: *const device) -> *const ::cty::c_void,
        >,
        pub get_ownership: ::core::option::Option<
            unsafe extern "C" fn(dev: *const device, uid: *mut kuid_t, gid: *mut kgid_t),
        >,
        pub pm: *const dev_pm_ops,
    }
    #[test]
    fn bindgen_test_layout_class() {
        assert_eq!(
            ::core::mem::size_of::<class>(),
            96usize,
            concat!("Size of: ", stringify!(class))
        );
        assert_eq!(
            ::core::mem::align_of::<class>(),
            8usize,
            concat!("Alignment of ", stringify!(class))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<class>())).name as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(class),
                "::",
                stringify!(name)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<class>())).class_groups as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(class),
                "::",
                stringify!(class_groups)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<class>())).dev_groups as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(class),
                "::",
                stringify!(dev_groups)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<class>())).dev_uevent as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(class),
                "::",
                stringify!(dev_uevent)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<class>())).devnode as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(class),
                "::",
                stringify!(devnode)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<class>())).class_release as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(class),
                "::",
                stringify!(class_release)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<class>())).dev_release as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(class),
                "::",
                stringify!(dev_release)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<class>())).shutdown_pre as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(class),
                "::",
                stringify!(shutdown_pre)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<class>())).ns_type as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(class),
                "::",
                stringify!(ns_type)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<class>())).namespace as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(class),
                "::",
                stringify!(namespace)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<class>())).get_ownership as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(class),
                "::",
                stringify!(get_ownership)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<class>())).pm as *const _ as usize },
            88usize,
            concat!("Offset of field: ", stringify!(class), "::", stringify!(pm))
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct vdso_image {
        pub data: *mut ::cty::c_void,
        pub size: ::cty::c_ulong,
        pub alt: ::cty::c_ulong,
        pub alt_len: ::cty::c_ulong,
        pub extable_base: ::cty::c_ulong,
        pub extable_len: ::cty::c_ulong,
        pub extable: *const ::cty::c_void,
        pub sym_vvar_start: ::cty::c_long,
        pub sym_vvar_page: ::cty::c_long,
        pub sym_pvclock_page: ::cty::c_long,
        pub sym_hvclock_page: ::cty::c_long,
        pub sym_timens_page: ::cty::c_long,
        pub sym_VDSO32_NOTE_MASK: ::cty::c_long,
        pub sym___kernel_sigreturn: ::cty::c_long,
        pub sym___kernel_rt_sigreturn: ::cty::c_long,
        pub sym___kernel_vsyscall: ::cty::c_long,
        pub sym_int80_landing_pad: ::cty::c_long,
        pub sym_vdso32_sigreturn_landing_pad: ::cty::c_long,
        pub sym_vdso32_rt_sigreturn_landing_pad: ::cty::c_long,
    }
    #[test]
    fn bindgen_test_layout_vdso_image() {
        assert_eq!(
            ::core::mem::size_of::<vdso_image>(),
            152usize,
            concat!("Size of: ", stringify!(vdso_image))
        );
        assert_eq!(
            ::core::mem::align_of::<vdso_image>(),
            8usize,
            concat!("Alignment of ", stringify!(vdso_image))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vdso_image>())).data as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(vdso_image),
                "::",
                stringify!(data)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vdso_image>())).size as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(vdso_image),
                "::",
                stringify!(size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vdso_image>())).alt as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(vdso_image),
                "::",
                stringify!(alt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vdso_image>())).alt_len as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(vdso_image),
                "::",
                stringify!(alt_len)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vdso_image>())).extable_base as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(vdso_image),
                "::",
                stringify!(extable_base)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vdso_image>())).extable_len as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(vdso_image),
                "::",
                stringify!(extable_len)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vdso_image>())).extable as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(vdso_image),
                "::",
                stringify!(extable)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vdso_image>())).sym_vvar_start as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(vdso_image),
                "::",
                stringify!(sym_vvar_start)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vdso_image>())).sym_vvar_page as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(vdso_image),
                "::",
                stringify!(sym_vvar_page)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<vdso_image>())).sym_pvclock_page as *const _ as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(vdso_image),
                "::",
                stringify!(sym_pvclock_page)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<vdso_image>())).sym_hvclock_page as *const _ as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(vdso_image),
                "::",
                stringify!(sym_hvclock_page)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vdso_image>())).sym_timens_page as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(vdso_image),
                "::",
                stringify!(sym_timens_page)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<vdso_image>())).sym_VDSO32_NOTE_MASK as *const _ as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(vdso_image),
                "::",
                stringify!(sym_VDSO32_NOTE_MASK)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<vdso_image>())).sym___kernel_sigreturn as *const _ as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(vdso_image),
                "::",
                stringify!(sym___kernel_sigreturn)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<vdso_image>())).sym___kernel_rt_sigreturn as *const _
                    as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(vdso_image),
                "::",
                stringify!(sym___kernel_rt_sigreturn)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<vdso_image>())).sym___kernel_vsyscall as *const _ as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(vdso_image),
                "::",
                stringify!(sym___kernel_vsyscall)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<vdso_image>())).sym_int80_landing_pad as *const _ as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(vdso_image),
                "::",
                stringify!(sym_int80_landing_pad)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<vdso_image>())).sym_vdso32_sigreturn_landing_pad as *const _
                    as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(vdso_image),
                "::",
                stringify!(sym_vdso32_sigreturn_landing_pad)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<vdso_image>())).sym_vdso32_rt_sigreturn_landing_pad
                    as *const _ as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(vdso_image),
                "::",
                stringify!(sym_vdso32_rt_sigreturn_landing_pad)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct linux_binprm {
        _unused: [u8; 0],
    }
    pub type Elf64_Addr = __u64;
    pub type Elf64_Half = __u16;
    pub type Elf64_Off = __u64;
    pub type Elf64_Word = __u32;
    pub type Elf64_Xword = __u64;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct elf64_sym {
        pub st_name: Elf64_Word,
        pub st_info: ::cty::c_uchar,
        pub st_other: ::cty::c_uchar,
        pub st_shndx: Elf64_Half,
        pub st_value: Elf64_Addr,
        pub st_size: Elf64_Xword,
    }
    #[test]
    fn bindgen_test_layout_elf64_sym() {
        assert_eq!(
            ::core::mem::size_of::<elf64_sym>(),
            24usize,
            concat!("Size of: ", stringify!(elf64_sym))
        );
        assert_eq!(
            ::core::mem::align_of::<elf64_sym>(),
            8usize,
            concat!("Alignment of ", stringify!(elf64_sym))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<elf64_sym>())).st_name as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(elf64_sym),
                "::",
                stringify!(st_name)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<elf64_sym>())).st_info as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(elf64_sym),
                "::",
                stringify!(st_info)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<elf64_sym>())).st_other as *const _ as usize },
            5usize,
            concat!(
                "Offset of field: ",
                stringify!(elf64_sym),
                "::",
                stringify!(st_other)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<elf64_sym>())).st_shndx as *const _ as usize },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(elf64_sym),
                "::",
                stringify!(st_shndx)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<elf64_sym>())).st_value as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(elf64_sym),
                "::",
                stringify!(st_value)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<elf64_sym>())).st_size as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(elf64_sym),
                "::",
                stringify!(st_size)
            )
        );
    }
    pub type Elf64_Sym = elf64_sym;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct elf64_hdr {
        pub e_ident: [::cty::c_uchar; 16usize],
        pub e_type: Elf64_Half,
        pub e_machine: Elf64_Half,
        pub e_version: Elf64_Word,
        pub e_entry: Elf64_Addr,
        pub e_phoff: Elf64_Off,
        pub e_shoff: Elf64_Off,
        pub e_flags: Elf64_Word,
        pub e_ehsize: Elf64_Half,
        pub e_phentsize: Elf64_Half,
        pub e_phnum: Elf64_Half,
        pub e_shentsize: Elf64_Half,
        pub e_shnum: Elf64_Half,
        pub e_shstrndx: Elf64_Half,
    }
    #[test]
    fn bindgen_test_layout_elf64_hdr() {
        assert_eq!(
            ::core::mem::size_of::<elf64_hdr>(),
            64usize,
            concat!("Size of: ", stringify!(elf64_hdr))
        );
        assert_eq!(
            ::core::mem::align_of::<elf64_hdr>(),
            8usize,
            concat!("Alignment of ", stringify!(elf64_hdr))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_ident as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(elf64_hdr),
                "::",
                stringify!(e_ident)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_type as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(elf64_hdr),
                "::",
                stringify!(e_type)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_machine as *const _ as usize },
            18usize,
            concat!(
                "Offset of field: ",
                stringify!(elf64_hdr),
                "::",
                stringify!(e_machine)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_version as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(elf64_hdr),
                "::",
                stringify!(e_version)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_entry as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(elf64_hdr),
                "::",
                stringify!(e_entry)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_phoff as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(elf64_hdr),
                "::",
                stringify!(e_phoff)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_shoff as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(elf64_hdr),
                "::",
                stringify!(e_shoff)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_flags as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(elf64_hdr),
                "::",
                stringify!(e_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_ehsize as *const _ as usize },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(elf64_hdr),
                "::",
                stringify!(e_ehsize)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_phentsize as *const _ as usize },
            54usize,
            concat!(
                "Offset of field: ",
                stringify!(elf64_hdr),
                "::",
                stringify!(e_phentsize)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_phnum as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(elf64_hdr),
                "::",
                stringify!(e_phnum)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_shentsize as *const _ as usize },
            58usize,
            concat!(
                "Offset of field: ",
                stringify!(elf64_hdr),
                "::",
                stringify!(e_shentsize)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_shnum as *const _ as usize },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(elf64_hdr),
                "::",
                stringify!(e_shnum)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<elf64_hdr>())).e_shstrndx as *const _ as usize },
            62usize,
            concat!(
                "Offset of field: ",
                stringify!(elf64_hdr),
                "::",
                stringify!(e_shstrndx)
            )
        );
    }
    pub type Elf64_Ehdr = elf64_hdr;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct elf64_shdr {
        pub sh_name: Elf64_Word,
        pub sh_type: Elf64_Word,
        pub sh_flags: Elf64_Xword,
        pub sh_addr: Elf64_Addr,
        pub sh_offset: Elf64_Off,
        pub sh_size: Elf64_Xword,
        pub sh_link: Elf64_Word,
        pub sh_info: Elf64_Word,
        pub sh_addralign: Elf64_Xword,
        pub sh_entsize: Elf64_Xword,
    }
    #[test]
    fn bindgen_test_layout_elf64_shdr() {
        assert_eq!(
            ::core::mem::size_of::<elf64_shdr>(),
            64usize,
            concat!("Size of: ", stringify!(elf64_shdr))
        );
        assert_eq!(
            ::core::mem::align_of::<elf64_shdr>(),
            8usize,
            concat!("Alignment of ", stringify!(elf64_shdr))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<elf64_shdr>())).sh_name as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(elf64_shdr),
                "::",
                stringify!(sh_name)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<elf64_shdr>())).sh_type as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(elf64_shdr),
                "::",
                stringify!(sh_type)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<elf64_shdr>())).sh_flags as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(elf64_shdr),
                "::",
                stringify!(sh_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<elf64_shdr>())).sh_addr as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(elf64_shdr),
                "::",
                stringify!(sh_addr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<elf64_shdr>())).sh_offset as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(elf64_shdr),
                "::",
                stringify!(sh_offset)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<elf64_shdr>())).sh_size as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(elf64_shdr),
                "::",
                stringify!(sh_size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<elf64_shdr>())).sh_link as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(elf64_shdr),
                "::",
                stringify!(sh_link)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<elf64_shdr>())).sh_info as *const _ as usize },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(elf64_shdr),
                "::",
                stringify!(sh_info)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<elf64_shdr>())).sh_addralign as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(elf64_shdr),
                "::",
                stringify!(sh_addralign)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<elf64_shdr>())).sh_entsize as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(elf64_shdr),
                "::",
                stringify!(sh_entsize)
            )
        );
    }
    pub type Elf64_Shdr = elf64_shdr;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct kernel_param {
        pub name: *const ::cty::c_char,
        pub mod_: *mut module,
        pub ops: *const kernel_param_ops,
        pub perm: _cargo_bpf_u16,
        pub level: s8,
        pub flags: _cargo_bpf_u8,
        pub __bindgen_anon_1: kernel_param__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union kernel_param__bindgen_ty_1 {
        pub arg: *mut ::cty::c_void,
        pub str_: *const kparam_string,
        pub arr: *const kparam_array,
    }
    #[test]
    fn bindgen_test_layout_kernel_param__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<kernel_param__bindgen_ty_1>(),
            8usize,
            concat!("Size of: ", stringify!(kernel_param__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<kernel_param__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(kernel_param__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<kernel_param__bindgen_ty_1>())).arg as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(kernel_param__bindgen_ty_1),
                "::",
                stringify!(arg)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<kernel_param__bindgen_ty_1>())).str_ as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(kernel_param__bindgen_ty_1),
                "::",
                stringify!(str_)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<kernel_param__bindgen_ty_1>())).arr as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(kernel_param__bindgen_ty_1),
                "::",
                stringify!(arr)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_kernel_param() {
        assert_eq!(
            ::core::mem::size_of::<kernel_param>(),
            40usize,
            concat!("Size of: ", stringify!(kernel_param))
        );
        assert_eq!(
            ::core::mem::align_of::<kernel_param>(),
            8usize,
            concat!("Alignment of ", stringify!(kernel_param))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kernel_param>())).name as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(kernel_param),
                "::",
                stringify!(name)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kernel_param>())).mod_ as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(kernel_param),
                "::",
                stringify!(mod_)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kernel_param>())).ops as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(kernel_param),
                "::",
                stringify!(ops)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kernel_param>())).perm as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(kernel_param),
                "::",
                stringify!(perm)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kernel_param>())).level as *const _ as usize },
            26usize,
            concat!(
                "Offset of field: ",
                stringify!(kernel_param),
                "::",
                stringify!(level)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kernel_param>())).flags as *const _ as usize },
            27usize,
            concat!(
                "Offset of field: ",
                stringify!(kernel_param),
                "::",
                stringify!(flags)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct kparam_string {
        pub maxlen: ::cty::c_uint,
        pub string: *mut ::cty::c_char,
    }
    #[test]
    fn bindgen_test_layout_kparam_string() {
        assert_eq!(
            ::core::mem::size_of::<kparam_string>(),
            16usize,
            concat!("Size of: ", stringify!(kparam_string))
        );
        assert_eq!(
            ::core::mem::align_of::<kparam_string>(),
            8usize,
            concat!("Alignment of ", stringify!(kparam_string))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kparam_string>())).maxlen as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(kparam_string),
                "::",
                stringify!(maxlen)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kparam_string>())).string as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(kparam_string),
                "::",
                stringify!(string)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct kparam_array {
        pub max: ::cty::c_uint,
        pub elemsize: ::cty::c_uint,
        pub num: *mut ::cty::c_uint,
        pub ops: *const kernel_param_ops,
        pub elem: *mut ::cty::c_void,
    }
    #[test]
    fn bindgen_test_layout_kparam_array() {
        assert_eq!(
            ::core::mem::size_of::<kparam_array>(),
            32usize,
            concat!("Size of: ", stringify!(kparam_array))
        );
        assert_eq!(
            ::core::mem::align_of::<kparam_array>(),
            8usize,
            concat!("Alignment of ", stringify!(kparam_array))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kparam_array>())).max as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(kparam_array),
                "::",
                stringify!(max)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kparam_array>())).elemsize as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(kparam_array),
                "::",
                stringify!(elemsize)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kparam_array>())).num as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(kparam_array),
                "::",
                stringify!(num)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kparam_array>())).ops as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(kparam_array),
                "::",
                stringify!(ops)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<kparam_array>())).elem as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(kparam_array),
                "::",
                stringify!(elem)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct latch_tree_node {
        pub node: [rb_node; 2usize],
    }
    #[test]
    fn bindgen_test_layout_latch_tree_node() {
        assert_eq!(
            ::core::mem::size_of::<latch_tree_node>(),
            48usize,
            concat!("Size of: ", stringify!(latch_tree_node))
        );
        assert_eq!(
            ::core::mem::align_of::<latch_tree_node>(),
            8usize,
            concat!("Alignment of ", stringify!(latch_tree_node))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<latch_tree_node>())).node as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(latch_tree_node),
                "::",
                stringify!(node)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct error_injection_entry {
        pub addr: ::cty::c_ulong,
        pub etype: ::cty::c_int,
    }
    #[test]
    fn bindgen_test_layout_error_injection_entry() {
        assert_eq!(
            ::core::mem::size_of::<error_injection_entry>(),
            16usize,
            concat!("Size of: ", stringify!(error_injection_entry))
        );
        assert_eq!(
            ::core::mem::align_of::<error_injection_entry>(),
            8usize,
            concat!("Alignment of ", stringify!(error_injection_entry))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<error_injection_entry>())).addr as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(error_injection_entry),
                "::",
                stringify!(addr)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<error_injection_entry>())).etype as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(error_injection_entry),
                "::",
                stringify!(etype)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct mod_arch_specific {}
    #[test]
    fn bindgen_test_layout_mod_arch_specific() {
        assert_eq!(
            ::core::mem::size_of::<mod_arch_specific>(),
            0usize,
            concat!("Size of: ", stringify!(mod_arch_specific))
        );
        assert_eq!(
            ::core::mem::align_of::<mod_arch_specific>(),
            1usize,
            concat!("Alignment of ", stringify!(mod_arch_specific))
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct module_kobject {
        pub kobj: kobject,
        pub mod_: *mut module,
        pub drivers_dir: *mut kobject,
        pub mp: *mut module_param_attrs,
        pub kobj_completion: *mut completion,
    }
    #[test]
    fn bindgen_test_layout_module_kobject() {
        assert_eq!(
            ::core::mem::size_of::<module_kobject>(),
            96usize,
            concat!("Size of: ", stringify!(module_kobject))
        );
        assert_eq!(
            ::core::mem::align_of::<module_kobject>(),
            8usize,
            concat!("Alignment of ", stringify!(module_kobject))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module_kobject>())).kobj as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(module_kobject),
                "::",
                stringify!(kobj)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module_kobject>())).mod_ as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(module_kobject),
                "::",
                stringify!(mod_)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module_kobject>())).drivers_dir as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(module_kobject),
                "::",
                stringify!(drivers_dir)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module_kobject>())).mp as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(module_kobject),
                "::",
                stringify!(mp)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<module_kobject>())).kobj_completion as *const _ as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(module_kobject),
                "::",
                stringify!(kobj_completion)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct module_attribute {
        pub attr: attribute,
        pub show: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut module_attribute,
                arg2: *mut module_kobject,
                arg3: *mut ::cty::c_char,
            ) -> ssize_t,
        >,
        pub store: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut module_attribute,
                arg2: *mut module_kobject,
                arg3: *const ::cty::c_char,
                count: size_t,
            ) -> ssize_t,
        >,
        pub setup: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut module, arg2: *const ::cty::c_char),
        >,
        pub test: ::core::option::Option<unsafe extern "C" fn(arg1: *mut module) -> ::cty::c_int>,
        pub free: ::core::option::Option<unsafe extern "C" fn(arg1: *mut module)>,
    }
    #[test]
    fn bindgen_test_layout_module_attribute() {
        assert_eq!(
            ::core::mem::size_of::<module_attribute>(),
            56usize,
            concat!("Size of: ", stringify!(module_attribute))
        );
        assert_eq!(
            ::core::mem::align_of::<module_attribute>(),
            8usize,
            concat!("Alignment of ", stringify!(module_attribute))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module_attribute>())).attr as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(module_attribute),
                "::",
                stringify!(attr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module_attribute>())).show as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(module_attribute),
                "::",
                stringify!(show)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module_attribute>())).store as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(module_attribute),
                "::",
                stringify!(store)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module_attribute>())).setup as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(module_attribute),
                "::",
                stringify!(setup)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module_attribute>())).test as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(module_attribute),
                "::",
                stringify!(test)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module_attribute>())).free as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(module_attribute),
                "::",
                stringify!(free)
            )
        );
    }
    pub const module_state_MODULE_STATE_LIVE: module_state = 0;
    pub const module_state_MODULE_STATE_COMING: module_state = 1;
    pub const module_state_MODULE_STATE_GOING: module_state = 2;
    pub const module_state_MODULE_STATE_UNFORMED: module_state = 3;
    pub type module_state = ::cty::c_uint;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct mod_tree_node {
        pub mod_: *mut module,
        pub node: latch_tree_node,
    }
    #[test]
    fn bindgen_test_layout_mod_tree_node() {
        assert_eq!(
            ::core::mem::size_of::<mod_tree_node>(),
            56usize,
            concat!("Size of: ", stringify!(mod_tree_node))
        );
        assert_eq!(
            ::core::mem::align_of::<mod_tree_node>(),
            8usize,
            concat!("Alignment of ", stringify!(mod_tree_node))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mod_tree_node>())).mod_ as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mod_tree_node),
                "::",
                stringify!(mod_)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mod_tree_node>())).node as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mod_tree_node),
                "::",
                stringify!(node)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct module_memory {
        pub base: *mut ::cty::c_void,
        pub size: ::cty::c_uint,
        pub mtn: mod_tree_node,
    }
    #[test]
    fn bindgen_test_layout_module_memory() {
        assert_eq!(
            ::core::mem::size_of::<module_memory>(),
            72usize,
            concat!("Size of: ", stringify!(module_memory))
        );
        assert_eq!(
            ::core::mem::align_of::<module_memory>(),
            8usize,
            concat!("Alignment of ", stringify!(module_memory))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module_memory>())).base as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(module_memory),
                "::",
                stringify!(base)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module_memory>())).size as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(module_memory),
                "::",
                stringify!(size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module_memory>())).mtn as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(module_memory),
                "::",
                stringify!(mtn)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct mod_kallsyms {
        pub symtab: *mut Elf64_Sym,
        pub num_symtab: ::cty::c_uint,
        pub strtab: *mut ::cty::c_char,
        pub typetab: *mut ::cty::c_char,
    }
    #[test]
    fn bindgen_test_layout_mod_kallsyms() {
        assert_eq!(
            ::core::mem::size_of::<mod_kallsyms>(),
            32usize,
            concat!("Size of: ", stringify!(mod_kallsyms))
        );
        assert_eq!(
            ::core::mem::align_of::<mod_kallsyms>(),
            8usize,
            concat!("Alignment of ", stringify!(mod_kallsyms))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mod_kallsyms>())).symtab as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mod_kallsyms),
                "::",
                stringify!(symtab)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mod_kallsyms>())).num_symtab as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mod_kallsyms),
                "::",
                stringify!(num_symtab)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mod_kallsyms>())).strtab as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(mod_kallsyms),
                "::",
                stringify!(strtab)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mod_kallsyms>())).typetab as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(mod_kallsyms),
                "::",
                stringify!(typetab)
            )
        );
    }
    #[doc = " struct klp_modinfo - ELF information preserved from the livepatch module"]
    #[doc = ""]
    #[doc = " @hdr: ELF header"]
    #[doc = " @sechdrs: Section header table"]
    #[doc = " @secstrings: String table for the section headers"]
    #[doc = " @symndx: The symbol table section index"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct klp_modinfo {
        pub hdr: Elf64_Ehdr,
        pub sechdrs: *mut Elf64_Shdr,
        pub secstrings: *mut ::cty::c_char,
        pub symndx: ::cty::c_uint,
    }
    #[test]
    fn bindgen_test_layout_klp_modinfo() {
        assert_eq!(
            ::core::mem::size_of::<klp_modinfo>(),
            88usize,
            concat!("Size of: ", stringify!(klp_modinfo))
        );
        assert_eq!(
            ::core::mem::align_of::<klp_modinfo>(),
            8usize,
            concat!("Alignment of ", stringify!(klp_modinfo))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<klp_modinfo>())).hdr as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(klp_modinfo),
                "::",
                stringify!(hdr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<klp_modinfo>())).sechdrs as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(klp_modinfo),
                "::",
                stringify!(sechdrs)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<klp_modinfo>())).secstrings as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(klp_modinfo),
                "::",
                stringify!(secstrings)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<klp_modinfo>())).symndx as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(klp_modinfo),
                "::",
                stringify!(symndx)
            )
        );
    }
    #[repr(C)]
    #[repr(align(64))]
    #[derive(Copy, Clone)]
    pub struct module {
        pub state: module_state,
        pub list: list_head,
        pub name: [::cty::c_char; 56usize],
        pub mkobj: module_kobject,
        pub modinfo_attrs: *mut module_attribute,
        pub version: *const ::cty::c_char,
        pub srcversion: *const ::cty::c_char,
        pub holders_dir: *mut kobject,
        pub syms: *mut kernel_symbol,
        pub crcs: *const s32,
        pub num_syms: ::cty::c_uint,
        pub param_lock: mutex,
        pub kp: *mut kernel_param,
        pub num_kp: ::cty::c_uint,
        pub num_gpl_syms: ::cty::c_uint,
        pub gpl_syms: *const kernel_symbol,
        pub gpl_crcs: *const s32,
        pub using_gplonly_symbols: bool_,
        pub sig_ok: bool_,
        pub async_probe_requested: bool_,
        pub num_exentries: ::cty::c_uint,
        pub extable: *mut exception_table_entry,
        pub init: ::core::option::Option<unsafe extern "C" fn() -> ::cty::c_int>,
        pub mem: [module_memory; 7usize],
        pub arch: mod_arch_specific,
        pub taints: ::cty::c_ulong,
        pub num_bugs: ::cty::c_uint,
        pub bug_list: list_head,
        pub bug_table: *mut bug_entry,
        pub kallsyms: *mut mod_kallsyms,
        pub core_kallsyms: mod_kallsyms,
        pub sect_attrs: *mut module_sect_attrs,
        pub notes_attrs: *mut module_notes_attrs,
        pub args: *mut ::cty::c_char,
        pub percpu: *mut ::cty::c_void,
        pub percpu_size: ::cty::c_uint,
        pub noinstr_text_start: *mut ::cty::c_void,
        pub noinstr_text_size: ::cty::c_uint,
        pub num_tracepoints: ::cty::c_uint,
        pub tracepoints_ptrs: *mut tracepoint_ptr_t,
        pub num_srcu_structs: ::cty::c_uint,
        pub srcu_struct_ptrs: *mut *mut srcu_struct,
        pub num_bpf_raw_events: ::cty::c_uint,
        pub bpf_raw_events: *mut bpf_raw_event_map,
        pub btf_data_size: ::cty::c_uint,
        pub btf_data: *mut ::cty::c_void,
        pub jump_entries: *mut jump_entry,
        pub num_jump_entries: ::cty::c_uint,
        pub num_trace_bprintk_fmt: ::cty::c_uint,
        pub trace_bprintk_fmt_start: *mut *const ::cty::c_char,
        pub trace_events: *mut *mut trace_event_call,
        pub num_trace_events: ::cty::c_uint,
        pub trace_evals: *mut *mut trace_eval_map,
        pub num_trace_evals: ::cty::c_uint,
        pub num_ftrace_callsites: ::cty::c_uint,
        pub ftrace_callsites: *mut ::cty::c_ulong,
        pub kprobes_text_start: *mut ::cty::c_void,
        pub kprobes_text_size: ::cty::c_uint,
        pub kprobe_blacklist: *mut ::cty::c_ulong,
        pub num_kprobe_blacklist: ::cty::c_uint,
        pub num_static_call_sites: ::cty::c_int,
        pub static_call_sites: *mut static_call_site,
        pub klp: bool_,
        pub klp_alive: bool_,
        pub klp_info: *mut klp_modinfo,
        pub source_list: list_head,
        pub target_list: list_head,
        pub exit: ::core::option::Option<unsafe extern "C" fn()>,
        pub refcnt: atomic_t,
        pub ei_funcs: *mut error_injection_entry,
        pub num_ei_funcs: ::cty::c_uint,
        pub dyndbg_info: _ddebug_info,
    }
    #[test]
    fn bindgen_test_layout_module() {
        assert_eq!(
            ::core::mem::size_of::<module>(),
            1280usize,
            concat!("Size of: ", stringify!(module))
        );
        assert_eq!(
            ::core::mem::align_of::<module>(),
            64usize,
            concat!("Alignment of ", stringify!(module))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).state as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(state)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).list as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).name as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(name)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).mkobj as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(mkobj)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).modinfo_attrs as *const _ as usize },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(modinfo_attrs)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).version as *const _ as usize },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(version)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).srcversion as *const _ as usize },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(srcversion)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).holders_dir as *const _ as usize },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(holders_dir)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).syms as *const _ as usize },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(syms)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).crcs as *const _ as usize },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(crcs)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).num_syms as *const _ as usize },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(num_syms)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).param_lock as *const _ as usize },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(param_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).kp as *const _ as usize },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(kp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).num_kp as *const _ as usize },
            272usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(num_kp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).num_gpl_syms as *const _ as usize },
            276usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(num_gpl_syms)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).gpl_syms as *const _ as usize },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(gpl_syms)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).gpl_crcs as *const _ as usize },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(gpl_crcs)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<module>())).using_gplonly_symbols as *const _ as usize
            },
            296usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(using_gplonly_symbols)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).sig_ok as *const _ as usize },
            297usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(sig_ok)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<module>())).async_probe_requested as *const _ as usize
            },
            298usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(async_probe_requested)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).num_exentries as *const _ as usize },
            300usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(num_exentries)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).extable as *const _ as usize },
            304usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(extable)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).init as *const _ as usize },
            312usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(init)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).mem as *const _ as usize },
            320usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(mem)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).arch as *const _ as usize },
            824usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(arch)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).taints as *const _ as usize },
            824usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(taints)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).num_bugs as *const _ as usize },
            832usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(num_bugs)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).bug_list as *const _ as usize },
            840usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(bug_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).bug_table as *const _ as usize },
            856usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(bug_table)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).kallsyms as *const _ as usize },
            864usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(kallsyms)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).core_kallsyms as *const _ as usize },
            872usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(core_kallsyms)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).sect_attrs as *const _ as usize },
            904usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(sect_attrs)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).notes_attrs as *const _ as usize },
            912usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(notes_attrs)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).args as *const _ as usize },
            920usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(args)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).percpu as *const _ as usize },
            928usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(percpu)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).percpu_size as *const _ as usize },
            936usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(percpu_size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).noinstr_text_start as *const _ as usize },
            944usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(noinstr_text_start)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).noinstr_text_size as *const _ as usize },
            952usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(noinstr_text_size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).num_tracepoints as *const _ as usize },
            956usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(num_tracepoints)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).tracepoints_ptrs as *const _ as usize },
            960usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(tracepoints_ptrs)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).num_srcu_structs as *const _ as usize },
            968usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(num_srcu_structs)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).srcu_struct_ptrs as *const _ as usize },
            976usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(srcu_struct_ptrs)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).num_bpf_raw_events as *const _ as usize },
            984usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(num_bpf_raw_events)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).bpf_raw_events as *const _ as usize },
            992usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(bpf_raw_events)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).btf_data_size as *const _ as usize },
            1000usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(btf_data_size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).btf_data as *const _ as usize },
            1008usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(btf_data)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).jump_entries as *const _ as usize },
            1016usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(jump_entries)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).num_jump_entries as *const _ as usize },
            1024usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(num_jump_entries)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<module>())).num_trace_bprintk_fmt as *const _ as usize
            },
            1028usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(num_trace_bprintk_fmt)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<module>())).trace_bprintk_fmt_start as *const _ as usize
            },
            1032usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(trace_bprintk_fmt_start)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).trace_events as *const _ as usize },
            1040usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(trace_events)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).num_trace_events as *const _ as usize },
            1048usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(num_trace_events)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).trace_evals as *const _ as usize },
            1056usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(trace_evals)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).num_trace_evals as *const _ as usize },
            1064usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(num_trace_evals)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<module>())).num_ftrace_callsites as *const _ as usize
            },
            1068usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(num_ftrace_callsites)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).ftrace_callsites as *const _ as usize },
            1072usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(ftrace_callsites)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).kprobes_text_start as *const _ as usize },
            1080usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(kprobes_text_start)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).kprobes_text_size as *const _ as usize },
            1088usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(kprobes_text_size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).kprobe_blacklist as *const _ as usize },
            1096usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(kprobe_blacklist)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<module>())).num_kprobe_blacklist as *const _ as usize
            },
            1104usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(num_kprobe_blacklist)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<module>())).num_static_call_sites as *const _ as usize
            },
            1108usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(num_static_call_sites)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).static_call_sites as *const _ as usize },
            1112usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(static_call_sites)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).klp as *const _ as usize },
            1120usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(klp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).klp_alive as *const _ as usize },
            1121usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(klp_alive)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).klp_info as *const _ as usize },
            1128usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(klp_info)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).source_list as *const _ as usize },
            1136usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(source_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).target_list as *const _ as usize },
            1152usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(target_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).exit as *const _ as usize },
            1168usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(exit)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).refcnt as *const _ as usize },
            1176usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(refcnt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).ei_funcs as *const _ as usize },
            1184usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(ei_funcs)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).num_ei_funcs as *const _ as usize },
            1192usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(num_ei_funcs)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<module>())).dyndbg_info as *const _ as usize },
            1200usize,
            concat!(
                "Offset of field: ",
                stringify!(module),
                "::",
                stringify!(dyndbg_info)
            )
        );
    }
    pub const probe_type_PROBE_DEFAULT_STRATEGY: probe_type = 0;
    pub const probe_type_PROBE_PREFER_ASYNCHRONOUS: probe_type = 1;
    pub const probe_type_PROBE_FORCE_SYNCHRONOUS: probe_type = 2;
    #[doc = " enum probe_type - device driver probe type to try"]
    #[doc = "\tDevice drivers may opt in for special handling of their"]
    #[doc = "\trespective probe routines. This tells the core what to"]
    #[doc = "\texpect and prefer."]
    #[doc = ""]
    #[doc = " @PROBE_DEFAULT_STRATEGY: Used by drivers that work equally well"]
    #[doc = "\twhether probed synchronously or asynchronously."]
    #[doc = " @PROBE_PREFER_ASYNCHRONOUS: Drivers for \"slow\" devices which"]
    #[doc = "\tprobing order is not essential for booting the system may"]
    #[doc = "\topt into executing their probes asynchronously."]
    #[doc = " @PROBE_FORCE_SYNCHRONOUS: Use this to annotate drivers that need"]
    #[doc = "\ttheir probe routines to run synchronously with driver and"]
    #[doc = "\tdevice registration (with the exception of -EPROBE_DEFER"]
    #[doc = "\thandling - re-probing always ends up being done asynchronously)."]
    #[doc = ""]
    #[doc = " Note that the end goal is to switch the kernel to use asynchronous"]
    #[doc = " probing by default, so annotating drivers with"]
    #[doc = " %PROBE_PREFER_ASYNCHRONOUS is a temporary measure that allows us"]
    #[doc = " to speed up boot process while we are validating the rest of the"]
    #[doc = " drivers."]
    pub type probe_type = ::cty::c_uint;
    #[doc = " struct device_driver - The basic device driver structure"]
    #[doc = " @name:\tName of the device driver."]
    #[doc = " @bus:\tThe bus which the device of this driver belongs to."]
    #[doc = " @owner:\tThe module owner."]
    #[doc = " @mod_name:\tUsed for built-in modules."]
    #[doc = " @suppress_bind_attrs: Disables bind/unbind via sysfs."]
    #[doc = " @probe_type:\tType of the probe (synchronous or asynchronous) to use."]
    #[doc = " @of_match_table: The open firmware table."]
    #[doc = " @acpi_match_table: The ACPI match table."]
    #[doc = " @probe:\tCalled to query the existence of a specific device,"]
    #[doc = "\t\twhether this driver can work with it, and bind the driver"]
    #[doc = "\t\tto a specific device."]
    #[doc = " @sync_state:\tCalled to sync device state to software state after all the"]
    #[doc = "\t\tstate tracking consumers linked to this device (present at"]
    #[doc = "\t\tthe time of late_initcall) have successfully bound to a"]
    #[doc = "\t\tdriver. If the device has no consumers, this function will"]
    #[doc = "\t\tbe called at late_initcall_sync level. If the device has"]
    #[doc = "\t\tconsumers that are never bound to a driver, this function"]
    #[doc = "\t\twill never get called until they do."]
    #[doc = " @remove:\tCalled when the device is removed from the system to"]
    #[doc = "\t\tunbind a device from this driver."]
    #[doc = " @shutdown:\tCalled at shut-down time to quiesce the device."]
    #[doc = " @suspend:\tCalled to put the device to sleep mode. Usually to a"]
    #[doc = "\t\tlow power state."]
    #[doc = " @resume:\tCalled to bring a device from sleep mode."]
    #[doc = " @groups:\tDefault attributes that get created by the driver core"]
    #[doc = "\t\tautomatically."]
    #[doc = " @dev_groups:\tAdditional attributes attached to device instance once"]
    #[doc = "\t\tit is bound to the driver."]
    #[doc = " @pm:\t\tPower management operations of the device which matched"]
    #[doc = "\t\tthis driver."]
    #[doc = " @coredump:\tCalled when sysfs entry is written to. The device driver"]
    #[doc = "\t\tis expected to call the dev_coredump API resulting in a"]
    #[doc = "\t\tuevent."]
    #[doc = " @p:\t\tDriver core's private data, no one other than the driver"]
    #[doc = "\t\tcore can touch this."]
    #[doc = ""]
    #[doc = " The device driver-model tracks all of the drivers known to the system."]
    #[doc = " The main reason for this tracking is to enable the driver core to match"]
    #[doc = " up drivers with new devices. Once drivers are known objects within the"]
    #[doc = " system, however, a number of other things become possible. Device drivers"]
    #[doc = " can export information and configuration variables that are independent"]
    #[doc = " of any specific device."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct device_driver {
        pub name: *const ::cty::c_char,
        pub bus: *const bus_type,
        pub owner: *mut module,
        pub mod_name: *const ::cty::c_char,
        pub suppress_bind_attrs: bool_,
        pub probe_type: probe_type,
        pub of_match_table: *mut of_device_id,
        pub acpi_match_table: *mut acpi_device_id,
        pub probe: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ::cty::c_int>,
        pub sync_state: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
        pub remove: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ::cty::c_int>,
        pub shutdown: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
        pub suspend: ::core::option::Option<
            unsafe extern "C" fn(dev: *mut device, state: pm_message_t) -> ::cty::c_int,
        >,
        pub resume: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ::cty::c_int>,
        pub groups: *mut *const attribute_group,
        pub dev_groups: *mut *const attribute_group,
        pub pm: *const dev_pm_ops,
        pub coredump: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
        pub p: *mut driver_private,
    }
    #[test]
    fn bindgen_test_layout_device_driver() {
        assert_eq!(
            ::core::mem::size_of::<device_driver>(),
            144usize,
            concat!("Size of: ", stringify!(device_driver))
        );
        assert_eq!(
            ::core::mem::align_of::<device_driver>(),
            8usize,
            concat!("Alignment of ", stringify!(device_driver))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device_driver>())).name as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(device_driver),
                "::",
                stringify!(name)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device_driver>())).bus as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(device_driver),
                "::",
                stringify!(bus)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device_driver>())).owner as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(device_driver),
                "::",
                stringify!(owner)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device_driver>())).mod_name as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(device_driver),
                "::",
                stringify!(mod_name)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<device_driver>())).suppress_bind_attrs as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(device_driver),
                "::",
                stringify!(suppress_bind_attrs)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device_driver>())).probe_type as *const _ as usize },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(device_driver),
                "::",
                stringify!(probe_type)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<device_driver>())).of_match_table as *const _ as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(device_driver),
                "::",
                stringify!(of_match_table)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<device_driver>())).acpi_match_table as *const _ as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(device_driver),
                "::",
                stringify!(acpi_match_table)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device_driver>())).probe as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(device_driver),
                "::",
                stringify!(probe)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device_driver>())).sync_state as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(device_driver),
                "::",
                stringify!(sync_state)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device_driver>())).remove as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(device_driver),
                "::",
                stringify!(remove)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device_driver>())).shutdown as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(device_driver),
                "::",
                stringify!(shutdown)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device_driver>())).suspend as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(device_driver),
                "::",
                stringify!(suspend)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device_driver>())).resume as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(device_driver),
                "::",
                stringify!(resume)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device_driver>())).groups as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(device_driver),
                "::",
                stringify!(groups)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device_driver>())).dev_groups as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(device_driver),
                "::",
                stringify!(dev_groups)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device_driver>())).pm as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(device_driver),
                "::",
                stringify!(pm)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device_driver>())).coredump as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(device_driver),
                "::",
                stringify!(coredump)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device_driver>())).p as *const _ as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(device_driver),
                "::",
                stringify!(p)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dev_archdata {}
    #[test]
    fn bindgen_test_layout_dev_archdata() {
        assert_eq!(
            ::core::mem::size_of::<dev_archdata>(),
            0usize,
            concat!("Size of: ", stringify!(dev_archdata))
        );
        assert_eq!(
            ::core::mem::align_of::<dev_archdata>(),
            1usize,
            concat!("Alignment of ", stringify!(dev_archdata))
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct device_private {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct driver_private {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct iommu_ops {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct iommu_group {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dev_pin_info {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dev_iommu {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct msi_device_data {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct device_type {
        pub name: *const ::cty::c_char,
        pub groups: *mut *const attribute_group,
        pub uevent: ::core::option::Option<
            unsafe extern "C" fn(dev: *const device, env: *mut kobj_uevent_env) -> ::cty::c_int,
        >,
        pub devnode: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *const device,
                mode: *mut umode_t,
                uid: *mut kuid_t,
                gid: *mut kgid_t,
            ) -> *mut ::cty::c_char,
        >,
        pub release: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
        pub pm: *const dev_pm_ops,
    }
    #[test]
    fn bindgen_test_layout_device_type() {
        assert_eq!(
            ::core::mem::size_of::<device_type>(),
            48usize,
            concat!("Size of: ", stringify!(device_type))
        );
        assert_eq!(
            ::core::mem::align_of::<device_type>(),
            8usize,
            concat!("Alignment of ", stringify!(device_type))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device_type>())).name as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(device_type),
                "::",
                stringify!(name)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device_type>())).groups as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(device_type),
                "::",
                stringify!(groups)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device_type>())).uevent as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(device_type),
                "::",
                stringify!(uevent)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device_type>())).devnode as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(device_type),
                "::",
                stringify!(devnode)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device_type>())).release as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(device_type),
                "::",
                stringify!(release)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device_type>())).pm as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(device_type),
                "::",
                stringify!(pm)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct device_dma_parameters {
        pub max_segment_size: ::cty::c_uint,
        pub min_align_mask: ::cty::c_uint,
        pub segment_boundary_mask: ::cty::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_device_dma_parameters() {
        assert_eq!(
            ::core::mem::size_of::<device_dma_parameters>(),
            16usize,
            concat!("Size of: ", stringify!(device_dma_parameters))
        );
        assert_eq!(
            ::core::mem::align_of::<device_dma_parameters>(),
            8usize,
            concat!("Alignment of ", stringify!(device_dma_parameters))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<device_dma_parameters>())).max_segment_size as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(device_dma_parameters),
                "::",
                stringify!(max_segment_size)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<device_dma_parameters>())).min_align_mask as *const _
                    as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(device_dma_parameters),
                "::",
                stringify!(min_align_mask)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<device_dma_parameters>())).segment_boundary_mask as *const _
                    as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(device_dma_parameters),
                "::",
                stringify!(segment_boundary_mask)
            )
        );
    }
    pub const dl_dev_state_DL_DEV_NO_DRIVER: dl_dev_state = 0;
    pub const dl_dev_state_DL_DEV_PROBING: dl_dev_state = 1;
    pub const dl_dev_state_DL_DEV_DRIVER_BOUND: dl_dev_state = 2;
    pub const dl_dev_state_DL_DEV_UNBINDING: dl_dev_state = 3;
    #[doc = " enum dl_dev_state - Device driver presence tracking information."]
    #[doc = " @DL_DEV_NO_DRIVER: There is no driver attached to the device."]
    #[doc = " @DL_DEV_PROBING: A driver is probing."]
    #[doc = " @DL_DEV_DRIVER_BOUND: The driver has been bound to the device."]
    #[doc = " @DL_DEV_UNBINDING: The driver is unbinding from the device."]
    pub type dl_dev_state = ::cty::c_uint;
    pub const device_removable_DEVICE_REMOVABLE_NOT_SUPPORTED: device_removable = 0;
    pub const device_removable_DEVICE_REMOVABLE_UNKNOWN: device_removable = 1;
    pub const device_removable_DEVICE_FIXED: device_removable = 2;
    pub const device_removable_DEVICE_REMOVABLE: device_removable = 3;
    #[doc = " enum device_removable - Whether the device is removable. The criteria for a"]
    #[doc = " device to be classified as removable is determined by its subsystem or bus."]
    #[doc = " @DEVICE_REMOVABLE_NOT_SUPPORTED: This attribute is not supported for this"]
    #[doc = "\t\t\t\t    device (default)."]
    #[doc = " @DEVICE_REMOVABLE_UNKNOWN:  Device location is Unknown."]
    #[doc = " @DEVICE_FIXED: Device is not removable by the user."]
    #[doc = " @DEVICE_REMOVABLE: Device is removable by the user."]
    pub type device_removable = ::cty::c_uint;
    #[doc = " struct dev_links_info - Device data related to device links."]
    #[doc = " @suppliers: List of links to supplier devices."]
    #[doc = " @consumers: List of links to consumer devices."]
    #[doc = " @defer_sync: Hook to global list of devices that have deferred sync_state."]
    #[doc = " @status: Driver status information."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dev_links_info {
        pub suppliers: list_head,
        pub consumers: list_head,
        pub defer_sync: list_head,
        pub status: dl_dev_state,
    }
    #[test]
    fn bindgen_test_layout_dev_links_info() {
        assert_eq!(
            ::core::mem::size_of::<dev_links_info>(),
            56usize,
            concat!("Size of: ", stringify!(dev_links_info))
        );
        assert_eq!(
            ::core::mem::align_of::<dev_links_info>(),
            8usize,
            concat!("Alignment of ", stringify!(dev_links_info))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_links_info>())).suppliers as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_links_info),
                "::",
                stringify!(suppliers)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_links_info>())).consumers as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_links_info),
                "::",
                stringify!(consumers)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_links_info>())).defer_sync as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_links_info),
                "::",
                stringify!(defer_sync)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_links_info>())).status as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_links_info),
                "::",
                stringify!(status)
            )
        );
    }
    #[doc = " struct dev_msi_info - Device data related to MSI"]
    #[doc = " @domain:\tThe MSI interrupt domain associated to the device"]
    #[doc = " @data:\tPointer to MSI device data"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dev_msi_info {
        pub domain: *mut irq_domain,
        pub data: *mut msi_device_data,
    }
    #[test]
    fn bindgen_test_layout_dev_msi_info() {
        assert_eq!(
            ::core::mem::size_of::<dev_msi_info>(),
            16usize,
            concat!("Size of: ", stringify!(dev_msi_info))
        );
        assert_eq!(
            ::core::mem::align_of::<dev_msi_info>(),
            8usize,
            concat!("Alignment of ", stringify!(dev_msi_info))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_msi_info>())).domain as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_msi_info),
                "::",
                stringify!(domain)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_msi_info>())).data as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_msi_info),
                "::",
                stringify!(data)
            )
        );
    }
    pub const device_physical_location_panel_DEVICE_PANEL_TOP: device_physical_location_panel = 0;
    pub const device_physical_location_panel_DEVICE_PANEL_BOTTOM: device_physical_location_panel =
        1;
    pub const device_physical_location_panel_DEVICE_PANEL_LEFT: device_physical_location_panel = 2;
    pub const device_physical_location_panel_DEVICE_PANEL_RIGHT: device_physical_location_panel = 3;
    pub const device_physical_location_panel_DEVICE_PANEL_FRONT: device_physical_location_panel = 4;
    pub const device_physical_location_panel_DEVICE_PANEL_BACK: device_physical_location_panel = 5;
    pub const device_physical_location_panel_DEVICE_PANEL_UNKNOWN: device_physical_location_panel =
        6;
    #[doc = " enum device_physical_location_panel - Describes which panel surface of the"]
    #[doc = " system's housing the device connection point resides on."]
    #[doc = " @DEVICE_PANEL_TOP: Device connection point is on the top panel."]
    #[doc = " @DEVICE_PANEL_BOTTOM: Device connection point is on the bottom panel."]
    #[doc = " @DEVICE_PANEL_LEFT: Device connection point is on the left panel."]
    #[doc = " @DEVICE_PANEL_RIGHT: Device connection point is on the right panel."]
    #[doc = " @DEVICE_PANEL_FRONT: Device connection point is on the front panel."]
    #[doc = " @DEVICE_PANEL_BACK: Device connection point is on the back panel."]
    #[doc = " @DEVICE_PANEL_UNKNOWN: The panel with device connection point is unknown."]
    pub type device_physical_location_panel = ::cty::c_uint;
    pub const device_physical_location_vertical_position_DEVICE_VERT_POS_UPPER:
        device_physical_location_vertical_position = 0;
    pub const device_physical_location_vertical_position_DEVICE_VERT_POS_CENTER:
        device_physical_location_vertical_position = 1;
    pub const device_physical_location_vertical_position_DEVICE_VERT_POS_LOWER:
        device_physical_location_vertical_position = 2;
    #[doc = " enum device_physical_location_vertical_position - Describes vertical"]
    #[doc = " position of the device connection point on the panel surface."]
    #[doc = " @DEVICE_VERT_POS_UPPER: Device connection point is at upper part of panel."]
    #[doc = " @DEVICE_VERT_POS_CENTER: Device connection point is at center part of panel."]
    #[doc = " @DEVICE_VERT_POS_LOWER: Device connection point is at lower part of panel."]
    pub type device_physical_location_vertical_position = ::cty::c_uint;
    pub const device_physical_location_horizontal_position_DEVICE_HORI_POS_LEFT:
        device_physical_location_horizontal_position = 0;
    pub const device_physical_location_horizontal_position_DEVICE_HORI_POS_CENTER:
        device_physical_location_horizontal_position = 1;
    pub const device_physical_location_horizontal_position_DEVICE_HORI_POS_RIGHT:
        device_physical_location_horizontal_position = 2;
    #[doc = " enum device_physical_location_horizontal_position - Describes horizontal"]
    #[doc = " position of the device connection point on the panel surface."]
    #[doc = " @DEVICE_HORI_POS_LEFT: Device connection point is at left part of panel."]
    #[doc = " @DEVICE_HORI_POS_CENTER: Device connection point is at center part of panel."]
    #[doc = " @DEVICE_HORI_POS_RIGHT: Device connection point is at right part of panel."]
    pub type device_physical_location_horizontal_position = ::cty::c_uint;
    #[doc = " struct device_physical_location - Device data related to physical location"]
    #[doc = " of the device connection point."]
    #[doc = " @panel: Panel surface of the system's housing that the device connection"]
    #[doc = "         point resides on."]
    #[doc = " @vertical_position: Vertical position of the device connection point within"]
    #[doc = "                     the panel."]
    #[doc = " @horizontal_position: Horizontal position of the device connection point"]
    #[doc = "                       within the panel."]
    #[doc = " @dock: Set if the device connection point resides in a docking station or"]
    #[doc = "        port replicator."]
    #[doc = " @lid: Set if this device connection point resides on the lid of laptop"]
    #[doc = "       system."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct device_physical_location {
        pub panel: device_physical_location_panel,
        pub vertical_position: device_physical_location_vertical_position,
        pub horizontal_position: device_physical_location_horizontal_position,
        pub dock: bool_,
        pub lid: bool_,
    }
    #[test]
    fn bindgen_test_layout_device_physical_location() {
        assert_eq!(
            ::core::mem::size_of::<device_physical_location>(),
            16usize,
            concat!("Size of: ", stringify!(device_physical_location))
        );
        assert_eq!(
            ::core::mem::align_of::<device_physical_location>(),
            4usize,
            concat!("Alignment of ", stringify!(device_physical_location))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<device_physical_location>())).panel as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(device_physical_location),
                "::",
                stringify!(panel)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<device_physical_location>())).vertical_position as *const _
                    as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(device_physical_location),
                "::",
                stringify!(vertical_position)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<device_physical_location>())).horizontal_position
                    as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(device_physical_location),
                "::",
                stringify!(horizontal_position)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<device_physical_location>())).dock as *const _ as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(device_physical_location),
                "::",
                stringify!(dock)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<device_physical_location>())).lid as *const _ as usize
            },
            13usize,
            concat!(
                "Offset of field: ",
                stringify!(device_physical_location),
                "::",
                stringify!(lid)
            )
        );
    }
    #[doc = " struct device - The basic device structure"]
    #[doc = " @parent:\tThe device's \"parent\" device, the device to which it is attached."]
    #[doc = " \t\tIn most cases, a parent device is some sort of bus or host"]
    #[doc = " \t\tcontroller. If parent is NULL, the device, is a top-level device,"]
    #[doc = " \t\twhich is not usually what you want."]
    #[doc = " @p:\t\tHolds the private data of the driver core portions of the device."]
    #[doc = " \t\tSee the comment of the struct device_private for detail."]
    #[doc = " @kobj:\tA top-level, abstract class from which other classes are derived."]
    #[doc = " @init_name:\tInitial name of the device."]
    #[doc = " @type:\tThe type of device."]
    #[doc = " \t\tThis identifies the device type and carries type-specific"]
    #[doc = " \t\tinformation."]
    #[doc = " @mutex:\tMutex to synchronize calls to its driver."]
    #[doc = " @bus:\tType of bus device is on."]
    #[doc = " @driver:\tWhich driver has allocated this"]
    #[doc = " @platform_data: Platform data specific to the device."]
    #[doc = " \t\tExample: For devices on custom boards, as typical of embedded"]
    #[doc = " \t\tand SOC based hardware, Linux often uses platform_data to point"]
    #[doc = " \t\tto board-specific structures describing devices and how they"]
    #[doc = " \t\tare wired.  That can include what ports are available, chip"]
    #[doc = " \t\tvariants, which GPIO pins act in what additional roles, and so"]
    #[doc = " \t\ton.  This shrinks the \"Board Support Packages\" (BSPs) and"]
    #[doc = " \t\tminimizes board-specific #ifdefs in drivers."]
    #[doc = " @driver_data: Private pointer for driver specific info."]
    #[doc = " @links:\tLinks to suppliers and consumers of this device."]
    #[doc = " @power:\tFor device power management."]
    #[doc = "\t\tSee Documentation/driver-api/pm/devices.rst for details."]
    #[doc = " @pm_domain:\tProvide callbacks that are executed during system suspend,"]
    #[doc = " \t\thibernation, system resume and during runtime PM transitions"]
    #[doc = " \t\talong with subsystem-level and driver-level callbacks."]
    #[doc = " @em_pd:\tdevice's energy model performance domain"]
    #[doc = " @pins:\tFor device pin management."]
    #[doc = "\t\tSee Documentation/driver-api/pin-control.rst for details."]
    #[doc = " @msi:\tMSI related data"]
    #[doc = " @numa_node:\tNUMA node this device is close to."]
    #[doc = " @dma_ops:    DMA mapping operations for this device."]
    #[doc = " @dma_mask:\tDma mask (if dma'ble device)."]
    #[doc = " @coherent_dma_mask: Like dma_mask, but for alloc_coherent mapping as not all"]
    #[doc = " \t\thardware supports 64-bit addresses for consistent allocations"]
    #[doc = " \t\tsuch descriptors."]
    #[doc = " @bus_dma_limit: Limit of an upstream bridge or bus which imposes a smaller"]
    #[doc = "\t\tDMA limit than the device itself supports."]
    #[doc = " @dma_range_map: map for DMA memory ranges relative to that of RAM"]
    #[doc = " @dma_parms:\tA low level driver may set these to teach IOMMU code about"]
    #[doc = " \t\tsegment limitations."]
    #[doc = " @dma_pools:\tDma pools (if dma'ble device)."]
    #[doc = " @dma_mem:\tInternal for coherent mem override."]
    #[doc = " @cma_area:\tContiguous memory area for dma allocations"]
    #[doc = " @dma_io_tlb_mem: Pointer to the swiotlb pool used.  Not for driver use."]
    #[doc = " @archdata:\tFor arch-specific additions."]
    #[doc = " @of_node:\tAssociated device tree node."]
    #[doc = " @fwnode:\tAssociated device node supplied by platform firmware."]
    #[doc = " @devt:\tFor creating the sysfs \"dev\"."]
    #[doc = " @id:\t\tdevice instance"]
    #[doc = " @devres_lock: Spinlock to protect the resource of the device."]
    #[doc = " @devres_head: The resources list of the device."]
    #[doc = " @knode_class: The node used to add the device to the class list."]
    #[doc = " @class:\tThe class of the device."]
    #[doc = " @groups:\tOptional attribute groups."]
    #[doc = " @release:\tCallback to free the device after all references have"]
    #[doc = " \t\tgone away. This should be set by the allocator of the"]
    #[doc = " \t\tdevice (i.e. the bus driver that discovered the device)."]
    #[doc = " @iommu_group: IOMMU group the device belongs to."]
    #[doc = " @iommu:\tPer device generic IOMMU runtime data"]
    #[doc = " @physical_location: Describes physical location of the device connection"]
    #[doc = "\t\tpoint in the system housing."]
    #[doc = " @removable:  Whether the device can be removed from the system. This"]
    #[doc = "              should be set by the subsystem / bus driver that discovered"]
    #[doc = "              the device."]
    #[doc = ""]
    #[doc = " @offline_disabled: If set, the device is permanently online."]
    #[doc = " @offline:\tSet after successful invocation of bus type's .offline()."]
    #[doc = " @of_node_reused: Set if the device-tree node is shared with an ancestor"]
    #[doc = "              device."]
    #[doc = " @state_synced: The hardware state of this device has been synced to match"]
    #[doc = "\t\t  the software state of this device by calling the driver/bus"]
    #[doc = "\t\t  sync_state() callback."]
    #[doc = " @can_match:\tThe device has matched with a driver at least once or it is in"]
    #[doc = "\t\ta bus (like AMBA) which can't check for matching drivers until"]
    #[doc = "\t\tother devices probe successfully."]
    #[doc = " @dma_coherent: this particular device is dma coherent, even if the"]
    #[doc = "\t\tarchitecture supports non-coherent devices."]
    #[doc = " @dma_ops_bypass: If set to %true then the dma_ops are bypassed for the"]
    #[doc = "\t\tstreaming DMA operations (->map_* / ->unmap_* / ->sync_*),"]
    #[doc = "\t\tand optionall (if the coherent mask is large enough) also"]
    #[doc = "\t\tfor dma allocations.  This flag is managed by the dma ops"]
    #[doc = "\t\tinstance from ->dma_supported."]
    #[doc = ""]
    #[doc = " At the lowest level, every device in a Linux system is represented by an"]
    #[doc = " instance of struct device. The device structure contains the information"]
    #[doc = " that the device model core needs to model the system. Most subsystems,"]
    #[doc = " however, track additional information about the devices they host. As a"]
    #[doc = " result, it is rare for devices to be represented by bare device structures;"]
    #[doc = " instead, that structure, like kobject structures, is usually embedded within"]
    #[doc = " a higher-level representation of the device."]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct device {
        pub kobj: kobject,
        pub parent: *mut device,
        pub p: *mut device_private,
        pub init_name: *const ::cty::c_char,
        pub type_: *const device_type,
        pub bus: *const bus_type,
        pub driver: *mut device_driver,
        pub platform_data: *mut ::cty::c_void,
        pub driver_data: *mut ::cty::c_void,
        pub mutex: mutex,
        pub links: dev_links_info,
        pub power: dev_pm_info,
        pub pm_domain: *mut dev_pm_domain,
        pub em_pd: *mut em_perf_domain,
        pub pins: *mut dev_pin_info,
        pub msi: dev_msi_info,
        pub dma_ops: *mut dma_map_ops,
        pub dma_mask: *mut _cargo_bpf_u64,
        pub coherent_dma_mask: _cargo_bpf_u64,
        pub bus_dma_limit: _cargo_bpf_u64,
        pub dma_range_map: *mut bus_dma_region,
        pub dma_parms: *mut device_dma_parameters,
        pub dma_pools: list_head,
        pub dma_io_tlb_mem: *mut io_tlb_mem,
        pub archdata: dev_archdata,
        pub of_node: *mut device_node,
        pub fwnode: *mut fwnode_handle,
        pub numa_node: ::cty::c_int,
        pub devt: dev_t,
        pub id: _cargo_bpf_u32,
        pub devres_lock: spinlock_t,
        pub devres_head: list_head,
        pub class: *const class,
        pub groups: *mut *const attribute_group,
        pub release: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
        pub iommu_group: *mut iommu_group,
        pub iommu: *mut dev_iommu,
        pub physical_location: *mut device_physical_location,
        pub removable: device_removable,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
        pub __bindgen_padding_0: [u8; 3usize],
    }
    #[test]
    fn bindgen_test_layout_device() {
        assert_eq!(
            ::core::mem::size_of::<device>(),
            744usize,
            concat!("Size of: ", stringify!(device))
        );
        assert_eq!(
            ::core::mem::align_of::<device>(),
            8usize,
            concat!("Alignment of ", stringify!(device))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device>())).kobj as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(device),
                "::",
                stringify!(kobj)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device>())).parent as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(device),
                "::",
                stringify!(parent)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device>())).p as *const _ as usize },
            72usize,
            concat!("Offset of field: ", stringify!(device), "::", stringify!(p))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device>())).init_name as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(device),
                "::",
                stringify!(init_name)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device>())).type_ as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(device),
                "::",
                stringify!(type_)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device>())).bus as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(device),
                "::",
                stringify!(bus)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device>())).driver as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(device),
                "::",
                stringify!(driver)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device>())).platform_data as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(device),
                "::",
                stringify!(platform_data)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device>())).driver_data as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(device),
                "::",
                stringify!(driver_data)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device>())).mutex as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(device),
                "::",
                stringify!(mutex)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device>())).links as *const _ as usize },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(device),
                "::",
                stringify!(links)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device>())).power as *const _ as usize },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(device),
                "::",
                stringify!(power)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device>())).pm_domain as *const _ as usize },
            528usize,
            concat!(
                "Offset of field: ",
                stringify!(device),
                "::",
                stringify!(pm_domain)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device>())).em_pd as *const _ as usize },
            536usize,
            concat!(
                "Offset of field: ",
                stringify!(device),
                "::",
                stringify!(em_pd)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device>())).pins as *const _ as usize },
            544usize,
            concat!(
                "Offset of field: ",
                stringify!(device),
                "::",
                stringify!(pins)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device>())).msi as *const _ as usize },
            552usize,
            concat!(
                "Offset of field: ",
                stringify!(device),
                "::",
                stringify!(msi)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device>())).dma_ops as *const _ as usize },
            568usize,
            concat!(
                "Offset of field: ",
                stringify!(device),
                "::",
                stringify!(dma_ops)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device>())).dma_mask as *const _ as usize },
            576usize,
            concat!(
                "Offset of field: ",
                stringify!(device),
                "::",
                stringify!(dma_mask)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device>())).coherent_dma_mask as *const _ as usize },
            584usize,
            concat!(
                "Offset of field: ",
                stringify!(device),
                "::",
                stringify!(coherent_dma_mask)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device>())).bus_dma_limit as *const _ as usize },
            592usize,
            concat!(
                "Offset of field: ",
                stringify!(device),
                "::",
                stringify!(bus_dma_limit)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device>())).dma_range_map as *const _ as usize },
            600usize,
            concat!(
                "Offset of field: ",
                stringify!(device),
                "::",
                stringify!(dma_range_map)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device>())).dma_parms as *const _ as usize },
            608usize,
            concat!(
                "Offset of field: ",
                stringify!(device),
                "::",
                stringify!(dma_parms)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device>())).dma_pools as *const _ as usize },
            616usize,
            concat!(
                "Offset of field: ",
                stringify!(device),
                "::",
                stringify!(dma_pools)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device>())).dma_io_tlb_mem as *const _ as usize },
            632usize,
            concat!(
                "Offset of field: ",
                stringify!(device),
                "::",
                stringify!(dma_io_tlb_mem)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device>())).archdata as *const _ as usize },
            640usize,
            concat!(
                "Offset of field: ",
                stringify!(device),
                "::",
                stringify!(archdata)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device>())).of_node as *const _ as usize },
            640usize,
            concat!(
                "Offset of field: ",
                stringify!(device),
                "::",
                stringify!(of_node)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device>())).fwnode as *const _ as usize },
            648usize,
            concat!(
                "Offset of field: ",
                stringify!(device),
                "::",
                stringify!(fwnode)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device>())).numa_node as *const _ as usize },
            656usize,
            concat!(
                "Offset of field: ",
                stringify!(device),
                "::",
                stringify!(numa_node)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device>())).devt as *const _ as usize },
            660usize,
            concat!(
                "Offset of field: ",
                stringify!(device),
                "::",
                stringify!(devt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device>())).id as *const _ as usize },
            664usize,
            concat!(
                "Offset of field: ",
                stringify!(device),
                "::",
                stringify!(id)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device>())).devres_lock as *const _ as usize },
            668usize,
            concat!(
                "Offset of field: ",
                stringify!(device),
                "::",
                stringify!(devres_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device>())).devres_head as *const _ as usize },
            672usize,
            concat!(
                "Offset of field: ",
                stringify!(device),
                "::",
                stringify!(devres_head)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device>())).class as *const _ as usize },
            688usize,
            concat!(
                "Offset of field: ",
                stringify!(device),
                "::",
                stringify!(class)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device>())).groups as *const _ as usize },
            696usize,
            concat!(
                "Offset of field: ",
                stringify!(device),
                "::",
                stringify!(groups)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device>())).release as *const _ as usize },
            704usize,
            concat!(
                "Offset of field: ",
                stringify!(device),
                "::",
                stringify!(release)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device>())).iommu_group as *const _ as usize },
            712usize,
            concat!(
                "Offset of field: ",
                stringify!(device),
                "::",
                stringify!(iommu_group)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device>())).iommu as *const _ as usize },
            720usize,
            concat!(
                "Offset of field: ",
                stringify!(device),
                "::",
                stringify!(iommu)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device>())).physical_location as *const _ as usize },
            728usize,
            concat!(
                "Offset of field: ",
                stringify!(device),
                "::",
                stringify!(physical_location)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<device>())).removable as *const _ as usize },
            736usize,
            concat!(
                "Offset of field: ",
                stringify!(device),
                "::",
                stringify!(removable)
            )
        );
    }
    impl device {
        #[inline]
        pub fn offline_disabled(&self) -> bool_ {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_offline_disabled(&mut self, val: bool_) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn offline(&self) -> bool_ {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_offline(&mut self, val: bool_) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(1usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn of_node_reused(&self) -> bool_ {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_of_node_reused(&mut self, val: bool_) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(2usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn state_synced(&self) -> bool_ {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_state_synced(&mut self, val: bool_) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(3usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn can_match(&self) -> bool_ {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_can_match(&mut self, val: bool_) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(4usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            offline_disabled: bool_,
            offline: bool_,
            of_node_reused: bool_,
            state_synced: bool_,
            can_match: bool_,
        ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 1u8, {
                let offline_disabled: u8 = unsafe { ::core::mem::transmute(offline_disabled) };
                offline_disabled as u64
            });
            __bindgen_bitfield_unit.set(1usize, 1u8, {
                let offline: u8 = unsafe { ::core::mem::transmute(offline) };
                offline as u64
            });
            __bindgen_bitfield_unit.set(2usize, 1u8, {
                let of_node_reused: u8 = unsafe { ::core::mem::transmute(of_node_reused) };
                of_node_reused as u64
            });
            __bindgen_bitfield_unit.set(3usize, 1u8, {
                let state_synced: u8 = unsafe { ::core::mem::transmute(state_synced) };
                state_synced as u64
            });
            __bindgen_bitfield_unit.set(4usize, 1u8, {
                let can_match: u8 = unsafe { ::core::mem::transmute(can_match) };
                can_match as u64
            });
            __bindgen_bitfield_unit
        }
    }
    #[doc = " struct wakeup_source - Representation of wakeup sources"]
    #[doc = ""]
    #[doc = " @name: Name of the wakeup source"]
    #[doc = " @id: Wakeup source id"]
    #[doc = " @entry: Wakeup source list entry"]
    #[doc = " @lock: Wakeup source lock"]
    #[doc = " @wakeirq: Optional device specific wakeirq"]
    #[doc = " @timer: Wakeup timer list"]
    #[doc = " @timer_expires: Wakeup timer expiration"]
    #[doc = " @total_time: Total time this wakeup source has been active."]
    #[doc = " @max_time: Maximum time this wakeup source has been continuously active."]
    #[doc = " @last_time: Monotonic clock when the wakeup source's was touched last time."]
    #[doc = " @prevent_sleep_time: Total time this source has been preventing autosleep."]
    #[doc = " @event_count: Number of signaled wakeup events."]
    #[doc = " @active_count: Number of times the wakeup source was activated."]
    #[doc = " @relax_count: Number of times the wakeup source was deactivated."]
    #[doc = " @expire_count: Number of times the wakeup source's timeout has expired."]
    #[doc = " @wakeup_count: Number of times the wakeup source might abort suspend."]
    #[doc = " @dev: Struct device for sysfs statistics about the wakeup source."]
    #[doc = " @active: Status of the wakeup source."]
    #[doc = " @autosleep_enabled: Autosleep is active, so update @prevent_sleep_time."]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct wakeup_source {
        pub name: *const ::cty::c_char,
        pub id: ::cty::c_int,
        pub entry: list_head,
        pub lock: spinlock_t,
        pub wakeirq: *mut wake_irq,
        pub timer: timer_list,
        pub timer_expires: ::cty::c_ulong,
        pub total_time: ktime_t,
        pub max_time: ktime_t,
        pub last_time: ktime_t,
        pub start_prevent_time: ktime_t,
        pub prevent_sleep_time: ktime_t,
        pub event_count: ::cty::c_ulong,
        pub active_count: ::cty::c_ulong,
        pub relax_count: ::cty::c_ulong,
        pub expire_count: ::cty::c_ulong,
        pub wakeup_count: ::cty::c_ulong,
        pub dev: *mut device,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
        pub __bindgen_padding_0: [u8; 7usize],
    }
    #[test]
    fn bindgen_test_layout_wakeup_source() {
        assert_eq!(
            ::core::mem::size_of::<wakeup_source>(),
            192usize,
            concat!("Size of: ", stringify!(wakeup_source))
        );
        assert_eq!(
            ::core::mem::align_of::<wakeup_source>(),
            8usize,
            concat!("Alignment of ", stringify!(wakeup_source))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<wakeup_source>())).name as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(wakeup_source),
                "::",
                stringify!(name)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<wakeup_source>())).id as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(wakeup_source),
                "::",
                stringify!(id)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<wakeup_source>())).entry as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(wakeup_source),
                "::",
                stringify!(entry)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<wakeup_source>())).lock as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(wakeup_source),
                "::",
                stringify!(lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<wakeup_source>())).wakeirq as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(wakeup_source),
                "::",
                stringify!(wakeirq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<wakeup_source>())).timer as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(wakeup_source),
                "::",
                stringify!(timer)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<wakeup_source>())).timer_expires as *const _ as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(wakeup_source),
                "::",
                stringify!(timer_expires)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<wakeup_source>())).total_time as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(wakeup_source),
                "::",
                stringify!(total_time)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<wakeup_source>())).max_time as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(wakeup_source),
                "::",
                stringify!(max_time)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<wakeup_source>())).last_time as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(wakeup_source),
                "::",
                stringify!(last_time)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<wakeup_source>())).start_prevent_time as *const _ as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(wakeup_source),
                "::",
                stringify!(start_prevent_time)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<wakeup_source>())).prevent_sleep_time as *const _ as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(wakeup_source),
                "::",
                stringify!(prevent_sleep_time)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<wakeup_source>())).event_count as *const _ as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(wakeup_source),
                "::",
                stringify!(event_count)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<wakeup_source>())).active_count as *const _ as usize },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(wakeup_source),
                "::",
                stringify!(active_count)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<wakeup_source>())).relax_count as *const _ as usize },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(wakeup_source),
                "::",
                stringify!(relax_count)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<wakeup_source>())).expire_count as *const _ as usize },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(wakeup_source),
                "::",
                stringify!(expire_count)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<wakeup_source>())).wakeup_count as *const _ as usize },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(wakeup_source),
                "::",
                stringify!(wakeup_count)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<wakeup_source>())).dev as *const _ as usize },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(wakeup_source),
                "::",
                stringify!(dev)
            )
        );
    }
    impl wakeup_source {
        #[inline]
        pub fn active(&self) -> bool_ {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_active(&mut self, val: bool_) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn autosleep_enabled(&self) -> bool_ {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_autosleep_enabled(&mut self, val: bool_) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(1usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            active: bool_,
            autosleep_enabled: bool_,
        ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 1u8, {
                let active: u8 = unsafe { ::core::mem::transmute(active) };
                active as u64
            });
            __bindgen_bitfield_unit.set(1usize, 1u8, {
                let autosleep_enabled: u8 = unsafe { ::core::mem::transmute(autosleep_enabled) };
                autosleep_enabled as u64
            });
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct fwnode_handle {
        pub secondary: *mut fwnode_handle,
        pub ops: *const fwnode_operations,
        pub dev: *mut device,
        pub suppliers: list_head,
        pub consumers: list_head,
        pub flags: _cargo_bpf_u8,
    }
    #[test]
    fn bindgen_test_layout_fwnode_handle() {
        assert_eq!(
            ::core::mem::size_of::<fwnode_handle>(),
            64usize,
            concat!("Size of: ", stringify!(fwnode_handle))
        );
        assert_eq!(
            ::core::mem::align_of::<fwnode_handle>(),
            8usize,
            concat!("Alignment of ", stringify!(fwnode_handle))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fwnode_handle>())).secondary as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fwnode_handle),
                "::",
                stringify!(secondary)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fwnode_handle>())).ops as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fwnode_handle),
                "::",
                stringify!(ops)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fwnode_handle>())).dev as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fwnode_handle),
                "::",
                stringify!(dev)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fwnode_handle>())).suppliers as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(fwnode_handle),
                "::",
                stringify!(suppliers)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fwnode_handle>())).consumers as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(fwnode_handle),
                "::",
                stringify!(consumers)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fwnode_handle>())).flags as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(fwnode_handle),
                "::",
                stringify!(flags)
            )
        );
    }
    #[doc = " struct fwnode_endpoint - Fwnode graph endpoint"]
    #[doc = " @port: Port number"]
    #[doc = " @id: Endpoint id"]
    #[doc = " @local_fwnode: reference to the related fwnode"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct fwnode_endpoint {
        pub port: ::cty::c_uint,
        pub id: ::cty::c_uint,
        pub local_fwnode: *const fwnode_handle,
    }
    #[test]
    fn bindgen_test_layout_fwnode_endpoint() {
        assert_eq!(
            ::core::mem::size_of::<fwnode_endpoint>(),
            16usize,
            concat!("Size of: ", stringify!(fwnode_endpoint))
        );
        assert_eq!(
            ::core::mem::align_of::<fwnode_endpoint>(),
            8usize,
            concat!("Alignment of ", stringify!(fwnode_endpoint))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fwnode_endpoint>())).port as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fwnode_endpoint),
                "::",
                stringify!(port)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fwnode_endpoint>())).id as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(fwnode_endpoint),
                "::",
                stringify!(id)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<fwnode_endpoint>())).local_fwnode as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fwnode_endpoint),
                "::",
                stringify!(local_fwnode)
            )
        );
    }
    #[doc = " struct fwnode_reference_args - Fwnode reference with additional arguments"]
    #[doc = " @fwnode:- A reference to the base fwnode"]
    #[doc = " @nargs: Number of elements in @args array"]
    #[doc = " @args: Integer arguments on the fwnode"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct fwnode_reference_args {
        pub fwnode: *mut fwnode_handle,
        pub nargs: ::cty::c_uint,
        pub args: [_cargo_bpf_u64; 8usize],
    }
    #[test]
    fn bindgen_test_layout_fwnode_reference_args() {
        assert_eq!(
            ::core::mem::size_of::<fwnode_reference_args>(),
            80usize,
            concat!("Size of: ", stringify!(fwnode_reference_args))
        );
        assert_eq!(
            ::core::mem::align_of::<fwnode_reference_args>(),
            8usize,
            concat!("Alignment of ", stringify!(fwnode_reference_args))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<fwnode_reference_args>())).fwnode as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fwnode_reference_args),
                "::",
                stringify!(fwnode)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<fwnode_reference_args>())).nargs as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fwnode_reference_args),
                "::",
                stringify!(nargs)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fwnode_reference_args>())).args as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fwnode_reference_args),
                "::",
                stringify!(args)
            )
        );
    }
    #[doc = " struct fwnode_operations - Operations for fwnode interface"]
    #[doc = " @get: Get a reference to an fwnode."]
    #[doc = " @put: Put a reference to an fwnode."]
    #[doc = " @device_is_available: Return true if the device is available."]
    #[doc = " @device_get_match_data: Return the device driver match data."]
    #[doc = " @property_present: Return true if a property is present."]
    #[doc = " @property_read_int_array: Read an array of integer properties. Return zero on"]
    #[doc = "\t\t\t     success, a negative error code otherwise."]
    #[doc = " @property_read_string_array: Read an array of string properties. Return zero"]
    #[doc = "\t\t\t\ton success, a negative error code otherwise."]
    #[doc = " @get_name: Return the name of an fwnode."]
    #[doc = " @get_name_prefix: Get a prefix for a node (for printing purposes)."]
    #[doc = " @get_parent: Return the parent of an fwnode."]
    #[doc = " @get_next_child_node: Return the next child node in an iteration."]
    #[doc = " @get_named_child_node: Return a child node with a given name."]
    #[doc = " @get_reference_args: Return a reference pointed to by a property, with args"]
    #[doc = " @graph_get_next_endpoint: Return an endpoint node in an iteration."]
    #[doc = " @graph_get_remote_endpoint: Return the remote endpoint node of a local"]
    #[doc = "\t\t\t       endpoint node."]
    #[doc = " @graph_get_port_parent: Return the parent node of a port node."]
    #[doc = " @graph_parse_endpoint: Parse endpoint for port and endpoint id."]
    #[doc = " @add_links:\tCreate fwnode links to all the suppliers of the fwnode. Return"]
    #[doc = "\t\tzero on success, a negative error code otherwise."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct fwnode_operations {
        pub get: ::core::option::Option<
            unsafe extern "C" fn(fwnode: *mut fwnode_handle) -> *mut fwnode_handle,
        >,
        pub put: ::core::option::Option<unsafe extern "C" fn(fwnode: *mut fwnode_handle)>,
        pub device_is_available:
            ::core::option::Option<unsafe extern "C" fn(fwnode: *const fwnode_handle) -> bool_>,
        pub device_get_match_data: ::core::option::Option<
            unsafe extern "C" fn(
                fwnode: *const fwnode_handle,
                dev: *const device,
            ) -> *const ::cty::c_void,
        >,
        pub device_dma_supported:
            ::core::option::Option<unsafe extern "C" fn(fwnode: *const fwnode_handle) -> bool_>,
        pub device_get_dma_attr: ::core::option::Option<
            unsafe extern "C" fn(fwnode: *const fwnode_handle) -> dev_dma_attr,
        >,
        pub property_present: ::core::option::Option<
            unsafe extern "C" fn(
                fwnode: *const fwnode_handle,
                propname: *const ::cty::c_char,
            ) -> bool_,
        >,
        pub property_read_int_array: ::core::option::Option<
            unsafe extern "C" fn(
                fwnode: *const fwnode_handle,
                propname: *const ::cty::c_char,
                elem_size: ::cty::c_uint,
                val: *mut ::cty::c_void,
                nval: size_t,
            ) -> ::cty::c_int,
        >,
        pub property_read_string_array: ::core::option::Option<
            unsafe extern "C" fn(
                fwnode_handle: *const fwnode_handle,
                propname: *const ::cty::c_char,
                val: *mut *const ::cty::c_char,
                nval: size_t,
            ) -> ::cty::c_int,
        >,
        pub get_name: ::core::option::Option<
            unsafe extern "C" fn(fwnode: *const fwnode_handle) -> *const ::cty::c_char,
        >,
        pub get_name_prefix: ::core::option::Option<
            unsafe extern "C" fn(fwnode: *const fwnode_handle) -> *const ::cty::c_char,
        >,
        pub get_parent: ::core::option::Option<
            unsafe extern "C" fn(fwnode: *const fwnode_handle) -> *mut fwnode_handle,
        >,
        pub get_next_child_node: ::core::option::Option<
            unsafe extern "C" fn(
                fwnode: *const fwnode_handle,
                child: *mut fwnode_handle,
            ) -> *mut fwnode_handle,
        >,
        pub get_named_child_node: ::core::option::Option<
            unsafe extern "C" fn(
                fwnode: *const fwnode_handle,
                name: *const ::cty::c_char,
            ) -> *mut fwnode_handle,
        >,
        pub get_reference_args: ::core::option::Option<
            unsafe extern "C" fn(
                fwnode: *const fwnode_handle,
                prop: *const ::cty::c_char,
                nargs_prop: *const ::cty::c_char,
                nargs: ::cty::c_uint,
                index: ::cty::c_uint,
                args: *mut fwnode_reference_args,
            ) -> ::cty::c_int,
        >,
        pub graph_get_next_endpoint: ::core::option::Option<
            unsafe extern "C" fn(
                fwnode: *const fwnode_handle,
                prev: *mut fwnode_handle,
            ) -> *mut fwnode_handle,
        >,
        pub graph_get_remote_endpoint: ::core::option::Option<
            unsafe extern "C" fn(fwnode: *const fwnode_handle) -> *mut fwnode_handle,
        >,
        pub graph_get_port_parent: ::core::option::Option<
            unsafe extern "C" fn(fwnode: *mut fwnode_handle) -> *mut fwnode_handle,
        >,
        pub graph_parse_endpoint: ::core::option::Option<
            unsafe extern "C" fn(
                fwnode: *const fwnode_handle,
                endpoint: *mut fwnode_endpoint,
            ) -> ::cty::c_int,
        >,
        pub iomap: ::core::option::Option<
            unsafe extern "C" fn(
                fwnode: *mut fwnode_handle,
                index: ::cty::c_int,
            ) -> *mut ::cty::c_void,
        >,
        pub irq_get: ::core::option::Option<
            unsafe extern "C" fn(
                fwnode: *const fwnode_handle,
                index: ::cty::c_uint,
            ) -> ::cty::c_int,
        >,
        pub add_links: ::core::option::Option<
            unsafe extern "C" fn(fwnode: *mut fwnode_handle) -> ::cty::c_int,
        >,
    }
    #[test]
    fn bindgen_test_layout_fwnode_operations() {
        assert_eq!(
            ::core::mem::size_of::<fwnode_operations>(),
            176usize,
            concat!("Size of: ", stringify!(fwnode_operations))
        );
        assert_eq!(
            ::core::mem::align_of::<fwnode_operations>(),
            8usize,
            concat!("Alignment of ", stringify!(fwnode_operations))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fwnode_operations>())).get as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fwnode_operations),
                "::",
                stringify!(get)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fwnode_operations>())).put as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fwnode_operations),
                "::",
                stringify!(put)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<fwnode_operations>())).device_is_available as *const _
                    as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fwnode_operations),
                "::",
                stringify!(device_is_available)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<fwnode_operations>())).device_get_match_data as *const _
                    as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(fwnode_operations),
                "::",
                stringify!(device_get_match_data)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<fwnode_operations>())).device_dma_supported as *const _
                    as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(fwnode_operations),
                "::",
                stringify!(device_dma_supported)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<fwnode_operations>())).device_get_dma_attr as *const _
                    as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(fwnode_operations),
                "::",
                stringify!(device_get_dma_attr)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<fwnode_operations>())).property_present as *const _ as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(fwnode_operations),
                "::",
                stringify!(property_present)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<fwnode_operations>())).property_read_int_array as *const _
                    as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(fwnode_operations),
                "::",
                stringify!(property_read_int_array)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<fwnode_operations>())).property_read_string_array
                    as *const _ as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(fwnode_operations),
                "::",
                stringify!(property_read_string_array)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fwnode_operations>())).get_name as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(fwnode_operations),
                "::",
                stringify!(get_name)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<fwnode_operations>())).get_name_prefix as *const _ as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(fwnode_operations),
                "::",
                stringify!(get_name_prefix)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<fwnode_operations>())).get_parent as *const _ as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(fwnode_operations),
                "::",
                stringify!(get_parent)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<fwnode_operations>())).get_next_child_node as *const _
                    as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(fwnode_operations),
                "::",
                stringify!(get_next_child_node)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<fwnode_operations>())).get_named_child_node as *const _
                    as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(fwnode_operations),
                "::",
                stringify!(get_named_child_node)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<fwnode_operations>())).get_reference_args as *const _
                    as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(fwnode_operations),
                "::",
                stringify!(get_reference_args)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<fwnode_operations>())).graph_get_next_endpoint as *const _
                    as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(fwnode_operations),
                "::",
                stringify!(graph_get_next_endpoint)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<fwnode_operations>())).graph_get_remote_endpoint as *const _
                    as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(fwnode_operations),
                "::",
                stringify!(graph_get_remote_endpoint)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<fwnode_operations>())).graph_get_port_parent as *const _
                    as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(fwnode_operations),
                "::",
                stringify!(graph_get_port_parent)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<fwnode_operations>())).graph_parse_endpoint as *const _
                    as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(fwnode_operations),
                "::",
                stringify!(graph_parse_endpoint)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fwnode_operations>())).iomap as *const _ as usize },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(fwnode_operations),
                "::",
                stringify!(iomap)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fwnode_operations>())).irq_get as *const _ as usize },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(fwnode_operations),
                "::",
                stringify!(irq_get)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<fwnode_operations>())).add_links as *const _ as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(fwnode_operations),
                "::",
                stringify!(add_links)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct vm_struct {
        pub next: *mut vm_struct,
        pub addr: *mut ::cty::c_void,
        pub size: ::cty::c_ulong,
        pub flags: ::cty::c_ulong,
        pub pages: *mut *mut page,
        pub page_order: ::cty::c_uint,
        pub nr_pages: ::cty::c_uint,
        pub phys_addr: phys_addr_t,
        pub caller: *const ::cty::c_void,
    }
    #[test]
    fn bindgen_test_layout_vm_struct() {
        assert_eq!(
            ::core::mem::size_of::<vm_struct>(),
            64usize,
            concat!("Size of: ", stringify!(vm_struct))
        );
        assert_eq!(
            ::core::mem::align_of::<vm_struct>(),
            8usize,
            concat!("Alignment of ", stringify!(vm_struct))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vm_struct>())).next as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_struct),
                "::",
                stringify!(next)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vm_struct>())).addr as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_struct),
                "::",
                stringify!(addr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vm_struct>())).size as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_struct),
                "::",
                stringify!(size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vm_struct>())).flags as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_struct),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vm_struct>())).pages as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_struct),
                "::",
                stringify!(pages)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vm_struct>())).page_order as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_struct),
                "::",
                stringify!(page_order)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vm_struct>())).nr_pages as *const _ as usize },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_struct),
                "::",
                stringify!(nr_pages)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vm_struct>())).phys_addr as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_struct),
                "::",
                stringify!(phys_addr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vm_struct>())).caller as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_struct),
                "::",
                stringify!(caller)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct scatterlist {
        pub page_link: ::cty::c_ulong,
        pub offset: ::cty::c_uint,
        pub length: ::cty::c_uint,
        pub dma_address: dma_addr_t,
        pub dma_length: ::cty::c_uint,
        pub dma_flags: ::cty::c_uint,
    }
    #[test]
    fn bindgen_test_layout_scatterlist() {
        assert_eq!(
            ::core::mem::size_of::<scatterlist>(),
            32usize,
            concat!("Size of: ", stringify!(scatterlist))
        );
        assert_eq!(
            ::core::mem::align_of::<scatterlist>(),
            8usize,
            concat!("Alignment of ", stringify!(scatterlist))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<scatterlist>())).page_link as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(scatterlist),
                "::",
                stringify!(page_link)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<scatterlist>())).offset as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(scatterlist),
                "::",
                stringify!(offset)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<scatterlist>())).length as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(scatterlist),
                "::",
                stringify!(length)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<scatterlist>())).dma_address as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(scatterlist),
                "::",
                stringify!(dma_address)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<scatterlist>())).dma_length as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(scatterlist),
                "::",
                stringify!(dma_length)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<scatterlist>())).dma_flags as *const _ as usize },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(scatterlist),
                "::",
                stringify!(dma_flags)
            )
        );
    }
    pub type netdev_features_t = _cargo_bpf_u64;
    #[repr(C, packed)]
    #[derive(Debug, Copy, Clone)]
    pub struct ethhdr {
        pub h_dest: [::cty::c_uchar; 6usize],
        pub h_source: [::cty::c_uchar; 6usize],
        pub h_proto: __be16,
    }
    #[test]
    fn bindgen_test_layout_ethhdr() {
        assert_eq!(
            ::core::mem::size_of::<ethhdr>(),
            14usize,
            concat!("Size of: ", stringify!(ethhdr))
        );
        assert_eq!(
            ::core::mem::align_of::<ethhdr>(),
            1usize,
            concat!("Alignment of ", stringify!(ethhdr))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ethhdr>())).h_dest as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ethhdr),
                "::",
                stringify!(h_dest)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ethhdr>())).h_source as *const _ as usize },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(ethhdr),
                "::",
                stringify!(h_source)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ethhdr>())).h_proto as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(ethhdr),
                "::",
                stringify!(h_proto)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_flow_dissector {
        pub flow_keys: *mut bpf_flow_keys,
        pub skb: *const sk_buff,
        pub data: *const ::cty::c_void,
        pub data_end: *const ::cty::c_void,
    }
    #[test]
    fn bindgen_test_layout_bpf_flow_dissector() {
        assert_eq!(
            ::core::mem::size_of::<bpf_flow_dissector>(),
            32usize,
            concat!("Size of: ", stringify!(bpf_flow_dissector))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_flow_dissector>(),
            8usize,
            concat!("Alignment of ", stringify!(bpf_flow_dissector))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_flow_dissector>())).flow_keys as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_flow_dissector),
                "::",
                stringify!(flow_keys)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_flow_dissector>())).skb as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_flow_dissector),
                "::",
                stringify!(skb)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_flow_dissector>())).data as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_flow_dissector),
                "::",
                stringify!(data)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_flow_dissector>())).data_end as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_flow_dissector),
                "::",
                stringify!(data_end)
            )
        );
    }
    #[repr(C)]
    #[repr(align(64))]
    #[derive(Copy, Clone)]
    pub struct ptr_ring {
        pub producer: ::cty::c_int,
        pub producer_lock: spinlock_t,
        pub __bindgen_padding_0: [u32; 14usize],
        pub consumer_head: ::cty::c_int,
        pub consumer_tail: ::cty::c_int,
        pub consumer_lock: spinlock_t,
        pub __bindgen_padding_1: [u32; 13usize],
        pub size: ::cty::c_int,
        pub batch: ::cty::c_int,
        pub queue: *mut *mut ::cty::c_void,
    }
    #[test]
    fn bindgen_test_layout_ptr_ring() {
        assert_eq!(
            ::core::mem::size_of::<ptr_ring>(),
            192usize,
            concat!("Size of: ", stringify!(ptr_ring))
        );
        assert_eq!(
            ::core::mem::align_of::<ptr_ring>(),
            64usize,
            concat!("Alignment of ", stringify!(ptr_ring))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ptr_ring>())).producer as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ptr_ring),
                "::",
                stringify!(producer)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ptr_ring>())).producer_lock as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(ptr_ring),
                "::",
                stringify!(producer_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ptr_ring>())).consumer_head as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(ptr_ring),
                "::",
                stringify!(consumer_head)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ptr_ring>())).consumer_tail as *const _ as usize },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(ptr_ring),
                "::",
                stringify!(consumer_tail)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ptr_ring>())).consumer_lock as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(ptr_ring),
                "::",
                stringify!(consumer_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ptr_ring>())).size as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(ptr_ring),
                "::",
                stringify!(size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ptr_ring>())).batch as *const _ as usize },
            132usize,
            concat!(
                "Offset of field: ",
                stringify!(ptr_ring),
                "::",
                stringify!(batch)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ptr_ring>())).queue as *const _ as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(ptr_ring),
                "::",
                stringify!(queue)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct pp_alloc_cache {
        pub count: _cargo_bpf_u32,
        pub cache: [*mut page; 128usize],
    }
    #[test]
    fn bindgen_test_layout_pp_alloc_cache() {
        assert_eq!(
            ::core::mem::size_of::<pp_alloc_cache>(),
            1032usize,
            concat!("Size of: ", stringify!(pp_alloc_cache))
        );
        assert_eq!(
            ::core::mem::align_of::<pp_alloc_cache>(),
            8usize,
            concat!("Alignment of ", stringify!(pp_alloc_cache))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pp_alloc_cache>())).count as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pp_alloc_cache),
                "::",
                stringify!(count)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pp_alloc_cache>())).cache as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(pp_alloc_cache),
                "::",
                stringify!(cache)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct page_pool_params {
        pub flags: ::cty::c_uint,
        pub order: ::cty::c_uint,
        pub pool_size: ::cty::c_uint,
        pub nid: ::cty::c_int,
        pub dev: *mut device,
        pub napi: *mut napi_struct,
        pub dma_dir: dma_data_direction,
        pub max_len: ::cty::c_uint,
        pub offset: ::cty::c_uint,
        pub init_callback:
            ::core::option::Option<unsafe extern "C" fn(page: *mut page, arg: *mut ::cty::c_void)>,
        pub init_arg: *mut ::cty::c_void,
    }
    #[test]
    fn bindgen_test_layout_page_pool_params() {
        assert_eq!(
            ::core::mem::size_of::<page_pool_params>(),
            64usize,
            concat!("Size of: ", stringify!(page_pool_params))
        );
        assert_eq!(
            ::core::mem::align_of::<page_pool_params>(),
            8usize,
            concat!("Alignment of ", stringify!(page_pool_params))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<page_pool_params>())).flags as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(page_pool_params),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<page_pool_params>())).order as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(page_pool_params),
                "::",
                stringify!(order)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<page_pool_params>())).pool_size as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(page_pool_params),
                "::",
                stringify!(pool_size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<page_pool_params>())).nid as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(page_pool_params),
                "::",
                stringify!(nid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<page_pool_params>())).dev as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(page_pool_params),
                "::",
                stringify!(dev)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<page_pool_params>())).napi as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(page_pool_params),
                "::",
                stringify!(napi)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<page_pool_params>())).dma_dir as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(page_pool_params),
                "::",
                stringify!(dma_dir)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<page_pool_params>())).max_len as *const _ as usize },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(page_pool_params),
                "::",
                stringify!(max_len)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<page_pool_params>())).offset as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(page_pool_params),
                "::",
                stringify!(offset)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<page_pool_params>())).init_callback as *const _ as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(page_pool_params),
                "::",
                stringify!(init_callback)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<page_pool_params>())).init_arg as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(page_pool_params),
                "::",
                stringify!(init_arg)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct page_pool_alloc_stats {
        pub fast: _cargo_bpf_u64,
        pub slow: _cargo_bpf_u64,
        pub slow_high_order: _cargo_bpf_u64,
        pub empty: _cargo_bpf_u64,
        pub refill: _cargo_bpf_u64,
        pub waive: _cargo_bpf_u64,
    }
    #[test]
    fn bindgen_test_layout_page_pool_alloc_stats() {
        assert_eq!(
            ::core::mem::size_of::<page_pool_alloc_stats>(),
            48usize,
            concat!("Size of: ", stringify!(page_pool_alloc_stats))
        );
        assert_eq!(
            ::core::mem::align_of::<page_pool_alloc_stats>(),
            8usize,
            concat!("Alignment of ", stringify!(page_pool_alloc_stats))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<page_pool_alloc_stats>())).fast as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(page_pool_alloc_stats),
                "::",
                stringify!(fast)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<page_pool_alloc_stats>())).slow as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(page_pool_alloc_stats),
                "::",
                stringify!(slow)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<page_pool_alloc_stats>())).slow_high_order as *const _
                    as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(page_pool_alloc_stats),
                "::",
                stringify!(slow_high_order)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<page_pool_alloc_stats>())).empty as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(page_pool_alloc_stats),
                "::",
                stringify!(empty)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<page_pool_alloc_stats>())).refill as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(page_pool_alloc_stats),
                "::",
                stringify!(refill)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<page_pool_alloc_stats>())).waive as *const _ as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(page_pool_alloc_stats),
                "::",
                stringify!(waive)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct page_pool_recycle_stats {
        pub cached: _cargo_bpf_u64,
        pub cache_full: _cargo_bpf_u64,
        pub ring: _cargo_bpf_u64,
        pub ring_full: _cargo_bpf_u64,
        pub released_refcnt: _cargo_bpf_u64,
    }
    #[test]
    fn bindgen_test_layout_page_pool_recycle_stats() {
        assert_eq!(
            ::core::mem::size_of::<page_pool_recycle_stats>(),
            40usize,
            concat!("Size of: ", stringify!(page_pool_recycle_stats))
        );
        assert_eq!(
            ::core::mem::align_of::<page_pool_recycle_stats>(),
            8usize,
            concat!("Alignment of ", stringify!(page_pool_recycle_stats))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<page_pool_recycle_stats>())).cached as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(page_pool_recycle_stats),
                "::",
                stringify!(cached)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<page_pool_recycle_stats>())).cache_full as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(page_pool_recycle_stats),
                "::",
                stringify!(cache_full)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<page_pool_recycle_stats>())).ring as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(page_pool_recycle_stats),
                "::",
                stringify!(ring)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<page_pool_recycle_stats>())).ring_full as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(page_pool_recycle_stats),
                "::",
                stringify!(ring_full)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<page_pool_recycle_stats>())).released_refcnt as *const _
                    as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(page_pool_recycle_stats),
                "::",
                stringify!(released_refcnt)
            )
        );
    }
    #[repr(C)]
    #[repr(align(64))]
    #[derive(Copy, Clone)]
    pub struct page_pool {
        pub p: page_pool_params,
        pub release_dw: delayed_work,
        pub disconnect: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::cty::c_void)>,
        pub defer_start: ::cty::c_ulong,
        pub defer_warn: ::cty::c_ulong,
        pub pages_state_hold_cnt: _cargo_bpf_u32,
        pub frag_offset: ::cty::c_uint,
        pub frag_page: *mut page,
        pub frag_users: ::cty::c_long,
        pub alloc_stats: page_pool_alloc_stats,
        pub xdp_mem_id: _cargo_bpf_u32,
        pub alloc: pp_alloc_cache,
        pub __bindgen_padding_0: [u64; 7usize],
        pub ring: ptr_ring,
        pub recycle_stats: *mut page_pool_recycle_stats,
        pub pages_state_release_cnt: atomic_t,
        pub user_cnt: refcount_t,
        pub destroy_cnt: _cargo_bpf_u64,
    }
    #[test]
    fn bindgen_test_layout_page_pool() {
        assert_eq!(
            ::core::mem::size_of::<page_pool>(),
            1600usize,
            concat!("Size of: ", stringify!(page_pool))
        );
        assert_eq!(
            ::core::mem::align_of::<page_pool>(),
            64usize,
            concat!("Alignment of ", stringify!(page_pool))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<page_pool>())).p as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(page_pool),
                "::",
                stringify!(p)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<page_pool>())).release_dw as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(page_pool),
                "::",
                stringify!(release_dw)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<page_pool>())).disconnect as *const _ as usize },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(page_pool),
                "::",
                stringify!(disconnect)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<page_pool>())).defer_start as *const _ as usize },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(page_pool),
                "::",
                stringify!(defer_start)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<page_pool>())).defer_warn as *const _ as usize },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(page_pool),
                "::",
                stringify!(defer_warn)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<page_pool>())).pages_state_hold_cnt as *const _ as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(page_pool),
                "::",
                stringify!(pages_state_hold_cnt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<page_pool>())).frag_offset as *const _ as usize },
            180usize,
            concat!(
                "Offset of field: ",
                stringify!(page_pool),
                "::",
                stringify!(frag_offset)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<page_pool>())).frag_page as *const _ as usize },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(page_pool),
                "::",
                stringify!(frag_page)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<page_pool>())).frag_users as *const _ as usize },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(page_pool),
                "::",
                stringify!(frag_users)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<page_pool>())).alloc_stats as *const _ as usize },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(page_pool),
                "::",
                stringify!(alloc_stats)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<page_pool>())).xdp_mem_id as *const _ as usize },
            248usize,
            concat!(
                "Offset of field: ",
                stringify!(page_pool),
                "::",
                stringify!(xdp_mem_id)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<page_pool>())).alloc as *const _ as usize },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(page_pool),
                "::",
                stringify!(alloc)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<page_pool>())).ring as *const _ as usize },
            1344usize,
            concat!(
                "Offset of field: ",
                stringify!(page_pool),
                "::",
                stringify!(ring)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<page_pool>())).recycle_stats as *const _ as usize },
            1536usize,
            concat!(
                "Offset of field: ",
                stringify!(page_pool),
                "::",
                stringify!(recycle_stats)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<page_pool>())).pages_state_release_cnt as *const _ as usize
            },
            1544usize,
            concat!(
                "Offset of field: ",
                stringify!(page_pool),
                "::",
                stringify!(pages_state_release_cnt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<page_pool>())).user_cnt as *const _ as usize },
            1548usize,
            concat!(
                "Offset of field: ",
                stringify!(page_pool),
                "::",
                stringify!(user_cnt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<page_pool>())).destroy_cnt as *const _ as usize },
            1552usize,
            concat!(
                "Offset of field: ",
                stringify!(page_pool),
                "::",
                stringify!(destroy_cnt)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct sk_buff_head {
        pub __bindgen_anon_1: sk_buff_head__bindgen_ty_1,
        pub qlen: __u32,
        pub lock: spinlock_t,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union sk_buff_head__bindgen_ty_1 {
        pub __bindgen_anon_1: sk_buff_head__bindgen_ty_1__bindgen_ty_1,
        pub list: sk_buff_head__bindgen_ty_1_sk_buff_list,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct sk_buff_head__bindgen_ty_1__bindgen_ty_1 {
        pub next: *mut sk_buff,
        pub prev: *mut sk_buff,
    }
    #[test]
    fn bindgen_test_layout_sk_buff_head__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<sk_buff_head__bindgen_ty_1__bindgen_ty_1>(),
            16usize,
            concat!(
                "Size of: ",
                stringify!(sk_buff_head__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<sk_buff_head__bindgen_ty_1__bindgen_ty_1>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(sk_buff_head__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff_head__bindgen_ty_1__bindgen_ty_1>())).next
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff_head__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(next)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff_head__bindgen_ty_1__bindgen_ty_1>())).prev
                    as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff_head__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(prev)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct sk_buff_head__bindgen_ty_1_sk_buff_list {
        pub next: *mut sk_buff,
        pub prev: *mut sk_buff,
    }
    #[test]
    fn bindgen_test_layout_sk_buff_head__bindgen_ty_1_sk_buff_list() {
        assert_eq!(
            ::core::mem::size_of::<sk_buff_head__bindgen_ty_1_sk_buff_list>(),
            16usize,
            concat!(
                "Size of: ",
                stringify!(sk_buff_head__bindgen_ty_1_sk_buff_list)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<sk_buff_head__bindgen_ty_1_sk_buff_list>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(sk_buff_head__bindgen_ty_1_sk_buff_list)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff_head__bindgen_ty_1_sk_buff_list>())).next
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff_head__bindgen_ty_1_sk_buff_list),
                "::",
                stringify!(next)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff_head__bindgen_ty_1_sk_buff_list>())).prev
                    as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff_head__bindgen_ty_1_sk_buff_list),
                "::",
                stringify!(prev)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_sk_buff_head__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<sk_buff_head__bindgen_ty_1>(),
            16usize,
            concat!("Size of: ", stringify!(sk_buff_head__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<sk_buff_head__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(sk_buff_head__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff_head__bindgen_ty_1>())).list as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff_head__bindgen_ty_1),
                "::",
                stringify!(list)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_sk_buff_head() {
        assert_eq!(
            ::core::mem::size_of::<sk_buff_head>(),
            24usize,
            concat!("Size of: ", stringify!(sk_buff_head))
        );
        assert_eq!(
            ::core::mem::align_of::<sk_buff_head>(),
            8usize,
            concat!("Alignment of ", stringify!(sk_buff_head))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sk_buff_head>())).qlen as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff_head),
                "::",
                stringify!(qlen)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sk_buff_head>())).lock as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff_head),
                "::",
                stringify!(lock)
            )
        );
    }
    #[doc = " struct skb_shared_hwtstamps - hardware time stamps"]
    #[doc = " @hwtstamp:\t\thardware time stamp transformed into duration"]
    #[doc = "\t\t\tsince arbitrary point in time"]
    #[doc = " @netdev_data:\taddress/cookie of network device driver used as"]
    #[doc = "\t\t\treference to actual hardware time stamp"]
    #[doc = ""]
    #[doc = " Software time stamps generated by ktime_get_real() are stored in"]
    #[doc = " skb->tstamp."]
    #[doc = ""]
    #[doc = " hwtstamps can only be compared against other hwtstamps from"]
    #[doc = " the same device."]
    #[doc = ""]
    #[doc = " This structure is attached to packets as part of the"]
    #[doc = " &skb_shared_info. Use skb_hwtstamps() to get a pointer."]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct skb_shared_hwtstamps {
        pub __bindgen_anon_1: skb_shared_hwtstamps__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union skb_shared_hwtstamps__bindgen_ty_1 {
        pub hwtstamp: ktime_t,
        pub netdev_data: *mut ::cty::c_void,
    }
    #[test]
    fn bindgen_test_layout_skb_shared_hwtstamps__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<skb_shared_hwtstamps__bindgen_ty_1>(),
            8usize,
            concat!("Size of: ", stringify!(skb_shared_hwtstamps__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<skb_shared_hwtstamps__bindgen_ty_1>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(skb_shared_hwtstamps__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<skb_shared_hwtstamps__bindgen_ty_1>())).hwtstamp as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(skb_shared_hwtstamps__bindgen_ty_1),
                "::",
                stringify!(hwtstamp)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<skb_shared_hwtstamps__bindgen_ty_1>())).netdev_data
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(skb_shared_hwtstamps__bindgen_ty_1),
                "::",
                stringify!(netdev_data)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_skb_shared_hwtstamps() {
        assert_eq!(
            ::core::mem::size_of::<skb_shared_hwtstamps>(),
            8usize,
            concat!("Size of: ", stringify!(skb_shared_hwtstamps))
        );
        assert_eq!(
            ::core::mem::align_of::<skb_shared_hwtstamps>(),
            8usize,
            concat!("Alignment of ", stringify!(skb_shared_hwtstamps))
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ubuf_info {
        pub callback: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut sk_buff, arg2: *mut ubuf_info, zerocopy_success: bool_),
        >,
        pub refcnt: refcount_t,
        pub flags: _cargo_bpf_u8,
    }
    #[test]
    fn bindgen_test_layout_ubuf_info() {
        assert_eq!(
            ::core::mem::size_of::<ubuf_info>(),
            16usize,
            concat!("Size of: ", stringify!(ubuf_info))
        );
        assert_eq!(
            ::core::mem::align_of::<ubuf_info>(),
            8usize,
            concat!("Alignment of ", stringify!(ubuf_info))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ubuf_info>())).callback as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ubuf_info),
                "::",
                stringify!(callback)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ubuf_info>())).refcnt as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ubuf_info),
                "::",
                stringify!(refcnt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ubuf_info>())).flags as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(ubuf_info),
                "::",
                stringify!(flags)
            )
        );
    }
    pub type sk_buff_data_t = ::cty::c_uint;
    #[doc = "\tstruct sk_buff - socket buffer"]
    #[doc = "\t@next: Next buffer in list"]
    #[doc = "\t@prev: Previous buffer in list"]
    #[doc = "\t@tstamp: Time we arrived/left"]
    #[doc = "\t@skb_mstamp_ns: (aka @tstamp) earliest departure time; start point"]
    #[doc = "\t\tfor retransmit timer"]
    #[doc = "\t@rbnode: RB tree node, alternative to next/prev for netem/tcp"]
    #[doc = "\t@list: queue head"]
    #[doc = "\t@ll_node: anchor in an llist (eg socket defer_list)"]
    #[doc = "\t@sk: Socket we are owned by"]
    #[doc = "\t@ip_defrag_offset: (aka @sk) alternate use of @sk, used in"]
    #[doc = "\t\tfragmentation management"]
    #[doc = "\t@dev: Device we arrived on/are leaving by"]
    #[doc = "\t@dev_scratch: (aka @dev) alternate use of @dev when @dev would be %NULL"]
    #[doc = "\t@cb: Control buffer. Free for use by every layer. Put private vars here"]
    #[doc = "\t@_skb_refdst: destination entry (with norefcount bit)"]
    #[doc = "\t@sp: the security path, used for xfrm"]
    #[doc = "\t@len: Length of actual data"]
    #[doc = "\t@data_len: Data length"]
    #[doc = "\t@mac_len: Length of link layer header"]
    #[doc = "\t@hdr_len: writable header length of cloned skb"]
    #[doc = "\t@csum: Checksum (must include start/offset pair)"]
    #[doc = "\t@csum_start: Offset from skb->head where checksumming should start"]
    #[doc = "\t@csum_offset: Offset from csum_start where checksum should be stored"]
    #[doc = "\t@priority: Packet queueing priority"]
    #[doc = "\t@ignore_df: allow local fragmentation"]
    #[doc = "\t@cloned: Head may be cloned (check refcnt to be sure)"]
    #[doc = "\t@ip_summed: Driver fed us an IP checksum"]
    #[doc = "\t@nohdr: Payload reference only, must not modify header"]
    #[doc = "\t@pkt_type: Packet class"]
    #[doc = "\t@fclone: skbuff clone status"]
    #[doc = "\t@ipvs_property: skbuff is owned by ipvs"]
    #[doc = "\t@inner_protocol_type: whether the inner protocol is"]
    #[doc = "\t\tENCAP_TYPE_ETHER or ENCAP_TYPE_IPPROTO"]
    #[doc = "\t@remcsum_offload: remote checksum offload is enabled"]
    #[doc = "\t@offload_fwd_mark: Packet was L2-forwarded in hardware"]
    #[doc = "\t@offload_l3_fwd_mark: Packet was L3-forwarded in hardware"]
    #[doc = "\t@tc_skip_classify: do not classify packet. set by IFB device"]
    #[doc = "\t@tc_at_ingress: used within tc_classify to distinguish in/egress"]
    #[doc = "\t@redirected: packet was redirected by packet classifier"]
    #[doc = "\t@from_ingress: packet was redirected from the ingress path"]
    #[doc = "\t@nf_skip_egress: packet shall skip nf egress - see netfilter_netdev.h"]
    #[doc = "\t@peeked: this packet has been seen already, so stats have been"]
    #[doc = "\t\tdone for it, don't do them again"]
    #[doc = "\t@nf_trace: netfilter packet trace flag"]
    #[doc = "\t@protocol: Packet protocol from driver"]
    #[doc = "\t@destructor: Destruct function"]
    #[doc = "\t@tcp_tsorted_anchor: list structure for TCP (tp->tsorted_sent_queue)"]
    #[doc = "\t@_sk_redir: socket redirection information for skmsg"]
    #[doc = "\t@_nfct: Associated connection, if any (with nfctinfo bits)"]
    #[doc = "\t@nf_bridge: Saved data about a bridged frame - see br_netfilter.c"]
    #[doc = "\t@skb_iif: ifindex of device we arrived on"]
    #[doc = "\t@tc_index: Traffic control index"]
    #[doc = "\t@hash: the packet hash"]
    #[doc = "\t@queue_mapping: Queue mapping for multiqueue devices"]
    #[doc = "\t@head_frag: skb was allocated from page fragments,"]
    #[doc = "\t\tnot allocated by kmalloc() or vmalloc()."]
    #[doc = "\t@pfmemalloc: skbuff was allocated from PFMEMALLOC reserves"]
    #[doc = "\t@pp_recycle: mark the packet for recycling instead of freeing (implies"]
    #[doc = "\t\tpage_pool support on driver)"]
    #[doc = "\t@active_extensions: active extensions (skb_ext_id types)"]
    #[doc = "\t@ndisc_nodetype: router type (from link layer)"]
    #[doc = "\t@ooo_okay: allow the mapping of a socket to a queue to be changed"]
    #[doc = "\t@l4_hash: indicate hash is a canonical 4-tuple hash over transport"]
    #[doc = "\t\tports."]
    #[doc = "\t@sw_hash: indicates hash was computed in software stack"]
    #[doc = "\t@wifi_acked_valid: wifi_acked was set"]
    #[doc = "\t@wifi_acked: whether frame was acked on wifi or not"]
    #[doc = "\t@no_fcs:  Request NIC to treat last 4 bytes as Ethernet FCS"]
    #[doc = "\t@encapsulation: indicates the inner headers in the skbuff are valid"]
    #[doc = "\t@encap_hdr_csum: software checksum is needed"]
    #[doc = "\t@csum_valid: checksum is already valid"]
    #[doc = "\t@csum_not_inet: use CRC32c to resolve CHECKSUM_PARTIAL"]
    #[doc = "\t@csum_complete_sw: checksum was completed by software"]
    #[doc = "\t@csum_level: indicates the number of consecutive checksums found in"]
    #[doc = "\t\tthe packet minus one that have been verified as"]
    #[doc = "\t\tCHECKSUM_UNNECESSARY (max 3)"]
    #[doc = "\t@dst_pending_confirm: need to confirm neighbour"]
    #[doc = "\t@decrypted: Decrypted SKB"]
    #[doc = "\t@slow_gro: state present at GRO time, slower prepare step required"]
    #[doc = "\t@mono_delivery_time: When set, skb->tstamp has the"]
    #[doc = "\t\tdelivery_time in mono clock base (i.e. EDT).  Otherwise, the"]
    #[doc = "\t\tskb->tstamp has the (rcv) timestamp at ingress and"]
    #[doc = "\t\tdelivery_time at egress."]
    #[doc = "\t@napi_id: id of the NAPI struct this skb came from"]
    #[doc = "\t@sender_cpu: (aka @napi_id) source CPU in XPS"]
    #[doc = "\t@alloc_cpu: CPU which did the skb allocation."]
    #[doc = "\t@secmark: security marking"]
    #[doc = "\t@mark: Generic packet mark"]
    #[doc = "\t@reserved_tailroom: (aka @mark) number of bytes of free space available"]
    #[doc = "\t\tat the tail of an sk_buff"]
    #[doc = "\t@vlan_all: vlan fields (proto & tci)"]
    #[doc = "\t@vlan_proto: vlan encapsulation protocol"]
    #[doc = "\t@vlan_tci: vlan tag control information"]
    #[doc = "\t@inner_protocol: Protocol (encapsulation)"]
    #[doc = "\t@inner_ipproto: (aka @inner_protocol) stores ipproto when"]
    #[doc = "\t\tskb->inner_protocol_type == ENCAP_TYPE_IPPROTO;"]
    #[doc = "\t@inner_transport_header: Inner transport layer header (encapsulation)"]
    #[doc = "\t@inner_network_header: Network layer header (encapsulation)"]
    #[doc = "\t@inner_mac_header: Link layer header (encapsulation)"]
    #[doc = "\t@transport_header: Transport layer header"]
    #[doc = "\t@network_header: Network layer header"]
    #[doc = "\t@mac_header: Link layer header"]
    #[doc = "\t@kcov_handle: KCOV remote handle for remote coverage collection"]
    #[doc = "\t@tail: Tail pointer"]
    #[doc = "\t@end: End pointer"]
    #[doc = "\t@head: Head of buffer"]
    #[doc = "\t@data: Data head pointer"]
    #[doc = "\t@truesize: Buffer size"]
    #[doc = "\t@users: User count - see {datagram,tcp}.c"]
    #[doc = "\t@extensions: allocated extensions, valid if active_extensions is nonzero"]
    #[repr(C)]
    pub struct sk_buff {
        pub __bindgen_anon_1: sk_buff__bindgen_ty_1,
        pub __bindgen_anon_2: sk_buff__bindgen_ty_2,
        pub __bindgen_anon_3: sk_buff__bindgen_ty_3,
        pub cb: [::cty::c_char; 48usize],
        pub __bindgen_anon_4: sk_buff__bindgen_ty_4,
        pub _nfct: ::cty::c_ulong,
        pub len: ::cty::c_uint,
        pub data_len: ::cty::c_uint,
        pub mac_len: __u16,
        pub hdr_len: __u16,
        pub queue_mapping: __u16,
        pub __cloned_offset: __IncompleteArrayField<__u8>,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
        pub active_extensions: __u8,
        pub __bindgen_anon_5: sk_buff__bindgen_ty_5,
        pub tail: sk_buff_data_t,
        pub end: sk_buff_data_t,
        pub head: *mut ::cty::c_uchar,
        pub data: *mut ::cty::c_uchar,
        pub truesize: ::cty::c_uint,
        pub users: refcount_t,
        pub extensions: *mut skb_ext,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union sk_buff__bindgen_ty_1 {
        pub __bindgen_anon_1: sk_buff__bindgen_ty_1__bindgen_ty_1,
        pub rbnode: rb_node,
        pub list: list_head,
        pub ll_node: llist_node,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct sk_buff__bindgen_ty_1__bindgen_ty_1 {
        pub next: *mut sk_buff,
        pub prev: *mut sk_buff,
        pub __bindgen_anon_1: sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
        pub dev: *mut net_device,
        pub dev_scratch: ::cty::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
            8usize,
            concat!(
                "Size of: ",
                stringify!(sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).dev
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(dev)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()))
                    .dev_scratch as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(dev_scratch)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_sk_buff__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<sk_buff__bindgen_ty_1__bindgen_ty_1>(),
            24usize,
            concat!("Size of: ", stringify!(sk_buff__bindgen_ty_1__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<sk_buff__bindgen_ty_1__bindgen_ty_1>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(sk_buff__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_1__bindgen_ty_1>())).next as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(next)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_1__bindgen_ty_1>())).prev as *const _
                    as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(prev)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_sk_buff__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<sk_buff__bindgen_ty_1>(),
            24usize,
            concat!("Size of: ", stringify!(sk_buff__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<sk_buff__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(sk_buff__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_1>())).rbnode as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_1),
                "::",
                stringify!(rbnode)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sk_buff__bindgen_ty_1>())).list as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_1),
                "::",
                stringify!(list)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_1>())).ll_node as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_1),
                "::",
                stringify!(ll_node)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union sk_buff__bindgen_ty_2 {
        pub sk: *mut sock,
        pub ip_defrag_offset: ::cty::c_int,
    }
    #[test]
    fn bindgen_test_layout_sk_buff__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<sk_buff__bindgen_ty_2>(),
            8usize,
            concat!("Size of: ", stringify!(sk_buff__bindgen_ty_2))
        );
        assert_eq!(
            ::core::mem::align_of::<sk_buff__bindgen_ty_2>(),
            8usize,
            concat!("Alignment of ", stringify!(sk_buff__bindgen_ty_2))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sk_buff__bindgen_ty_2>())).sk as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_2),
                "::",
                stringify!(sk)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_2>())).ip_defrag_offset as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_2),
                "::",
                stringify!(ip_defrag_offset)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union sk_buff__bindgen_ty_3 {
        pub tstamp: ktime_t,
        pub skb_mstamp_ns: _cargo_bpf_u64,
    }
    #[test]
    fn bindgen_test_layout_sk_buff__bindgen_ty_3() {
        assert_eq!(
            ::core::mem::size_of::<sk_buff__bindgen_ty_3>(),
            8usize,
            concat!("Size of: ", stringify!(sk_buff__bindgen_ty_3))
        );
        assert_eq!(
            ::core::mem::align_of::<sk_buff__bindgen_ty_3>(),
            8usize,
            concat!("Alignment of ", stringify!(sk_buff__bindgen_ty_3))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_3>())).tstamp as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_3),
                "::",
                stringify!(tstamp)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_3>())).skb_mstamp_ns as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_3),
                "::",
                stringify!(skb_mstamp_ns)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union sk_buff__bindgen_ty_4 {
        pub __bindgen_anon_1: sk_buff__bindgen_ty_4__bindgen_ty_1,
        pub tcp_tsorted_anchor: list_head,
        pub _sk_redir: ::cty::c_ulong,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct sk_buff__bindgen_ty_4__bindgen_ty_1 {
        pub _skb_refdst: ::cty::c_ulong,
        pub destructor: ::core::option::Option<unsafe extern "C" fn(skb: *mut sk_buff)>,
    }
    #[test]
    fn bindgen_test_layout_sk_buff__bindgen_ty_4__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<sk_buff__bindgen_ty_4__bindgen_ty_1>(),
            16usize,
            concat!("Size of: ", stringify!(sk_buff__bindgen_ty_4__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<sk_buff__bindgen_ty_4__bindgen_ty_1>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(sk_buff__bindgen_ty_4__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_4__bindgen_ty_1>()))._skb_refdst
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_4__bindgen_ty_1),
                "::",
                stringify!(_skb_refdst)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_4__bindgen_ty_1>())).destructor
                    as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_4__bindgen_ty_1),
                "::",
                stringify!(destructor)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_sk_buff__bindgen_ty_4() {
        assert_eq!(
            ::core::mem::size_of::<sk_buff__bindgen_ty_4>(),
            16usize,
            concat!("Size of: ", stringify!(sk_buff__bindgen_ty_4))
        );
        assert_eq!(
            ::core::mem::align_of::<sk_buff__bindgen_ty_4>(),
            8usize,
            concat!("Alignment of ", stringify!(sk_buff__bindgen_ty_4))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_4>())).tcp_tsorted_anchor as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_4),
                "::",
                stringify!(tcp_tsorted_anchor)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_4>()))._sk_redir as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_4),
                "::",
                stringify!(_sk_redir)
            )
        );
    }
    #[repr(C)]
    pub struct sk_buff__bindgen_ty_5 {
        pub __bindgen_anon_1: __BindgenUnionField<sk_buff__bindgen_ty_5__bindgen_ty_1>,
        pub headers: __BindgenUnionField<sk_buff__bindgen_ty_5__bindgen_ty_2>,
        pub bindgen_union_field: [u32; 15usize],
    }
    #[repr(C)]
    pub struct sk_buff__bindgen_ty_5__bindgen_ty_1 {
        pub __pkt_type_offset: __IncompleteArrayField<__u8>,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
        pub __mono_tc_offset: __IncompleteArrayField<__u8>,
        pub _bitfield_align_2: [u8; 0],
        pub _bitfield_2: __BindgenBitfieldUnit<[u8; 4usize]>,
        pub tc_index: __u16,
        pub alloc_cpu: _cargo_bpf_u16,
        pub __bindgen_anon_1: sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
        pub priority: __u32,
        pub skb_iif: ::cty::c_int,
        pub hash: __u32,
        pub __bindgen_anon_2: sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2,
        pub __bindgen_anon_3: sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3,
        pub secmark: __u32,
        pub __bindgen_anon_4: sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_4,
        pub __bindgen_anon_5: sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_5,
        pub inner_transport_header: __u16,
        pub inner_network_header: __u16,
        pub inner_mac_header: __u16,
        pub protocol: __be16,
        pub transport_header: __u16,
        pub network_header: __u16,
        pub mac_header: __u16,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
        pub csum: __wsum,
        pub __bindgen_anon_1: sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
        pub csum_start: __u16,
        pub csum_offset: __u16,
    }
    #[test]
    fn bindgen_test_layout_sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(
            ),
            4usize,
            concat!(
                "Size of: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(
            ),
            2usize,
            concat!(
                "Alignment of ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<
                    sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
                >()))
                .csum_start as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(csum_start)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<
                    sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
                >()))
                .csum_offset as *const _ as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(csum_offset)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>(),
            4usize,
            concat!(
                "Size of: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>(),
            4usize,
            concat!(
                "Alignment of ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>())).csum
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(csum)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2 {
        pub vlan_all: _cargo_bpf_u32,
        pub __bindgen_anon_1: sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
        pub vlan_proto: __be16,
        pub vlan_tci: __u16,
    }
    #[test]
    fn bindgen_test_layout_sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>(
            ),
            4usize,
            concat!(
                "Size of: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>(
            ),
            2usize,
            concat!(
                "Alignment of ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<
                    sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
                >()))
                .vlan_proto as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1),
                "::",
                stringify!(vlan_proto)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<
                    sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
                >()))
                .vlan_tci as *const _ as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1),
                "::",
                stringify!(vlan_tci)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2>(),
            4usize,
            concat!(
                "Size of: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2>(),
            4usize,
            concat!(
                "Alignment of ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2>()))
                    .vlan_all as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(vlan_all)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3 {
        pub napi_id: ::cty::c_uint,
        pub sender_cpu: ::cty::c_uint,
    }
    #[test]
    fn bindgen_test_layout_sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3() {
        assert_eq!(
            ::core::mem::size_of::<sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3>(),
            4usize,
            concat!(
                "Size of: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3>(),
            4usize,
            concat!(
                "Alignment of ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3>()))
                    .napi_id as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(napi_id)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3>()))
                    .sender_cpu as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(sender_cpu)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_4 {
        pub mark: __u32,
        pub reserved_tailroom: __u32,
    }
    #[test]
    fn bindgen_test_layout_sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_4() {
        assert_eq!(
            ::core::mem::size_of::<sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_4>(),
            4usize,
            concat!(
                "Size of: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_4)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_4>(),
            4usize,
            concat!(
                "Alignment of ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_4)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_4>())).mark
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_4),
                "::",
                stringify!(mark)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_4>()))
                    .reserved_tailroom as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_4),
                "::",
                stringify!(reserved_tailroom)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_5 {
        pub inner_protocol: __be16,
        pub inner_ipproto: __u8,
    }
    #[test]
    fn bindgen_test_layout_sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_5() {
        assert_eq!(
            ::core::mem::size_of::<sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_5>(),
            2usize,
            concat!(
                "Size of: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_5)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_5>(),
            2usize,
            concat!(
                "Alignment of ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_5)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_5>()))
                    .inner_protocol as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_5),
                "::",
                stringify!(inner_protocol)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_5>()))
                    .inner_ipproto as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_5),
                "::",
                stringify!(inner_ipproto)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_sk_buff__bindgen_ty_5__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<sk_buff__bindgen_ty_5__bindgen_ty_1>(),
            60usize,
            concat!("Size of: ", stringify!(sk_buff__bindgen_ty_5__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<sk_buff__bindgen_ty_5__bindgen_ty_1>(),
            4usize,
            concat!(
                "Alignment of ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_5__bindgen_ty_1>())).__pkt_type_offset
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_1),
                "::",
                stringify!(__pkt_type_offset)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_5__bindgen_ty_1>())).__mono_tc_offset
                    as *const _ as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_1),
                "::",
                stringify!(__mono_tc_offset)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_5__bindgen_ty_1>())).tc_index
                    as *const _ as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_1),
                "::",
                stringify!(tc_index)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_5__bindgen_ty_1>())).alloc_cpu
                    as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_1),
                "::",
                stringify!(alloc_cpu)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_5__bindgen_ty_1>())).priority
                    as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_1),
                "::",
                stringify!(priority)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_5__bindgen_ty_1>())).skb_iif as *const _
                    as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_1),
                "::",
                stringify!(skb_iif)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_5__bindgen_ty_1>())).hash as *const _
                    as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_1),
                "::",
                stringify!(hash)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_5__bindgen_ty_1>())).secmark as *const _
                    as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_1),
                "::",
                stringify!(secmark)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_5__bindgen_ty_1>()))
                    .inner_transport_header as *const _ as usize
            },
            46usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_1),
                "::",
                stringify!(inner_transport_header)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_5__bindgen_ty_1>()))
                    .inner_network_header as *const _ as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_1),
                "::",
                stringify!(inner_network_header)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_5__bindgen_ty_1>())).inner_mac_header
                    as *const _ as usize
            },
            50usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_1),
                "::",
                stringify!(inner_mac_header)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_5__bindgen_ty_1>())).protocol
                    as *const _ as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_1),
                "::",
                stringify!(protocol)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_5__bindgen_ty_1>())).transport_header
                    as *const _ as usize
            },
            54usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_1),
                "::",
                stringify!(transport_header)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_5__bindgen_ty_1>())).network_header
                    as *const _ as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_1),
                "::",
                stringify!(network_header)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_5__bindgen_ty_1>())).mac_header
                    as *const _ as usize
            },
            58usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_1),
                "::",
                stringify!(mac_header)
            )
        );
    }
    impl sk_buff__bindgen_ty_5__bindgen_ty_1 {
        #[inline]
        pub fn pkt_type(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
        }
        #[inline]
        pub fn set_pkt_type(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 3u8, val as u64)
            }
        }
        #[inline]
        pub fn ignore_df(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_ignore_df(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(3usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn dst_pending_confirm(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_dst_pending_confirm(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(4usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn ip_summed(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u8) }
        }
        #[inline]
        pub fn set_ip_summed(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(5usize, 2u8, val as u64)
            }
        }
        #[inline]
        pub fn ooo_okay(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_ooo_okay(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(7usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            pkt_type: __u8,
            ignore_df: __u8,
            dst_pending_confirm: __u8,
            ip_summed: __u8,
            ooo_okay: __u8,
        ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 3u8, {
                let pkt_type: u8 = unsafe { ::core::mem::transmute(pkt_type) };
                pkt_type as u64
            });
            __bindgen_bitfield_unit.set(3usize, 1u8, {
                let ignore_df: u8 = unsafe { ::core::mem::transmute(ignore_df) };
                ignore_df as u64
            });
            __bindgen_bitfield_unit.set(4usize, 1u8, {
                let dst_pending_confirm: u8 =
                    unsafe { ::core::mem::transmute(dst_pending_confirm) };
                dst_pending_confirm as u64
            });
            __bindgen_bitfield_unit.set(5usize, 2u8, {
                let ip_summed: u8 = unsafe { ::core::mem::transmute(ip_summed) };
                ip_summed as u64
            });
            __bindgen_bitfield_unit.set(7usize, 1u8, {
                let ooo_okay: u8 = unsafe { ::core::mem::transmute(ooo_okay) };
                ooo_okay as u64
            });
            __bindgen_bitfield_unit
        }
        #[inline]
        pub fn mono_delivery_time(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_mono_delivery_time(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(0usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn tc_at_ingress(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_tc_at_ingress(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(1usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn tc_skip_classify(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(2usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_tc_skip_classify(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(2usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn remcsum_offload(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(3usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_remcsum_offload(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(3usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn csum_complete_sw(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(4usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_csum_complete_sw(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(4usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn csum_level(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(5usize, 2u8) as u8) }
        }
        #[inline]
        pub fn set_csum_level(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(5usize, 2u8, val as u64)
            }
        }
        #[inline]
        pub fn inner_protocol_type(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(7usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_inner_protocol_type(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(7usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn l4_hash(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(8usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_l4_hash(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(8usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn sw_hash(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(9usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_sw_hash(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(9usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn wifi_acked_valid(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(10usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_wifi_acked_valid(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(10usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn wifi_acked(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(11usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_wifi_acked(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(11usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn no_fcs(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(12usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_no_fcs(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(12usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn encapsulation(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(13usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_encapsulation(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(13usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn encap_hdr_csum(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(14usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_encap_hdr_csum(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(14usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn csum_valid(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(15usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_csum_valid(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(15usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn ndisc_nodetype(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(16usize, 2u8) as u8) }
        }
        #[inline]
        pub fn set_ndisc_nodetype(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(16usize, 2u8, val as u64)
            }
        }
        #[inline]
        pub fn ipvs_property(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(18usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_ipvs_property(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(18usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn nf_trace(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(19usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_nf_trace(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(19usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn offload_fwd_mark(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(20usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_offload_fwd_mark(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(20usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn offload_l3_fwd_mark(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(21usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_offload_l3_fwd_mark(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(21usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn redirected(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(22usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_redirected(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(22usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn from_ingress(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(23usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_from_ingress(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(23usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn nf_skip_egress(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(24usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_nf_skip_egress(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(24usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn decrypted(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(25usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_decrypted(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(25usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn slow_gro(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(26usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_slow_gro(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(26usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn csum_not_inet(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(27usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_csum_not_inet(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(27usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_2(
            mono_delivery_time: __u8,
            tc_at_ingress: __u8,
            tc_skip_classify: __u8,
            remcsum_offload: __u8,
            csum_complete_sw: __u8,
            csum_level: __u8,
            inner_protocol_type: __u8,
            l4_hash: __u8,
            sw_hash: __u8,
            wifi_acked_valid: __u8,
            wifi_acked: __u8,
            no_fcs: __u8,
            encapsulation: __u8,
            encap_hdr_csum: __u8,
            csum_valid: __u8,
            ndisc_nodetype: __u8,
            ipvs_property: __u8,
            nf_trace: __u8,
            offload_fwd_mark: __u8,
            offload_l3_fwd_mark: __u8,
            redirected: __u8,
            from_ingress: __u8,
            nf_skip_egress: __u8,
            decrypted: __u8,
            slow_gro: __u8,
            csum_not_inet: __u8,
        ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 1u8, {
                let mono_delivery_time: u8 = unsafe { ::core::mem::transmute(mono_delivery_time) };
                mono_delivery_time as u64
            });
            __bindgen_bitfield_unit.set(1usize, 1u8, {
                let tc_at_ingress: u8 = unsafe { ::core::mem::transmute(tc_at_ingress) };
                tc_at_ingress as u64
            });
            __bindgen_bitfield_unit.set(2usize, 1u8, {
                let tc_skip_classify: u8 = unsafe { ::core::mem::transmute(tc_skip_classify) };
                tc_skip_classify as u64
            });
            __bindgen_bitfield_unit.set(3usize, 1u8, {
                let remcsum_offload: u8 = unsafe { ::core::mem::transmute(remcsum_offload) };
                remcsum_offload as u64
            });
            __bindgen_bitfield_unit.set(4usize, 1u8, {
                let csum_complete_sw: u8 = unsafe { ::core::mem::transmute(csum_complete_sw) };
                csum_complete_sw as u64
            });
            __bindgen_bitfield_unit.set(5usize, 2u8, {
                let csum_level: u8 = unsafe { ::core::mem::transmute(csum_level) };
                csum_level as u64
            });
            __bindgen_bitfield_unit.set(7usize, 1u8, {
                let inner_protocol_type: u8 =
                    unsafe { ::core::mem::transmute(inner_protocol_type) };
                inner_protocol_type as u64
            });
            __bindgen_bitfield_unit.set(8usize, 1u8, {
                let l4_hash: u8 = unsafe { ::core::mem::transmute(l4_hash) };
                l4_hash as u64
            });
            __bindgen_bitfield_unit.set(9usize, 1u8, {
                let sw_hash: u8 = unsafe { ::core::mem::transmute(sw_hash) };
                sw_hash as u64
            });
            __bindgen_bitfield_unit.set(10usize, 1u8, {
                let wifi_acked_valid: u8 = unsafe { ::core::mem::transmute(wifi_acked_valid) };
                wifi_acked_valid as u64
            });
            __bindgen_bitfield_unit.set(11usize, 1u8, {
                let wifi_acked: u8 = unsafe { ::core::mem::transmute(wifi_acked) };
                wifi_acked as u64
            });
            __bindgen_bitfield_unit.set(12usize, 1u8, {
                let no_fcs: u8 = unsafe { ::core::mem::transmute(no_fcs) };
                no_fcs as u64
            });
            __bindgen_bitfield_unit.set(13usize, 1u8, {
                let encapsulation: u8 = unsafe { ::core::mem::transmute(encapsulation) };
                encapsulation as u64
            });
            __bindgen_bitfield_unit.set(14usize, 1u8, {
                let encap_hdr_csum: u8 = unsafe { ::core::mem::transmute(encap_hdr_csum) };
                encap_hdr_csum as u64
            });
            __bindgen_bitfield_unit.set(15usize, 1u8, {
                let csum_valid: u8 = unsafe { ::core::mem::transmute(csum_valid) };
                csum_valid as u64
            });
            __bindgen_bitfield_unit.set(16usize, 2u8, {
                let ndisc_nodetype: u8 = unsafe { ::core::mem::transmute(ndisc_nodetype) };
                ndisc_nodetype as u64
            });
            __bindgen_bitfield_unit.set(18usize, 1u8, {
                let ipvs_property: u8 = unsafe { ::core::mem::transmute(ipvs_property) };
                ipvs_property as u64
            });
            __bindgen_bitfield_unit.set(19usize, 1u8, {
                let nf_trace: u8 = unsafe { ::core::mem::transmute(nf_trace) };
                nf_trace as u64
            });
            __bindgen_bitfield_unit.set(20usize, 1u8, {
                let offload_fwd_mark: u8 = unsafe { ::core::mem::transmute(offload_fwd_mark) };
                offload_fwd_mark as u64
            });
            __bindgen_bitfield_unit.set(21usize, 1u8, {
                let offload_l3_fwd_mark: u8 =
                    unsafe { ::core::mem::transmute(offload_l3_fwd_mark) };
                offload_l3_fwd_mark as u64
            });
            __bindgen_bitfield_unit.set(22usize, 1u8, {
                let redirected: u8 = unsafe { ::core::mem::transmute(redirected) };
                redirected as u64
            });
            __bindgen_bitfield_unit.set(23usize, 1u8, {
                let from_ingress: u8 = unsafe { ::core::mem::transmute(from_ingress) };
                from_ingress as u64
            });
            __bindgen_bitfield_unit.set(24usize, 1u8, {
                let nf_skip_egress: u8 = unsafe { ::core::mem::transmute(nf_skip_egress) };
                nf_skip_egress as u64
            });
            __bindgen_bitfield_unit.set(25usize, 1u8, {
                let decrypted: u8 = unsafe { ::core::mem::transmute(decrypted) };
                decrypted as u64
            });
            __bindgen_bitfield_unit.set(26usize, 1u8, {
                let slow_gro: u8 = unsafe { ::core::mem::transmute(slow_gro) };
                slow_gro as u64
            });
            __bindgen_bitfield_unit.set(27usize, 1u8, {
                let csum_not_inet: u8 = unsafe { ::core::mem::transmute(csum_not_inet) };
                csum_not_inet as u64
            });
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    pub struct sk_buff__bindgen_ty_5__bindgen_ty_2 {
        pub __pkt_type_offset: __IncompleteArrayField<__u8>,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
        pub __mono_tc_offset: __IncompleteArrayField<__u8>,
        pub _bitfield_align_2: [u8; 0],
        pub _bitfield_2: __BindgenBitfieldUnit<[u8; 4usize]>,
        pub tc_index: __u16,
        pub alloc_cpu: _cargo_bpf_u16,
        pub __bindgen_anon_1: sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_1,
        pub priority: __u32,
        pub skb_iif: ::cty::c_int,
        pub hash: __u32,
        pub __bindgen_anon_2: sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_2,
        pub __bindgen_anon_3: sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_3,
        pub secmark: __u32,
        pub __bindgen_anon_4: sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_4,
        pub __bindgen_anon_5: sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_5,
        pub inner_transport_header: __u16,
        pub inner_network_header: __u16,
        pub inner_mac_header: __u16,
        pub protocol: __be16,
        pub transport_header: __u16,
        pub network_header: __u16,
        pub mac_header: __u16,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_1 {
        pub csum: __wsum,
        pub __bindgen_anon_1: sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
        pub csum_start: __u16,
        pub csum_offset: __u16,
    }
    #[test]
    fn bindgen_test_layout_sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>(
            ),
            4usize,
            concat!(
                "Size of: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>(
            ),
            2usize,
            concat!(
                "Alignment of ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<
                    sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
                >()))
                .csum_start as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(csum_start)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<
                    sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
                >()))
                .csum_offset as *const _ as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(csum_offset)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_1>(),
            4usize,
            concat!(
                "Size of: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_1>(),
            4usize,
            concat!(
                "Alignment of ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_1>())).csum
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_1),
                "::",
                stringify!(csum)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_2 {
        pub vlan_all: _cargo_bpf_u32,
        pub __bindgen_anon_1: sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1 {
        pub vlan_proto: __be16,
        pub vlan_tci: __u16,
    }
    #[test]
    fn bindgen_test_layout_sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1>(
            ),
            4usize,
            concat!(
                "Size of: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1>(
            ),
            2usize,
            concat!(
                "Alignment of ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<
                    sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1,
                >()))
                .vlan_proto as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1),
                "::",
                stringify!(vlan_proto)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<
                    sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1,
                >()))
                .vlan_tci as *const _ as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1),
                "::",
                stringify!(vlan_tci)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_2>(),
            4usize,
            concat!(
                "Size of: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_2)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_2>(),
            4usize,
            concat!(
                "Alignment of ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_2)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_2>()))
                    .vlan_all as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_2),
                "::",
                stringify!(vlan_all)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_3 {
        pub napi_id: ::cty::c_uint,
        pub sender_cpu: ::cty::c_uint,
    }
    #[test]
    fn bindgen_test_layout_sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_3() {
        assert_eq!(
            ::core::mem::size_of::<sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_3>(),
            4usize,
            concat!(
                "Size of: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_3)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_3>(),
            4usize,
            concat!(
                "Alignment of ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_3)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_3>()))
                    .napi_id as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_3),
                "::",
                stringify!(napi_id)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_3>()))
                    .sender_cpu as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_3),
                "::",
                stringify!(sender_cpu)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_4 {
        pub mark: __u32,
        pub reserved_tailroom: __u32,
    }
    #[test]
    fn bindgen_test_layout_sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_4() {
        assert_eq!(
            ::core::mem::size_of::<sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_4>(),
            4usize,
            concat!(
                "Size of: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_4)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_4>(),
            4usize,
            concat!(
                "Alignment of ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_4)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_4>())).mark
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_4),
                "::",
                stringify!(mark)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_4>()))
                    .reserved_tailroom as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_4),
                "::",
                stringify!(reserved_tailroom)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_5 {
        pub inner_protocol: __be16,
        pub inner_ipproto: __u8,
    }
    #[test]
    fn bindgen_test_layout_sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_5() {
        assert_eq!(
            ::core::mem::size_of::<sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_5>(),
            2usize,
            concat!(
                "Size of: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_5)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_5>(),
            2usize,
            concat!(
                "Alignment of ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_5)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_5>()))
                    .inner_protocol as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_5),
                "::",
                stringify!(inner_protocol)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_5>()))
                    .inner_ipproto as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_5),
                "::",
                stringify!(inner_ipproto)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_sk_buff__bindgen_ty_5__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<sk_buff__bindgen_ty_5__bindgen_ty_2>(),
            60usize,
            concat!("Size of: ", stringify!(sk_buff__bindgen_ty_5__bindgen_ty_2))
        );
        assert_eq!(
            ::core::mem::align_of::<sk_buff__bindgen_ty_5__bindgen_ty_2>(),
            4usize,
            concat!(
                "Alignment of ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_2)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_5__bindgen_ty_2>())).__pkt_type_offset
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_2),
                "::",
                stringify!(__pkt_type_offset)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_5__bindgen_ty_2>())).__mono_tc_offset
                    as *const _ as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_2),
                "::",
                stringify!(__mono_tc_offset)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_5__bindgen_ty_2>())).tc_index
                    as *const _ as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_2),
                "::",
                stringify!(tc_index)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_5__bindgen_ty_2>())).alloc_cpu
                    as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_2),
                "::",
                stringify!(alloc_cpu)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_5__bindgen_ty_2>())).priority
                    as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_2),
                "::",
                stringify!(priority)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_5__bindgen_ty_2>())).skb_iif as *const _
                    as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_2),
                "::",
                stringify!(skb_iif)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_5__bindgen_ty_2>())).hash as *const _
                    as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_2),
                "::",
                stringify!(hash)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_5__bindgen_ty_2>())).secmark as *const _
                    as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_2),
                "::",
                stringify!(secmark)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_5__bindgen_ty_2>()))
                    .inner_transport_header as *const _ as usize
            },
            46usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_2),
                "::",
                stringify!(inner_transport_header)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_5__bindgen_ty_2>()))
                    .inner_network_header as *const _ as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_2),
                "::",
                stringify!(inner_network_header)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_5__bindgen_ty_2>())).inner_mac_header
                    as *const _ as usize
            },
            50usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_2),
                "::",
                stringify!(inner_mac_header)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_5__bindgen_ty_2>())).protocol
                    as *const _ as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_2),
                "::",
                stringify!(protocol)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_5__bindgen_ty_2>())).transport_header
                    as *const _ as usize
            },
            54usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_2),
                "::",
                stringify!(transport_header)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_5__bindgen_ty_2>())).network_header
                    as *const _ as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_2),
                "::",
                stringify!(network_header)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_5__bindgen_ty_2>())).mac_header
                    as *const _ as usize
            },
            58usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5__bindgen_ty_2),
                "::",
                stringify!(mac_header)
            )
        );
    }
    impl sk_buff__bindgen_ty_5__bindgen_ty_2 {
        #[inline]
        pub fn pkt_type(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
        }
        #[inline]
        pub fn set_pkt_type(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 3u8, val as u64)
            }
        }
        #[inline]
        pub fn ignore_df(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_ignore_df(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(3usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn dst_pending_confirm(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_dst_pending_confirm(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(4usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn ip_summed(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u8) }
        }
        #[inline]
        pub fn set_ip_summed(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(5usize, 2u8, val as u64)
            }
        }
        #[inline]
        pub fn ooo_okay(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_ooo_okay(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(7usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            pkt_type: __u8,
            ignore_df: __u8,
            dst_pending_confirm: __u8,
            ip_summed: __u8,
            ooo_okay: __u8,
        ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 3u8, {
                let pkt_type: u8 = unsafe { ::core::mem::transmute(pkt_type) };
                pkt_type as u64
            });
            __bindgen_bitfield_unit.set(3usize, 1u8, {
                let ignore_df: u8 = unsafe { ::core::mem::transmute(ignore_df) };
                ignore_df as u64
            });
            __bindgen_bitfield_unit.set(4usize, 1u8, {
                let dst_pending_confirm: u8 =
                    unsafe { ::core::mem::transmute(dst_pending_confirm) };
                dst_pending_confirm as u64
            });
            __bindgen_bitfield_unit.set(5usize, 2u8, {
                let ip_summed: u8 = unsafe { ::core::mem::transmute(ip_summed) };
                ip_summed as u64
            });
            __bindgen_bitfield_unit.set(7usize, 1u8, {
                let ooo_okay: u8 = unsafe { ::core::mem::transmute(ooo_okay) };
                ooo_okay as u64
            });
            __bindgen_bitfield_unit
        }
        #[inline]
        pub fn mono_delivery_time(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_mono_delivery_time(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(0usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn tc_at_ingress(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_tc_at_ingress(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(1usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn tc_skip_classify(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(2usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_tc_skip_classify(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(2usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn remcsum_offload(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(3usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_remcsum_offload(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(3usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn csum_complete_sw(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(4usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_csum_complete_sw(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(4usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn csum_level(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(5usize, 2u8) as u8) }
        }
        #[inline]
        pub fn set_csum_level(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(5usize, 2u8, val as u64)
            }
        }
        #[inline]
        pub fn inner_protocol_type(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(7usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_inner_protocol_type(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(7usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn l4_hash(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(8usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_l4_hash(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(8usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn sw_hash(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(9usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_sw_hash(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(9usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn wifi_acked_valid(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(10usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_wifi_acked_valid(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(10usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn wifi_acked(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(11usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_wifi_acked(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(11usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn no_fcs(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(12usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_no_fcs(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(12usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn encapsulation(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(13usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_encapsulation(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(13usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn encap_hdr_csum(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(14usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_encap_hdr_csum(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(14usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn csum_valid(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(15usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_csum_valid(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(15usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn ndisc_nodetype(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(16usize, 2u8) as u8) }
        }
        #[inline]
        pub fn set_ndisc_nodetype(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(16usize, 2u8, val as u64)
            }
        }
        #[inline]
        pub fn ipvs_property(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(18usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_ipvs_property(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(18usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn nf_trace(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(19usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_nf_trace(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(19usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn offload_fwd_mark(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(20usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_offload_fwd_mark(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(20usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn offload_l3_fwd_mark(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(21usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_offload_l3_fwd_mark(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(21usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn redirected(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(22usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_redirected(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(22usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn from_ingress(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(23usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_from_ingress(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(23usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn nf_skip_egress(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(24usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_nf_skip_egress(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(24usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn decrypted(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(25usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_decrypted(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(25usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn slow_gro(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(26usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_slow_gro(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(26usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn csum_not_inet(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(27usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_csum_not_inet(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(27usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_2(
            mono_delivery_time: __u8,
            tc_at_ingress: __u8,
            tc_skip_classify: __u8,
            remcsum_offload: __u8,
            csum_complete_sw: __u8,
            csum_level: __u8,
            inner_protocol_type: __u8,
            l4_hash: __u8,
            sw_hash: __u8,
            wifi_acked_valid: __u8,
            wifi_acked: __u8,
            no_fcs: __u8,
            encapsulation: __u8,
            encap_hdr_csum: __u8,
            csum_valid: __u8,
            ndisc_nodetype: __u8,
            ipvs_property: __u8,
            nf_trace: __u8,
            offload_fwd_mark: __u8,
            offload_l3_fwd_mark: __u8,
            redirected: __u8,
            from_ingress: __u8,
            nf_skip_egress: __u8,
            decrypted: __u8,
            slow_gro: __u8,
            csum_not_inet: __u8,
        ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 1u8, {
                let mono_delivery_time: u8 = unsafe { ::core::mem::transmute(mono_delivery_time) };
                mono_delivery_time as u64
            });
            __bindgen_bitfield_unit.set(1usize, 1u8, {
                let tc_at_ingress: u8 = unsafe { ::core::mem::transmute(tc_at_ingress) };
                tc_at_ingress as u64
            });
            __bindgen_bitfield_unit.set(2usize, 1u8, {
                let tc_skip_classify: u8 = unsafe { ::core::mem::transmute(tc_skip_classify) };
                tc_skip_classify as u64
            });
            __bindgen_bitfield_unit.set(3usize, 1u8, {
                let remcsum_offload: u8 = unsafe { ::core::mem::transmute(remcsum_offload) };
                remcsum_offload as u64
            });
            __bindgen_bitfield_unit.set(4usize, 1u8, {
                let csum_complete_sw: u8 = unsafe { ::core::mem::transmute(csum_complete_sw) };
                csum_complete_sw as u64
            });
            __bindgen_bitfield_unit.set(5usize, 2u8, {
                let csum_level: u8 = unsafe { ::core::mem::transmute(csum_level) };
                csum_level as u64
            });
            __bindgen_bitfield_unit.set(7usize, 1u8, {
                let inner_protocol_type: u8 =
                    unsafe { ::core::mem::transmute(inner_protocol_type) };
                inner_protocol_type as u64
            });
            __bindgen_bitfield_unit.set(8usize, 1u8, {
                let l4_hash: u8 = unsafe { ::core::mem::transmute(l4_hash) };
                l4_hash as u64
            });
            __bindgen_bitfield_unit.set(9usize, 1u8, {
                let sw_hash: u8 = unsafe { ::core::mem::transmute(sw_hash) };
                sw_hash as u64
            });
            __bindgen_bitfield_unit.set(10usize, 1u8, {
                let wifi_acked_valid: u8 = unsafe { ::core::mem::transmute(wifi_acked_valid) };
                wifi_acked_valid as u64
            });
            __bindgen_bitfield_unit.set(11usize, 1u8, {
                let wifi_acked: u8 = unsafe { ::core::mem::transmute(wifi_acked) };
                wifi_acked as u64
            });
            __bindgen_bitfield_unit.set(12usize, 1u8, {
                let no_fcs: u8 = unsafe { ::core::mem::transmute(no_fcs) };
                no_fcs as u64
            });
            __bindgen_bitfield_unit.set(13usize, 1u8, {
                let encapsulation: u8 = unsafe { ::core::mem::transmute(encapsulation) };
                encapsulation as u64
            });
            __bindgen_bitfield_unit.set(14usize, 1u8, {
                let encap_hdr_csum: u8 = unsafe { ::core::mem::transmute(encap_hdr_csum) };
                encap_hdr_csum as u64
            });
            __bindgen_bitfield_unit.set(15usize, 1u8, {
                let csum_valid: u8 = unsafe { ::core::mem::transmute(csum_valid) };
                csum_valid as u64
            });
            __bindgen_bitfield_unit.set(16usize, 2u8, {
                let ndisc_nodetype: u8 = unsafe { ::core::mem::transmute(ndisc_nodetype) };
                ndisc_nodetype as u64
            });
            __bindgen_bitfield_unit.set(18usize, 1u8, {
                let ipvs_property: u8 = unsafe { ::core::mem::transmute(ipvs_property) };
                ipvs_property as u64
            });
            __bindgen_bitfield_unit.set(19usize, 1u8, {
                let nf_trace: u8 = unsafe { ::core::mem::transmute(nf_trace) };
                nf_trace as u64
            });
            __bindgen_bitfield_unit.set(20usize, 1u8, {
                let offload_fwd_mark: u8 = unsafe { ::core::mem::transmute(offload_fwd_mark) };
                offload_fwd_mark as u64
            });
            __bindgen_bitfield_unit.set(21usize, 1u8, {
                let offload_l3_fwd_mark: u8 =
                    unsafe { ::core::mem::transmute(offload_l3_fwd_mark) };
                offload_l3_fwd_mark as u64
            });
            __bindgen_bitfield_unit.set(22usize, 1u8, {
                let redirected: u8 = unsafe { ::core::mem::transmute(redirected) };
                redirected as u64
            });
            __bindgen_bitfield_unit.set(23usize, 1u8, {
                let from_ingress: u8 = unsafe { ::core::mem::transmute(from_ingress) };
                from_ingress as u64
            });
            __bindgen_bitfield_unit.set(24usize, 1u8, {
                let nf_skip_egress: u8 = unsafe { ::core::mem::transmute(nf_skip_egress) };
                nf_skip_egress as u64
            });
            __bindgen_bitfield_unit.set(25usize, 1u8, {
                let decrypted: u8 = unsafe { ::core::mem::transmute(decrypted) };
                decrypted as u64
            });
            __bindgen_bitfield_unit.set(26usize, 1u8, {
                let slow_gro: u8 = unsafe { ::core::mem::transmute(slow_gro) };
                slow_gro as u64
            });
            __bindgen_bitfield_unit.set(27usize, 1u8, {
                let csum_not_inet: u8 = unsafe { ::core::mem::transmute(csum_not_inet) };
                csum_not_inet as u64
            });
            __bindgen_bitfield_unit
        }
    }
    #[test]
    fn bindgen_test_layout_sk_buff__bindgen_ty_5() {
        assert_eq!(
            ::core::mem::size_of::<sk_buff__bindgen_ty_5>(),
            60usize,
            concat!("Size of: ", stringify!(sk_buff__bindgen_ty_5))
        );
        assert_eq!(
            ::core::mem::align_of::<sk_buff__bindgen_ty_5>(),
            4usize,
            concat!("Alignment of ", stringify!(sk_buff__bindgen_ty_5))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sk_buff__bindgen_ty_5>())).headers as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff__bindgen_ty_5),
                "::",
                stringify!(headers)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_sk_buff() {
        assert_eq!(
            ::core::mem::size_of::<sk_buff>(),
            232usize,
            concat!("Size of: ", stringify!(sk_buff))
        );
        assert_eq!(
            ::core::mem::align_of::<sk_buff>(),
            8usize,
            concat!("Alignment of ", stringify!(sk_buff))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sk_buff>())).cb as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff),
                "::",
                stringify!(cb)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sk_buff>()))._nfct as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff),
                "::",
                stringify!(_nfct)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sk_buff>())).len as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff),
                "::",
                stringify!(len)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sk_buff>())).data_len as *const _ as usize },
            116usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff),
                "::",
                stringify!(data_len)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sk_buff>())).mac_len as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff),
                "::",
                stringify!(mac_len)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sk_buff>())).hdr_len as *const _ as usize },
            122usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff),
                "::",
                stringify!(hdr_len)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sk_buff>())).queue_mapping as *const _ as usize },
            124usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff),
                "::",
                stringify!(queue_mapping)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sk_buff>())).__cloned_offset as *const _ as usize },
            126usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff),
                "::",
                stringify!(__cloned_offset)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sk_buff>())).active_extensions as *const _ as usize },
            127usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff),
                "::",
                stringify!(active_extensions)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sk_buff>())).tail as *const _ as usize },
            188usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff),
                "::",
                stringify!(tail)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sk_buff>())).end as *const _ as usize },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff),
                "::",
                stringify!(end)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sk_buff>())).head as *const _ as usize },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff),
                "::",
                stringify!(head)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sk_buff>())).data as *const _ as usize },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff),
                "::",
                stringify!(data)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sk_buff>())).truesize as *const _ as usize },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff),
                "::",
                stringify!(truesize)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sk_buff>())).users as *const _ as usize },
            220usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff),
                "::",
                stringify!(users)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sk_buff>())).extensions as *const _ as usize },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff),
                "::",
                stringify!(extensions)
            )
        );
    }
    impl sk_buff {
        #[inline]
        pub fn cloned(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_cloned(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn nohdr(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_nohdr(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(1usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn fclone(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
        }
        #[inline]
        pub fn set_fclone(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(2usize, 2u8, val as u64)
            }
        }
        #[inline]
        pub fn peeked(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_peeked(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(4usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn head_frag(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_head_frag(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(5usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn pfmemalloc(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_pfmemalloc(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(6usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn pp_recycle(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_pp_recycle(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(7usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            cloned: __u8,
            nohdr: __u8,
            fclone: __u8,
            peeked: __u8,
            head_frag: __u8,
            pfmemalloc: __u8,
            pp_recycle: __u8,
        ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 1u8, {
                let cloned: u8 = unsafe { ::core::mem::transmute(cloned) };
                cloned as u64
            });
            __bindgen_bitfield_unit.set(1usize, 1u8, {
                let nohdr: u8 = unsafe { ::core::mem::transmute(nohdr) };
                nohdr as u64
            });
            __bindgen_bitfield_unit.set(2usize, 2u8, {
                let fclone: u8 = unsafe { ::core::mem::transmute(fclone) };
                fclone as u64
            });
            __bindgen_bitfield_unit.set(4usize, 1u8, {
                let peeked: u8 = unsafe { ::core::mem::transmute(peeked) };
                peeked as u64
            });
            __bindgen_bitfield_unit.set(5usize, 1u8, {
                let head_frag: u8 = unsafe { ::core::mem::transmute(head_frag) };
                head_frag as u64
            });
            __bindgen_bitfield_unit.set(6usize, 1u8, {
                let pfmemalloc: u8 = unsafe { ::core::mem::transmute(pfmemalloc) };
                pfmemalloc as u64
            });
            __bindgen_bitfield_unit.set(7usize, 1u8, {
                let pp_recycle: u8 = unsafe { ::core::mem::transmute(pp_recycle) };
                pp_recycle as u64
            });
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    pub struct sk_buff_fclones {
        pub skb1: sk_buff,
        pub skb2: sk_buff,
        pub fclone_ref: refcount_t,
    }
    #[test]
    fn bindgen_test_layout_sk_buff_fclones() {
        assert_eq!(
            ::core::mem::size_of::<sk_buff_fclones>(),
            472usize,
            concat!("Size of: ", stringify!(sk_buff_fclones))
        );
        assert_eq!(
            ::core::mem::align_of::<sk_buff_fclones>(),
            8usize,
            concat!("Alignment of ", stringify!(sk_buff_fclones))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sk_buff_fclones>())).skb1 as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff_fclones),
                "::",
                stringify!(skb1)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sk_buff_fclones>())).skb2 as *const _ as usize },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff_fclones),
                "::",
                stringify!(skb2)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sk_buff_fclones>())).fclone_ref as *const _ as usize },
            464usize,
            concat!(
                "Offset of field: ",
                stringify!(sk_buff_fclones),
                "::",
                stringify!(fclone_ref)
            )
        );
    }
    #[doc = "\tstruct skb_ext - sk_buff extensions"]
    #[doc = "\t@refcnt: 1 on allocation, deallocated on 0"]
    #[doc = "\t@offset: offset to add to @data to obtain extension address"]
    #[doc = "\t@chunks: size currently allocated, stored in SKB_EXT_ALIGN_SHIFT units"]
    #[doc = "\t@data: start of extension data, variable sized"]
    #[doc = ""]
    #[doc = "\tNote: offsets/lengths are stored in chunks of 8 bytes, this allows"]
    #[doc = "\tto use 'u8' types while allowing up to 2kb worth of extension data."]
    #[repr(C)]
    #[repr(align(8))]
    #[derive(Debug)]
    pub struct skb_ext {
        pub refcnt: refcount_t,
        pub offset: [_cargo_bpf_u8; 4usize],
        pub chunks: _cargo_bpf_u8,
        pub __bindgen_padding_0: [u8; 7usize],
        pub data: __IncompleteArrayField<::cty::c_char>,
    }
    #[test]
    fn bindgen_test_layout_skb_ext() {
        assert_eq!(
            ::core::mem::size_of::<skb_ext>(),
            16usize,
            concat!("Size of: ", stringify!(skb_ext))
        );
        assert_eq!(
            ::core::mem::align_of::<skb_ext>(),
            8usize,
            concat!("Alignment of ", stringify!(skb_ext))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<skb_ext>())).refcnt as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(skb_ext),
                "::",
                stringify!(refcnt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<skb_ext>())).offset as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(skb_ext),
                "::",
                stringify!(offset)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<skb_ext>())).chunks as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(skb_ext),
                "::",
                stringify!(chunks)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<skb_ext>())).data as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(skb_ext),
                "::",
                stringify!(data)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct net_generic {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct uevent_sock {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct netns_ipvs {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[repr(align(64))]
    #[derive(Copy, Clone)]
    pub struct net {
        pub passive: refcount_t,
        pub rules_mod_lock: spinlock_t,
        pub dev_unreg_count: atomic_t,
        pub dev_base_seq: ::cty::c_uint,
        pub ifindex: ::cty::c_int,
        pub nsid_lock: spinlock_t,
        pub fnhe_genid: atomic_t,
        pub list: list_head,
        pub exit_list: list_head,
        pub cleanup_list: llist_node,
        pub key_domain: *mut key_tag,
        pub user_ns: *mut user_namespace,
        pub ucounts: *mut ucounts,
        pub netns_ids: idr,
        pub ns: ns_common,
        pub refcnt_tracker: ref_tracker_dir,
        pub notrefcnt_tracker: ref_tracker_dir,
        pub dev_base_head: list_head,
        pub proc_net: *mut proc_dir_entry,
        pub proc_net_stat: *mut proc_dir_entry,
        pub sysctls: ctl_table_set,
        pub rtnl: *mut sock,
        pub genl_sock: *mut sock,
        pub uevent_sock: *mut uevent_sock,
        pub dev_name_head: *mut hlist_head,
        pub dev_index_head: *mut hlist_head,
        pub netdev_chain: raw_notifier_head,
        pub hash_mix: _cargo_bpf_u32,
        pub loopback_dev: *mut net_device,
        pub rules_ops: list_head,
        pub core: netns_core,
        pub mib: netns_mib,
        pub packet: netns_packet,
        pub unx: netns_unix,
        pub nexthop: netns_nexthop,
        pub __bindgen_padding_0: [u64; 6usize],
        pub ipv4: netns_ipv4,
        pub ipv6: netns_ipv6,
        pub ieee802154_lowpan: netns_ieee802154_lowpan,
        pub sctp: netns_sctp,
        pub nf: netns_nf,
        pub ct: netns_ct,
        pub nft: netns_nftables,
        pub ft: netns_ft,
        pub wext_nlevents: sk_buff_head,
        pub gen: *mut net_generic,
        pub bpf: netns_bpf,
        pub __bindgen_padding_1: [u64; 5usize],
        pub xfrm: netns_xfrm,
        pub net_cookie: _cargo_bpf_u64,
        pub ipvs: *mut netns_ipvs,
        pub mpls: netns_mpls,
        pub can: netns_can,
        pub xdp: netns_xdp,
        pub mctp: netns_mctp,
        pub crypto_nlsk: *mut sock,
        pub diag_nlsk: *mut sock,
        pub smc: netns_smc,
    }
    #[test]
    fn bindgen_test_layout_net() {
        assert_eq!(
            ::core::mem::size_of::<net>(),
            4608usize,
            concat!("Size of: ", stringify!(net))
        );
        assert_eq!(
            ::core::mem::align_of::<net>(),
            64usize,
            concat!("Alignment of ", stringify!(net))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).passive as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net),
                "::",
                stringify!(passive)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).rules_mod_lock as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(net),
                "::",
                stringify!(rules_mod_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).dev_unreg_count as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(net),
                "::",
                stringify!(dev_unreg_count)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).dev_base_seq as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(net),
                "::",
                stringify!(dev_base_seq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).ifindex as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(net),
                "::",
                stringify!(ifindex)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).nsid_lock as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(net),
                "::",
                stringify!(nsid_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).fnhe_genid as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(net),
                "::",
                stringify!(fnhe_genid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).list as *const _ as usize },
            32usize,
            concat!("Offset of field: ", stringify!(net), "::", stringify!(list))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).exit_list as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(net),
                "::",
                stringify!(exit_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).cleanup_list as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(net),
                "::",
                stringify!(cleanup_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).key_domain as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(net),
                "::",
                stringify!(key_domain)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).user_ns as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(net),
                "::",
                stringify!(user_ns)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).ucounts as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(net),
                "::",
                stringify!(ucounts)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).netns_ids as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(net),
                "::",
                stringify!(netns_ids)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).ns as *const _ as usize },
            120usize,
            concat!("Offset of field: ", stringify!(net), "::", stringify!(ns))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).refcnt_tracker as *const _ as usize },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(net),
                "::",
                stringify!(refcnt_tracker)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).notrefcnt_tracker as *const _ as usize },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(net),
                "::",
                stringify!(notrefcnt_tracker)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).dev_base_head as *const _ as usize },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(net),
                "::",
                stringify!(dev_base_head)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).proc_net as *const _ as usize },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(net),
                "::",
                stringify!(proc_net)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).proc_net_stat as *const _ as usize },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(net),
                "::",
                stringify!(proc_net_stat)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).sysctls as *const _ as usize },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(net),
                "::",
                stringify!(sysctls)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).rtnl as *const _ as usize },
            272usize,
            concat!("Offset of field: ", stringify!(net), "::", stringify!(rtnl))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).genl_sock as *const _ as usize },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(net),
                "::",
                stringify!(genl_sock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).uevent_sock as *const _ as usize },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(net),
                "::",
                stringify!(uevent_sock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).dev_name_head as *const _ as usize },
            296usize,
            concat!(
                "Offset of field: ",
                stringify!(net),
                "::",
                stringify!(dev_name_head)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).dev_index_head as *const _ as usize },
            304usize,
            concat!(
                "Offset of field: ",
                stringify!(net),
                "::",
                stringify!(dev_index_head)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).netdev_chain as *const _ as usize },
            312usize,
            concat!(
                "Offset of field: ",
                stringify!(net),
                "::",
                stringify!(netdev_chain)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).hash_mix as *const _ as usize },
            320usize,
            concat!(
                "Offset of field: ",
                stringify!(net),
                "::",
                stringify!(hash_mix)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).loopback_dev as *const _ as usize },
            328usize,
            concat!(
                "Offset of field: ",
                stringify!(net),
                "::",
                stringify!(loopback_dev)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).rules_ops as *const _ as usize },
            336usize,
            concat!(
                "Offset of field: ",
                stringify!(net),
                "::",
                stringify!(rules_ops)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).core as *const _ as usize },
            352usize,
            concat!("Offset of field: ", stringify!(net), "::", stringify!(core))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).mib as *const _ as usize },
            384usize,
            concat!("Offset of field: ", stringify!(net), "::", stringify!(mib))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).packet as *const _ as usize },
            512usize,
            concat!(
                "Offset of field: ",
                stringify!(net),
                "::",
                stringify!(packet)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).unx as *const _ as usize },
            552usize,
            concat!("Offset of field: ", stringify!(net), "::", stringify!(unx))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).nexthop as *const _ as usize },
            584usize,
            concat!(
                "Offset of field: ",
                stringify!(net),
                "::",
                stringify!(nexthop)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).ipv4 as *const _ as usize },
            704usize,
            concat!("Offset of field: ", stringify!(net), "::", stringify!(ipv4))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).ipv6 as *const _ as usize },
            1472usize,
            concat!("Offset of field: ", stringify!(net), "::", stringify!(ipv6))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).ieee802154_lowpan as *const _ as usize },
            2304usize,
            concat!(
                "Offset of field: ",
                stringify!(net),
                "::",
                stringify!(ieee802154_lowpan)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).sctp as *const _ as usize },
            2320usize,
            concat!("Offset of field: ", stringify!(net), "::", stringify!(sctp))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).nf as *const _ as usize },
            2624usize,
            concat!("Offset of field: ", stringify!(net), "::", stringify!(nf))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).ct as *const _ as usize },
            2880usize,
            concat!("Offset of field: ", stringify!(net), "::", stringify!(ct))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).nft as *const _ as usize },
            3112usize,
            concat!("Offset of field: ", stringify!(net), "::", stringify!(nft))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).ft as *const _ as usize },
            3120usize,
            concat!("Offset of field: ", stringify!(net), "::", stringify!(ft))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).wext_nlevents as *const _ as usize },
            3128usize,
            concat!(
                "Offset of field: ",
                stringify!(net),
                "::",
                stringify!(wext_nlevents)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).gen as *const _ as usize },
            3152usize,
            concat!("Offset of field: ", stringify!(net), "::", stringify!(gen))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).bpf as *const _ as usize },
            3160usize,
            concat!("Offset of field: ", stringify!(net), "::", stringify!(bpf))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).xfrm as *const _ as usize },
            3264usize,
            concat!("Offset of field: ", stringify!(net), "::", stringify!(xfrm))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).net_cookie as *const _ as usize },
            4096usize,
            concat!(
                "Offset of field: ",
                stringify!(net),
                "::",
                stringify!(net_cookie)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).ipvs as *const _ as usize },
            4104usize,
            concat!("Offset of field: ", stringify!(net), "::", stringify!(ipvs))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).mpls as *const _ as usize },
            4112usize,
            concat!("Offset of field: ", stringify!(net), "::", stringify!(mpls))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).can as *const _ as usize },
            4144usize,
            concat!("Offset of field: ", stringify!(net), "::", stringify!(can))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).xdp as *const _ as usize },
            4304usize,
            concat!("Offset of field: ", stringify!(net), "::", stringify!(xdp))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).mctp as *const _ as usize },
            4344usize,
            concat!("Offset of field: ", stringify!(net), "::", stringify!(mctp))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).crypto_nlsk as *const _ as usize },
            4472usize,
            concat!(
                "Offset of field: ",
                stringify!(net),
                "::",
                stringify!(crypto_nlsk)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).diag_nlsk as *const _ as usize },
            4480usize,
            concat!(
                "Offset of field: ",
                stringify!(net),
                "::",
                stringify!(diag_nlsk)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net>())).smc as *const _ as usize },
            4488usize,
            concat!("Offset of field: ", stringify!(net), "::", stringify!(smc))
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct seq_file {
        pub buf: *mut ::cty::c_char,
        pub size: size_t,
        pub from: size_t,
        pub count: size_t,
        pub pad_until: size_t,
        pub index: loff_t,
        pub read_pos: loff_t,
        pub lock: mutex,
        pub op: *const seq_operations,
        pub poll_event: ::cty::c_int,
        pub file: *const file,
        pub private: *mut ::cty::c_void,
    }
    #[test]
    fn bindgen_test_layout_seq_file() {
        assert_eq!(
            ::core::mem::size_of::<seq_file>(),
            120usize,
            concat!("Size of: ", stringify!(seq_file))
        );
        assert_eq!(
            ::core::mem::align_of::<seq_file>(),
            8usize,
            concat!("Alignment of ", stringify!(seq_file))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<seq_file>())).buf as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(seq_file),
                "::",
                stringify!(buf)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<seq_file>())).size as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(seq_file),
                "::",
                stringify!(size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<seq_file>())).from as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(seq_file),
                "::",
                stringify!(from)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<seq_file>())).count as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(seq_file),
                "::",
                stringify!(count)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<seq_file>())).pad_until as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(seq_file),
                "::",
                stringify!(pad_until)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<seq_file>())).index as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(seq_file),
                "::",
                stringify!(index)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<seq_file>())).read_pos as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(seq_file),
                "::",
                stringify!(read_pos)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<seq_file>())).lock as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(seq_file),
                "::",
                stringify!(lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<seq_file>())).op as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(seq_file),
                "::",
                stringify!(op)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<seq_file>())).poll_event as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(seq_file),
                "::",
                stringify!(poll_event)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<seq_file>())).file as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(seq_file),
                "::",
                stringify!(file)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<seq_file>())).private as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(seq_file),
                "::",
                stringify!(private)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct possible_net_t {
        pub net: *mut net,
    }
    #[test]
    fn bindgen_test_layout_possible_net_t() {
        assert_eq!(
            ::core::mem::size_of::<possible_net_t>(),
            8usize,
            concat!("Size of: ", stringify!(possible_net_t))
        );
        assert_eq!(
            ::core::mem::align_of::<possible_net_t>(),
            8usize,
            concat!("Alignment of ", stringify!(possible_net_t))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<possible_net_t>())).net as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(possible_net_t),
                "::",
                stringify!(net)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ieee_ets {
        pub willing: __u8,
        pub ets_cap: __u8,
        pub cbs: __u8,
        pub tc_tx_bw: [__u8; 8usize],
        pub tc_rx_bw: [__u8; 8usize],
        pub tc_tsa: [__u8; 8usize],
        pub prio_tc: [__u8; 8usize],
        pub tc_reco_bw: [__u8; 8usize],
        pub tc_reco_tsa: [__u8; 8usize],
        pub reco_prio_tc: [__u8; 8usize],
    }
    #[test]
    fn bindgen_test_layout_ieee_ets() {
        assert_eq!(
            ::core::mem::size_of::<ieee_ets>(),
            59usize,
            concat!("Size of: ", stringify!(ieee_ets))
        );
        assert_eq!(
            ::core::mem::align_of::<ieee_ets>(),
            1usize,
            concat!("Alignment of ", stringify!(ieee_ets))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ieee_ets>())).willing as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ieee_ets),
                "::",
                stringify!(willing)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ieee_ets>())).ets_cap as *const _ as usize },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(ieee_ets),
                "::",
                stringify!(ets_cap)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ieee_ets>())).cbs as *const _ as usize },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(ieee_ets),
                "::",
                stringify!(cbs)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ieee_ets>())).tc_tx_bw as *const _ as usize },
            3usize,
            concat!(
                "Offset of field: ",
                stringify!(ieee_ets),
                "::",
                stringify!(tc_tx_bw)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ieee_ets>())).tc_rx_bw as *const _ as usize },
            11usize,
            concat!(
                "Offset of field: ",
                stringify!(ieee_ets),
                "::",
                stringify!(tc_rx_bw)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ieee_ets>())).tc_tsa as *const _ as usize },
            19usize,
            concat!(
                "Offset of field: ",
                stringify!(ieee_ets),
                "::",
                stringify!(tc_tsa)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ieee_ets>())).prio_tc as *const _ as usize },
            27usize,
            concat!(
                "Offset of field: ",
                stringify!(ieee_ets),
                "::",
                stringify!(prio_tc)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ieee_ets>())).tc_reco_bw as *const _ as usize },
            35usize,
            concat!(
                "Offset of field: ",
                stringify!(ieee_ets),
                "::",
                stringify!(tc_reco_bw)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ieee_ets>())).tc_reco_tsa as *const _ as usize },
            43usize,
            concat!(
                "Offset of field: ",
                stringify!(ieee_ets),
                "::",
                stringify!(tc_reco_tsa)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ieee_ets>())).reco_prio_tc as *const _ as usize },
            51usize,
            concat!(
                "Offset of field: ",
                stringify!(ieee_ets),
                "::",
                stringify!(reco_prio_tc)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ieee_maxrate {
        pub tc_maxrate: [__u64; 8usize],
    }
    #[test]
    fn bindgen_test_layout_ieee_maxrate() {
        assert_eq!(
            ::core::mem::size_of::<ieee_maxrate>(),
            64usize,
            concat!("Size of: ", stringify!(ieee_maxrate))
        );
        assert_eq!(
            ::core::mem::align_of::<ieee_maxrate>(),
            8usize,
            concat!("Alignment of ", stringify!(ieee_maxrate))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ieee_maxrate>())).tc_maxrate as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ieee_maxrate),
                "::",
                stringify!(tc_maxrate)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ieee_qcn {
        pub rpg_enable: [__u8; 8usize],
        pub rppp_max_rps: [__u32; 8usize],
        pub rpg_time_reset: [__u32; 8usize],
        pub rpg_byte_reset: [__u32; 8usize],
        pub rpg_threshold: [__u32; 8usize],
        pub rpg_max_rate: [__u32; 8usize],
        pub rpg_ai_rate: [__u32; 8usize],
        pub rpg_hai_rate: [__u32; 8usize],
        pub rpg_gd: [__u32; 8usize],
        pub rpg_min_dec_fac: [__u32; 8usize],
        pub rpg_min_rate: [__u32; 8usize],
        pub cndd_state_machine: [__u32; 8usize],
    }
    #[test]
    fn bindgen_test_layout_ieee_qcn() {
        assert_eq!(
            ::core::mem::size_of::<ieee_qcn>(),
            360usize,
            concat!("Size of: ", stringify!(ieee_qcn))
        );
        assert_eq!(
            ::core::mem::align_of::<ieee_qcn>(),
            4usize,
            concat!("Alignment of ", stringify!(ieee_qcn))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ieee_qcn>())).rpg_enable as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ieee_qcn),
                "::",
                stringify!(rpg_enable)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ieee_qcn>())).rppp_max_rps as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ieee_qcn),
                "::",
                stringify!(rppp_max_rps)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ieee_qcn>())).rpg_time_reset as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(ieee_qcn),
                "::",
                stringify!(rpg_time_reset)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ieee_qcn>())).rpg_byte_reset as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(ieee_qcn),
                "::",
                stringify!(rpg_byte_reset)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ieee_qcn>())).rpg_threshold as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(ieee_qcn),
                "::",
                stringify!(rpg_threshold)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ieee_qcn>())).rpg_max_rate as *const _ as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(ieee_qcn),
                "::",
                stringify!(rpg_max_rate)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ieee_qcn>())).rpg_ai_rate as *const _ as usize },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(ieee_qcn),
                "::",
                stringify!(rpg_ai_rate)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ieee_qcn>())).rpg_hai_rate as *const _ as usize },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(ieee_qcn),
                "::",
                stringify!(rpg_hai_rate)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ieee_qcn>())).rpg_gd as *const _ as usize },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(ieee_qcn),
                "::",
                stringify!(rpg_gd)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ieee_qcn>())).rpg_min_dec_fac as *const _ as usize },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(ieee_qcn),
                "::",
                stringify!(rpg_min_dec_fac)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ieee_qcn>())).rpg_min_rate as *const _ as usize },
            296usize,
            concat!(
                "Offset of field: ",
                stringify!(ieee_qcn),
                "::",
                stringify!(rpg_min_rate)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ieee_qcn>())).cndd_state_machine as *const _ as usize
            },
            328usize,
            concat!(
                "Offset of field: ",
                stringify!(ieee_qcn),
                "::",
                stringify!(cndd_state_machine)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ieee_qcn_stats {
        pub rppp_rp_centiseconds: [__u64; 8usize],
        pub rppp_created_rps: [__u32; 8usize],
    }
    #[test]
    fn bindgen_test_layout_ieee_qcn_stats() {
        assert_eq!(
            ::core::mem::size_of::<ieee_qcn_stats>(),
            96usize,
            concat!("Size of: ", stringify!(ieee_qcn_stats))
        );
        assert_eq!(
            ::core::mem::align_of::<ieee_qcn_stats>(),
            8usize,
            concat!("Alignment of ", stringify!(ieee_qcn_stats))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ieee_qcn_stats>())).rppp_rp_centiseconds as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ieee_qcn_stats),
                "::",
                stringify!(rppp_rp_centiseconds)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ieee_qcn_stats>())).rppp_created_rps as *const _ as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(ieee_qcn_stats),
                "::",
                stringify!(rppp_created_rps)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ieee_pfc {
        pub pfc_cap: __u8,
        pub pfc_en: __u8,
        pub mbc: __u8,
        pub delay: __u16,
        pub requests: [__u64; 8usize],
        pub indications: [__u64; 8usize],
    }
    #[test]
    fn bindgen_test_layout_ieee_pfc() {
        assert_eq!(
            ::core::mem::size_of::<ieee_pfc>(),
            136usize,
            concat!("Size of: ", stringify!(ieee_pfc))
        );
        assert_eq!(
            ::core::mem::align_of::<ieee_pfc>(),
            8usize,
            concat!("Alignment of ", stringify!(ieee_pfc))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ieee_pfc>())).pfc_cap as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ieee_pfc),
                "::",
                stringify!(pfc_cap)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ieee_pfc>())).pfc_en as *const _ as usize },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(ieee_pfc),
                "::",
                stringify!(pfc_en)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ieee_pfc>())).mbc as *const _ as usize },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(ieee_pfc),
                "::",
                stringify!(mbc)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ieee_pfc>())).delay as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(ieee_pfc),
                "::",
                stringify!(delay)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ieee_pfc>())).requests as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ieee_pfc),
                "::",
                stringify!(requests)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ieee_pfc>())).indications as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(ieee_pfc),
                "::",
                stringify!(indications)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dcbnl_buffer {
        pub prio2buffer: [__u8; 8usize],
        pub buffer_size: [__u32; 8usize],
        pub total_size: __u32,
    }
    #[test]
    fn bindgen_test_layout_dcbnl_buffer() {
        assert_eq!(
            ::core::mem::size_of::<dcbnl_buffer>(),
            44usize,
            concat!("Size of: ", stringify!(dcbnl_buffer))
        );
        assert_eq!(
            ::core::mem::align_of::<dcbnl_buffer>(),
            4usize,
            concat!("Alignment of ", stringify!(dcbnl_buffer))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dcbnl_buffer>())).prio2buffer as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_buffer),
                "::",
                stringify!(prio2buffer)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dcbnl_buffer>())).buffer_size as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_buffer),
                "::",
                stringify!(buffer_size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dcbnl_buffer>())).total_size as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_buffer),
                "::",
                stringify!(total_size)
            )
        );
    }
    #[doc = " struct cee_pg - CEE Priority-Group managed object"]
    #[doc = ""]
    #[doc = " @willing: willing bit in the PG tlv"]
    #[doc = " @error: error bit in the PG tlv"]
    #[doc = " @pg_en: enable bit of the PG feature"]
    #[doc = " @tcs_supported: number of traffic classes supported"]
    #[doc = " @pg_bw: bandwidth percentage for each priority group"]
    #[doc = " @prio_pg: priority to PG mapping indexed by priority"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cee_pg {
        pub willing: __u8,
        pub error: __u8,
        pub pg_en: __u8,
        pub tcs_supported: __u8,
        pub pg_bw: [__u8; 8usize],
        pub prio_pg: [__u8; 8usize],
    }
    #[test]
    fn bindgen_test_layout_cee_pg() {
        assert_eq!(
            ::core::mem::size_of::<cee_pg>(),
            20usize,
            concat!("Size of: ", stringify!(cee_pg))
        );
        assert_eq!(
            ::core::mem::align_of::<cee_pg>(),
            1usize,
            concat!("Alignment of ", stringify!(cee_pg))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cee_pg>())).willing as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cee_pg),
                "::",
                stringify!(willing)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cee_pg>())).error as *const _ as usize },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(cee_pg),
                "::",
                stringify!(error)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cee_pg>())).pg_en as *const _ as usize },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(cee_pg),
                "::",
                stringify!(pg_en)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cee_pg>())).tcs_supported as *const _ as usize },
            3usize,
            concat!(
                "Offset of field: ",
                stringify!(cee_pg),
                "::",
                stringify!(tcs_supported)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cee_pg>())).pg_bw as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(cee_pg),
                "::",
                stringify!(pg_bw)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cee_pg>())).prio_pg as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(cee_pg),
                "::",
                stringify!(prio_pg)
            )
        );
    }
    #[doc = " struct cee_pfc - CEE PFC managed object"]
    #[doc = ""]
    #[doc = " @willing: willing bit in the PFC tlv"]
    #[doc = " @error: error bit in the PFC tlv"]
    #[doc = " @pfc_en: bitmap indicating pfc enabled traffic classes"]
    #[doc = " @tcs_supported: number of traffic classes supported"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cee_pfc {
        pub willing: __u8,
        pub error: __u8,
        pub pfc_en: __u8,
        pub tcs_supported: __u8,
    }
    #[test]
    fn bindgen_test_layout_cee_pfc() {
        assert_eq!(
            ::core::mem::size_of::<cee_pfc>(),
            4usize,
            concat!("Size of: ", stringify!(cee_pfc))
        );
        assert_eq!(
            ::core::mem::align_of::<cee_pfc>(),
            1usize,
            concat!("Alignment of ", stringify!(cee_pfc))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cee_pfc>())).willing as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cee_pfc),
                "::",
                stringify!(willing)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cee_pfc>())).error as *const _ as usize },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(cee_pfc),
                "::",
                stringify!(error)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cee_pfc>())).pfc_en as *const _ as usize },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(cee_pfc),
                "::",
                stringify!(pfc_en)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cee_pfc>())).tcs_supported as *const _ as usize },
            3usize,
            concat!(
                "Offset of field: ",
                stringify!(cee_pfc),
                "::",
                stringify!(tcs_supported)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dcb_app {
        pub selector: __u8,
        pub priority: __u8,
        pub protocol: __u16,
    }
    #[test]
    fn bindgen_test_layout_dcb_app() {
        assert_eq!(
            ::core::mem::size_of::<dcb_app>(),
            4usize,
            concat!("Size of: ", stringify!(dcb_app))
        );
        assert_eq!(
            ::core::mem::align_of::<dcb_app>(),
            2usize,
            concat!("Alignment of ", stringify!(dcb_app))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dcb_app>())).selector as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(dcb_app),
                "::",
                stringify!(selector)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dcb_app>())).priority as *const _ as usize },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(dcb_app),
                "::",
                stringify!(priority)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dcb_app>())).protocol as *const _ as usize },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(dcb_app),
                "::",
                stringify!(protocol)
            )
        );
    }
    #[doc = " struct dcb_peer_app_info - APP feature information sent by the peer"]
    #[doc = ""]
    #[doc = " @willing: willing bit in the peer APP tlv"]
    #[doc = " @error: error bit in the peer APP tlv"]
    #[doc = ""]
    #[doc = " In addition to this information the full peer APP tlv also contains"]
    #[doc = " a table of 'app_count' APP objects defined above."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dcb_peer_app_info {
        pub willing: __u8,
        pub error: __u8,
    }
    #[test]
    fn bindgen_test_layout_dcb_peer_app_info() {
        assert_eq!(
            ::core::mem::size_of::<dcb_peer_app_info>(),
            2usize,
            concat!("Size of: ", stringify!(dcb_peer_app_info))
        );
        assert_eq!(
            ::core::mem::align_of::<dcb_peer_app_info>(),
            1usize,
            concat!("Alignment of ", stringify!(dcb_peer_app_info))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dcb_peer_app_info>())).willing as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(dcb_peer_app_info),
                "::",
                stringify!(willing)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dcb_peer_app_info>())).error as *const _ as usize },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(dcb_peer_app_info),
                "::",
                stringify!(error)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dcbnl_rtnl_ops {
        pub ieee_getets: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ieee_ets) -> ::cty::c_int,
        >,
        pub ieee_setets: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ieee_ets) -> ::cty::c_int,
        >,
        pub ieee_getmaxrate: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ieee_maxrate) -> ::cty::c_int,
        >,
        pub ieee_setmaxrate: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ieee_maxrate) -> ::cty::c_int,
        >,
        pub ieee_getqcn: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ieee_qcn) -> ::cty::c_int,
        >,
        pub ieee_setqcn: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ieee_qcn) -> ::cty::c_int,
        >,
        pub ieee_getqcnstats: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ieee_qcn_stats) -> ::cty::c_int,
        >,
        pub ieee_getpfc: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ieee_pfc) -> ::cty::c_int,
        >,
        pub ieee_setpfc: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ieee_pfc) -> ::cty::c_int,
        >,
        pub ieee_getapp: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut dcb_app) -> ::cty::c_int,
        >,
        pub ieee_setapp: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut dcb_app) -> ::cty::c_int,
        >,
        pub ieee_delapp: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut dcb_app) -> ::cty::c_int,
        >,
        pub ieee_peer_getets: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ieee_ets) -> ::cty::c_int,
        >,
        pub ieee_peer_getpfc: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut ieee_pfc) -> ::cty::c_int,
        >,
        pub getstate:
            ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> _cargo_bpf_u8>,
        pub setstate: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: _cargo_bpf_u8) -> _cargo_bpf_u8,
        >,
        pub getpermhwaddr: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut _cargo_bpf_u8),
        >,
        pub setpgtccfgtx: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: ::cty::c_int,
                arg3: _cargo_bpf_u8,
                arg4: _cargo_bpf_u8,
                arg5: _cargo_bpf_u8,
                arg6: _cargo_bpf_u8,
            ),
        >,
        pub setpgbwgcfgtx: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: ::cty::c_int, arg3: _cargo_bpf_u8),
        >,
        pub setpgtccfgrx: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: ::cty::c_int,
                arg3: _cargo_bpf_u8,
                arg4: _cargo_bpf_u8,
                arg5: _cargo_bpf_u8,
                arg6: _cargo_bpf_u8,
            ),
        >,
        pub setpgbwgcfgrx: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: ::cty::c_int, arg3: _cargo_bpf_u8),
        >,
        pub getpgtccfgtx: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: ::cty::c_int,
                arg3: *mut _cargo_bpf_u8,
                arg4: *mut _cargo_bpf_u8,
                arg5: *mut _cargo_bpf_u8,
                arg6: *mut _cargo_bpf_u8,
            ),
        >,
        pub getpgbwgcfgtx: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: ::cty::c_int,
                arg3: *mut _cargo_bpf_u8,
            ),
        >,
        pub getpgtccfgrx: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: ::cty::c_int,
                arg3: *mut _cargo_bpf_u8,
                arg4: *mut _cargo_bpf_u8,
                arg5: *mut _cargo_bpf_u8,
                arg6: *mut _cargo_bpf_u8,
            ),
        >,
        pub getpgbwgcfgrx: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: ::cty::c_int,
                arg3: *mut _cargo_bpf_u8,
            ),
        >,
        pub setpfccfg: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: ::cty::c_int, arg3: _cargo_bpf_u8),
        >,
        pub getpfccfg: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: ::cty::c_int,
                arg3: *mut _cargo_bpf_u8,
            ),
        >,
        pub setall:
            ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> _cargo_bpf_u8>,
        pub getcap: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: ::cty::c_int,
                arg3: *mut _cargo_bpf_u8,
            ) -> _cargo_bpf_u8,
        >,
        pub getnumtcs: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: ::cty::c_int,
                arg3: *mut _cargo_bpf_u8,
            ) -> ::cty::c_int,
        >,
        pub setnumtcs: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: ::cty::c_int,
                arg3: _cargo_bpf_u8,
            ) -> ::cty::c_int,
        >,
        pub getpfcstate:
            ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> _cargo_bpf_u8>,
        pub setpfcstate: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: _cargo_bpf_u8),
        >,
        pub getbcncfg: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: ::cty::c_int,
                arg3: *mut _cargo_bpf_u32,
            ),
        >,
        pub setbcncfg: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: ::cty::c_int, arg3: _cargo_bpf_u32),
        >,
        pub getbcnrp: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: ::cty::c_int,
                arg3: *mut _cargo_bpf_u8,
            ),
        >,
        pub setbcnrp: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: ::cty::c_int, arg3: _cargo_bpf_u8),
        >,
        pub setapp: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: _cargo_bpf_u8,
                arg3: _cargo_bpf_u16,
                arg4: _cargo_bpf_u8,
            ) -> ::cty::c_int,
        >,
        pub getapp: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: _cargo_bpf_u8,
                arg3: _cargo_bpf_u16,
            ) -> ::cty::c_int,
        >,
        pub getfeatcfg: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: ::cty::c_int,
                arg3: *mut _cargo_bpf_u8,
            ) -> _cargo_bpf_u8,
        >,
        pub setfeatcfg: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: ::cty::c_int,
                arg3: _cargo_bpf_u8,
            ) -> _cargo_bpf_u8,
        >,
        pub getdcbx:
            ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device) -> _cargo_bpf_u8>,
        pub setdcbx: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: _cargo_bpf_u8) -> _cargo_bpf_u8,
        >,
        pub peer_getappinfo: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut dcb_peer_app_info,
                arg3: *mut _cargo_bpf_u16,
            ) -> ::cty::c_int,
        >,
        pub peer_getapptable: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut dcb_app) -> ::cty::c_int,
        >,
        pub cee_peer_getpg: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut cee_pg) -> ::cty::c_int,
        >,
        pub cee_peer_getpfc: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut cee_pfc) -> ::cty::c_int,
        >,
        pub dcbnl_getbuffer: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut dcbnl_buffer) -> ::cty::c_int,
        >,
        pub dcbnl_setbuffer: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net_device, arg2: *mut dcbnl_buffer) -> ::cty::c_int,
        >,
        pub dcbnl_setapptrust: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut _cargo_bpf_u8,
                arg3: ::cty::c_int,
            ) -> ::cty::c_int,
        >,
        pub dcbnl_getapptrust: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *mut _cargo_bpf_u8,
                arg3: *mut ::cty::c_int,
            ) -> ::cty::c_int,
        >,
        pub dcbnl_setrewr: ::core::option::Option<
            unsafe extern "C" fn(dev: *mut net_device, app: *mut dcb_app) -> ::cty::c_int,
        >,
        pub dcbnl_delrewr: ::core::option::Option<
            unsafe extern "C" fn(dev: *mut net_device, app: *mut dcb_app) -> ::cty::c_int,
        >,
    }
    #[test]
    fn bindgen_test_layout_dcbnl_rtnl_ops() {
        assert_eq!(
            ::core::mem::size_of::<dcbnl_rtnl_ops>(),
            424usize,
            concat!("Size of: ", stringify!(dcbnl_rtnl_ops))
        );
        assert_eq!(
            ::core::mem::align_of::<dcbnl_rtnl_ops>(),
            8usize,
            concat!("Alignment of ", stringify!(dcbnl_rtnl_ops))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).ieee_getets as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(ieee_getets)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).ieee_setets as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(ieee_setets)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).ieee_getmaxrate as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(ieee_getmaxrate)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).ieee_setmaxrate as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(ieee_setmaxrate)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).ieee_getqcn as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(ieee_getqcn)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).ieee_setqcn as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(ieee_setqcn)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).ieee_getqcnstats as *const _ as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(ieee_getqcnstats)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).ieee_getpfc as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(ieee_getpfc)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).ieee_setpfc as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(ieee_setpfc)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).ieee_getapp as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(ieee_getapp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).ieee_setapp as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(ieee_setapp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).ieee_delapp as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(ieee_delapp)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).ieee_peer_getets as *const _ as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(ieee_peer_getets)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).ieee_peer_getpfc as *const _ as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(ieee_peer_getpfc)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).getstate as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(getstate)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).setstate as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(setstate)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).getpermhwaddr as *const _ as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(getpermhwaddr)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).setpgtccfgtx as *const _ as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(setpgtccfgtx)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).setpgbwgcfgtx as *const _ as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(setpgbwgcfgtx)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).setpgtccfgrx as *const _ as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(setpgtccfgrx)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).setpgbwgcfgrx as *const _ as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(setpgbwgcfgrx)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).getpgtccfgtx as *const _ as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(getpgtccfgtx)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).getpgbwgcfgtx as *const _ as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(getpgbwgcfgtx)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).getpgtccfgrx as *const _ as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(getpgtccfgrx)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).getpgbwgcfgrx as *const _ as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(getpgbwgcfgrx)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).setpfccfg as *const _ as usize },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(setpfccfg)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).getpfccfg as *const _ as usize },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(getpfccfg)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).setall as *const _ as usize },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(setall)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).getcap as *const _ as usize },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(getcap)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).getnumtcs as *const _ as usize },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(getnumtcs)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).setnumtcs as *const _ as usize },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(setnumtcs)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).getpfcstate as *const _ as usize },
            248usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(getpfcstate)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).setpfcstate as *const _ as usize },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(setpfcstate)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).getbcncfg as *const _ as usize },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(getbcncfg)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).setbcncfg as *const _ as usize },
            272usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(setbcncfg)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).getbcnrp as *const _ as usize },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(getbcnrp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).setbcnrp as *const _ as usize },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(setbcnrp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).setapp as *const _ as usize },
            296usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(setapp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).getapp as *const _ as usize },
            304usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(getapp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).getfeatcfg as *const _ as usize },
            312usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(getfeatcfg)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).setfeatcfg as *const _ as usize },
            320usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(setfeatcfg)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).getdcbx as *const _ as usize },
            328usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(getdcbx)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).setdcbx as *const _ as usize },
            336usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(setdcbx)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).peer_getappinfo as *const _ as usize
            },
            344usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(peer_getappinfo)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).peer_getapptable as *const _ as usize
            },
            352usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(peer_getapptable)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).cee_peer_getpg as *const _ as usize
            },
            360usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(cee_peer_getpg)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).cee_peer_getpfc as *const _ as usize
            },
            368usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(cee_peer_getpfc)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).dcbnl_getbuffer as *const _ as usize
            },
            376usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(dcbnl_getbuffer)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).dcbnl_setbuffer as *const _ as usize
            },
            384usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(dcbnl_setbuffer)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).dcbnl_setapptrust as *const _ as usize
            },
            392usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(dcbnl_setapptrust)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).dcbnl_getapptrust as *const _ as usize
            },
            400usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(dcbnl_getapptrust)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).dcbnl_setrewr as *const _ as usize
            },
            408usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(dcbnl_setrewr)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<dcbnl_rtnl_ops>())).dcbnl_delrewr as *const _ as usize
            },
            416usize,
            concat!(
                "Offset of field: ",
                stringify!(dcbnl_rtnl_ops),
                "::",
                stringify!(dcbnl_delrewr)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct taskstats {
        pub version: __u16,
        pub ac_exitcode: __u32,
        pub ac_flag: __u8,
        pub ac_nice: __u8,
        pub cpu_count: __u64,
        pub cpu_delay_total: __u64,
        pub blkio_count: __u64,
        pub blkio_delay_total: __u64,
        pub swapin_count: __u64,
        pub swapin_delay_total: __u64,
        pub cpu_run_real_total: __u64,
        pub cpu_run_virtual_total: __u64,
        pub ac_comm: [::cty::c_char; 32usize],
        pub ac_sched: __u8,
        pub ac_pad: [__u8; 3usize],
        pub __bindgen_padding_0: u32,
        pub ac_uid: __u32,
        pub ac_gid: __u32,
        pub ac_pid: __u32,
        pub ac_ppid: __u32,
        pub ac_btime: __u32,
        pub ac_etime: __u64,
        pub ac_utime: __u64,
        pub ac_stime: __u64,
        pub ac_minflt: __u64,
        pub ac_majflt: __u64,
        pub coremem: __u64,
        pub virtmem: __u64,
        pub hiwater_rss: __u64,
        pub hiwater_vm: __u64,
        pub read_char: __u64,
        pub write_char: __u64,
        pub read_syscalls: __u64,
        pub write_syscalls: __u64,
        pub read_bytes: __u64,
        pub write_bytes: __u64,
        pub cancelled_write_bytes: __u64,
        pub nvcsw: __u64,
        pub nivcsw: __u64,
        pub ac_utimescaled: __u64,
        pub ac_stimescaled: __u64,
        pub cpu_scaled_run_real_total: __u64,
        pub freepages_count: __u64,
        pub freepages_delay_total: __u64,
        pub thrashing_count: __u64,
        pub thrashing_delay_total: __u64,
        pub ac_btime64: __u64,
        pub compact_count: __u64,
        pub compact_delay_total: __u64,
        pub ac_tgid: __u32,
        pub ac_tgetime: __u64,
        pub ac_exe_dev: __u64,
        pub ac_exe_inode: __u64,
        pub wpcopy_count: __u64,
        pub wpcopy_delay_total: __u64,
        pub irq_count: __u64,
        pub irq_delay_total: __u64,
    }
    #[test]
    fn bindgen_test_layout_taskstats() {
        assert_eq!(
            ::core::mem::size_of::<taskstats>(),
            432usize,
            concat!("Size of: ", stringify!(taskstats))
        );
        assert_eq!(
            ::core::mem::align_of::<taskstats>(),
            8usize,
            concat!("Alignment of ", stringify!(taskstats))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<taskstats>())).version as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(version)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<taskstats>())).ac_exitcode as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(ac_exitcode)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<taskstats>())).ac_flag as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(ac_flag)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<taskstats>())).ac_nice as *const _ as usize },
            9usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(ac_nice)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<taskstats>())).cpu_count as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(cpu_count)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<taskstats>())).cpu_delay_total as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(cpu_delay_total)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<taskstats>())).blkio_count as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(blkio_count)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<taskstats>())).blkio_delay_total as *const _ as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(blkio_delay_total)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<taskstats>())).swapin_count as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(swapin_count)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<taskstats>())).swapin_delay_total as *const _ as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(swapin_delay_total)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<taskstats>())).cpu_run_real_total as *const _ as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(cpu_run_real_total)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<taskstats>())).cpu_run_virtual_total as *const _ as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(cpu_run_virtual_total)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<taskstats>())).ac_comm as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(ac_comm)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<taskstats>())).ac_sched as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(ac_sched)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<taskstats>())).ac_pad as *const _ as usize },
            113usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(ac_pad)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<taskstats>())).ac_uid as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(ac_uid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<taskstats>())).ac_gid as *const _ as usize },
            124usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(ac_gid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<taskstats>())).ac_pid as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(ac_pid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<taskstats>())).ac_ppid as *const _ as usize },
            132usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(ac_ppid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<taskstats>())).ac_btime as *const _ as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(ac_btime)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<taskstats>())).ac_etime as *const _ as usize },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(ac_etime)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<taskstats>())).ac_utime as *const _ as usize },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(ac_utime)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<taskstats>())).ac_stime as *const _ as usize },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(ac_stime)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<taskstats>())).ac_minflt as *const _ as usize },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(ac_minflt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<taskstats>())).ac_majflt as *const _ as usize },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(ac_majflt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<taskstats>())).coremem as *const _ as usize },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(coremem)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<taskstats>())).virtmem as *const _ as usize },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(virtmem)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<taskstats>())).hiwater_rss as *const _ as usize },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(hiwater_rss)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<taskstats>())).hiwater_vm as *const _ as usize },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(hiwater_vm)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<taskstats>())).read_char as *const _ as usize },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(read_char)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<taskstats>())).write_char as *const _ as usize },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(write_char)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<taskstats>())).read_syscalls as *const _ as usize },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(read_syscalls)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<taskstats>())).write_syscalls as *const _ as usize },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(write_syscalls)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<taskstats>())).read_bytes as *const _ as usize },
            248usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(read_bytes)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<taskstats>())).write_bytes as *const _ as usize },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(write_bytes)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<taskstats>())).cancelled_write_bytes as *const _ as usize
            },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(cancelled_write_bytes)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<taskstats>())).nvcsw as *const _ as usize },
            272usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(nvcsw)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<taskstats>())).nivcsw as *const _ as usize },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(nivcsw)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<taskstats>())).ac_utimescaled as *const _ as usize },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(ac_utimescaled)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<taskstats>())).ac_stimescaled as *const _ as usize },
            296usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(ac_stimescaled)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<taskstats>())).cpu_scaled_run_real_total as *const _
                    as usize
            },
            304usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(cpu_scaled_run_real_total)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<taskstats>())).freepages_count as *const _ as usize },
            312usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(freepages_count)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<taskstats>())).freepages_delay_total as *const _ as usize
            },
            320usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(freepages_delay_total)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<taskstats>())).thrashing_count as *const _ as usize },
            328usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(thrashing_count)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<taskstats>())).thrashing_delay_total as *const _ as usize
            },
            336usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(thrashing_delay_total)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<taskstats>())).ac_btime64 as *const _ as usize },
            344usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(ac_btime64)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<taskstats>())).compact_count as *const _ as usize },
            352usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(compact_count)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<taskstats>())).compact_delay_total as *const _ as usize
            },
            360usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(compact_delay_total)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<taskstats>())).ac_tgid as *const _ as usize },
            368usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(ac_tgid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<taskstats>())).ac_tgetime as *const _ as usize },
            376usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(ac_tgetime)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<taskstats>())).ac_exe_dev as *const _ as usize },
            384usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(ac_exe_dev)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<taskstats>())).ac_exe_inode as *const _ as usize },
            392usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(ac_exe_inode)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<taskstats>())).wpcopy_count as *const _ as usize },
            400usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(wpcopy_count)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<taskstats>())).wpcopy_delay_total as *const _ as usize
            },
            408usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(wpcopy_delay_total)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<taskstats>())).irq_count as *const _ as usize },
            416usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(irq_count)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<taskstats>())).irq_delay_total as *const _ as usize },
            424usize,
            concat!(
                "Offset of field: ",
                stringify!(taskstats),
                "::",
                stringify!(irq_delay_total)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct mnt_namespace {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct uts_namespace {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ipc_namespace {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsproxy {
        pub count: atomic_t,
        pub uts_ns: *mut uts_namespace,
        pub ipc_ns: *mut ipc_namespace,
        pub mnt_ns: *mut mnt_namespace,
        pub pid_ns_for_children: *mut pid_namespace,
        pub net_ns: *mut net,
        pub time_ns: *mut time_namespace,
        pub time_ns_for_children: *mut time_namespace,
        pub cgroup_ns: *mut cgroup_namespace,
    }
    #[test]
    fn bindgen_test_layout_nsproxy() {
        assert_eq!(
            ::core::mem::size_of::<nsproxy>(),
            72usize,
            concat!("Size of: ", stringify!(nsproxy))
        );
        assert_eq!(
            ::core::mem::align_of::<nsproxy>(),
            8usize,
            concat!("Alignment of ", stringify!(nsproxy))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<nsproxy>())).count as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(nsproxy),
                "::",
                stringify!(count)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<nsproxy>())).uts_ns as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(nsproxy),
                "::",
                stringify!(uts_ns)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<nsproxy>())).ipc_ns as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(nsproxy),
                "::",
                stringify!(ipc_ns)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<nsproxy>())).mnt_ns as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(nsproxy),
                "::",
                stringify!(mnt_ns)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<nsproxy>())).pid_ns_for_children as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(nsproxy),
                "::",
                stringify!(pid_ns_for_children)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<nsproxy>())).net_ns as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(nsproxy),
                "::",
                stringify!(net_ns)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<nsproxy>())).time_ns as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(nsproxy),
                "::",
                stringify!(time_ns)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<nsproxy>())).time_ns_for_children as *const _ as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(nsproxy),
                "::",
                stringify!(time_ns_for_children)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<nsproxy>())).cgroup_ns as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(nsproxy),
                "::",
                stringify!(cgroup_ns)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct uid_gid_extent {
        pub first: _cargo_bpf_u32,
        pub lower_first: _cargo_bpf_u32,
        pub count: _cargo_bpf_u32,
    }
    #[test]
    fn bindgen_test_layout_uid_gid_extent() {
        assert_eq!(
            ::core::mem::size_of::<uid_gid_extent>(),
            12usize,
            concat!("Size of: ", stringify!(uid_gid_extent))
        );
        assert_eq!(
            ::core::mem::align_of::<uid_gid_extent>(),
            4usize,
            concat!("Alignment of ", stringify!(uid_gid_extent))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<uid_gid_extent>())).first as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(uid_gid_extent),
                "::",
                stringify!(first)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<uid_gid_extent>())).lower_first as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(uid_gid_extent),
                "::",
                stringify!(lower_first)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<uid_gid_extent>())).count as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(uid_gid_extent),
                "::",
                stringify!(count)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct uid_gid_map {
        pub nr_extents: _cargo_bpf_u32,
        pub __bindgen_anon_1: uid_gid_map__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union uid_gid_map__bindgen_ty_1 {
        pub extent: [uid_gid_extent; 5usize],
        pub __bindgen_anon_1: uid_gid_map__bindgen_ty_1__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct uid_gid_map__bindgen_ty_1__bindgen_ty_1 {
        pub forward: *mut uid_gid_extent,
        pub reverse: *mut uid_gid_extent,
    }
    #[test]
    fn bindgen_test_layout_uid_gid_map__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<uid_gid_map__bindgen_ty_1__bindgen_ty_1>(),
            16usize,
            concat!(
                "Size of: ",
                stringify!(uid_gid_map__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<uid_gid_map__bindgen_ty_1__bindgen_ty_1>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(uid_gid_map__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<uid_gid_map__bindgen_ty_1__bindgen_ty_1>())).forward
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(uid_gid_map__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(forward)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<uid_gid_map__bindgen_ty_1__bindgen_ty_1>())).reverse
                    as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(uid_gid_map__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(reverse)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_uid_gid_map__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<uid_gid_map__bindgen_ty_1>(),
            64usize,
            concat!("Size of: ", stringify!(uid_gid_map__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<uid_gid_map__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(uid_gid_map__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<uid_gid_map__bindgen_ty_1>())).extent as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(uid_gid_map__bindgen_ty_1),
                "::",
                stringify!(extent)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_uid_gid_map() {
        assert_eq!(
            ::core::mem::size_of::<uid_gid_map>(),
            72usize,
            concat!("Size of: ", stringify!(uid_gid_map))
        );
        assert_eq!(
            ::core::mem::align_of::<uid_gid_map>(),
            8usize,
            concat!("Alignment of ", stringify!(uid_gid_map))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<uid_gid_map>())).nr_extents as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(uid_gid_map),
                "::",
                stringify!(nr_extents)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ucounts {
        pub node: hlist_node,
        pub ns: *mut user_namespace,
        pub uid: kuid_t,
        pub count: atomic_t,
        pub ucount: [atomic_long_t; 12usize],
        pub rlimit: [atomic_long_t; 4usize],
    }
    #[test]
    fn bindgen_test_layout_ucounts() {
        assert_eq!(
            ::core::mem::size_of::<ucounts>(),
            160usize,
            concat!("Size of: ", stringify!(ucounts))
        );
        assert_eq!(
            ::core::mem::align_of::<ucounts>(),
            8usize,
            concat!("Alignment of ", stringify!(ucounts))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ucounts>())).node as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ucounts),
                "::",
                stringify!(node)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ucounts>())).ns as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ucounts),
                "::",
                stringify!(ns)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ucounts>())).uid as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(ucounts),
                "::",
                stringify!(uid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ucounts>())).count as *const _ as usize },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(ucounts),
                "::",
                stringify!(count)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ucounts>())).ucount as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(ucounts),
                "::",
                stringify!(ucount)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ucounts>())).rlimit as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(ucounts),
                "::",
                stringify!(rlimit)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cgroup_bpf {
        pub effective: [*mut bpf_prog_array; 33usize],
        pub progs: [hlist_head; 33usize],
        pub flags: [_cargo_bpf_u8; 33usize],
        pub storages: list_head,
        pub inactive: *mut bpf_prog_array,
        pub refcnt: percpu_ref,
        pub release_work: work_struct,
    }
    #[test]
    fn bindgen_test_layout_cgroup_bpf() {
        assert_eq!(
            ::core::mem::size_of::<cgroup_bpf>(),
            640usize,
            concat!("Size of: ", stringify!(cgroup_bpf))
        );
        assert_eq!(
            ::core::mem::align_of::<cgroup_bpf>(),
            8usize,
            concat!("Alignment of ", stringify!(cgroup_bpf))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_bpf>())).effective as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_bpf),
                "::",
                stringify!(effective)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_bpf>())).progs as *const _ as usize },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_bpf),
                "::",
                stringify!(progs)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_bpf>())).flags as *const _ as usize },
            528usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_bpf),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_bpf>())).storages as *const _ as usize },
            568usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_bpf),
                "::",
                stringify!(storages)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_bpf>())).inactive as *const _ as usize },
            584usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_bpf),
                "::",
                stringify!(inactive)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_bpf>())).refcnt as *const _ as usize },
            592usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_bpf),
                "::",
                stringify!(refcnt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_bpf>())).release_work as *const _ as usize },
            608usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_bpf),
                "::",
                stringify!(release_work)
            )
        );
    }
    #[repr(C)]
    #[repr(align(64))]
    #[derive(Debug, Copy, Clone)]
    pub struct psi_group_cpu {
        pub seq: seqcount_t,
        pub tasks: [::cty::c_uint; 4usize],
        pub state_mask: _cargo_bpf_u32,
        pub times: [_cargo_bpf_u32; 7usize],
        pub state_start: _cargo_bpf_u64,
        pub times_prev: [[_cargo_bpf_u32; 7usize]; 2usize],
    }
    #[test]
    fn bindgen_test_layout_psi_group_cpu() {
        assert_eq!(
            ::core::mem::size_of::<psi_group_cpu>(),
            128usize,
            concat!("Size of: ", stringify!(psi_group_cpu))
        );
        assert_eq!(
            ::core::mem::align_of::<psi_group_cpu>(),
            64usize,
            concat!("Alignment of ", stringify!(psi_group_cpu))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<psi_group_cpu>())).seq as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(psi_group_cpu),
                "::",
                stringify!(seq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<psi_group_cpu>())).tasks as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(psi_group_cpu),
                "::",
                stringify!(tasks)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<psi_group_cpu>())).state_mask as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(psi_group_cpu),
                "::",
                stringify!(state_mask)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<psi_group_cpu>())).times as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(psi_group_cpu),
                "::",
                stringify!(times)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<psi_group_cpu>())).state_start as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(psi_group_cpu),
                "::",
                stringify!(state_start)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<psi_group_cpu>())).times_prev as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(psi_group_cpu),
                "::",
                stringify!(times_prev)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct psi_group {
        pub parent: *mut psi_group,
        pub enabled: bool_,
        pub avgs_lock: mutex,
        pub pcpu: *mut psi_group_cpu,
        pub avg_total: [_cargo_bpf_u64; 6usize],
        pub avg_last_update: _cargo_bpf_u64,
        pub avg_next_update: _cargo_bpf_u64,
        pub avgs_work: delayed_work,
        pub avg_triggers: list_head,
        pub avg_nr_triggers: [_cargo_bpf_u32; 6usize],
        pub total: [[_cargo_bpf_u64; 6usize]; 2usize],
        pub avg: [[::cty::c_ulong; 3usize]; 6usize],
        pub rtpoll_task: *mut task_struct,
        pub rtpoll_timer: timer_list,
        pub rtpoll_wait: wait_queue_head_t,
        pub rtpoll_wakeup: atomic_t,
        pub rtpoll_scheduled: atomic_t,
        pub rtpoll_trigger_lock: mutex,
        pub rtpoll_triggers: list_head,
        pub rtpoll_nr_triggers: [_cargo_bpf_u32; 6usize],
        pub rtpoll_states: _cargo_bpf_u32,
        pub rtpoll_min_period: _cargo_bpf_u64,
        pub rtpoll_total: [_cargo_bpf_u64; 6usize],
        pub rtpoll_next_update: _cargo_bpf_u64,
        pub rtpoll_until: _cargo_bpf_u64,
    }
    #[test]
    fn bindgen_test_layout_psi_group() {
        assert_eq!(
            ::core::mem::size_of::<psi_group>(),
            720usize,
            concat!("Size of: ", stringify!(psi_group))
        );
        assert_eq!(
            ::core::mem::align_of::<psi_group>(),
            8usize,
            concat!("Alignment of ", stringify!(psi_group))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<psi_group>())).parent as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(psi_group),
                "::",
                stringify!(parent)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<psi_group>())).enabled as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(psi_group),
                "::",
                stringify!(enabled)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<psi_group>())).avgs_lock as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(psi_group),
                "::",
                stringify!(avgs_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<psi_group>())).pcpu as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(psi_group),
                "::",
                stringify!(pcpu)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<psi_group>())).avg_total as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(psi_group),
                "::",
                stringify!(avg_total)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<psi_group>())).avg_last_update as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(psi_group),
                "::",
                stringify!(avg_last_update)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<psi_group>())).avg_next_update as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(psi_group),
                "::",
                stringify!(avg_next_update)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<psi_group>())).avgs_work as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(psi_group),
                "::",
                stringify!(avgs_work)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<psi_group>())).avg_triggers as *const _ as usize },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(psi_group),
                "::",
                stringify!(avg_triggers)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<psi_group>())).avg_nr_triggers as *const _ as usize },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(psi_group),
                "::",
                stringify!(avg_nr_triggers)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<psi_group>())).total as *const _ as usize },
            248usize,
            concat!(
                "Offset of field: ",
                stringify!(psi_group),
                "::",
                stringify!(total)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<psi_group>())).avg as *const _ as usize },
            344usize,
            concat!(
                "Offset of field: ",
                stringify!(psi_group),
                "::",
                stringify!(avg)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<psi_group>())).rtpoll_task as *const _ as usize },
            488usize,
            concat!(
                "Offset of field: ",
                stringify!(psi_group),
                "::",
                stringify!(rtpoll_task)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<psi_group>())).rtpoll_timer as *const _ as usize },
            496usize,
            concat!(
                "Offset of field: ",
                stringify!(psi_group),
                "::",
                stringify!(rtpoll_timer)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<psi_group>())).rtpoll_wait as *const _ as usize },
            536usize,
            concat!(
                "Offset of field: ",
                stringify!(psi_group),
                "::",
                stringify!(rtpoll_wait)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<psi_group>())).rtpoll_wakeup as *const _ as usize },
            560usize,
            concat!(
                "Offset of field: ",
                stringify!(psi_group),
                "::",
                stringify!(rtpoll_wakeup)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<psi_group>())).rtpoll_scheduled as *const _ as usize },
            564usize,
            concat!(
                "Offset of field: ",
                stringify!(psi_group),
                "::",
                stringify!(rtpoll_scheduled)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<psi_group>())).rtpoll_trigger_lock as *const _ as usize
            },
            568usize,
            concat!(
                "Offset of field: ",
                stringify!(psi_group),
                "::",
                stringify!(rtpoll_trigger_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<psi_group>())).rtpoll_triggers as *const _ as usize },
            600usize,
            concat!(
                "Offset of field: ",
                stringify!(psi_group),
                "::",
                stringify!(rtpoll_triggers)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<psi_group>())).rtpoll_nr_triggers as *const _ as usize
            },
            616usize,
            concat!(
                "Offset of field: ",
                stringify!(psi_group),
                "::",
                stringify!(rtpoll_nr_triggers)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<psi_group>())).rtpoll_states as *const _ as usize },
            640usize,
            concat!(
                "Offset of field: ",
                stringify!(psi_group),
                "::",
                stringify!(rtpoll_states)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<psi_group>())).rtpoll_min_period as *const _ as usize
            },
            648usize,
            concat!(
                "Offset of field: ",
                stringify!(psi_group),
                "::",
                stringify!(rtpoll_min_period)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<psi_group>())).rtpoll_total as *const _ as usize },
            656usize,
            concat!(
                "Offset of field: ",
                stringify!(psi_group),
                "::",
                stringify!(rtpoll_total)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<psi_group>())).rtpoll_next_update as *const _ as usize
            },
            704usize,
            concat!(
                "Offset of field: ",
                stringify!(psi_group),
                "::",
                stringify!(rtpoll_next_update)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<psi_group>())).rtpoll_until as *const _ as usize },
            712usize,
            concat!(
                "Offset of field: ",
                stringify!(psi_group),
                "::",
                stringify!(rtpoll_until)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cgroup_taskset {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cgroup_file {
        pub kn: *mut kernfs_node,
        pub notified_at: ::cty::c_ulong,
        pub notify_timer: timer_list,
    }
    #[test]
    fn bindgen_test_layout_cgroup_file() {
        assert_eq!(
            ::core::mem::size_of::<cgroup_file>(),
            56usize,
            concat!("Size of: ", stringify!(cgroup_file))
        );
        assert_eq!(
            ::core::mem::align_of::<cgroup_file>(),
            8usize,
            concat!("Alignment of ", stringify!(cgroup_file))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_file>())).kn as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_file),
                "::",
                stringify!(kn)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_file>())).notified_at as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_file),
                "::",
                stringify!(notified_at)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_file>())).notify_timer as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_file),
                "::",
                stringify!(notify_timer)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cgroup_subsys_state {
        pub cgroup: *mut cgroup,
        pub ss: *mut cgroup_subsys,
        pub refcnt: percpu_ref,
        pub sibling: list_head,
        pub children: list_head,
        pub rstat_css_node: list_head,
        pub id: ::cty::c_int,
        pub flags: ::cty::c_uint,
        pub serial_nr: _cargo_bpf_u64,
        pub online_cnt: atomic_t,
        pub destroy_work: work_struct,
        pub destroy_rwork: rcu_work,
        pub parent: *mut cgroup_subsys_state,
    }
    #[test]
    fn bindgen_test_layout_cgroup_subsys_state() {
        assert_eq!(
            ::core::mem::size_of::<cgroup_subsys_state>(),
            200usize,
            concat!("Size of: ", stringify!(cgroup_subsys_state))
        );
        assert_eq!(
            ::core::mem::align_of::<cgroup_subsys_state>(),
            8usize,
            concat!("Alignment of ", stringify!(cgroup_subsys_state))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_subsys_state>())).cgroup as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_subsys_state),
                "::",
                stringify!(cgroup)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_subsys_state>())).ss as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_subsys_state),
                "::",
                stringify!(ss)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_subsys_state>())).refcnt as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_subsys_state),
                "::",
                stringify!(refcnt)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<cgroup_subsys_state>())).sibling as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_subsys_state),
                "::",
                stringify!(sibling)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<cgroup_subsys_state>())).children as *const _ as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_subsys_state),
                "::",
                stringify!(children)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<cgroup_subsys_state>())).rstat_css_node as *const _ as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_subsys_state),
                "::",
                stringify!(rstat_css_node)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_subsys_state>())).id as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_subsys_state),
                "::",
                stringify!(id)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_subsys_state>())).flags as *const _ as usize },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_subsys_state),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<cgroup_subsys_state>())).serial_nr as *const _ as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_subsys_state),
                "::",
                stringify!(serial_nr)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<cgroup_subsys_state>())).online_cnt as *const _ as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_subsys_state),
                "::",
                stringify!(online_cnt)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<cgroup_subsys_state>())).destroy_work as *const _ as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_subsys_state),
                "::",
                stringify!(destroy_work)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<cgroup_subsys_state>())).destroy_rwork as *const _ as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_subsys_state),
                "::",
                stringify!(destroy_rwork)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_subsys_state>())).parent as *const _ as usize },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_subsys_state),
                "::",
                stringify!(parent)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct css_set {
        pub subsys: [*mut cgroup_subsys_state; 14usize],
        pub refcount: refcount_t,
        pub dom_cset: *mut css_set,
        pub dfl_cgrp: *mut cgroup,
        pub nr_tasks: ::cty::c_int,
        pub tasks: list_head,
        pub mg_tasks: list_head,
        pub dying_tasks: list_head,
        pub task_iters: list_head,
        pub e_cset_node: [list_head; 14usize],
        pub threaded_csets: list_head,
        pub threaded_csets_node: list_head,
        pub hlist: hlist_node,
        pub cgrp_links: list_head,
        pub mg_src_preload_node: list_head,
        pub mg_dst_preload_node: list_head,
        pub mg_node: list_head,
        pub mg_src_cgrp: *mut cgroup,
        pub mg_dst_cgrp: *mut cgroup,
        pub mg_dst_cset: *mut css_set,
        pub dead: bool_,
        pub callback_head: callback_head,
    }
    #[test]
    fn bindgen_test_layout_css_set() {
        assert_eq!(
            ::core::mem::size_of::<css_set>(),
            592usize,
            concat!("Size of: ", stringify!(css_set))
        );
        assert_eq!(
            ::core::mem::align_of::<css_set>(),
            8usize,
            concat!("Alignment of ", stringify!(css_set))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<css_set>())).subsys as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(css_set),
                "::",
                stringify!(subsys)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<css_set>())).refcount as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(css_set),
                "::",
                stringify!(refcount)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<css_set>())).dom_cset as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(css_set),
                "::",
                stringify!(dom_cset)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<css_set>())).dfl_cgrp as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(css_set),
                "::",
                stringify!(dfl_cgrp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<css_set>())).nr_tasks as *const _ as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(css_set),
                "::",
                stringify!(nr_tasks)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<css_set>())).tasks as *const _ as usize },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(css_set),
                "::",
                stringify!(tasks)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<css_set>())).mg_tasks as *const _ as usize },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(css_set),
                "::",
                stringify!(mg_tasks)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<css_set>())).dying_tasks as *const _ as usize },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(css_set),
                "::",
                stringify!(dying_tasks)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<css_set>())).task_iters as *const _ as usize },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(css_set),
                "::",
                stringify!(task_iters)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<css_set>())).e_cset_node as *const _ as usize },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(css_set),
                "::",
                stringify!(e_cset_node)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<css_set>())).threaded_csets as *const _ as usize },
            432usize,
            concat!(
                "Offset of field: ",
                stringify!(css_set),
                "::",
                stringify!(threaded_csets)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<css_set>())).threaded_csets_node as *const _ as usize
            },
            448usize,
            concat!(
                "Offset of field: ",
                stringify!(css_set),
                "::",
                stringify!(threaded_csets_node)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<css_set>())).hlist as *const _ as usize },
            464usize,
            concat!(
                "Offset of field: ",
                stringify!(css_set),
                "::",
                stringify!(hlist)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<css_set>())).cgrp_links as *const _ as usize },
            480usize,
            concat!(
                "Offset of field: ",
                stringify!(css_set),
                "::",
                stringify!(cgrp_links)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<css_set>())).mg_src_preload_node as *const _ as usize
            },
            496usize,
            concat!(
                "Offset of field: ",
                stringify!(css_set),
                "::",
                stringify!(mg_src_preload_node)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<css_set>())).mg_dst_preload_node as *const _ as usize
            },
            512usize,
            concat!(
                "Offset of field: ",
                stringify!(css_set),
                "::",
                stringify!(mg_dst_preload_node)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<css_set>())).mg_node as *const _ as usize },
            528usize,
            concat!(
                "Offset of field: ",
                stringify!(css_set),
                "::",
                stringify!(mg_node)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<css_set>())).mg_src_cgrp as *const _ as usize },
            544usize,
            concat!(
                "Offset of field: ",
                stringify!(css_set),
                "::",
                stringify!(mg_src_cgrp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<css_set>())).mg_dst_cgrp as *const _ as usize },
            552usize,
            concat!(
                "Offset of field: ",
                stringify!(css_set),
                "::",
                stringify!(mg_dst_cgrp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<css_set>())).mg_dst_cset as *const _ as usize },
            560usize,
            concat!(
                "Offset of field: ",
                stringify!(css_set),
                "::",
                stringify!(mg_dst_cset)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<css_set>())).dead as *const _ as usize },
            568usize,
            concat!(
                "Offset of field: ",
                stringify!(css_set),
                "::",
                stringify!(dead)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<css_set>())).callback_head as *const _ as usize },
            576usize,
            concat!(
                "Offset of field: ",
                stringify!(css_set),
                "::",
                stringify!(callback_head)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cgroup_base_stat {
        pub cputime: task_cputime,
        pub forceidle_sum: _cargo_bpf_u64,
    }
    #[test]
    fn bindgen_test_layout_cgroup_base_stat() {
        assert_eq!(
            ::core::mem::size_of::<cgroup_base_stat>(),
            32usize,
            concat!("Size of: ", stringify!(cgroup_base_stat))
        );
        assert_eq!(
            ::core::mem::align_of::<cgroup_base_stat>(),
            8usize,
            concat!("Alignment of ", stringify!(cgroup_base_stat))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_base_stat>())).cputime as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_base_stat),
                "::",
                stringify!(cputime)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<cgroup_base_stat>())).forceidle_sum as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_base_stat),
                "::",
                stringify!(forceidle_sum)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cgroup_rstat_cpu {
        pub bsync: u64_stats_sync,
        pub bstat: cgroup_base_stat,
        pub last_bstat: cgroup_base_stat,
        pub updated_children: *mut cgroup,
        pub updated_next: *mut cgroup,
    }
    #[test]
    fn bindgen_test_layout_cgroup_rstat_cpu() {
        assert_eq!(
            ::core::mem::size_of::<cgroup_rstat_cpu>(),
            80usize,
            concat!("Size of: ", stringify!(cgroup_rstat_cpu))
        );
        assert_eq!(
            ::core::mem::align_of::<cgroup_rstat_cpu>(),
            8usize,
            concat!("Alignment of ", stringify!(cgroup_rstat_cpu))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_rstat_cpu>())).bsync as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_rstat_cpu),
                "::",
                stringify!(bsync)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_rstat_cpu>())).bstat as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_rstat_cpu),
                "::",
                stringify!(bstat)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<cgroup_rstat_cpu>())).last_bstat as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_rstat_cpu),
                "::",
                stringify!(last_bstat)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<cgroup_rstat_cpu>())).updated_children as *const _ as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_rstat_cpu),
                "::",
                stringify!(updated_children)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<cgroup_rstat_cpu>())).updated_next as *const _ as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_rstat_cpu),
                "::",
                stringify!(updated_next)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cgroup_freezer_state {
        pub freeze: bool_,
        pub e_freeze: ::cty::c_int,
        pub nr_frozen_descendants: ::cty::c_int,
        pub nr_frozen_tasks: ::cty::c_int,
    }
    #[test]
    fn bindgen_test_layout_cgroup_freezer_state() {
        assert_eq!(
            ::core::mem::size_of::<cgroup_freezer_state>(),
            16usize,
            concat!("Size of: ", stringify!(cgroup_freezer_state))
        );
        assert_eq!(
            ::core::mem::align_of::<cgroup_freezer_state>(),
            4usize,
            concat!("Alignment of ", stringify!(cgroup_freezer_state))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<cgroup_freezer_state>())).freeze as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_freezer_state),
                "::",
                stringify!(freeze)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<cgroup_freezer_state>())).e_freeze as *const _ as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_freezer_state),
                "::",
                stringify!(e_freeze)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<cgroup_freezer_state>())).nr_frozen_descendants as *const _
                    as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_freezer_state),
                "::",
                stringify!(nr_frozen_descendants)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<cgroup_freezer_state>())).nr_frozen_tasks as *const _
                    as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_freezer_state),
                "::",
                stringify!(nr_frozen_tasks)
            )
        );
    }
    #[repr(C)]
    pub struct cgroup {
        pub self_: cgroup_subsys_state,
        pub flags: ::cty::c_ulong,
        pub level: ::cty::c_int,
        pub max_depth: ::cty::c_int,
        pub nr_descendants: ::cty::c_int,
        pub nr_dying_descendants: ::cty::c_int,
        pub max_descendants: ::cty::c_int,
        pub nr_populated_csets: ::cty::c_int,
        pub nr_populated_domain_children: ::cty::c_int,
        pub nr_populated_threaded_children: ::cty::c_int,
        pub nr_threaded_children: ::cty::c_int,
        pub kn: *mut kernfs_node,
        pub procs_file: cgroup_file,
        pub events_file: cgroup_file,
        pub psi_files: [cgroup_file; 3usize],
        pub subtree_control: _cargo_bpf_u16,
        pub subtree_ss_mask: _cargo_bpf_u16,
        pub old_subtree_control: _cargo_bpf_u16,
        pub old_subtree_ss_mask: _cargo_bpf_u16,
        pub subsys: [*mut cgroup_subsys_state; 14usize],
        pub root: *mut cgroup_root,
        pub cset_links: list_head,
        pub e_csets: [list_head; 14usize],
        pub dom_cgrp: *mut cgroup,
        pub old_dom_cgrp: *mut cgroup,
        pub rstat_cpu: *mut cgroup_rstat_cpu,
        pub rstat_css_list: list_head,
        pub last_bstat: cgroup_base_stat,
        pub bstat: cgroup_base_stat,
        pub prev_cputime: prev_cputime,
        pub pidlists: list_head,
        pub pidlist_mutex: mutex,
        pub offline_waitq: wait_queue_head_t,
        pub release_agent_work: work_struct,
        pub psi: *mut psi_group,
        pub bpf: cgroup_bpf,
        pub congestion_count: atomic_t,
        pub freezer: cgroup_freezer_state,
        pub bpf_cgrp_storage: *mut bpf_local_storage,
        pub ancestors: __IncompleteArrayField<*mut cgroup>,
    }
    #[test]
    fn bindgen_test_layout_cgroup() {
        assert_eq!(
            ::core::mem::size_of::<cgroup>(),
            1816usize,
            concat!("Size of: ", stringify!(cgroup))
        );
        assert_eq!(
            ::core::mem::align_of::<cgroup>(),
            8usize,
            concat!("Alignment of ", stringify!(cgroup))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup>())).self_ as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup),
                "::",
                stringify!(self_)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup>())).flags as *const _ as usize },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup>())).level as *const _ as usize },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup),
                "::",
                stringify!(level)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup>())).max_depth as *const _ as usize },
            212usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup),
                "::",
                stringify!(max_depth)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup>())).nr_descendants as *const _ as usize },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup),
                "::",
                stringify!(nr_descendants)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<cgroup>())).nr_dying_descendants as *const _ as usize
            },
            220usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup),
                "::",
                stringify!(nr_dying_descendants)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup>())).max_descendants as *const _ as usize },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup),
                "::",
                stringify!(max_descendants)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup>())).nr_populated_csets as *const _ as usize },
            228usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup),
                "::",
                stringify!(nr_populated_csets)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<cgroup>())).nr_populated_domain_children as *const _
                    as usize
            },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup),
                "::",
                stringify!(nr_populated_domain_children)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<cgroup>())).nr_populated_threaded_children as *const _
                    as usize
            },
            236usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup),
                "::",
                stringify!(nr_populated_threaded_children)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<cgroup>())).nr_threaded_children as *const _ as usize
            },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup),
                "::",
                stringify!(nr_threaded_children)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup>())).kn as *const _ as usize },
            248usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup),
                "::",
                stringify!(kn)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup>())).procs_file as *const _ as usize },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup),
                "::",
                stringify!(procs_file)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup>())).events_file as *const _ as usize },
            312usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup),
                "::",
                stringify!(events_file)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup>())).psi_files as *const _ as usize },
            368usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup),
                "::",
                stringify!(psi_files)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup>())).subtree_control as *const _ as usize },
            536usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup),
                "::",
                stringify!(subtree_control)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup>())).subtree_ss_mask as *const _ as usize },
            538usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup),
                "::",
                stringify!(subtree_ss_mask)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup>())).old_subtree_control as *const _ as usize },
            540usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup),
                "::",
                stringify!(old_subtree_control)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup>())).old_subtree_ss_mask as *const _ as usize },
            542usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup),
                "::",
                stringify!(old_subtree_ss_mask)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup>())).subsys as *const _ as usize },
            544usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup),
                "::",
                stringify!(subsys)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup>())).root as *const _ as usize },
            656usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup),
                "::",
                stringify!(root)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup>())).cset_links as *const _ as usize },
            664usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup),
                "::",
                stringify!(cset_links)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup>())).e_csets as *const _ as usize },
            680usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup),
                "::",
                stringify!(e_csets)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup>())).dom_cgrp as *const _ as usize },
            904usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup),
                "::",
                stringify!(dom_cgrp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup>())).old_dom_cgrp as *const _ as usize },
            912usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup),
                "::",
                stringify!(old_dom_cgrp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup>())).rstat_cpu as *const _ as usize },
            920usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup),
                "::",
                stringify!(rstat_cpu)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup>())).rstat_css_list as *const _ as usize },
            928usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup),
                "::",
                stringify!(rstat_css_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup>())).last_bstat as *const _ as usize },
            944usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup),
                "::",
                stringify!(last_bstat)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup>())).bstat as *const _ as usize },
            976usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup),
                "::",
                stringify!(bstat)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup>())).prev_cputime as *const _ as usize },
            1008usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup),
                "::",
                stringify!(prev_cputime)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup>())).pidlists as *const _ as usize },
            1032usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup),
                "::",
                stringify!(pidlists)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup>())).pidlist_mutex as *const _ as usize },
            1048usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup),
                "::",
                stringify!(pidlist_mutex)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup>())).offline_waitq as *const _ as usize },
            1080usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup),
                "::",
                stringify!(offline_waitq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup>())).release_agent_work as *const _ as usize },
            1104usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup),
                "::",
                stringify!(release_agent_work)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup>())).psi as *const _ as usize },
            1136usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup),
                "::",
                stringify!(psi)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup>())).bpf as *const _ as usize },
            1144usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup),
                "::",
                stringify!(bpf)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup>())).congestion_count as *const _ as usize },
            1784usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup),
                "::",
                stringify!(congestion_count)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup>())).freezer as *const _ as usize },
            1788usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup),
                "::",
                stringify!(freezer)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup>())).bpf_cgrp_storage as *const _ as usize },
            1808usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup),
                "::",
                stringify!(bpf_cgrp_storage)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup>())).ancestors as *const _ as usize },
            1816usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup),
                "::",
                stringify!(ancestors)
            )
        );
    }
    #[repr(C)]
    pub struct cgroup_root {
        pub kf_root: *mut kernfs_root,
        pub subsys_mask: ::cty::c_uint,
        pub hierarchy_id: ::cty::c_int,
        pub cgrp: cgroup,
        pub cgrp_ancestor_storage: *mut cgroup,
        pub nr_cgrps: atomic_t,
        pub root_list: list_head,
        pub flags: ::cty::c_uint,
        pub release_agent_path: [::cty::c_char; 4096usize],
        pub name: [::cty::c_char; 64usize],
    }
    #[test]
    fn bindgen_test_layout_cgroup_root() {
        assert_eq!(
            ::core::mem::size_of::<cgroup_root>(),
            6032usize,
            concat!("Size of: ", stringify!(cgroup_root))
        );
        assert_eq!(
            ::core::mem::align_of::<cgroup_root>(),
            8usize,
            concat!("Alignment of ", stringify!(cgroup_root))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_root>())).kf_root as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_root),
                "::",
                stringify!(kf_root)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_root>())).subsys_mask as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_root),
                "::",
                stringify!(subsys_mask)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_root>())).hierarchy_id as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_root),
                "::",
                stringify!(hierarchy_id)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_root>())).cgrp as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_root),
                "::",
                stringify!(cgrp)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<cgroup_root>())).cgrp_ancestor_storage as *const _ as usize
            },
            1832usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_root),
                "::",
                stringify!(cgrp_ancestor_storage)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_root>())).nr_cgrps as *const _ as usize },
            1840usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_root),
                "::",
                stringify!(nr_cgrps)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_root>())).root_list as *const _ as usize },
            1848usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_root),
                "::",
                stringify!(root_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_root>())).flags as *const _ as usize },
            1864usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_root),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<cgroup_root>())).release_agent_path as *const _ as usize
            },
            1868usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_root),
                "::",
                stringify!(release_agent_path)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_root>())).name as *const _ as usize },
            5964usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_root),
                "::",
                stringify!(name)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cftype {
        pub name: [::cty::c_char; 64usize],
        pub private: ::cty::c_ulong,
        pub max_write_len: size_t,
        pub flags: ::cty::c_uint,
        pub file_offset: ::cty::c_uint,
        pub ss: *mut cgroup_subsys,
        pub node: list_head,
        pub kf_ops: *mut kernfs_ops,
        pub open:
            ::core::option::Option<unsafe extern "C" fn(of: *mut kernfs_open_file) -> ::cty::c_int>,
        pub release: ::core::option::Option<unsafe extern "C" fn(of: *mut kernfs_open_file)>,
        pub read_u64: ::core::option::Option<
            unsafe extern "C" fn(css: *mut cgroup_subsys_state, cft: *mut cftype) -> _cargo_bpf_u64,
        >,
        pub read_s64: ::core::option::Option<
            unsafe extern "C" fn(css: *mut cgroup_subsys_state, cft: *mut cftype) -> s64,
        >,
        pub seq_show: ::core::option::Option<
            unsafe extern "C" fn(sf: *mut seq_file, v: *mut ::cty::c_void) -> ::cty::c_int,
        >,
        pub seq_start: ::core::option::Option<
            unsafe extern "C" fn(sf: *mut seq_file, ppos: *mut loff_t) -> *mut ::cty::c_void,
        >,
        pub seq_next: ::core::option::Option<
            unsafe extern "C" fn(
                sf: *mut seq_file,
                v: *mut ::cty::c_void,
                ppos: *mut loff_t,
            ) -> *mut ::cty::c_void,
        >,
        pub seq_stop:
            ::core::option::Option<unsafe extern "C" fn(sf: *mut seq_file, v: *mut ::cty::c_void)>,
        pub write_u64: ::core::option::Option<
            unsafe extern "C" fn(
                css: *mut cgroup_subsys_state,
                cft: *mut cftype,
                val: _cargo_bpf_u64,
            ) -> ::cty::c_int,
        >,
        pub write_s64: ::core::option::Option<
            unsafe extern "C" fn(
                css: *mut cgroup_subsys_state,
                cft: *mut cftype,
                val: s64,
            ) -> ::cty::c_int,
        >,
        pub write: ::core::option::Option<
            unsafe extern "C" fn(
                of: *mut kernfs_open_file,
                buf: *mut ::cty::c_char,
                nbytes: size_t,
                off: loff_t,
            ) -> ssize_t,
        >,
        pub poll: ::core::option::Option<
            unsafe extern "C" fn(of: *mut kernfs_open_file, pt: *mut poll_table_struct) -> __poll_t,
        >,
    }
    #[test]
    fn bindgen_test_layout_cftype() {
        assert_eq!(
            ::core::mem::size_of::<cftype>(),
            216usize,
            concat!("Size of: ", stringify!(cftype))
        );
        assert_eq!(
            ::core::mem::align_of::<cftype>(),
            8usize,
            concat!("Alignment of ", stringify!(cftype))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cftype>())).name as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cftype),
                "::",
                stringify!(name)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cftype>())).private as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(cftype),
                "::",
                stringify!(private)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cftype>())).max_write_len as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(cftype),
                "::",
                stringify!(max_write_len)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cftype>())).flags as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(cftype),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cftype>())).file_offset as *const _ as usize },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(cftype),
                "::",
                stringify!(file_offset)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cftype>())).ss as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(cftype),
                "::",
                stringify!(ss)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cftype>())).node as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(cftype),
                "::",
                stringify!(node)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cftype>())).kf_ops as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(cftype),
                "::",
                stringify!(kf_ops)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cftype>())).open as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(cftype),
                "::",
                stringify!(open)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cftype>())).release as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(cftype),
                "::",
                stringify!(release)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cftype>())).read_u64 as *const _ as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(cftype),
                "::",
                stringify!(read_u64)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cftype>())).read_s64 as *const _ as usize },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(cftype),
                "::",
                stringify!(read_s64)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cftype>())).seq_show as *const _ as usize },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(cftype),
                "::",
                stringify!(seq_show)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cftype>())).seq_start as *const _ as usize },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(cftype),
                "::",
                stringify!(seq_start)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cftype>())).seq_next as *const _ as usize },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(cftype),
                "::",
                stringify!(seq_next)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cftype>())).seq_stop as *const _ as usize },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(cftype),
                "::",
                stringify!(seq_stop)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cftype>())).write_u64 as *const _ as usize },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(cftype),
                "::",
                stringify!(write_u64)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cftype>())).write_s64 as *const _ as usize },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(cftype),
                "::",
                stringify!(write_s64)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cftype>())).write as *const _ as usize },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(cftype),
                "::",
                stringify!(write)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cftype>())).poll as *const _ as usize },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(cftype),
                "::",
                stringify!(poll)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct cgroup_subsys {
        pub css_alloc: ::core::option::Option<
            unsafe extern "C" fn(parent_css: *mut cgroup_subsys_state) -> *mut cgroup_subsys_state,
        >,
        pub css_online: ::core::option::Option<
            unsafe extern "C" fn(css: *mut cgroup_subsys_state) -> ::cty::c_int,
        >,
        pub css_offline:
            ::core::option::Option<unsafe extern "C" fn(css: *mut cgroup_subsys_state)>,
        pub css_released:
            ::core::option::Option<unsafe extern "C" fn(css: *mut cgroup_subsys_state)>,
        pub css_free: ::core::option::Option<unsafe extern "C" fn(css: *mut cgroup_subsys_state)>,
        pub css_reset: ::core::option::Option<unsafe extern "C" fn(css: *mut cgroup_subsys_state)>,
        pub css_rstat_flush: ::core::option::Option<
            unsafe extern "C" fn(css: *mut cgroup_subsys_state, cpu: ::cty::c_int),
        >,
        pub css_extra_stat_show: ::core::option::Option<
            unsafe extern "C" fn(seq: *mut seq_file, css: *mut cgroup_subsys_state) -> ::cty::c_int,
        >,
        pub can_attach:
            ::core::option::Option<unsafe extern "C" fn(tset: *mut cgroup_taskset) -> ::cty::c_int>,
        pub cancel_attach: ::core::option::Option<unsafe extern "C" fn(tset: *mut cgroup_taskset)>,
        pub attach: ::core::option::Option<unsafe extern "C" fn(tset: *mut cgroup_taskset)>,
        pub post_attach: ::core::option::Option<unsafe extern "C" fn()>,
        pub can_fork: ::core::option::Option<
            unsafe extern "C" fn(task: *mut task_struct, cset: *mut css_set) -> ::cty::c_int,
        >,
        pub cancel_fork: ::core::option::Option<
            unsafe extern "C" fn(task: *mut task_struct, cset: *mut css_set),
        >,
        pub fork: ::core::option::Option<unsafe extern "C" fn(task: *mut task_struct)>,
        pub exit: ::core::option::Option<unsafe extern "C" fn(task: *mut task_struct)>,
        pub release: ::core::option::Option<unsafe extern "C" fn(task: *mut task_struct)>,
        pub bind: ::core::option::Option<unsafe extern "C" fn(root_css: *mut cgroup_subsys_state)>,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
        pub id: ::cty::c_int,
        pub name: *const ::cty::c_char,
        pub legacy_name: *const ::cty::c_char,
        pub root: *mut cgroup_root,
        pub css_idr: idr,
        pub cfts: list_head,
        pub dfl_cftypes: *mut cftype,
        pub legacy_cftypes: *mut cftype,
        pub depends_on: ::cty::c_uint,
    }
    #[test]
    fn bindgen_test_layout_cgroup_subsys() {
        assert_eq!(
            ::core::mem::size_of::<cgroup_subsys>(),
            240usize,
            concat!("Size of: ", stringify!(cgroup_subsys))
        );
        assert_eq!(
            ::core::mem::align_of::<cgroup_subsys>(),
            8usize,
            concat!("Alignment of ", stringify!(cgroup_subsys))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_subsys>())).css_alloc as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_subsys),
                "::",
                stringify!(css_alloc)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_subsys>())).css_online as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_subsys),
                "::",
                stringify!(css_online)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_subsys>())).css_offline as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_subsys),
                "::",
                stringify!(css_offline)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_subsys>())).css_released as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_subsys),
                "::",
                stringify!(css_released)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_subsys>())).css_free as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_subsys),
                "::",
                stringify!(css_free)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_subsys>())).css_reset as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_subsys),
                "::",
                stringify!(css_reset)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<cgroup_subsys>())).css_rstat_flush as *const _ as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_subsys),
                "::",
                stringify!(css_rstat_flush)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<cgroup_subsys>())).css_extra_stat_show as *const _ as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_subsys),
                "::",
                stringify!(css_extra_stat_show)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_subsys>())).can_attach as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_subsys),
                "::",
                stringify!(can_attach)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<cgroup_subsys>())).cancel_attach as *const _ as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_subsys),
                "::",
                stringify!(cancel_attach)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_subsys>())).attach as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_subsys),
                "::",
                stringify!(attach)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_subsys>())).post_attach as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_subsys),
                "::",
                stringify!(post_attach)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_subsys>())).can_fork as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_subsys),
                "::",
                stringify!(can_fork)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_subsys>())).cancel_fork as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_subsys),
                "::",
                stringify!(cancel_fork)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_subsys>())).fork as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_subsys),
                "::",
                stringify!(fork)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_subsys>())).exit as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_subsys),
                "::",
                stringify!(exit)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_subsys>())).release as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_subsys),
                "::",
                stringify!(release)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_subsys>())).bind as *const _ as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_subsys),
                "::",
                stringify!(bind)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_subsys>())).id as *const _ as usize },
            148usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_subsys),
                "::",
                stringify!(id)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_subsys>())).name as *const _ as usize },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_subsys),
                "::",
                stringify!(name)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_subsys>())).legacy_name as *const _ as usize },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_subsys),
                "::",
                stringify!(legacy_name)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_subsys>())).root as *const _ as usize },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_subsys),
                "::",
                stringify!(root)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_subsys>())).css_idr as *const _ as usize },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_subsys),
                "::",
                stringify!(css_idr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_subsys>())).cfts as *const _ as usize },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_subsys),
                "::",
                stringify!(cfts)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_subsys>())).dfl_cftypes as *const _ as usize },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_subsys),
                "::",
                stringify!(dfl_cftypes)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<cgroup_subsys>())).legacy_cftypes as *const _ as usize
            },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_subsys),
                "::",
                stringify!(legacy_cftypes)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_subsys>())).depends_on as *const _ as usize },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_subsys),
                "::",
                stringify!(depends_on)
            )
        );
    }
    impl cgroup_subsys {
        #[inline]
        pub fn early_init(&self) -> bool_ {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_early_init(&mut self, val: bool_) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn implicit_on_dfl(&self) -> bool_ {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_implicit_on_dfl(&mut self, val: bool_) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(1usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn threaded(&self) -> bool_ {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_threaded(&mut self, val: bool_) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(2usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            early_init: bool_,
            implicit_on_dfl: bool_,
            threaded: bool_,
        ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 1u8, {
                let early_init: u8 = unsafe { ::core::mem::transmute(early_init) };
                early_init as u64
            });
            __bindgen_bitfield_unit.set(1usize, 1u8, {
                let implicit_on_dfl: u8 = unsafe { ::core::mem::transmute(implicit_on_dfl) };
                implicit_on_dfl as u64
            });
            __bindgen_bitfield_unit.set(2usize, 1u8, {
                let threaded: u8 = unsafe { ::core::mem::transmute(threaded) };
                threaded as u64
            });
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct sock_cgroup_data {
        pub cgroup: *mut cgroup,
        pub classid: _cargo_bpf_u32,
        pub prioidx: _cargo_bpf_u16,
    }
    #[test]
    fn bindgen_test_layout_sock_cgroup_data() {
        assert_eq!(
            ::core::mem::size_of::<sock_cgroup_data>(),
            16usize,
            concat!("Size of: ", stringify!(sock_cgroup_data))
        );
        assert_eq!(
            ::core::mem::align_of::<sock_cgroup_data>(),
            8usize,
            concat!("Alignment of ", stringify!(sock_cgroup_data))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock_cgroup_data>())).cgroup as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sock_cgroup_data),
                "::",
                stringify!(cgroup)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock_cgroup_data>())).classid as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sock_cgroup_data),
                "::",
                stringify!(classid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock_cgroup_data>())).prioidx as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(sock_cgroup_data),
                "::",
                stringify!(prioidx)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cgroup_namespace {
        pub ns: ns_common,
        pub user_ns: *mut user_namespace,
        pub ucounts: *mut ucounts,
        pub root_cset: *mut css_set,
    }
    #[test]
    fn bindgen_test_layout_cgroup_namespace() {
        assert_eq!(
            ::core::mem::size_of::<cgroup_namespace>(),
            48usize,
            concat!("Size of: ", stringify!(cgroup_namespace))
        );
        assert_eq!(
            ::core::mem::align_of::<cgroup_namespace>(),
            8usize,
            concat!("Alignment of ", stringify!(cgroup_namespace))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_namespace>())).ns as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_namespace),
                "::",
                stringify!(ns)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_namespace>())).user_ns as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_namespace),
                "::",
                stringify!(user_ns)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_namespace>())).ucounts as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_namespace),
                "::",
                stringify!(ucounts)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cgroup_namespace>())).root_cset as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(cgroup_namespace),
                "::",
                stringify!(root_cset)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct netprio_map {
        pub rcu: callback_head,
        pub priomap_len: _cargo_bpf_u32,
        pub priomap: __IncompleteArrayField<_cargo_bpf_u32>,
    }
    #[test]
    fn bindgen_test_layout_netprio_map() {
        assert_eq!(
            ::core::mem::size_of::<netprio_map>(),
            24usize,
            concat!("Size of: ", stringify!(netprio_map))
        );
        assert_eq!(
            ::core::mem::align_of::<netprio_map>(),
            8usize,
            concat!("Alignment of ", stringify!(netprio_map))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netprio_map>())).rcu as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(netprio_map),
                "::",
                stringify!(rcu)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netprio_map>())).priomap_len as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(netprio_map),
                "::",
                stringify!(priomap_len)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netprio_map>())).priomap as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(netprio_map),
                "::",
                stringify!(priomap)
            )
        );
    }
    pub type xdp_features_t = _cargo_bpf_u32;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct xdp_mem_info {
        pub type_: _cargo_bpf_u32,
        pub id: _cargo_bpf_u32,
    }
    #[test]
    fn bindgen_test_layout_xdp_mem_info() {
        assert_eq!(
            ::core::mem::size_of::<xdp_mem_info>(),
            8usize,
            concat!("Size of: ", stringify!(xdp_mem_info))
        );
        assert_eq!(
            ::core::mem::align_of::<xdp_mem_info>(),
            4usize,
            concat!("Alignment of ", stringify!(xdp_mem_info))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xdp_mem_info>())).type_ as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(xdp_mem_info),
                "::",
                stringify!(type_)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xdp_mem_info>())).id as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(xdp_mem_info),
                "::",
                stringify!(id)
            )
        );
    }
    #[repr(C)]
    #[repr(align(64))]
    #[derive(Debug, Copy, Clone)]
    pub struct xdp_rxq_info {
        pub dev: *mut net_device,
        pub queue_index: _cargo_bpf_u32,
        pub reg_state: _cargo_bpf_u32,
        pub mem: xdp_mem_info,
        pub napi_id: ::cty::c_uint,
        pub frag_size: _cargo_bpf_u32,
    }
    #[test]
    fn bindgen_test_layout_xdp_rxq_info() {
        assert_eq!(
            ::core::mem::size_of::<xdp_rxq_info>(),
            64usize,
            concat!("Size of: ", stringify!(xdp_rxq_info))
        );
        assert_eq!(
            ::core::mem::align_of::<xdp_rxq_info>(),
            64usize,
            concat!("Alignment of ", stringify!(xdp_rxq_info))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xdp_rxq_info>())).dev as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(xdp_rxq_info),
                "::",
                stringify!(dev)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xdp_rxq_info>())).queue_index as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(xdp_rxq_info),
                "::",
                stringify!(queue_index)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xdp_rxq_info>())).reg_state as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(xdp_rxq_info),
                "::",
                stringify!(reg_state)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xdp_rxq_info>())).mem as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(xdp_rxq_info),
                "::",
                stringify!(mem)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xdp_rxq_info>())).napi_id as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(xdp_rxq_info),
                "::",
                stringify!(napi_id)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xdp_rxq_info>())).frag_size as *const _ as usize },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(xdp_rxq_info),
                "::",
                stringify!(frag_size)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct xdp_txq_info {
        pub dev: *mut net_device,
    }
    #[test]
    fn bindgen_test_layout_xdp_txq_info() {
        assert_eq!(
            ::core::mem::size_of::<xdp_txq_info>(),
            8usize,
            concat!("Size of: ", stringify!(xdp_txq_info))
        );
        assert_eq!(
            ::core::mem::align_of::<xdp_txq_info>(),
            8usize,
            concat!("Alignment of ", stringify!(xdp_txq_info))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xdp_txq_info>())).dev as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(xdp_txq_info),
                "::",
                stringify!(dev)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct xdp_buff {
        pub data: *mut ::cty::c_void,
        pub data_end: *mut ::cty::c_void,
        pub data_meta: *mut ::cty::c_void,
        pub data_hard_start: *mut ::cty::c_void,
        pub rxq: *mut xdp_rxq_info,
        pub txq: *mut xdp_txq_info,
        pub frame_sz: _cargo_bpf_u32,
        pub flags: _cargo_bpf_u32,
    }
    #[test]
    fn bindgen_test_layout_xdp_buff() {
        assert_eq!(
            ::core::mem::size_of::<xdp_buff>(),
            56usize,
            concat!("Size of: ", stringify!(xdp_buff))
        );
        assert_eq!(
            ::core::mem::align_of::<xdp_buff>(),
            8usize,
            concat!("Alignment of ", stringify!(xdp_buff))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xdp_buff>())).data as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(xdp_buff),
                "::",
                stringify!(data)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xdp_buff>())).data_end as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(xdp_buff),
                "::",
                stringify!(data_end)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xdp_buff>())).data_meta as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(xdp_buff),
                "::",
                stringify!(data_meta)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xdp_buff>())).data_hard_start as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(xdp_buff),
                "::",
                stringify!(data_hard_start)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xdp_buff>())).rxq as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(xdp_buff),
                "::",
                stringify!(rxq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xdp_buff>())).txq as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(xdp_buff),
                "::",
                stringify!(txq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xdp_buff>())).frame_sz as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(xdp_buff),
                "::",
                stringify!(frame_sz)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xdp_buff>())).flags as *const _ as usize },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(xdp_buff),
                "::",
                stringify!(flags)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct xdp_frame {
        pub data: *mut ::cty::c_void,
        pub len: _cargo_bpf_u16,
        pub headroom: _cargo_bpf_u16,
        pub metasize: _cargo_bpf_u32,
        pub mem: xdp_mem_info,
        pub dev_rx: *mut net_device,
        pub frame_sz: _cargo_bpf_u32,
        pub flags: _cargo_bpf_u32,
    }
    #[test]
    fn bindgen_test_layout_xdp_frame() {
        assert_eq!(
            ::core::mem::size_of::<xdp_frame>(),
            40usize,
            concat!("Size of: ", stringify!(xdp_frame))
        );
        assert_eq!(
            ::core::mem::align_of::<xdp_frame>(),
            8usize,
            concat!("Alignment of ", stringify!(xdp_frame))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xdp_frame>())).data as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(xdp_frame),
                "::",
                stringify!(data)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xdp_frame>())).len as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(xdp_frame),
                "::",
                stringify!(len)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xdp_frame>())).headroom as *const _ as usize },
            10usize,
            concat!(
                "Offset of field: ",
                stringify!(xdp_frame),
                "::",
                stringify!(headroom)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xdp_frame>())).metasize as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(xdp_frame),
                "::",
                stringify!(metasize)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xdp_frame>())).mem as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(xdp_frame),
                "::",
                stringify!(mem)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xdp_frame>())).dev_rx as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(xdp_frame),
                "::",
                stringify!(dev_rx)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xdp_frame>())).frame_sz as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(xdp_frame),
                "::",
                stringify!(frame_sz)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xdp_frame>())).flags as *const _ as usize },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(xdp_frame),
                "::",
                stringify!(flags)
            )
        );
    }
    pub const xdp_rss_hash_type_XDP_RSS_L3_IPV4: xdp_rss_hash_type = 1;
    pub const xdp_rss_hash_type_XDP_RSS_L3_IPV6: xdp_rss_hash_type = 2;
    pub const xdp_rss_hash_type_XDP_RSS_L3_DYNHDR: xdp_rss_hash_type = 4;
    pub const xdp_rss_hash_type_XDP_RSS_L4: xdp_rss_hash_type = 8;
    pub const xdp_rss_hash_type_XDP_RSS_L4_TCP: xdp_rss_hash_type = 16;
    pub const xdp_rss_hash_type_XDP_RSS_L4_UDP: xdp_rss_hash_type = 32;
    pub const xdp_rss_hash_type_XDP_RSS_L4_SCTP: xdp_rss_hash_type = 64;
    pub const xdp_rss_hash_type_XDP_RSS_L4_IPSEC: xdp_rss_hash_type = 128;
    pub const xdp_rss_hash_type_XDP_RSS_TYPE_NONE: xdp_rss_hash_type = 0;
    pub const xdp_rss_hash_type_XDP_RSS_TYPE_L2: xdp_rss_hash_type = 0;
    pub const xdp_rss_hash_type_XDP_RSS_TYPE_L3_IPV4: xdp_rss_hash_type = 1;
    pub const xdp_rss_hash_type_XDP_RSS_TYPE_L3_IPV6: xdp_rss_hash_type = 2;
    pub const xdp_rss_hash_type_XDP_RSS_TYPE_L3_IPV4_OPT: xdp_rss_hash_type = 5;
    pub const xdp_rss_hash_type_XDP_RSS_TYPE_L3_IPV6_EX: xdp_rss_hash_type = 6;
    pub const xdp_rss_hash_type_XDP_RSS_TYPE_L4_ANY: xdp_rss_hash_type = 8;
    pub const xdp_rss_hash_type_XDP_RSS_TYPE_L4_IPV4_TCP: xdp_rss_hash_type = 25;
    pub const xdp_rss_hash_type_XDP_RSS_TYPE_L4_IPV4_UDP: xdp_rss_hash_type = 41;
    pub const xdp_rss_hash_type_XDP_RSS_TYPE_L4_IPV4_SCTP: xdp_rss_hash_type = 73;
    pub const xdp_rss_hash_type_XDP_RSS_TYPE_L4_IPV4_IPSEC: xdp_rss_hash_type = 137;
    pub const xdp_rss_hash_type_XDP_RSS_TYPE_L4_IPV6_TCP: xdp_rss_hash_type = 26;
    pub const xdp_rss_hash_type_XDP_RSS_TYPE_L4_IPV6_UDP: xdp_rss_hash_type = 42;
    pub const xdp_rss_hash_type_XDP_RSS_TYPE_L4_IPV6_SCTP: xdp_rss_hash_type = 74;
    pub const xdp_rss_hash_type_XDP_RSS_TYPE_L4_IPV6_IPSEC: xdp_rss_hash_type = 138;
    pub const xdp_rss_hash_type_XDP_RSS_TYPE_L4_IPV6_TCP_EX: xdp_rss_hash_type = 30;
    pub const xdp_rss_hash_type_XDP_RSS_TYPE_L4_IPV6_UDP_EX: xdp_rss_hash_type = 46;
    pub const xdp_rss_hash_type_XDP_RSS_TYPE_L4_IPV6_SCTP_EX: xdp_rss_hash_type = 78;
    pub type xdp_rss_hash_type = ::cty::c_uint;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct sockptr_t {
        pub __bindgen_anon_1: sockptr_t__bindgen_ty_1,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
        pub __bindgen_padding_0: [u8; 7usize],
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union sockptr_t__bindgen_ty_1 {
        pub kernel: *mut ::cty::c_void,
        pub user: *mut ::cty::c_void,
    }
    #[test]
    fn bindgen_test_layout_sockptr_t__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<sockptr_t__bindgen_ty_1>(),
            8usize,
            concat!("Size of: ", stringify!(sockptr_t__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<sockptr_t__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(sockptr_t__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sockptr_t__bindgen_ty_1>())).kernel as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sockptr_t__bindgen_ty_1),
                "::",
                stringify!(kernel)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sockptr_t__bindgen_ty_1>())).user as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sockptr_t__bindgen_ty_1),
                "::",
                stringify!(user)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_sockptr_t() {
        assert_eq!(
            ::core::mem::size_of::<sockptr_t>(),
            16usize,
            concat!("Size of: ", stringify!(sockptr_t))
        );
        assert_eq!(
            ::core::mem::align_of::<sockptr_t>(),
            8usize,
            concat!("Alignment of ", stringify!(sockptr_t))
        );
    }
    impl sockptr_t {
        #[inline]
        pub fn is_kernel(&self) -> bool_ {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_is_kernel(&mut self, val: bool_) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(is_kernel: bool_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 1u8, {
                let is_kernel: u8 = unsafe { ::core::mem::transmute(is_kernel) };
                is_kernel as u64
            });
            __bindgen_bitfield_unit
        }
    }
    pub const socket_state_SS_FREE: socket_state = 0;
    pub const socket_state_SS_UNCONNECTED: socket_state = 1;
    pub const socket_state_SS_CONNECTING: socket_state = 2;
    pub const socket_state_SS_CONNECTED: socket_state = 3;
    pub const socket_state_SS_DISCONNECTING: socket_state = 4;
    pub type socket_state = ::cty::c_uint;
    pub const sock_type_SOCK_STREAM: sock_type = 1;
    pub const sock_type_SOCK_DGRAM: sock_type = 2;
    pub const sock_type_SOCK_RAW: sock_type = 3;
    pub const sock_type_SOCK_RDM: sock_type = 4;
    pub const sock_type_SOCK_SEQPACKET: sock_type = 5;
    pub const sock_type_SOCK_DCCP: sock_type = 6;
    pub const sock_type_SOCK_PACKET: sock_type = 10;
    #[doc = " enum sock_type - Socket types"]
    #[doc = " @SOCK_STREAM: stream (connection) socket"]
    #[doc = " @SOCK_DGRAM: datagram (conn.less) socket"]
    #[doc = " @SOCK_RAW: raw socket"]
    #[doc = " @SOCK_RDM: reliably-delivered message"]
    #[doc = " @SOCK_SEQPACKET: sequential packet socket"]
    #[doc = " @SOCK_DCCP: Datagram Congestion Control Protocol socket"]
    #[doc = " @SOCK_PACKET: linux specific way of getting packets at the dev level."]
    #[doc = "\t\t  For writing rarp and other similar things on the user level."]
    #[doc = ""]
    #[doc = " When adding some new socket type please"]
    #[doc = " grep ARCH_HAS_SOCKET_TYPE include/asm-* /socket.h, at least MIPS"]
    #[doc = " overrides this enum for binary compat reasons."]
    pub type sock_type = ::cty::c_uint;
    #[repr(C)]
    #[repr(align(64))]
    #[derive(Copy, Clone)]
    pub struct socket_wq {
        pub wait: wait_queue_head_t,
        pub fasync_list: *mut fasync_struct,
        pub flags: ::cty::c_ulong,
        pub rcu: callback_head,
    }
    #[test]
    fn bindgen_test_layout_socket_wq() {
        assert_eq!(
            ::core::mem::size_of::<socket_wq>(),
            64usize,
            concat!("Size of: ", stringify!(socket_wq))
        );
        assert_eq!(
            ::core::mem::align_of::<socket_wq>(),
            64usize,
            concat!("Alignment of ", stringify!(socket_wq))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<socket_wq>())).wait as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(socket_wq),
                "::",
                stringify!(wait)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<socket_wq>())).fasync_list as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(socket_wq),
                "::",
                stringify!(fasync_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<socket_wq>())).flags as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(socket_wq),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<socket_wq>())).rcu as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(socket_wq),
                "::",
                stringify!(rcu)
            )
        );
    }
    #[doc = "  struct socket - general BSD socket"]
    #[doc = "  @state: socket state (%SS_CONNECTED, etc)"]
    #[doc = "  @type: socket type (%SOCK_STREAM, etc)"]
    #[doc = "  @flags: socket flags (%SOCK_NOSPACE, etc)"]
    #[doc = "  @ops: protocol specific socket operations"]
    #[doc = "  @file: File back pointer for gc"]
    #[doc = "  @sk: internal networking protocol agnostic socket representation"]
    #[doc = "  @wq: wait queue for several uses"]
    #[repr(C)]
    #[repr(align(64))]
    #[derive(Copy, Clone)]
    pub struct socket {
        pub state: socket_state,
        pub type_: ::cty::c_short,
        pub flags: ::cty::c_ulong,
        pub file: *mut file,
        pub sk: *mut sock,
        pub ops: *const proto_ops,
        pub __bindgen_padding_0: [u64; 3usize],
        pub wq: socket_wq,
    }
    #[test]
    fn bindgen_test_layout_socket() {
        assert_eq!(
            ::core::mem::size_of::<socket>(),
            128usize,
            concat!("Size of: ", stringify!(socket))
        );
        assert_eq!(
            ::core::mem::align_of::<socket>(),
            64usize,
            concat!("Alignment of ", stringify!(socket))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<socket>())).state as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(socket),
                "::",
                stringify!(state)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<socket>())).type_ as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(socket),
                "::",
                stringify!(type_)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<socket>())).flags as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(socket),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<socket>())).file as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(socket),
                "::",
                stringify!(file)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<socket>())).sk as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(socket),
                "::",
                stringify!(sk)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<socket>())).ops as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(socket),
                "::",
                stringify!(ops)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<socket>())).wq as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(socket),
                "::",
                stringify!(wq)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct read_descriptor_t {
        pub written: size_t,
        pub count: size_t,
        pub arg: read_descriptor_t__bindgen_ty_1,
        pub error: ::cty::c_int,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union read_descriptor_t__bindgen_ty_1 {
        pub buf: *mut ::cty::c_char,
        pub data: *mut ::cty::c_void,
    }
    #[test]
    fn bindgen_test_layout_read_descriptor_t__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<read_descriptor_t__bindgen_ty_1>(),
            8usize,
            concat!("Size of: ", stringify!(read_descriptor_t__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<read_descriptor_t__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(read_descriptor_t__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<read_descriptor_t__bindgen_ty_1>())).buf as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(read_descriptor_t__bindgen_ty_1),
                "::",
                stringify!(buf)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<read_descriptor_t__bindgen_ty_1>())).data as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(read_descriptor_t__bindgen_ty_1),
                "::",
                stringify!(data)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_read_descriptor_t() {
        assert_eq!(
            ::core::mem::size_of::<read_descriptor_t>(),
            32usize,
            concat!("Size of: ", stringify!(read_descriptor_t))
        );
        assert_eq!(
            ::core::mem::align_of::<read_descriptor_t>(),
            8usize,
            concat!("Alignment of ", stringify!(read_descriptor_t))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<read_descriptor_t>())).written as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(read_descriptor_t),
                "::",
                stringify!(written)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<read_descriptor_t>())).count as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(read_descriptor_t),
                "::",
                stringify!(count)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<read_descriptor_t>())).arg as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(read_descriptor_t),
                "::",
                stringify!(arg)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<read_descriptor_t>())).error as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(read_descriptor_t),
                "::",
                stringify!(error)
            )
        );
    }
    pub type sk_read_actor_t = ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut read_descriptor_t,
            arg2: *mut sk_buff,
            arg3: ::cty::c_uint,
            arg4: size_t,
        ) -> ::cty::c_int,
    >;
    pub type skb_read_actor_t = ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut sock, arg2: *mut sk_buff) -> ::cty::c_int,
    >;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct proto_ops {
        pub family: ::cty::c_int,
        pub owner: *mut module,
        pub release:
            ::core::option::Option<unsafe extern "C" fn(sock: *mut socket) -> ::cty::c_int>,
        pub bind: ::core::option::Option<
            unsafe extern "C" fn(
                sock: *mut socket,
                myaddr: *mut sockaddr,
                sockaddr_len: ::cty::c_int,
            ) -> ::cty::c_int,
        >,
        pub connect: ::core::option::Option<
            unsafe extern "C" fn(
                sock: *mut socket,
                vaddr: *mut sockaddr,
                sockaddr_len: ::cty::c_int,
                flags: ::cty::c_int,
            ) -> ::cty::c_int,
        >,
        pub socketpair: ::core::option::Option<
            unsafe extern "C" fn(sock1: *mut socket, sock2: *mut socket) -> ::cty::c_int,
        >,
        pub accept: ::core::option::Option<
            unsafe extern "C" fn(
                sock: *mut socket,
                newsock: *mut socket,
                flags: ::cty::c_int,
                kern: bool_,
            ) -> ::cty::c_int,
        >,
        pub getname: ::core::option::Option<
            unsafe extern "C" fn(
                sock: *mut socket,
                addr: *mut sockaddr,
                peer: ::cty::c_int,
            ) -> ::cty::c_int,
        >,
        pub poll: ::core::option::Option<
            unsafe extern "C" fn(
                file: *mut file,
                sock: *mut socket,
                wait: *mut poll_table_struct,
            ) -> __poll_t,
        >,
        pub ioctl: ::core::option::Option<
            unsafe extern "C" fn(
                sock: *mut socket,
                cmd: ::cty::c_uint,
                arg: ::cty::c_ulong,
            ) -> ::cty::c_int,
        >,
        pub compat_ioctl: ::core::option::Option<
            unsafe extern "C" fn(
                sock: *mut socket,
                cmd: ::cty::c_uint,
                arg: ::cty::c_ulong,
            ) -> ::cty::c_int,
        >,
        pub gettstamp: ::core::option::Option<
            unsafe extern "C" fn(
                sock: *mut socket,
                userstamp: *mut ::cty::c_void,
                timeval: bool_,
                time32: bool_,
            ) -> ::cty::c_int,
        >,
        pub listen: ::core::option::Option<
            unsafe extern "C" fn(sock: *mut socket, len: ::cty::c_int) -> ::cty::c_int,
        >,
        pub shutdown: ::core::option::Option<
            unsafe extern "C" fn(sock: *mut socket, flags: ::cty::c_int) -> ::cty::c_int,
        >,
        pub setsockopt: ::core::option::Option<
            unsafe extern "C" fn(
                sock: *mut socket,
                level: ::cty::c_int,
                optname: ::cty::c_int,
                optval: sockptr_t,
                optlen: ::cty::c_uint,
            ) -> ::cty::c_int,
        >,
        pub getsockopt: ::core::option::Option<
            unsafe extern "C" fn(
                sock: *mut socket,
                level: ::cty::c_int,
                optname: ::cty::c_int,
                optval: *mut ::cty::c_char,
                optlen: *mut ::cty::c_int,
            ) -> ::cty::c_int,
        >,
        pub show_fdinfo:
            ::core::option::Option<unsafe extern "C" fn(m: *mut seq_file, sock: *mut socket)>,
        pub sendmsg: ::core::option::Option<
            unsafe extern "C" fn(
                sock: *mut socket,
                m: *mut msghdr,
                total_len: size_t,
            ) -> ::cty::c_int,
        >,
        pub recvmsg: ::core::option::Option<
            unsafe extern "C" fn(
                sock: *mut socket,
                m: *mut msghdr,
                total_len: size_t,
                flags: ::cty::c_int,
            ) -> ::cty::c_int,
        >,
        pub mmap: ::core::option::Option<
            unsafe extern "C" fn(
                file: *mut file,
                sock: *mut socket,
                vma: *mut vm_area_struct,
            ) -> ::cty::c_int,
        >,
        pub splice_read: ::core::option::Option<
            unsafe extern "C" fn(
                sock: *mut socket,
                ppos: *mut loff_t,
                pipe: *mut pipe_inode_info,
                len: size_t,
                flags: ::cty::c_uint,
            ) -> ssize_t,
        >,
        pub splice_eof: ::core::option::Option<unsafe extern "C" fn(sock: *mut socket)>,
        pub set_peek_off: ::core::option::Option<
            unsafe extern "C" fn(sk: *mut sock, val: ::cty::c_int) -> ::cty::c_int,
        >,
        pub peek_len:
            ::core::option::Option<unsafe extern "C" fn(sock: *mut socket) -> ::cty::c_int>,
        pub read_sock: ::core::option::Option<
            unsafe extern "C" fn(
                sk: *mut sock,
                desc: *mut read_descriptor_t,
                recv_actor: sk_read_actor_t,
            ) -> ::cty::c_int,
        >,
        pub read_skb: ::core::option::Option<
            unsafe extern "C" fn(sk: *mut sock, recv_actor: skb_read_actor_t) -> ::cty::c_int,
        >,
        pub sendmsg_locked: ::core::option::Option<
            unsafe extern "C" fn(sk: *mut sock, msg: *mut msghdr, size: size_t) -> ::cty::c_int,
        >,
        pub set_rcvlowat: ::core::option::Option<
            unsafe extern "C" fn(sk: *mut sock, val: ::cty::c_int) -> ::cty::c_int,
        >,
    }
    #[test]
    fn bindgen_test_layout_proto_ops() {
        assert_eq!(
            ::core::mem::size_of::<proto_ops>(),
            224usize,
            concat!("Size of: ", stringify!(proto_ops))
        );
        assert_eq!(
            ::core::mem::align_of::<proto_ops>(),
            8usize,
            concat!("Alignment of ", stringify!(proto_ops))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto_ops>())).family as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(proto_ops),
                "::",
                stringify!(family)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto_ops>())).owner as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(proto_ops),
                "::",
                stringify!(owner)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto_ops>())).release as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(proto_ops),
                "::",
                stringify!(release)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto_ops>())).bind as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(proto_ops),
                "::",
                stringify!(bind)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto_ops>())).connect as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(proto_ops),
                "::",
                stringify!(connect)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto_ops>())).socketpair as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(proto_ops),
                "::",
                stringify!(socketpair)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto_ops>())).accept as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(proto_ops),
                "::",
                stringify!(accept)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto_ops>())).getname as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(proto_ops),
                "::",
                stringify!(getname)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto_ops>())).poll as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(proto_ops),
                "::",
                stringify!(poll)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto_ops>())).ioctl as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(proto_ops),
                "::",
                stringify!(ioctl)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto_ops>())).compat_ioctl as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(proto_ops),
                "::",
                stringify!(compat_ioctl)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto_ops>())).gettstamp as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(proto_ops),
                "::",
                stringify!(gettstamp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto_ops>())).listen as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(proto_ops),
                "::",
                stringify!(listen)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto_ops>())).shutdown as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(proto_ops),
                "::",
                stringify!(shutdown)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto_ops>())).setsockopt as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(proto_ops),
                "::",
                stringify!(setsockopt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto_ops>())).getsockopt as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(proto_ops),
                "::",
                stringify!(getsockopt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto_ops>())).show_fdinfo as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(proto_ops),
                "::",
                stringify!(show_fdinfo)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto_ops>())).sendmsg as *const _ as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(proto_ops),
                "::",
                stringify!(sendmsg)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto_ops>())).recvmsg as *const _ as usize },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(proto_ops),
                "::",
                stringify!(recvmsg)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto_ops>())).mmap as *const _ as usize },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(proto_ops),
                "::",
                stringify!(mmap)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto_ops>())).splice_read as *const _ as usize },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(proto_ops),
                "::",
                stringify!(splice_read)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto_ops>())).splice_eof as *const _ as usize },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(proto_ops),
                "::",
                stringify!(splice_eof)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto_ops>())).set_peek_off as *const _ as usize },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(proto_ops),
                "::",
                stringify!(set_peek_off)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto_ops>())).peek_len as *const _ as usize },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(proto_ops),
                "::",
                stringify!(peek_len)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto_ops>())).read_sock as *const _ as usize },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(proto_ops),
                "::",
                stringify!(read_sock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto_ops>())).read_skb as *const _ as usize },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(proto_ops),
                "::",
                stringify!(read_skb)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto_ops>())).sendmsg_locked as *const _ as usize },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(proto_ops),
                "::",
                stringify!(sendmsg_locked)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto_ops>())).set_rcvlowat as *const _ as usize },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(proto_ops),
                "::",
                stringify!(set_rcvlowat)
            )
        );
    }
    pub const SOCK_WAKE_IO: ::cty::c_uint = 0;
    pub const SOCK_WAKE_WAITD: ::cty::c_uint = 1;
    pub const SOCK_WAKE_SPACE: ::cty::c_uint = 2;
    pub const SOCK_WAKE_URG: ::cty::c_uint = 3;
    pub type _bindgen_ty_177 = ::cty::c_uint;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct xfrm_policy {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct xfrm_state {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_map {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_prog_aux {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct sync_serial_settings {
        pub clock_rate: ::cty::c_uint,
        pub clock_type: ::cty::c_uint,
        pub loopback: ::cty::c_ushort,
    }
    #[test]
    fn bindgen_test_layout_sync_serial_settings() {
        assert_eq!(
            ::core::mem::size_of::<sync_serial_settings>(),
            12usize,
            concat!("Size of: ", stringify!(sync_serial_settings))
        );
        assert_eq!(
            ::core::mem::align_of::<sync_serial_settings>(),
            4usize,
            concat!("Alignment of ", stringify!(sync_serial_settings))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sync_serial_settings>())).clock_rate as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sync_serial_settings),
                "::",
                stringify!(clock_rate)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sync_serial_settings>())).clock_type as *const _ as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(sync_serial_settings),
                "::",
                stringify!(clock_type)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sync_serial_settings>())).loopback as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sync_serial_settings),
                "::",
                stringify!(loopback)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct te1_settings {
        pub clock_rate: ::cty::c_uint,
        pub clock_type: ::cty::c_uint,
        pub loopback: ::cty::c_ushort,
        pub slot_map: ::cty::c_uint,
    }
    #[test]
    fn bindgen_test_layout_te1_settings() {
        assert_eq!(
            ::core::mem::size_of::<te1_settings>(),
            16usize,
            concat!("Size of: ", stringify!(te1_settings))
        );
        assert_eq!(
            ::core::mem::align_of::<te1_settings>(),
            4usize,
            concat!("Alignment of ", stringify!(te1_settings))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<te1_settings>())).clock_rate as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(te1_settings),
                "::",
                stringify!(clock_rate)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<te1_settings>())).clock_type as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(te1_settings),
                "::",
                stringify!(clock_type)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<te1_settings>())).loopback as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(te1_settings),
                "::",
                stringify!(loopback)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<te1_settings>())).slot_map as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(te1_settings),
                "::",
                stringify!(slot_map)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct raw_hdlc_proto {
        pub encoding: ::cty::c_ushort,
        pub parity: ::cty::c_ushort,
    }
    #[test]
    fn bindgen_test_layout_raw_hdlc_proto() {
        assert_eq!(
            ::core::mem::size_of::<raw_hdlc_proto>(),
            4usize,
            concat!("Size of: ", stringify!(raw_hdlc_proto))
        );
        assert_eq!(
            ::core::mem::align_of::<raw_hdlc_proto>(),
            2usize,
            concat!("Alignment of ", stringify!(raw_hdlc_proto))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<raw_hdlc_proto>())).encoding as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(raw_hdlc_proto),
                "::",
                stringify!(encoding)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<raw_hdlc_proto>())).parity as *const _ as usize },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(raw_hdlc_proto),
                "::",
                stringify!(parity)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct fr_proto {
        pub t391: ::cty::c_uint,
        pub t392: ::cty::c_uint,
        pub n391: ::cty::c_uint,
        pub n392: ::cty::c_uint,
        pub n393: ::cty::c_uint,
        pub lmi: ::cty::c_ushort,
        pub dce: ::cty::c_ushort,
    }
    #[test]
    fn bindgen_test_layout_fr_proto() {
        assert_eq!(
            ::core::mem::size_of::<fr_proto>(),
            24usize,
            concat!("Size of: ", stringify!(fr_proto))
        );
        assert_eq!(
            ::core::mem::align_of::<fr_proto>(),
            4usize,
            concat!("Alignment of ", stringify!(fr_proto))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fr_proto>())).t391 as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fr_proto),
                "::",
                stringify!(t391)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fr_proto>())).t392 as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(fr_proto),
                "::",
                stringify!(t392)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fr_proto>())).n391 as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fr_proto),
                "::",
                stringify!(n391)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fr_proto>())).n392 as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(fr_proto),
                "::",
                stringify!(n392)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fr_proto>())).n393 as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fr_proto),
                "::",
                stringify!(n393)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fr_proto>())).lmi as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(fr_proto),
                "::",
                stringify!(lmi)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fr_proto>())).dce as *const _ as usize },
            22usize,
            concat!(
                "Offset of field: ",
                stringify!(fr_proto),
                "::",
                stringify!(dce)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct fr_proto_pvc {
        pub dlci: ::cty::c_uint,
    }
    #[test]
    fn bindgen_test_layout_fr_proto_pvc() {
        assert_eq!(
            ::core::mem::size_of::<fr_proto_pvc>(),
            4usize,
            concat!("Size of: ", stringify!(fr_proto_pvc))
        );
        assert_eq!(
            ::core::mem::align_of::<fr_proto_pvc>(),
            4usize,
            concat!("Alignment of ", stringify!(fr_proto_pvc))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fr_proto_pvc>())).dlci as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fr_proto_pvc),
                "::",
                stringify!(dlci)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct fr_proto_pvc_info {
        pub dlci: ::cty::c_uint,
        pub master: [::cty::c_char; 16usize],
    }
    #[test]
    fn bindgen_test_layout_fr_proto_pvc_info() {
        assert_eq!(
            ::core::mem::size_of::<fr_proto_pvc_info>(),
            20usize,
            concat!("Size of: ", stringify!(fr_proto_pvc_info))
        );
        assert_eq!(
            ::core::mem::align_of::<fr_proto_pvc_info>(),
            4usize,
            concat!("Alignment of ", stringify!(fr_proto_pvc_info))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fr_proto_pvc_info>())).dlci as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fr_proto_pvc_info),
                "::",
                stringify!(dlci)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fr_proto_pvc_info>())).master as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(fr_proto_pvc_info),
                "::",
                stringify!(master)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cisco_proto {
        pub interval: ::cty::c_uint,
        pub timeout: ::cty::c_uint,
    }
    #[test]
    fn bindgen_test_layout_cisco_proto() {
        assert_eq!(
            ::core::mem::size_of::<cisco_proto>(),
            8usize,
            concat!("Size of: ", stringify!(cisco_proto))
        );
        assert_eq!(
            ::core::mem::align_of::<cisco_proto>(),
            4usize,
            concat!("Alignment of ", stringify!(cisco_proto))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cisco_proto>())).interval as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cisco_proto),
                "::",
                stringify!(interval)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<cisco_proto>())).timeout as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(cisco_proto),
                "::",
                stringify!(timeout)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct x25_hdlc_proto {
        pub dce: ::cty::c_ushort,
        pub modulo: ::cty::c_uint,
        pub window: ::cty::c_uint,
        pub t1: ::cty::c_uint,
        pub t2: ::cty::c_uint,
        pub n2: ::cty::c_uint,
    }
    #[test]
    fn bindgen_test_layout_x25_hdlc_proto() {
        assert_eq!(
            ::core::mem::size_of::<x25_hdlc_proto>(),
            24usize,
            concat!("Size of: ", stringify!(x25_hdlc_proto))
        );
        assert_eq!(
            ::core::mem::align_of::<x25_hdlc_proto>(),
            4usize,
            concat!("Alignment of ", stringify!(x25_hdlc_proto))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<x25_hdlc_proto>())).dce as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(x25_hdlc_proto),
                "::",
                stringify!(dce)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<x25_hdlc_proto>())).modulo as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(x25_hdlc_proto),
                "::",
                stringify!(modulo)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<x25_hdlc_proto>())).window as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(x25_hdlc_proto),
                "::",
                stringify!(window)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<x25_hdlc_proto>())).t1 as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(x25_hdlc_proto),
                "::",
                stringify!(t1)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<x25_hdlc_proto>())).t2 as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(x25_hdlc_proto),
                "::",
                stringify!(t2)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<x25_hdlc_proto>())).n2 as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(x25_hdlc_proto),
                "::",
                stringify!(n2)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ifmap {
        pub mem_start: ::cty::c_ulong,
        pub mem_end: ::cty::c_ulong,
        pub base_addr: ::cty::c_ushort,
        pub irq: ::cty::c_uchar,
        pub dma: ::cty::c_uchar,
        pub port: ::cty::c_uchar,
    }
    #[test]
    fn bindgen_test_layout_ifmap() {
        assert_eq!(
            ::core::mem::size_of::<ifmap>(),
            24usize,
            concat!("Size of: ", stringify!(ifmap))
        );
        assert_eq!(
            ::core::mem::align_of::<ifmap>(),
            8usize,
            concat!("Alignment of ", stringify!(ifmap))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ifmap>())).mem_start as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifmap),
                "::",
                stringify!(mem_start)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ifmap>())).mem_end as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ifmap),
                "::",
                stringify!(mem_end)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ifmap>())).base_addr as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ifmap),
                "::",
                stringify!(base_addr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ifmap>())).irq as *const _ as usize },
            18usize,
            concat!(
                "Offset of field: ",
                stringify!(ifmap),
                "::",
                stringify!(irq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ifmap>())).dma as *const _ as usize },
            19usize,
            concat!(
                "Offset of field: ",
                stringify!(ifmap),
                "::",
                stringify!(dma)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ifmap>())).port as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(ifmap),
                "::",
                stringify!(port)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct if_settings {
        pub type_: ::cty::c_uint,
        pub size: ::cty::c_uint,
        pub ifs_ifsu: if_settings__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union if_settings__bindgen_ty_1 {
        pub raw_hdlc: *mut raw_hdlc_proto,
        pub cisco: *mut cisco_proto,
        pub fr: *mut fr_proto,
        pub fr_pvc: *mut fr_proto_pvc,
        pub fr_pvc_info: *mut fr_proto_pvc_info,
        pub x25: *mut x25_hdlc_proto,
        pub sync: *mut sync_serial_settings,
        pub te1: *mut te1_settings,
    }
    #[test]
    fn bindgen_test_layout_if_settings__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<if_settings__bindgen_ty_1>(),
            8usize,
            concat!("Size of: ", stringify!(if_settings__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<if_settings__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(if_settings__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<if_settings__bindgen_ty_1>())).raw_hdlc as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(if_settings__bindgen_ty_1),
                "::",
                stringify!(raw_hdlc)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<if_settings__bindgen_ty_1>())).cisco as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(if_settings__bindgen_ty_1),
                "::",
                stringify!(cisco)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<if_settings__bindgen_ty_1>())).fr as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(if_settings__bindgen_ty_1),
                "::",
                stringify!(fr)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<if_settings__bindgen_ty_1>())).fr_pvc as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(if_settings__bindgen_ty_1),
                "::",
                stringify!(fr_pvc)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<if_settings__bindgen_ty_1>())).fr_pvc_info as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(if_settings__bindgen_ty_1),
                "::",
                stringify!(fr_pvc_info)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<if_settings__bindgen_ty_1>())).x25 as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(if_settings__bindgen_ty_1),
                "::",
                stringify!(x25)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<if_settings__bindgen_ty_1>())).sync as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(if_settings__bindgen_ty_1),
                "::",
                stringify!(sync)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<if_settings__bindgen_ty_1>())).te1 as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(if_settings__bindgen_ty_1),
                "::",
                stringify!(te1)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_if_settings() {
        assert_eq!(
            ::core::mem::size_of::<if_settings>(),
            16usize,
            concat!("Size of: ", stringify!(if_settings))
        );
        assert_eq!(
            ::core::mem::align_of::<if_settings>(),
            8usize,
            concat!("Alignment of ", stringify!(if_settings))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<if_settings>())).type_ as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(if_settings),
                "::",
                stringify!(type_)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<if_settings>())).size as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(if_settings),
                "::",
                stringify!(size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<if_settings>())).ifs_ifsu as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(if_settings),
                "::",
                stringify!(ifs_ifsu)
            )
        );
    }
    #[repr(C)]
    pub struct ifreq {
        pub ifr_ifrn: ifreq__bindgen_ty_1,
        pub ifr_ifru: ifreq__bindgen_ty_2,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union ifreq__bindgen_ty_1 {
        pub ifrn_name: [::cty::c_char; 16usize],
    }
    #[test]
    fn bindgen_test_layout_ifreq__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<ifreq__bindgen_ty_1>(),
            16usize,
            concat!("Size of: ", stringify!(ifreq__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<ifreq__bindgen_ty_1>(),
            1usize,
            concat!("Alignment of ", stringify!(ifreq__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ifreq__bindgen_ty_1>())).ifrn_name as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifreq__bindgen_ty_1),
                "::",
                stringify!(ifrn_name)
            )
        );
    }
    #[repr(C)]
    pub struct ifreq__bindgen_ty_2 {
        pub ifru_addr: __BindgenUnionField<sockaddr>,
        pub ifru_dstaddr: __BindgenUnionField<sockaddr>,
        pub ifru_broadaddr: __BindgenUnionField<sockaddr>,
        pub ifru_netmask: __BindgenUnionField<sockaddr>,
        pub ifru_hwaddr: __BindgenUnionField<sockaddr>,
        pub ifru_flags: __BindgenUnionField<::cty::c_short>,
        pub ifru_ivalue: __BindgenUnionField<::cty::c_int>,
        pub ifru_mtu: __BindgenUnionField<::cty::c_int>,
        pub ifru_map: __BindgenUnionField<ifmap>,
        pub ifru_slave: __BindgenUnionField<[::cty::c_char; 16usize]>,
        pub ifru_newname: __BindgenUnionField<[::cty::c_char; 16usize]>,
        pub ifru_data: __BindgenUnionField<*mut ::cty::c_void>,
        pub ifru_settings: __BindgenUnionField<if_settings>,
        pub bindgen_union_field: [u64; 3usize],
    }
    #[test]
    fn bindgen_test_layout_ifreq__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<ifreq__bindgen_ty_2>(),
            24usize,
            concat!("Size of: ", stringify!(ifreq__bindgen_ty_2))
        );
        assert_eq!(
            ::core::mem::align_of::<ifreq__bindgen_ty_2>(),
            8usize,
            concat!("Alignment of ", stringify!(ifreq__bindgen_ty_2))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ifreq__bindgen_ty_2>())).ifru_addr as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifreq__bindgen_ty_2),
                "::",
                stringify!(ifru_addr)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ifreq__bindgen_ty_2>())).ifru_dstaddr as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifreq__bindgen_ty_2),
                "::",
                stringify!(ifru_dstaddr)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ifreq__bindgen_ty_2>())).ifru_broadaddr as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifreq__bindgen_ty_2),
                "::",
                stringify!(ifru_broadaddr)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ifreq__bindgen_ty_2>())).ifru_netmask as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifreq__bindgen_ty_2),
                "::",
                stringify!(ifru_netmask)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ifreq__bindgen_ty_2>())).ifru_hwaddr as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifreq__bindgen_ty_2),
                "::",
                stringify!(ifru_hwaddr)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ifreq__bindgen_ty_2>())).ifru_flags as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifreq__bindgen_ty_2),
                "::",
                stringify!(ifru_flags)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ifreq__bindgen_ty_2>())).ifru_ivalue as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifreq__bindgen_ty_2),
                "::",
                stringify!(ifru_ivalue)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ifreq__bindgen_ty_2>())).ifru_mtu as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifreq__bindgen_ty_2),
                "::",
                stringify!(ifru_mtu)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ifreq__bindgen_ty_2>())).ifru_map as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifreq__bindgen_ty_2),
                "::",
                stringify!(ifru_map)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ifreq__bindgen_ty_2>())).ifru_slave as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifreq__bindgen_ty_2),
                "::",
                stringify!(ifru_slave)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ifreq__bindgen_ty_2>())).ifru_newname as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifreq__bindgen_ty_2),
                "::",
                stringify!(ifru_newname)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ifreq__bindgen_ty_2>())).ifru_data as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifreq__bindgen_ty_2),
                "::",
                stringify!(ifru_data)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ifreq__bindgen_ty_2>())).ifru_settings as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifreq__bindgen_ty_2),
                "::",
                stringify!(ifru_settings)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_ifreq() {
        assert_eq!(
            ::core::mem::size_of::<ifreq>(),
            40usize,
            concat!("Size of: ", stringify!(ifreq))
        );
        assert_eq!(
            ::core::mem::align_of::<ifreq>(),
            8usize,
            concat!("Alignment of ", stringify!(ifreq))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ifreq>())).ifr_ifrn as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifreq),
                "::",
                stringify!(ifr_ifrn)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ifreq>())).ifr_ifru as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ifreq),
                "::",
                stringify!(ifr_ifru)
            )
        );
    }
    pub type compat_long_t = s32;
    pub type compat_uptr_t = _cargo_bpf_u32;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct compat_robust_list {
        pub next: compat_uptr_t,
    }
    #[test]
    fn bindgen_test_layout_compat_robust_list() {
        assert_eq!(
            ::core::mem::size_of::<compat_robust_list>(),
            4usize,
            concat!("Size of: ", stringify!(compat_robust_list))
        );
        assert_eq!(
            ::core::mem::align_of::<compat_robust_list>(),
            4usize,
            concat!("Alignment of ", stringify!(compat_robust_list))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<compat_robust_list>())).next as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(compat_robust_list),
                "::",
                stringify!(next)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct compat_robust_list_head {
        pub list: compat_robust_list,
        pub futex_offset: compat_long_t,
        pub list_op_pending: compat_uptr_t,
    }
    #[test]
    fn bindgen_test_layout_compat_robust_list_head() {
        assert_eq!(
            ::core::mem::size_of::<compat_robust_list_head>(),
            12usize,
            concat!("Size of: ", stringify!(compat_robust_list_head))
        );
        assert_eq!(
            ::core::mem::align_of::<compat_robust_list_head>(),
            4usize,
            concat!("Alignment of ", stringify!(compat_robust_list_head))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<compat_robust_list_head>())).list as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(compat_robust_list_head),
                "::",
                stringify!(list)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<compat_robust_list_head>())).futex_offset as *const _
                    as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(compat_robust_list_head),
                "::",
                stringify!(futex_offset)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<compat_robust_list_head>())).list_op_pending as *const _
                    as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(compat_robust_list_head),
                "::",
                stringify!(list_op_pending)
            )
        );
    }
    #[doc = " struct nlmsghdr - fixed format metadata header of Netlink messages"]
    #[doc = " @nlmsg_len:   Length of message including header"]
    #[doc = " @nlmsg_type:  Message content type"]
    #[doc = " @nlmsg_flags: Additional flags"]
    #[doc = " @nlmsg_seq:   Sequence number"]
    #[doc = " @nlmsg_pid:   Sending process port ID"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nlmsghdr {
        pub nlmsg_len: __u32,
        pub nlmsg_type: __u16,
        pub nlmsg_flags: __u16,
        pub nlmsg_seq: __u32,
        pub nlmsg_pid: __u32,
    }
    #[test]
    fn bindgen_test_layout_nlmsghdr() {
        assert_eq!(
            ::core::mem::size_of::<nlmsghdr>(),
            16usize,
            concat!("Size of: ", stringify!(nlmsghdr))
        );
        assert_eq!(
            ::core::mem::align_of::<nlmsghdr>(),
            4usize,
            concat!("Alignment of ", stringify!(nlmsghdr))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<nlmsghdr>())).nlmsg_len as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(nlmsghdr),
                "::",
                stringify!(nlmsg_len)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<nlmsghdr>())).nlmsg_type as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(nlmsghdr),
                "::",
                stringify!(nlmsg_type)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<nlmsghdr>())).nlmsg_flags as *const _ as usize },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(nlmsghdr),
                "::",
                stringify!(nlmsg_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<nlmsghdr>())).nlmsg_seq as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(nlmsghdr),
                "::",
                stringify!(nlmsg_seq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<nlmsghdr>())).nlmsg_pid as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(nlmsghdr),
                "::",
                stringify!(nlmsg_pid)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nlattr {
        pub nla_len: __u16,
        pub nla_type: __u16,
    }
    #[test]
    fn bindgen_test_layout_nlattr() {
        assert_eq!(
            ::core::mem::size_of::<nlattr>(),
            4usize,
            concat!("Size of: ", stringify!(nlattr))
        );
        assert_eq!(
            ::core::mem::align_of::<nlattr>(),
            2usize,
            concat!("Alignment of ", stringify!(nlattr))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<nlattr>())).nla_len as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(nlattr),
                "::",
                stringify!(nla_len)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<nlattr>())).nla_type as *const _ as usize },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(nlattr),
                "::",
                stringify!(nla_type)
            )
        );
    }
    #[doc = " struct netlink_ext_ack - netlink extended ACK report struct"]
    #[doc = " @_msg: message string to report - don't access directly, use"]
    #[doc = "\t%NL_SET_ERR_MSG"]
    #[doc = " @bad_attr: attribute with error"]
    #[doc = " @policy: policy for a bad attribute"]
    #[doc = " @miss_type: attribute type which was missing"]
    #[doc = " @miss_nest: nest missing an attribute (%NULL if missing top level attr)"]
    #[doc = " @cookie: cookie data to return to userspace (for success)"]
    #[doc = " @cookie_len: actual cookie data length"]
    #[doc = " @_msg_buf: output buffer for formatted message strings - don't access"]
    #[doc = "\tdirectly, use %NL_SET_ERR_MSG_FMT"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct netlink_ext_ack {
        pub _msg: *const ::cty::c_char,
        pub bad_attr: *const nlattr,
        pub policy: *const nla_policy,
        pub miss_nest: *const nlattr,
        pub miss_type: _cargo_bpf_u16,
        pub cookie: [_cargo_bpf_u8; 20usize],
        pub cookie_len: _cargo_bpf_u8,
        pub _msg_buf: [::cty::c_char; 80usize],
    }
    #[test]
    fn bindgen_test_layout_netlink_ext_ack() {
        assert_eq!(
            ::core::mem::size_of::<netlink_ext_ack>(),
            136usize,
            concat!("Size of: ", stringify!(netlink_ext_ack))
        );
        assert_eq!(
            ::core::mem::align_of::<netlink_ext_ack>(),
            8usize,
            concat!("Alignment of ", stringify!(netlink_ext_ack))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netlink_ext_ack>()))._msg as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(netlink_ext_ack),
                "::",
                stringify!(_msg)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netlink_ext_ack>())).bad_attr as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(netlink_ext_ack),
                "::",
                stringify!(bad_attr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netlink_ext_ack>())).policy as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(netlink_ext_ack),
                "::",
                stringify!(policy)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netlink_ext_ack>())).miss_nest as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(netlink_ext_ack),
                "::",
                stringify!(miss_nest)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netlink_ext_ack>())).miss_type as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(netlink_ext_ack),
                "::",
                stringify!(miss_type)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netlink_ext_ack>())).cookie as *const _ as usize },
            34usize,
            concat!(
                "Offset of field: ",
                stringify!(netlink_ext_ack),
                "::",
                stringify!(cookie)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netlink_ext_ack>())).cookie_len as *const _ as usize },
            54usize,
            concat!(
                "Offset of field: ",
                stringify!(netlink_ext_ack),
                "::",
                stringify!(cookie_len)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netlink_ext_ack>()))._msg_buf as *const _ as usize },
            55usize,
            concat!(
                "Offset of field: ",
                stringify!(netlink_ext_ack),
                "::",
                stringify!(_msg_buf)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct netlink_callback {
        pub skb: *mut sk_buff,
        pub nlh: *const nlmsghdr,
        pub dump: ::core::option::Option<
            unsafe extern "C" fn(skb: *mut sk_buff, cb: *mut netlink_callback) -> ::cty::c_int,
        >,
        pub done:
            ::core::option::Option<unsafe extern "C" fn(cb: *mut netlink_callback) -> ::cty::c_int>,
        pub data: *mut ::cty::c_void,
        pub module: *mut module,
        pub extack: *mut netlink_ext_ack,
        pub family: _cargo_bpf_u16,
        pub answer_flags: _cargo_bpf_u16,
        pub min_dump_alloc: _cargo_bpf_u32,
        pub prev_seq: ::cty::c_uint,
        pub seq: ::cty::c_uint,
        pub strict_check: bool_,
        pub __bindgen_anon_1: netlink_callback__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union netlink_callback__bindgen_ty_1 {
        pub ctx: [_cargo_bpf_u8; 48usize],
        pub args: [::cty::c_long; 6usize],
    }
    #[test]
    fn bindgen_test_layout_netlink_callback__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<netlink_callback__bindgen_ty_1>(),
            48usize,
            concat!("Size of: ", stringify!(netlink_callback__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<netlink_callback__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(netlink_callback__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netlink_callback__bindgen_ty_1>())).ctx as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(netlink_callback__bindgen_ty_1),
                "::",
                stringify!(ctx)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netlink_callback__bindgen_ty_1>())).args as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(netlink_callback__bindgen_ty_1),
                "::",
                stringify!(args)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_netlink_callback() {
        assert_eq!(
            ::core::mem::size_of::<netlink_callback>(),
            128usize,
            concat!("Size of: ", stringify!(netlink_callback))
        );
        assert_eq!(
            ::core::mem::align_of::<netlink_callback>(),
            8usize,
            concat!("Alignment of ", stringify!(netlink_callback))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netlink_callback>())).skb as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(netlink_callback),
                "::",
                stringify!(skb)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netlink_callback>())).nlh as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(netlink_callback),
                "::",
                stringify!(nlh)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netlink_callback>())).dump as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(netlink_callback),
                "::",
                stringify!(dump)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netlink_callback>())).done as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(netlink_callback),
                "::",
                stringify!(done)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netlink_callback>())).data as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(netlink_callback),
                "::",
                stringify!(data)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netlink_callback>())).module as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(netlink_callback),
                "::",
                stringify!(module)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netlink_callback>())).extack as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(netlink_callback),
                "::",
                stringify!(extack)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netlink_callback>())).family as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(netlink_callback),
                "::",
                stringify!(family)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netlink_callback>())).answer_flags as *const _ as usize
            },
            58usize,
            concat!(
                "Offset of field: ",
                stringify!(netlink_callback),
                "::",
                stringify!(answer_flags)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netlink_callback>())).min_dump_alloc as *const _ as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(netlink_callback),
                "::",
                stringify!(min_dump_alloc)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netlink_callback>())).prev_seq as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(netlink_callback),
                "::",
                stringify!(prev_seq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netlink_callback>())).seq as *const _ as usize },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(netlink_callback),
                "::",
                stringify!(seq)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netlink_callback>())).strict_check as *const _ as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(netlink_callback),
                "::",
                stringify!(strict_check)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ndmsg {
        pub ndm_family: __u8,
        pub ndm_pad1: __u8,
        pub ndm_pad2: __u16,
        pub ndm_ifindex: __s32,
        pub ndm_state: __u16,
        pub ndm_flags: __u8,
        pub ndm_type: __u8,
    }
    #[test]
    fn bindgen_test_layout_ndmsg() {
        assert_eq!(
            ::core::mem::size_of::<ndmsg>(),
            12usize,
            concat!("Size of: ", stringify!(ndmsg))
        );
        assert_eq!(
            ::core::mem::align_of::<ndmsg>(),
            4usize,
            concat!("Alignment of ", stringify!(ndmsg))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ndmsg>())).ndm_family as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ndmsg),
                "::",
                stringify!(ndm_family)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ndmsg>())).ndm_pad1 as *const _ as usize },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(ndmsg),
                "::",
                stringify!(ndm_pad1)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ndmsg>())).ndm_pad2 as *const _ as usize },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(ndmsg),
                "::",
                stringify!(ndm_pad2)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ndmsg>())).ndm_ifindex as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(ndmsg),
                "::",
                stringify!(ndm_ifindex)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ndmsg>())).ndm_state as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ndmsg),
                "::",
                stringify!(ndm_state)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ndmsg>())).ndm_flags as *const _ as usize },
            10usize,
            concat!(
                "Offset of field: ",
                stringify!(ndmsg),
                "::",
                stringify!(ndm_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ndmsg>())).ndm_type as *const _ as usize },
            11usize,
            concat!(
                "Offset of field: ",
                stringify!(ndmsg),
                "::",
                stringify!(ndm_type)
            )
        );
    }
    #[doc = " struct rtnl_link_stats64 - The main device statistics structure."]
    #[doc = ""]
    #[doc = " @rx_packets: Number of good packets received by the interface."]
    #[doc = "   For hardware interfaces counts all good packets received from the device"]
    #[doc = "   by the host, including packets which host had to drop at various stages"]
    #[doc = "   of processing (even in the driver)."]
    #[doc = ""]
    #[doc = " @tx_packets: Number of packets successfully transmitted."]
    #[doc = "   For hardware interfaces counts packets which host was able to successfully"]
    #[doc = "   hand over to the device, which does not necessarily mean that packets"]
    #[doc = "   had been successfully transmitted out of the device, only that device"]
    #[doc = "   acknowledged it copied them out of host memory."]
    #[doc = ""]
    #[doc = " @rx_bytes: Number of good received bytes, corresponding to @rx_packets."]
    #[doc = ""]
    #[doc = "   For IEEE 802.3 devices should count the length of Ethernet Frames"]
    #[doc = "   excluding the FCS."]
    #[doc = ""]
    #[doc = " @tx_bytes: Number of good transmitted bytes, corresponding to @tx_packets."]
    #[doc = ""]
    #[doc = "   For IEEE 802.3 devices should count the length of Ethernet Frames"]
    #[doc = "   excluding the FCS."]
    #[doc = ""]
    #[doc = " @rx_errors: Total number of bad packets received on this network device."]
    #[doc = "   This counter must include events counted by @rx_length_errors,"]
    #[doc = "   @rx_crc_errors, @rx_frame_errors and other errors not otherwise"]
    #[doc = "   counted."]
    #[doc = ""]
    #[doc = " @tx_errors: Total number of transmit problems."]
    #[doc = "   This counter must include events counter by @tx_aborted_errors,"]
    #[doc = "   @tx_carrier_errors, @tx_fifo_errors, @tx_heartbeat_errors,"]
    #[doc = "   @tx_window_errors and other errors not otherwise counted."]
    #[doc = ""]
    #[doc = " @rx_dropped: Number of packets received but not processed,"]
    #[doc = "   e.g. due to lack of resources or unsupported protocol."]
    #[doc = "   For hardware interfaces this counter may include packets discarded"]
    #[doc = "   due to L2 address filtering but should not include packets dropped"]
    #[doc = "   by the device due to buffer exhaustion which are counted separately in"]
    #[doc = "   @rx_missed_errors (since procfs folds those two counters together)."]
    #[doc = ""]
    #[doc = " @tx_dropped: Number of packets dropped on their way to transmission,"]
    #[doc = "   e.g. due to lack of resources."]
    #[doc = ""]
    #[doc = " @multicast: Multicast packets received."]
    #[doc = "   For hardware interfaces this statistic is commonly calculated"]
    #[doc = "   at the device level (unlike @rx_packets) and therefore may include"]
    #[doc = "   packets which did not reach the host."]
    #[doc = ""]
    #[doc = "   For IEEE 802.3 devices this counter may be equivalent to:"]
    #[doc = ""]
    #[doc = "    - 30.3.1.1.21 aMulticastFramesReceivedOK"]
    #[doc = ""]
    #[doc = " @collisions: Number of collisions during packet transmissions."]
    #[doc = ""]
    #[doc = " @rx_length_errors: Number of packets dropped due to invalid length."]
    #[doc = "   Part of aggregate \"frame\" errors in `/proc/net/dev`."]
    #[doc = ""]
    #[doc = "   For IEEE 802.3 devices this counter should be equivalent to a sum"]
    #[doc = "   of the following attributes:"]
    #[doc = ""]
    #[doc = "    - 30.3.1.1.23 aInRangeLengthErrors"]
    #[doc = "    - 30.3.1.1.24 aOutOfRangeLengthField"]
    #[doc = "    - 30.3.1.1.25 aFrameTooLongErrors"]
    #[doc = ""]
    #[doc = " @rx_over_errors: Receiver FIFO overflow event counter."]
    #[doc = ""]
    #[doc = "   Historically the count of overflow events. Such events may be"]
    #[doc = "   reported in the receive descriptors or via interrupts, and may"]
    #[doc = "   not correspond one-to-one with dropped packets."]
    #[doc = ""]
    #[doc = "   The recommended interpretation for high speed interfaces is -"]
    #[doc = "   number of packets dropped because they did not fit into buffers"]
    #[doc = "   provided by the host, e.g. packets larger than MTU or next buffer"]
    #[doc = "   in the ring was not available for a scatter transfer."]
    #[doc = ""]
    #[doc = "   Part of aggregate \"frame\" errors in `/proc/net/dev`."]
    #[doc = ""]
    #[doc = "   This statistics was historically used interchangeably with"]
    #[doc = "   @rx_fifo_errors."]
    #[doc = ""]
    #[doc = "   This statistic corresponds to hardware events and is not commonly used"]
    #[doc = "   on software devices."]
    #[doc = ""]
    #[doc = " @rx_crc_errors: Number of packets received with a CRC error."]
    #[doc = "   Part of aggregate \"frame\" errors in `/proc/net/dev`."]
    #[doc = ""]
    #[doc = "   For IEEE 802.3 devices this counter must be equivalent to:"]
    #[doc = ""]
    #[doc = "    - 30.3.1.1.6 aFrameCheckSequenceErrors"]
    #[doc = ""]
    #[doc = " @rx_frame_errors: Receiver frame alignment errors."]
    #[doc = "   Part of aggregate \"frame\" errors in `/proc/net/dev`."]
    #[doc = ""]
    #[doc = "   For IEEE 802.3 devices this counter should be equivalent to:"]
    #[doc = ""]
    #[doc = "    - 30.3.1.1.7 aAlignmentErrors"]
    #[doc = ""]
    #[doc = " @rx_fifo_errors: Receiver FIFO error counter."]
    #[doc = ""]
    #[doc = "   Historically the count of overflow events. Those events may be"]
    #[doc = "   reported in the receive descriptors or via interrupts, and may"]
    #[doc = "   not correspond one-to-one with dropped packets."]
    #[doc = ""]
    #[doc = "   This statistics was used interchangeably with @rx_over_errors."]
    #[doc = "   Not recommended for use in drivers for high speed interfaces."]
    #[doc = ""]
    #[doc = "   This statistic is used on software devices, e.g. to count software"]
    #[doc = "   packet queue overflow (can) or sequencing errors (GRE)."]
    #[doc = ""]
    #[doc = " @rx_missed_errors: Count of packets missed by the host."]
    #[doc = "   Folded into the \"drop\" counter in `/proc/net/dev`."]
    #[doc = ""]
    #[doc = "   Counts number of packets dropped by the device due to lack"]
    #[doc = "   of buffer space. This usually indicates that the host interface"]
    #[doc = "   is slower than the network interface, or host is not keeping up"]
    #[doc = "   with the receive packet rate."]
    #[doc = ""]
    #[doc = "   This statistic corresponds to hardware events and is not used"]
    #[doc = "   on software devices."]
    #[doc = ""]
    #[doc = " @tx_aborted_errors:"]
    #[doc = "   Part of aggregate \"carrier\" errors in `/proc/net/dev`."]
    #[doc = "   For IEEE 802.3 devices capable of half-duplex operation this counter"]
    #[doc = "   must be equivalent to:"]
    #[doc = ""]
    #[doc = "    - 30.3.1.1.11 aFramesAbortedDueToXSColls"]
    #[doc = ""]
    #[doc = "   High speed interfaces may use this counter as a general device"]
    #[doc = "   discard counter."]
    #[doc = ""]
    #[doc = " @tx_carrier_errors: Number of frame transmission errors due to loss"]
    #[doc = "   of carrier during transmission."]
    #[doc = "   Part of aggregate \"carrier\" errors in `/proc/net/dev`."]
    #[doc = ""]
    #[doc = "   For IEEE 802.3 devices this counter must be equivalent to:"]
    #[doc = ""]
    #[doc = "    - 30.3.1.1.13 aCarrierSenseErrors"]
    #[doc = ""]
    #[doc = " @tx_fifo_errors: Number of frame transmission errors due to device"]
    #[doc = "   FIFO underrun / underflow. This condition occurs when the device"]
    #[doc = "   begins transmission of a frame but is unable to deliver the"]
    #[doc = "   entire frame to the transmitter in time for transmission."]
    #[doc = "   Part of aggregate \"carrier\" errors in `/proc/net/dev`."]
    #[doc = ""]
    #[doc = " @tx_heartbeat_errors: Number of Heartbeat / SQE Test errors for"]
    #[doc = "   old half-duplex Ethernet."]
    #[doc = "   Part of aggregate \"carrier\" errors in `/proc/net/dev`."]
    #[doc = ""]
    #[doc = "   For IEEE 802.3 devices possibly equivalent to:"]
    #[doc = ""]
    #[doc = "    - 30.3.2.1.4 aSQETestErrors"]
    #[doc = ""]
    #[doc = " @tx_window_errors: Number of frame transmission errors due"]
    #[doc = "   to late collisions (for Ethernet - after the first 64B of transmission)."]
    #[doc = "   Part of aggregate \"carrier\" errors in `/proc/net/dev`."]
    #[doc = ""]
    #[doc = "   For IEEE 802.3 devices this counter must be equivalent to:"]
    #[doc = ""]
    #[doc = "    - 30.3.1.1.10 aLateCollisions"]
    #[doc = ""]
    #[doc = " @rx_compressed: Number of correctly received compressed packets."]
    #[doc = "   This counters is only meaningful for interfaces which support"]
    #[doc = "   packet compression (e.g. CSLIP, PPP)."]
    #[doc = ""]
    #[doc = " @tx_compressed: Number of transmitted compressed packets."]
    #[doc = "   This counters is only meaningful for interfaces which support"]
    #[doc = "   packet compression (e.g. CSLIP, PPP)."]
    #[doc = ""]
    #[doc = " @rx_nohandler: Number of packets received on the interface"]
    #[doc = "   but dropped by the networking stack because the device is"]
    #[doc = "   not designated to receive packets (e.g. backup link in a bond)."]
    #[doc = ""]
    #[doc = " @rx_otherhost_dropped: Number of packets dropped due to mismatch"]
    #[doc = "   in destination MAC address."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct rtnl_link_stats64 {
        pub rx_packets: __u64,
        pub tx_packets: __u64,
        pub rx_bytes: __u64,
        pub tx_bytes: __u64,
        pub rx_errors: __u64,
        pub tx_errors: __u64,
        pub rx_dropped: __u64,
        pub tx_dropped: __u64,
        pub multicast: __u64,
        pub collisions: __u64,
        pub rx_length_errors: __u64,
        pub rx_over_errors: __u64,
        pub rx_crc_errors: __u64,
        pub rx_frame_errors: __u64,
        pub rx_fifo_errors: __u64,
        pub rx_missed_errors: __u64,
        pub tx_aborted_errors: __u64,
        pub tx_carrier_errors: __u64,
        pub tx_fifo_errors: __u64,
        pub tx_heartbeat_errors: __u64,
        pub tx_window_errors: __u64,
        pub rx_compressed: __u64,
        pub tx_compressed: __u64,
        pub rx_nohandler: __u64,
        pub rx_otherhost_dropped: __u64,
    }
    #[test]
    fn bindgen_test_layout_rtnl_link_stats64() {
        assert_eq!(
            ::core::mem::size_of::<rtnl_link_stats64>(),
            200usize,
            concat!("Size of: ", stringify!(rtnl_link_stats64))
        );
        assert_eq!(
            ::core::mem::align_of::<rtnl_link_stats64>(),
            8usize,
            concat!("Alignment of ", stringify!(rtnl_link_stats64))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<rtnl_link_stats64>())).rx_packets as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_link_stats64),
                "::",
                stringify!(rx_packets)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<rtnl_link_stats64>())).tx_packets as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_link_stats64),
                "::",
                stringify!(tx_packets)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rtnl_link_stats64>())).rx_bytes as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_link_stats64),
                "::",
                stringify!(rx_bytes)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rtnl_link_stats64>())).tx_bytes as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_link_stats64),
                "::",
                stringify!(tx_bytes)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<rtnl_link_stats64>())).rx_errors as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_link_stats64),
                "::",
                stringify!(rx_errors)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<rtnl_link_stats64>())).tx_errors as *const _ as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_link_stats64),
                "::",
                stringify!(tx_errors)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<rtnl_link_stats64>())).rx_dropped as *const _ as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_link_stats64),
                "::",
                stringify!(rx_dropped)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<rtnl_link_stats64>())).tx_dropped as *const _ as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_link_stats64),
                "::",
                stringify!(tx_dropped)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<rtnl_link_stats64>())).multicast as *const _ as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_link_stats64),
                "::",
                stringify!(multicast)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<rtnl_link_stats64>())).collisions as *const _ as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_link_stats64),
                "::",
                stringify!(collisions)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<rtnl_link_stats64>())).rx_length_errors as *const _ as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_link_stats64),
                "::",
                stringify!(rx_length_errors)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<rtnl_link_stats64>())).rx_over_errors as *const _ as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_link_stats64),
                "::",
                stringify!(rx_over_errors)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<rtnl_link_stats64>())).rx_crc_errors as *const _ as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_link_stats64),
                "::",
                stringify!(rx_crc_errors)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<rtnl_link_stats64>())).rx_frame_errors as *const _ as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_link_stats64),
                "::",
                stringify!(rx_frame_errors)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<rtnl_link_stats64>())).rx_fifo_errors as *const _ as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_link_stats64),
                "::",
                stringify!(rx_fifo_errors)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<rtnl_link_stats64>())).rx_missed_errors as *const _ as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_link_stats64),
                "::",
                stringify!(rx_missed_errors)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<rtnl_link_stats64>())).tx_aborted_errors as *const _
                    as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_link_stats64),
                "::",
                stringify!(tx_aborted_errors)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<rtnl_link_stats64>())).tx_carrier_errors as *const _
                    as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_link_stats64),
                "::",
                stringify!(tx_carrier_errors)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<rtnl_link_stats64>())).tx_fifo_errors as *const _ as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_link_stats64),
                "::",
                stringify!(tx_fifo_errors)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<rtnl_link_stats64>())).tx_heartbeat_errors as *const _
                    as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_link_stats64),
                "::",
                stringify!(tx_heartbeat_errors)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<rtnl_link_stats64>())).tx_window_errors as *const _ as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_link_stats64),
                "::",
                stringify!(tx_window_errors)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<rtnl_link_stats64>())).rx_compressed as *const _ as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_link_stats64),
                "::",
                stringify!(rx_compressed)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<rtnl_link_stats64>())).tx_compressed as *const _ as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_link_stats64),
                "::",
                stringify!(tx_compressed)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<rtnl_link_stats64>())).rx_nohandler as *const _ as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_link_stats64),
                "::",
                stringify!(rx_nohandler)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<rtnl_link_stats64>())).rx_otherhost_dropped as *const _
                    as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_link_stats64),
                "::",
                stringify!(rx_otherhost_dropped)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct rtnl_hw_stats64 {
        pub rx_packets: __u64,
        pub tx_packets: __u64,
        pub rx_bytes: __u64,
        pub tx_bytes: __u64,
        pub rx_errors: __u64,
        pub tx_errors: __u64,
        pub rx_dropped: __u64,
        pub tx_dropped: __u64,
        pub multicast: __u64,
    }
    #[test]
    fn bindgen_test_layout_rtnl_hw_stats64() {
        assert_eq!(
            ::core::mem::size_of::<rtnl_hw_stats64>(),
            72usize,
            concat!("Size of: ", stringify!(rtnl_hw_stats64))
        );
        assert_eq!(
            ::core::mem::align_of::<rtnl_hw_stats64>(),
            8usize,
            concat!("Alignment of ", stringify!(rtnl_hw_stats64))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rtnl_hw_stats64>())).rx_packets as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_hw_stats64),
                "::",
                stringify!(rx_packets)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rtnl_hw_stats64>())).tx_packets as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_hw_stats64),
                "::",
                stringify!(tx_packets)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rtnl_hw_stats64>())).rx_bytes as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_hw_stats64),
                "::",
                stringify!(rx_bytes)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rtnl_hw_stats64>())).tx_bytes as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_hw_stats64),
                "::",
                stringify!(tx_bytes)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rtnl_hw_stats64>())).rx_errors as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_hw_stats64),
                "::",
                stringify!(rx_errors)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rtnl_hw_stats64>())).tx_errors as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_hw_stats64),
                "::",
                stringify!(tx_errors)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rtnl_hw_stats64>())).rx_dropped as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_hw_stats64),
                "::",
                stringify!(rx_dropped)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rtnl_hw_stats64>())).tx_dropped as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_hw_stats64),
                "::",
                stringify!(tx_dropped)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rtnl_hw_stats64>())).multicast as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_hw_stats64),
                "::",
                stringify!(multicast)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ifla_vf_guid {
        pub vf: __u32,
        pub guid: __u64,
    }
    #[test]
    fn bindgen_test_layout_ifla_vf_guid() {
        assert_eq!(
            ::core::mem::size_of::<ifla_vf_guid>(),
            16usize,
            concat!("Size of: ", stringify!(ifla_vf_guid))
        );
        assert_eq!(
            ::core::mem::align_of::<ifla_vf_guid>(),
            8usize,
            concat!("Alignment of ", stringify!(ifla_vf_guid))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ifla_vf_guid>())).vf as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifla_vf_guid),
                "::",
                stringify!(vf)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ifla_vf_guid>())).guid as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ifla_vf_guid),
                "::",
                stringify!(guid)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ifla_vf_stats {
        pub rx_packets: __u64,
        pub tx_packets: __u64,
        pub rx_bytes: __u64,
        pub tx_bytes: __u64,
        pub broadcast: __u64,
        pub multicast: __u64,
        pub rx_dropped: __u64,
        pub tx_dropped: __u64,
    }
    #[test]
    fn bindgen_test_layout_ifla_vf_stats() {
        assert_eq!(
            ::core::mem::size_of::<ifla_vf_stats>(),
            64usize,
            concat!("Size of: ", stringify!(ifla_vf_stats))
        );
        assert_eq!(
            ::core::mem::align_of::<ifla_vf_stats>(),
            8usize,
            concat!("Alignment of ", stringify!(ifla_vf_stats))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ifla_vf_stats>())).rx_packets as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifla_vf_stats),
                "::",
                stringify!(rx_packets)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ifla_vf_stats>())).tx_packets as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ifla_vf_stats),
                "::",
                stringify!(tx_packets)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ifla_vf_stats>())).rx_bytes as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ifla_vf_stats),
                "::",
                stringify!(rx_bytes)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ifla_vf_stats>())).tx_bytes as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(ifla_vf_stats),
                "::",
                stringify!(tx_bytes)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ifla_vf_stats>())).broadcast as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(ifla_vf_stats),
                "::",
                stringify!(broadcast)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ifla_vf_stats>())).multicast as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(ifla_vf_stats),
                "::",
                stringify!(multicast)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ifla_vf_stats>())).rx_dropped as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(ifla_vf_stats),
                "::",
                stringify!(rx_dropped)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ifla_vf_stats>())).tx_dropped as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(ifla_vf_stats),
                "::",
                stringify!(tx_dropped)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ifla_vf_info {
        pub vf: __u32,
        pub mac: [__u8; 32usize],
        pub vlan: __u32,
        pub qos: __u32,
        pub spoofchk: __u32,
        pub linkstate: __u32,
        pub min_tx_rate: __u32,
        pub max_tx_rate: __u32,
        pub rss_query_en: __u32,
        pub trusted: __u32,
        pub vlan_proto: __be16,
    }
    #[test]
    fn bindgen_test_layout_ifla_vf_info() {
        assert_eq!(
            ::core::mem::size_of::<ifla_vf_info>(),
            72usize,
            concat!("Size of: ", stringify!(ifla_vf_info))
        );
        assert_eq!(
            ::core::mem::align_of::<ifla_vf_info>(),
            4usize,
            concat!("Alignment of ", stringify!(ifla_vf_info))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ifla_vf_info>())).vf as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifla_vf_info),
                "::",
                stringify!(vf)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ifla_vf_info>())).mac as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(ifla_vf_info),
                "::",
                stringify!(mac)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ifla_vf_info>())).vlan as *const _ as usize },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(ifla_vf_info),
                "::",
                stringify!(vlan)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ifla_vf_info>())).qos as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(ifla_vf_info),
                "::",
                stringify!(qos)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ifla_vf_info>())).spoofchk as *const _ as usize },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(ifla_vf_info),
                "::",
                stringify!(spoofchk)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ifla_vf_info>())).linkstate as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(ifla_vf_info),
                "::",
                stringify!(linkstate)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ifla_vf_info>())).min_tx_rate as *const _ as usize },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(ifla_vf_info),
                "::",
                stringify!(min_tx_rate)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ifla_vf_info>())).max_tx_rate as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(ifla_vf_info),
                "::",
                stringify!(max_tx_rate)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ifla_vf_info>())).rss_query_en as *const _ as usize },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(ifla_vf_info),
                "::",
                stringify!(rss_query_en)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ifla_vf_info>())).trusted as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(ifla_vf_info),
                "::",
                stringify!(trusted)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ifla_vf_info>())).vlan_proto as *const _ as usize },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(ifla_vf_info),
                "::",
                stringify!(vlan_proto)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct netpoll_info {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ethtool_ops {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct phy_device {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dsa_port {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ip_tunnel_parm {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct macsec_ops {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct netdev_name_node {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct sfp_bus {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct wireless_dev {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct wpan_dev {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct mpls_dev {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct udp_tunnel_nic_info {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct udp_tunnel_nic {
        _unused: [u8; 0],
    }
    pub const netdev_tx___NETDEV_TX_MIN: netdev_tx = -2147483648;
    pub const netdev_tx_NETDEV_TX_OK: netdev_tx = 0;
    pub const netdev_tx_NETDEV_TX_BUSY: netdev_tx = 16;
    pub type netdev_tx = ::cty::c_int;
    pub use self::netdev_tx as netdev_tx_t;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct net_device_stats {
        pub __bindgen_anon_1: net_device_stats__bindgen_ty_1,
        pub __bindgen_anon_2: net_device_stats__bindgen_ty_2,
        pub __bindgen_anon_3: net_device_stats__bindgen_ty_3,
        pub __bindgen_anon_4: net_device_stats__bindgen_ty_4,
        pub __bindgen_anon_5: net_device_stats__bindgen_ty_5,
        pub __bindgen_anon_6: net_device_stats__bindgen_ty_6,
        pub __bindgen_anon_7: net_device_stats__bindgen_ty_7,
        pub __bindgen_anon_8: net_device_stats__bindgen_ty_8,
        pub __bindgen_anon_9: net_device_stats__bindgen_ty_9,
        pub __bindgen_anon_10: net_device_stats__bindgen_ty_10,
        pub __bindgen_anon_11: net_device_stats__bindgen_ty_11,
        pub __bindgen_anon_12: net_device_stats__bindgen_ty_12,
        pub __bindgen_anon_13: net_device_stats__bindgen_ty_13,
        pub __bindgen_anon_14: net_device_stats__bindgen_ty_14,
        pub __bindgen_anon_15: net_device_stats__bindgen_ty_15,
        pub __bindgen_anon_16: net_device_stats__bindgen_ty_16,
        pub __bindgen_anon_17: net_device_stats__bindgen_ty_17,
        pub __bindgen_anon_18: net_device_stats__bindgen_ty_18,
        pub __bindgen_anon_19: net_device_stats__bindgen_ty_19,
        pub __bindgen_anon_20: net_device_stats__bindgen_ty_20,
        pub __bindgen_anon_21: net_device_stats__bindgen_ty_21,
        pub __bindgen_anon_22: net_device_stats__bindgen_ty_22,
        pub __bindgen_anon_23: net_device_stats__bindgen_ty_23,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union net_device_stats__bindgen_ty_1 {
        pub rx_packets: ::cty::c_ulong,
        pub __rx_packets: atomic_long_t,
    }
    #[test]
    fn bindgen_test_layout_net_device_stats__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<net_device_stats__bindgen_ty_1>(),
            8usize,
            concat!("Size of: ", stringify!(net_device_stats__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<net_device_stats__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(net_device_stats__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_stats__bindgen_ty_1>())).rx_packets as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_stats__bindgen_ty_1),
                "::",
                stringify!(rx_packets)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_stats__bindgen_ty_1>())).__rx_packets as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_stats__bindgen_ty_1),
                "::",
                stringify!(__rx_packets)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union net_device_stats__bindgen_ty_2 {
        pub tx_packets: ::cty::c_ulong,
        pub __tx_packets: atomic_long_t,
    }
    #[test]
    fn bindgen_test_layout_net_device_stats__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<net_device_stats__bindgen_ty_2>(),
            8usize,
            concat!("Size of: ", stringify!(net_device_stats__bindgen_ty_2))
        );
        assert_eq!(
            ::core::mem::align_of::<net_device_stats__bindgen_ty_2>(),
            8usize,
            concat!("Alignment of ", stringify!(net_device_stats__bindgen_ty_2))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_stats__bindgen_ty_2>())).tx_packets as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_stats__bindgen_ty_2),
                "::",
                stringify!(tx_packets)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_stats__bindgen_ty_2>())).__tx_packets as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_stats__bindgen_ty_2),
                "::",
                stringify!(__tx_packets)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union net_device_stats__bindgen_ty_3 {
        pub rx_bytes: ::cty::c_ulong,
        pub __rx_bytes: atomic_long_t,
    }
    #[test]
    fn bindgen_test_layout_net_device_stats__bindgen_ty_3() {
        assert_eq!(
            ::core::mem::size_of::<net_device_stats__bindgen_ty_3>(),
            8usize,
            concat!("Size of: ", stringify!(net_device_stats__bindgen_ty_3))
        );
        assert_eq!(
            ::core::mem::align_of::<net_device_stats__bindgen_ty_3>(),
            8usize,
            concat!("Alignment of ", stringify!(net_device_stats__bindgen_ty_3))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_stats__bindgen_ty_3>())).rx_bytes as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_stats__bindgen_ty_3),
                "::",
                stringify!(rx_bytes)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_stats__bindgen_ty_3>())).__rx_bytes as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_stats__bindgen_ty_3),
                "::",
                stringify!(__rx_bytes)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union net_device_stats__bindgen_ty_4 {
        pub tx_bytes: ::cty::c_ulong,
        pub __tx_bytes: atomic_long_t,
    }
    #[test]
    fn bindgen_test_layout_net_device_stats__bindgen_ty_4() {
        assert_eq!(
            ::core::mem::size_of::<net_device_stats__bindgen_ty_4>(),
            8usize,
            concat!("Size of: ", stringify!(net_device_stats__bindgen_ty_4))
        );
        assert_eq!(
            ::core::mem::align_of::<net_device_stats__bindgen_ty_4>(),
            8usize,
            concat!("Alignment of ", stringify!(net_device_stats__bindgen_ty_4))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_stats__bindgen_ty_4>())).tx_bytes as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_stats__bindgen_ty_4),
                "::",
                stringify!(tx_bytes)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_stats__bindgen_ty_4>())).__tx_bytes as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_stats__bindgen_ty_4),
                "::",
                stringify!(__tx_bytes)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union net_device_stats__bindgen_ty_5 {
        pub rx_errors: ::cty::c_ulong,
        pub __rx_errors: atomic_long_t,
    }
    #[test]
    fn bindgen_test_layout_net_device_stats__bindgen_ty_5() {
        assert_eq!(
            ::core::mem::size_of::<net_device_stats__bindgen_ty_5>(),
            8usize,
            concat!("Size of: ", stringify!(net_device_stats__bindgen_ty_5))
        );
        assert_eq!(
            ::core::mem::align_of::<net_device_stats__bindgen_ty_5>(),
            8usize,
            concat!("Alignment of ", stringify!(net_device_stats__bindgen_ty_5))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_stats__bindgen_ty_5>())).rx_errors as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_stats__bindgen_ty_5),
                "::",
                stringify!(rx_errors)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_stats__bindgen_ty_5>())).__rx_errors as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_stats__bindgen_ty_5),
                "::",
                stringify!(__rx_errors)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union net_device_stats__bindgen_ty_6 {
        pub tx_errors: ::cty::c_ulong,
        pub __tx_errors: atomic_long_t,
    }
    #[test]
    fn bindgen_test_layout_net_device_stats__bindgen_ty_6() {
        assert_eq!(
            ::core::mem::size_of::<net_device_stats__bindgen_ty_6>(),
            8usize,
            concat!("Size of: ", stringify!(net_device_stats__bindgen_ty_6))
        );
        assert_eq!(
            ::core::mem::align_of::<net_device_stats__bindgen_ty_6>(),
            8usize,
            concat!("Alignment of ", stringify!(net_device_stats__bindgen_ty_6))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_stats__bindgen_ty_6>())).tx_errors as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_stats__bindgen_ty_6),
                "::",
                stringify!(tx_errors)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_stats__bindgen_ty_6>())).__tx_errors as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_stats__bindgen_ty_6),
                "::",
                stringify!(__tx_errors)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union net_device_stats__bindgen_ty_7 {
        pub rx_dropped: ::cty::c_ulong,
        pub __rx_dropped: atomic_long_t,
    }
    #[test]
    fn bindgen_test_layout_net_device_stats__bindgen_ty_7() {
        assert_eq!(
            ::core::mem::size_of::<net_device_stats__bindgen_ty_7>(),
            8usize,
            concat!("Size of: ", stringify!(net_device_stats__bindgen_ty_7))
        );
        assert_eq!(
            ::core::mem::align_of::<net_device_stats__bindgen_ty_7>(),
            8usize,
            concat!("Alignment of ", stringify!(net_device_stats__bindgen_ty_7))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_stats__bindgen_ty_7>())).rx_dropped as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_stats__bindgen_ty_7),
                "::",
                stringify!(rx_dropped)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_stats__bindgen_ty_7>())).__rx_dropped as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_stats__bindgen_ty_7),
                "::",
                stringify!(__rx_dropped)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union net_device_stats__bindgen_ty_8 {
        pub tx_dropped: ::cty::c_ulong,
        pub __tx_dropped: atomic_long_t,
    }
    #[test]
    fn bindgen_test_layout_net_device_stats__bindgen_ty_8() {
        assert_eq!(
            ::core::mem::size_of::<net_device_stats__bindgen_ty_8>(),
            8usize,
            concat!("Size of: ", stringify!(net_device_stats__bindgen_ty_8))
        );
        assert_eq!(
            ::core::mem::align_of::<net_device_stats__bindgen_ty_8>(),
            8usize,
            concat!("Alignment of ", stringify!(net_device_stats__bindgen_ty_8))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_stats__bindgen_ty_8>())).tx_dropped as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_stats__bindgen_ty_8),
                "::",
                stringify!(tx_dropped)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_stats__bindgen_ty_8>())).__tx_dropped as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_stats__bindgen_ty_8),
                "::",
                stringify!(__tx_dropped)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union net_device_stats__bindgen_ty_9 {
        pub multicast: ::cty::c_ulong,
        pub __multicast: atomic_long_t,
    }
    #[test]
    fn bindgen_test_layout_net_device_stats__bindgen_ty_9() {
        assert_eq!(
            ::core::mem::size_of::<net_device_stats__bindgen_ty_9>(),
            8usize,
            concat!("Size of: ", stringify!(net_device_stats__bindgen_ty_9))
        );
        assert_eq!(
            ::core::mem::align_of::<net_device_stats__bindgen_ty_9>(),
            8usize,
            concat!("Alignment of ", stringify!(net_device_stats__bindgen_ty_9))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_stats__bindgen_ty_9>())).multicast as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_stats__bindgen_ty_9),
                "::",
                stringify!(multicast)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_stats__bindgen_ty_9>())).__multicast as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_stats__bindgen_ty_9),
                "::",
                stringify!(__multicast)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union net_device_stats__bindgen_ty_10 {
        pub collisions: ::cty::c_ulong,
        pub __collisions: atomic_long_t,
    }
    #[test]
    fn bindgen_test_layout_net_device_stats__bindgen_ty_10() {
        assert_eq!(
            ::core::mem::size_of::<net_device_stats__bindgen_ty_10>(),
            8usize,
            concat!("Size of: ", stringify!(net_device_stats__bindgen_ty_10))
        );
        assert_eq!(
            ::core::mem::align_of::<net_device_stats__bindgen_ty_10>(),
            8usize,
            concat!("Alignment of ", stringify!(net_device_stats__bindgen_ty_10))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_stats__bindgen_ty_10>())).collisions as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_stats__bindgen_ty_10),
                "::",
                stringify!(collisions)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_stats__bindgen_ty_10>())).__collisions
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_stats__bindgen_ty_10),
                "::",
                stringify!(__collisions)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union net_device_stats__bindgen_ty_11 {
        pub rx_length_errors: ::cty::c_ulong,
        pub __rx_length_errors: atomic_long_t,
    }
    #[test]
    fn bindgen_test_layout_net_device_stats__bindgen_ty_11() {
        assert_eq!(
            ::core::mem::size_of::<net_device_stats__bindgen_ty_11>(),
            8usize,
            concat!("Size of: ", stringify!(net_device_stats__bindgen_ty_11))
        );
        assert_eq!(
            ::core::mem::align_of::<net_device_stats__bindgen_ty_11>(),
            8usize,
            concat!("Alignment of ", stringify!(net_device_stats__bindgen_ty_11))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_stats__bindgen_ty_11>())).rx_length_errors
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_stats__bindgen_ty_11),
                "::",
                stringify!(rx_length_errors)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_stats__bindgen_ty_11>())).__rx_length_errors
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_stats__bindgen_ty_11),
                "::",
                stringify!(__rx_length_errors)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union net_device_stats__bindgen_ty_12 {
        pub rx_over_errors: ::cty::c_ulong,
        pub __rx_over_errors: atomic_long_t,
    }
    #[test]
    fn bindgen_test_layout_net_device_stats__bindgen_ty_12() {
        assert_eq!(
            ::core::mem::size_of::<net_device_stats__bindgen_ty_12>(),
            8usize,
            concat!("Size of: ", stringify!(net_device_stats__bindgen_ty_12))
        );
        assert_eq!(
            ::core::mem::align_of::<net_device_stats__bindgen_ty_12>(),
            8usize,
            concat!("Alignment of ", stringify!(net_device_stats__bindgen_ty_12))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_stats__bindgen_ty_12>())).rx_over_errors
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_stats__bindgen_ty_12),
                "::",
                stringify!(rx_over_errors)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_stats__bindgen_ty_12>())).__rx_over_errors
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_stats__bindgen_ty_12),
                "::",
                stringify!(__rx_over_errors)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union net_device_stats__bindgen_ty_13 {
        pub rx_crc_errors: ::cty::c_ulong,
        pub __rx_crc_errors: atomic_long_t,
    }
    #[test]
    fn bindgen_test_layout_net_device_stats__bindgen_ty_13() {
        assert_eq!(
            ::core::mem::size_of::<net_device_stats__bindgen_ty_13>(),
            8usize,
            concat!("Size of: ", stringify!(net_device_stats__bindgen_ty_13))
        );
        assert_eq!(
            ::core::mem::align_of::<net_device_stats__bindgen_ty_13>(),
            8usize,
            concat!("Alignment of ", stringify!(net_device_stats__bindgen_ty_13))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_stats__bindgen_ty_13>())).rx_crc_errors
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_stats__bindgen_ty_13),
                "::",
                stringify!(rx_crc_errors)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_stats__bindgen_ty_13>())).__rx_crc_errors
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_stats__bindgen_ty_13),
                "::",
                stringify!(__rx_crc_errors)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union net_device_stats__bindgen_ty_14 {
        pub rx_frame_errors: ::cty::c_ulong,
        pub __rx_frame_errors: atomic_long_t,
    }
    #[test]
    fn bindgen_test_layout_net_device_stats__bindgen_ty_14() {
        assert_eq!(
            ::core::mem::size_of::<net_device_stats__bindgen_ty_14>(),
            8usize,
            concat!("Size of: ", stringify!(net_device_stats__bindgen_ty_14))
        );
        assert_eq!(
            ::core::mem::align_of::<net_device_stats__bindgen_ty_14>(),
            8usize,
            concat!("Alignment of ", stringify!(net_device_stats__bindgen_ty_14))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_stats__bindgen_ty_14>())).rx_frame_errors
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_stats__bindgen_ty_14),
                "::",
                stringify!(rx_frame_errors)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_stats__bindgen_ty_14>())).__rx_frame_errors
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_stats__bindgen_ty_14),
                "::",
                stringify!(__rx_frame_errors)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union net_device_stats__bindgen_ty_15 {
        pub rx_fifo_errors: ::cty::c_ulong,
        pub __rx_fifo_errors: atomic_long_t,
    }
    #[test]
    fn bindgen_test_layout_net_device_stats__bindgen_ty_15() {
        assert_eq!(
            ::core::mem::size_of::<net_device_stats__bindgen_ty_15>(),
            8usize,
            concat!("Size of: ", stringify!(net_device_stats__bindgen_ty_15))
        );
        assert_eq!(
            ::core::mem::align_of::<net_device_stats__bindgen_ty_15>(),
            8usize,
            concat!("Alignment of ", stringify!(net_device_stats__bindgen_ty_15))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_stats__bindgen_ty_15>())).rx_fifo_errors
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_stats__bindgen_ty_15),
                "::",
                stringify!(rx_fifo_errors)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_stats__bindgen_ty_15>())).__rx_fifo_errors
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_stats__bindgen_ty_15),
                "::",
                stringify!(__rx_fifo_errors)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union net_device_stats__bindgen_ty_16 {
        pub rx_missed_errors: ::cty::c_ulong,
        pub __rx_missed_errors: atomic_long_t,
    }
    #[test]
    fn bindgen_test_layout_net_device_stats__bindgen_ty_16() {
        assert_eq!(
            ::core::mem::size_of::<net_device_stats__bindgen_ty_16>(),
            8usize,
            concat!("Size of: ", stringify!(net_device_stats__bindgen_ty_16))
        );
        assert_eq!(
            ::core::mem::align_of::<net_device_stats__bindgen_ty_16>(),
            8usize,
            concat!("Alignment of ", stringify!(net_device_stats__bindgen_ty_16))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_stats__bindgen_ty_16>())).rx_missed_errors
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_stats__bindgen_ty_16),
                "::",
                stringify!(rx_missed_errors)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_stats__bindgen_ty_16>())).__rx_missed_errors
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_stats__bindgen_ty_16),
                "::",
                stringify!(__rx_missed_errors)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union net_device_stats__bindgen_ty_17 {
        pub tx_aborted_errors: ::cty::c_ulong,
        pub __tx_aborted_errors: atomic_long_t,
    }
    #[test]
    fn bindgen_test_layout_net_device_stats__bindgen_ty_17() {
        assert_eq!(
            ::core::mem::size_of::<net_device_stats__bindgen_ty_17>(),
            8usize,
            concat!("Size of: ", stringify!(net_device_stats__bindgen_ty_17))
        );
        assert_eq!(
            ::core::mem::align_of::<net_device_stats__bindgen_ty_17>(),
            8usize,
            concat!("Alignment of ", stringify!(net_device_stats__bindgen_ty_17))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_stats__bindgen_ty_17>())).tx_aborted_errors
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_stats__bindgen_ty_17),
                "::",
                stringify!(tx_aborted_errors)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_stats__bindgen_ty_17>())).__tx_aborted_errors
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_stats__bindgen_ty_17),
                "::",
                stringify!(__tx_aborted_errors)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union net_device_stats__bindgen_ty_18 {
        pub tx_carrier_errors: ::cty::c_ulong,
        pub __tx_carrier_errors: atomic_long_t,
    }
    #[test]
    fn bindgen_test_layout_net_device_stats__bindgen_ty_18() {
        assert_eq!(
            ::core::mem::size_of::<net_device_stats__bindgen_ty_18>(),
            8usize,
            concat!("Size of: ", stringify!(net_device_stats__bindgen_ty_18))
        );
        assert_eq!(
            ::core::mem::align_of::<net_device_stats__bindgen_ty_18>(),
            8usize,
            concat!("Alignment of ", stringify!(net_device_stats__bindgen_ty_18))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_stats__bindgen_ty_18>())).tx_carrier_errors
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_stats__bindgen_ty_18),
                "::",
                stringify!(tx_carrier_errors)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_stats__bindgen_ty_18>())).__tx_carrier_errors
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_stats__bindgen_ty_18),
                "::",
                stringify!(__tx_carrier_errors)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union net_device_stats__bindgen_ty_19 {
        pub tx_fifo_errors: ::cty::c_ulong,
        pub __tx_fifo_errors: atomic_long_t,
    }
    #[test]
    fn bindgen_test_layout_net_device_stats__bindgen_ty_19() {
        assert_eq!(
            ::core::mem::size_of::<net_device_stats__bindgen_ty_19>(),
            8usize,
            concat!("Size of: ", stringify!(net_device_stats__bindgen_ty_19))
        );
        assert_eq!(
            ::core::mem::align_of::<net_device_stats__bindgen_ty_19>(),
            8usize,
            concat!("Alignment of ", stringify!(net_device_stats__bindgen_ty_19))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_stats__bindgen_ty_19>())).tx_fifo_errors
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_stats__bindgen_ty_19),
                "::",
                stringify!(tx_fifo_errors)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_stats__bindgen_ty_19>())).__tx_fifo_errors
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_stats__bindgen_ty_19),
                "::",
                stringify!(__tx_fifo_errors)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union net_device_stats__bindgen_ty_20 {
        pub tx_heartbeat_errors: ::cty::c_ulong,
        pub __tx_heartbeat_errors: atomic_long_t,
    }
    #[test]
    fn bindgen_test_layout_net_device_stats__bindgen_ty_20() {
        assert_eq!(
            ::core::mem::size_of::<net_device_stats__bindgen_ty_20>(),
            8usize,
            concat!("Size of: ", stringify!(net_device_stats__bindgen_ty_20))
        );
        assert_eq!(
            ::core::mem::align_of::<net_device_stats__bindgen_ty_20>(),
            8usize,
            concat!("Alignment of ", stringify!(net_device_stats__bindgen_ty_20))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_stats__bindgen_ty_20>())).tx_heartbeat_errors
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_stats__bindgen_ty_20),
                "::",
                stringify!(tx_heartbeat_errors)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_stats__bindgen_ty_20>())).__tx_heartbeat_errors
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_stats__bindgen_ty_20),
                "::",
                stringify!(__tx_heartbeat_errors)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union net_device_stats__bindgen_ty_21 {
        pub tx_window_errors: ::cty::c_ulong,
        pub __tx_window_errors: atomic_long_t,
    }
    #[test]
    fn bindgen_test_layout_net_device_stats__bindgen_ty_21() {
        assert_eq!(
            ::core::mem::size_of::<net_device_stats__bindgen_ty_21>(),
            8usize,
            concat!("Size of: ", stringify!(net_device_stats__bindgen_ty_21))
        );
        assert_eq!(
            ::core::mem::align_of::<net_device_stats__bindgen_ty_21>(),
            8usize,
            concat!("Alignment of ", stringify!(net_device_stats__bindgen_ty_21))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_stats__bindgen_ty_21>())).tx_window_errors
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_stats__bindgen_ty_21),
                "::",
                stringify!(tx_window_errors)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_stats__bindgen_ty_21>())).__tx_window_errors
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_stats__bindgen_ty_21),
                "::",
                stringify!(__tx_window_errors)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union net_device_stats__bindgen_ty_22 {
        pub rx_compressed: ::cty::c_ulong,
        pub __rx_compressed: atomic_long_t,
    }
    #[test]
    fn bindgen_test_layout_net_device_stats__bindgen_ty_22() {
        assert_eq!(
            ::core::mem::size_of::<net_device_stats__bindgen_ty_22>(),
            8usize,
            concat!("Size of: ", stringify!(net_device_stats__bindgen_ty_22))
        );
        assert_eq!(
            ::core::mem::align_of::<net_device_stats__bindgen_ty_22>(),
            8usize,
            concat!("Alignment of ", stringify!(net_device_stats__bindgen_ty_22))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_stats__bindgen_ty_22>())).rx_compressed
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_stats__bindgen_ty_22),
                "::",
                stringify!(rx_compressed)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_stats__bindgen_ty_22>())).__rx_compressed
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_stats__bindgen_ty_22),
                "::",
                stringify!(__rx_compressed)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union net_device_stats__bindgen_ty_23 {
        pub tx_compressed: ::cty::c_ulong,
        pub __tx_compressed: atomic_long_t,
    }
    #[test]
    fn bindgen_test_layout_net_device_stats__bindgen_ty_23() {
        assert_eq!(
            ::core::mem::size_of::<net_device_stats__bindgen_ty_23>(),
            8usize,
            concat!("Size of: ", stringify!(net_device_stats__bindgen_ty_23))
        );
        assert_eq!(
            ::core::mem::align_of::<net_device_stats__bindgen_ty_23>(),
            8usize,
            concat!("Alignment of ", stringify!(net_device_stats__bindgen_ty_23))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_stats__bindgen_ty_23>())).tx_compressed
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_stats__bindgen_ty_23),
                "::",
                stringify!(tx_compressed)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_stats__bindgen_ty_23>())).__tx_compressed
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_stats__bindgen_ty_23),
                "::",
                stringify!(__tx_compressed)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_net_device_stats() {
        assert_eq!(
            ::core::mem::size_of::<net_device_stats>(),
            184usize,
            concat!("Size of: ", stringify!(net_device_stats))
        );
        assert_eq!(
            ::core::mem::align_of::<net_device_stats>(),
            8usize,
            concat!("Alignment of ", stringify!(net_device_stats))
        );
    }
    #[repr(C)]
    #[repr(align(32))]
    #[derive(Debug, Copy, Clone)]
    pub struct net_device_core_stats {
        pub rx_dropped: ::cty::c_ulong,
        pub tx_dropped: ::cty::c_ulong,
        pub rx_nohandler: ::cty::c_ulong,
        pub rx_otherhost_dropped: ::cty::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_net_device_core_stats() {
        assert_eq!(
            ::core::mem::size_of::<net_device_core_stats>(),
            32usize,
            concat!("Size of: ", stringify!(net_device_core_stats))
        );
        assert_eq!(
            ::core::mem::align_of::<net_device_core_stats>(),
            32usize,
            concat!("Alignment of ", stringify!(net_device_core_stats))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_core_stats>())).rx_dropped as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_core_stats),
                "::",
                stringify!(rx_dropped)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_core_stats>())).tx_dropped as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_core_stats),
                "::",
                stringify!(tx_dropped)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_core_stats>())).rx_nohandler as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_core_stats),
                "::",
                stringify!(rx_nohandler)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_core_stats>())).rx_otherhost_dropped as *const _
                    as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_core_stats),
                "::",
                stringify!(rx_otherhost_dropped)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct netdev_hw_addr_list {
        pub list: list_head,
        pub count: ::cty::c_int,
        pub tree: rb_root,
    }
    #[test]
    fn bindgen_test_layout_netdev_hw_addr_list() {
        assert_eq!(
            ::core::mem::size_of::<netdev_hw_addr_list>(),
            32usize,
            concat!("Size of: ", stringify!(netdev_hw_addr_list))
        );
        assert_eq!(
            ::core::mem::align_of::<netdev_hw_addr_list>(),
            8usize,
            concat!("Alignment of ", stringify!(netdev_hw_addr_list))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netdev_hw_addr_list>())).list as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(netdev_hw_addr_list),
                "::",
                stringify!(list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netdev_hw_addr_list>())).count as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(netdev_hw_addr_list),
                "::",
                stringify!(count)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netdev_hw_addr_list>())).tree as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(netdev_hw_addr_list),
                "::",
                stringify!(tree)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct hh_cache {
        pub hh_len: ::cty::c_uint,
        pub hh_lock: seqlock_t,
        pub hh_data: [::cty::c_ulong; 16usize],
    }
    #[test]
    fn bindgen_test_layout_hh_cache() {
        assert_eq!(
            ::core::mem::size_of::<hh_cache>(),
            144usize,
            concat!("Size of: ", stringify!(hh_cache))
        );
        assert_eq!(
            ::core::mem::align_of::<hh_cache>(),
            8usize,
            concat!("Alignment of ", stringify!(hh_cache))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<hh_cache>())).hh_len as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(hh_cache),
                "::",
                stringify!(hh_len)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<hh_cache>())).hh_lock as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(hh_cache),
                "::",
                stringify!(hh_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<hh_cache>())).hh_data as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(hh_cache),
                "::",
                stringify!(hh_data)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct header_ops {
        pub create: ::core::option::Option<
            unsafe extern "C" fn(
                skb: *mut sk_buff,
                dev: *mut net_device,
                type_: ::cty::c_ushort,
                daddr: *const ::cty::c_void,
                saddr: *const ::cty::c_void,
                len: ::cty::c_uint,
            ) -> ::cty::c_int,
        >,
        pub parse: ::core::option::Option<
            unsafe extern "C" fn(skb: *const sk_buff, haddr: *mut ::cty::c_uchar) -> ::cty::c_int,
        >,
        pub cache: ::core::option::Option<
            unsafe extern "C" fn(
                neigh: *const neighbour,
                hh: *mut hh_cache,
                type_: __be16,
            ) -> ::cty::c_int,
        >,
        pub cache_update: ::core::option::Option<
            unsafe extern "C" fn(
                hh: *mut hh_cache,
                dev: *const net_device,
                haddr: *const ::cty::c_uchar,
            ),
        >,
        pub validate: ::core::option::Option<
            unsafe extern "C" fn(ll_header: *const ::cty::c_char, len: ::cty::c_uint) -> bool_,
        >,
        pub parse_protocol:
            ::core::option::Option<unsafe extern "C" fn(skb: *const sk_buff) -> __be16>,
    }
    #[test]
    fn bindgen_test_layout_header_ops() {
        assert_eq!(
            ::core::mem::size_of::<header_ops>(),
            48usize,
            concat!("Size of: ", stringify!(header_ops))
        );
        assert_eq!(
            ::core::mem::align_of::<header_ops>(),
            8usize,
            concat!("Alignment of ", stringify!(header_ops))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<header_ops>())).create as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(header_ops),
                "::",
                stringify!(create)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<header_ops>())).parse as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(header_ops),
                "::",
                stringify!(parse)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<header_ops>())).cache as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(header_ops),
                "::",
                stringify!(cache)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<header_ops>())).cache_update as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(header_ops),
                "::",
                stringify!(cache_update)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<header_ops>())).validate as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(header_ops),
                "::",
                stringify!(validate)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<header_ops>())).parse_protocol as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(header_ops),
                "::",
                stringify!(parse_protocol)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct gro_list {
        pub list: list_head,
        pub count: ::cty::c_int,
    }
    #[test]
    fn bindgen_test_layout_gro_list() {
        assert_eq!(
            ::core::mem::size_of::<gro_list>(),
            24usize,
            concat!("Size of: ", stringify!(gro_list))
        );
        assert_eq!(
            ::core::mem::align_of::<gro_list>(),
            8usize,
            concat!("Alignment of ", stringify!(gro_list))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<gro_list>())).list as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(gro_list),
                "::",
                stringify!(list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<gro_list>())).count as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(gro_list),
                "::",
                stringify!(count)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct napi_struct {
        pub poll_list: list_head,
        pub state: ::cty::c_ulong,
        pub weight: ::cty::c_int,
        pub defer_hard_irqs_count: ::cty::c_int,
        pub gro_bitmask: ::cty::c_ulong,
        pub poll: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut napi_struct, arg2: ::cty::c_int) -> ::cty::c_int,
        >,
        pub poll_owner: ::cty::c_int,
        pub list_owner: ::cty::c_int,
        pub dev: *mut net_device,
        pub gro_hash: [gro_list; 8usize],
        pub skb: *mut sk_buff,
        pub rx_list: list_head,
        pub rx_count: ::cty::c_int,
        pub napi_id: ::cty::c_uint,
        pub timer: hrtimer,
        pub thread: *mut task_struct,
        pub dev_list: list_head,
        pub napi_hash_node: hlist_node,
    }
    #[test]
    fn bindgen_test_layout_napi_struct() {
        assert_eq!(
            ::core::mem::size_of::<napi_struct>(),
            392usize,
            concat!("Size of: ", stringify!(napi_struct))
        );
        assert_eq!(
            ::core::mem::align_of::<napi_struct>(),
            8usize,
            concat!("Alignment of ", stringify!(napi_struct))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<napi_struct>())).poll_list as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(napi_struct),
                "::",
                stringify!(poll_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<napi_struct>())).state as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(napi_struct),
                "::",
                stringify!(state)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<napi_struct>())).weight as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(napi_struct),
                "::",
                stringify!(weight)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<napi_struct>())).defer_hard_irqs_count as *const _ as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(napi_struct),
                "::",
                stringify!(defer_hard_irqs_count)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<napi_struct>())).gro_bitmask as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(napi_struct),
                "::",
                stringify!(gro_bitmask)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<napi_struct>())).poll as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(napi_struct),
                "::",
                stringify!(poll)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<napi_struct>())).poll_owner as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(napi_struct),
                "::",
                stringify!(poll_owner)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<napi_struct>())).list_owner as *const _ as usize },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(napi_struct),
                "::",
                stringify!(list_owner)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<napi_struct>())).dev as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(napi_struct),
                "::",
                stringify!(dev)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<napi_struct>())).gro_hash as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(napi_struct),
                "::",
                stringify!(gro_hash)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<napi_struct>())).skb as *const _ as usize },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(napi_struct),
                "::",
                stringify!(skb)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<napi_struct>())).rx_list as *const _ as usize },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(napi_struct),
                "::",
                stringify!(rx_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<napi_struct>())).rx_count as *const _ as usize },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(napi_struct),
                "::",
                stringify!(rx_count)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<napi_struct>())).napi_id as *const _ as usize },
            284usize,
            concat!(
                "Offset of field: ",
                stringify!(napi_struct),
                "::",
                stringify!(napi_id)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<napi_struct>())).timer as *const _ as usize },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(napi_struct),
                "::",
                stringify!(timer)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<napi_struct>())).thread as *const _ as usize },
            352usize,
            concat!(
                "Offset of field: ",
                stringify!(napi_struct),
                "::",
                stringify!(thread)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<napi_struct>())).dev_list as *const _ as usize },
            360usize,
            concat!(
                "Offset of field: ",
                stringify!(napi_struct),
                "::",
                stringify!(dev_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<napi_struct>())).napi_hash_node as *const _ as usize },
            376usize,
            concat!(
                "Offset of field: ",
                stringify!(napi_struct),
                "::",
                stringify!(napi_hash_node)
            )
        );
    }
    pub const rx_handler_result_RX_HANDLER_CONSUMED: rx_handler_result = 0;
    pub const rx_handler_result_RX_HANDLER_ANOTHER: rx_handler_result = 1;
    pub const rx_handler_result_RX_HANDLER_EXACT: rx_handler_result = 2;
    pub const rx_handler_result_RX_HANDLER_PASS: rx_handler_result = 3;
    pub type rx_handler_result = ::cty::c_uint;
    pub use self::rx_handler_result as rx_handler_result_t;
    pub type rx_handler_func_t = ::core::option::Option<
        unsafe extern "C" fn(pskb: *mut *mut sk_buff) -> rx_handler_result_t,
    >;
    #[repr(C)]
    #[repr(align(64))]
    #[derive(Copy, Clone)]
    pub struct netdev_queue {
        pub dev: *mut net_device,
        pub dev_tracker: netdevice_tracker,
        pub qdisc: *mut Qdisc,
        pub qdisc_sleeping: *mut Qdisc,
        pub kobj: kobject,
        pub numa_node: ::cty::c_int,
        pub tx_maxrate: ::cty::c_ulong,
        pub trans_timeout: atomic_long_t,
        pub sb_dev: *mut net_device,
        pub pool: *mut xsk_buff_pool,
        pub _xmit_lock: spinlock_t,
        pub xmit_lock_owner: ::cty::c_int,
        pub trans_start: ::cty::c_ulong,
        pub state: ::cty::c_ulong,
        pub __bindgen_padding_0: [u64; 5usize],
        pub dql: dql,
    }
    #[test]
    fn bindgen_test_layout_netdev_queue() {
        assert_eq!(
            ::core::mem::size_of::<netdev_queue>(),
            320usize,
            concat!("Size of: ", stringify!(netdev_queue))
        );
        assert_eq!(
            ::core::mem::align_of::<netdev_queue>(),
            64usize,
            concat!("Alignment of ", stringify!(netdev_queue))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netdev_queue>())).dev as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(netdev_queue),
                "::",
                stringify!(dev)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netdev_queue>())).dev_tracker as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(netdev_queue),
                "::",
                stringify!(dev_tracker)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netdev_queue>())).qdisc as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(netdev_queue),
                "::",
                stringify!(qdisc)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netdev_queue>())).qdisc_sleeping as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(netdev_queue),
                "::",
                stringify!(qdisc_sleeping)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netdev_queue>())).kobj as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(netdev_queue),
                "::",
                stringify!(kobj)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netdev_queue>())).numa_node as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(netdev_queue),
                "::",
                stringify!(numa_node)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netdev_queue>())).tx_maxrate as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(netdev_queue),
                "::",
                stringify!(tx_maxrate)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netdev_queue>())).trans_timeout as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(netdev_queue),
                "::",
                stringify!(trans_timeout)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netdev_queue>())).sb_dev as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(netdev_queue),
                "::",
                stringify!(sb_dev)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netdev_queue>())).pool as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(netdev_queue),
                "::",
                stringify!(pool)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netdev_queue>()))._xmit_lock as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(netdev_queue),
                "::",
                stringify!(_xmit_lock)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netdev_queue>())).xmit_lock_owner as *const _ as usize
            },
            132usize,
            concat!(
                "Offset of field: ",
                stringify!(netdev_queue),
                "::",
                stringify!(xmit_lock_owner)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netdev_queue>())).trans_start as *const _ as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(netdev_queue),
                "::",
                stringify!(trans_start)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netdev_queue>())).state as *const _ as usize },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(netdev_queue),
                "::",
                stringify!(state)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netdev_queue>())).dql as *const _ as usize },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(netdev_queue),
                "::",
                stringify!(dql)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct rps_map {
        pub len: ::cty::c_uint,
        pub rcu: callback_head,
        pub cpus: __IncompleteArrayField<_cargo_bpf_u16>,
    }
    #[test]
    fn bindgen_test_layout_rps_map() {
        assert_eq!(
            ::core::mem::size_of::<rps_map>(),
            24usize,
            concat!("Size of: ", stringify!(rps_map))
        );
        assert_eq!(
            ::core::mem::align_of::<rps_map>(),
            8usize,
            concat!("Alignment of ", stringify!(rps_map))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rps_map>())).len as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rps_map),
                "::",
                stringify!(len)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rps_map>())).rcu as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rps_map),
                "::",
                stringify!(rcu)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rps_map>())).cpus as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rps_map),
                "::",
                stringify!(cpus)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct rps_dev_flow {
        pub cpu: _cargo_bpf_u16,
        pub filter: _cargo_bpf_u16,
        pub last_qtail: ::cty::c_uint,
    }
    #[test]
    fn bindgen_test_layout_rps_dev_flow() {
        assert_eq!(
            ::core::mem::size_of::<rps_dev_flow>(),
            8usize,
            concat!("Size of: ", stringify!(rps_dev_flow))
        );
        assert_eq!(
            ::core::mem::align_of::<rps_dev_flow>(),
            4usize,
            concat!("Alignment of ", stringify!(rps_dev_flow))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rps_dev_flow>())).cpu as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rps_dev_flow),
                "::",
                stringify!(cpu)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rps_dev_flow>())).filter as *const _ as usize },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(rps_dev_flow),
                "::",
                stringify!(filter)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rps_dev_flow>())).last_qtail as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(rps_dev_flow),
                "::",
                stringify!(last_qtail)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct rps_dev_flow_table {
        pub mask: ::cty::c_uint,
        pub rcu: callback_head,
        pub flows: __IncompleteArrayField<rps_dev_flow>,
    }
    #[test]
    fn bindgen_test_layout_rps_dev_flow_table() {
        assert_eq!(
            ::core::mem::size_of::<rps_dev_flow_table>(),
            24usize,
            concat!("Size of: ", stringify!(rps_dev_flow_table))
        );
        assert_eq!(
            ::core::mem::align_of::<rps_dev_flow_table>(),
            8usize,
            concat!("Alignment of ", stringify!(rps_dev_flow_table))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rps_dev_flow_table>())).mask as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rps_dev_flow_table),
                "::",
                stringify!(mask)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rps_dev_flow_table>())).rcu as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rps_dev_flow_table),
                "::",
                stringify!(rcu)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rps_dev_flow_table>())).flows as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rps_dev_flow_table),
                "::",
                stringify!(flows)
            )
        );
    }
    #[repr(C)]
    #[repr(align(64))]
    #[derive(Debug, Copy, Clone)]
    pub struct netdev_rx_queue {
        pub xdp_rxq: xdp_rxq_info,
        pub rps_map: *mut rps_map,
        pub rps_flow_table: *mut rps_dev_flow_table,
        pub kobj: kobject,
        pub dev: *mut net_device,
        pub dev_tracker: netdevice_tracker,
        pub pool: *mut xsk_buff_pool,
    }
    #[test]
    fn bindgen_test_layout_netdev_rx_queue() {
        assert_eq!(
            ::core::mem::size_of::<netdev_rx_queue>(),
            192usize,
            concat!("Size of: ", stringify!(netdev_rx_queue))
        );
        assert_eq!(
            ::core::mem::align_of::<netdev_rx_queue>(),
            64usize,
            concat!("Alignment of ", stringify!(netdev_rx_queue))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netdev_rx_queue>())).xdp_rxq as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(netdev_rx_queue),
                "::",
                stringify!(xdp_rxq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netdev_rx_queue>())).rps_map as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(netdev_rx_queue),
                "::",
                stringify!(rps_map)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netdev_rx_queue>())).rps_flow_table as *const _ as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(netdev_rx_queue),
                "::",
                stringify!(rps_flow_table)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netdev_rx_queue>())).kobj as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(netdev_rx_queue),
                "::",
                stringify!(kobj)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netdev_rx_queue>())).dev as *const _ as usize },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(netdev_rx_queue),
                "::",
                stringify!(dev)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netdev_rx_queue>())).dev_tracker as *const _ as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(netdev_rx_queue),
                "::",
                stringify!(dev_tracker)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netdev_rx_queue>())).pool as *const _ as usize },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(netdev_rx_queue),
                "::",
                stringify!(pool)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct xps_map {
        pub len: ::cty::c_uint,
        pub alloc_len: ::cty::c_uint,
        pub rcu: callback_head,
        pub queues: __IncompleteArrayField<_cargo_bpf_u16>,
    }
    #[test]
    fn bindgen_test_layout_xps_map() {
        assert_eq!(
            ::core::mem::size_of::<xps_map>(),
            24usize,
            concat!("Size of: ", stringify!(xps_map))
        );
        assert_eq!(
            ::core::mem::align_of::<xps_map>(),
            8usize,
            concat!("Alignment of ", stringify!(xps_map))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xps_map>())).len as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(xps_map),
                "::",
                stringify!(len)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xps_map>())).alloc_len as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(xps_map),
                "::",
                stringify!(alloc_len)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xps_map>())).rcu as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(xps_map),
                "::",
                stringify!(rcu)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xps_map>())).queues as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(xps_map),
                "::",
                stringify!(queues)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct xps_dev_maps {
        pub rcu: callback_head,
        pub nr_ids: ::cty::c_uint,
        pub num_tc: s16,
        pub attr_map: __IncompleteArrayField<*mut xps_map>,
    }
    #[test]
    fn bindgen_test_layout_xps_dev_maps() {
        assert_eq!(
            ::core::mem::size_of::<xps_dev_maps>(),
            24usize,
            concat!("Size of: ", stringify!(xps_dev_maps))
        );
        assert_eq!(
            ::core::mem::align_of::<xps_dev_maps>(),
            8usize,
            concat!("Alignment of ", stringify!(xps_dev_maps))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xps_dev_maps>())).rcu as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(xps_dev_maps),
                "::",
                stringify!(rcu)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xps_dev_maps>())).nr_ids as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(xps_dev_maps),
                "::",
                stringify!(nr_ids)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xps_dev_maps>())).num_tc as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(xps_dev_maps),
                "::",
                stringify!(num_tc)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<xps_dev_maps>())).attr_map as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(xps_dev_maps),
                "::",
                stringify!(attr_map)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct netdev_tc_txq {
        pub count: _cargo_bpf_u16,
        pub offset: _cargo_bpf_u16,
    }
    #[test]
    fn bindgen_test_layout_netdev_tc_txq() {
        assert_eq!(
            ::core::mem::size_of::<netdev_tc_txq>(),
            4usize,
            concat!("Size of: ", stringify!(netdev_tc_txq))
        );
        assert_eq!(
            ::core::mem::align_of::<netdev_tc_txq>(),
            2usize,
            concat!("Alignment of ", stringify!(netdev_tc_txq))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netdev_tc_txq>())).count as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(netdev_tc_txq),
                "::",
                stringify!(count)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netdev_tc_txq>())).offset as *const _ as usize },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(netdev_tc_txq),
                "::",
                stringify!(offset)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct netdev_fcoe_hbainfo {
        pub manufacturer: [::cty::c_char; 64usize],
        pub serial_number: [::cty::c_char; 64usize],
        pub hardware_version: [::cty::c_char; 64usize],
        pub driver_version: [::cty::c_char; 64usize],
        pub optionrom_version: [::cty::c_char; 64usize],
        pub firmware_version: [::cty::c_char; 64usize],
        pub model: [::cty::c_char; 256usize],
        pub model_description: [::cty::c_char; 256usize],
    }
    #[test]
    fn bindgen_test_layout_netdev_fcoe_hbainfo() {
        assert_eq!(
            ::core::mem::size_of::<netdev_fcoe_hbainfo>(),
            896usize,
            concat!("Size of: ", stringify!(netdev_fcoe_hbainfo))
        );
        assert_eq!(
            ::core::mem::align_of::<netdev_fcoe_hbainfo>(),
            1usize,
            concat!("Alignment of ", stringify!(netdev_fcoe_hbainfo))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netdev_fcoe_hbainfo>())).manufacturer as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(netdev_fcoe_hbainfo),
                "::",
                stringify!(manufacturer)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netdev_fcoe_hbainfo>())).serial_number as *const _ as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(netdev_fcoe_hbainfo),
                "::",
                stringify!(serial_number)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netdev_fcoe_hbainfo>())).hardware_version as *const _
                    as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(netdev_fcoe_hbainfo),
                "::",
                stringify!(hardware_version)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netdev_fcoe_hbainfo>())).driver_version as *const _ as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(netdev_fcoe_hbainfo),
                "::",
                stringify!(driver_version)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netdev_fcoe_hbainfo>())).optionrom_version as *const _
                    as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(netdev_fcoe_hbainfo),
                "::",
                stringify!(optionrom_version)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netdev_fcoe_hbainfo>())).firmware_version as *const _
                    as usize
            },
            320usize,
            concat!(
                "Offset of field: ",
                stringify!(netdev_fcoe_hbainfo),
                "::",
                stringify!(firmware_version)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netdev_fcoe_hbainfo>())).model as *const _ as usize },
            384usize,
            concat!(
                "Offset of field: ",
                stringify!(netdev_fcoe_hbainfo),
                "::",
                stringify!(model)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netdev_fcoe_hbainfo>())).model_description as *const _
                    as usize
            },
            640usize,
            concat!(
                "Offset of field: ",
                stringify!(netdev_fcoe_hbainfo),
                "::",
                stringify!(model_description)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct netdev_phys_item_id {
        pub id: [::cty::c_uchar; 32usize],
        pub id_len: ::cty::c_uchar,
    }
    #[test]
    fn bindgen_test_layout_netdev_phys_item_id() {
        assert_eq!(
            ::core::mem::size_of::<netdev_phys_item_id>(),
            33usize,
            concat!("Size of: ", stringify!(netdev_phys_item_id))
        );
        assert_eq!(
            ::core::mem::align_of::<netdev_phys_item_id>(),
            1usize,
            concat!("Alignment of ", stringify!(netdev_phys_item_id))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netdev_phys_item_id>())).id as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(netdev_phys_item_id),
                "::",
                stringify!(id)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netdev_phys_item_id>())).id_len as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(netdev_phys_item_id),
                "::",
                stringify!(id_len)
            )
        );
    }
    pub const net_device_path_type_DEV_PATH_ETHERNET: net_device_path_type = 0;
    pub const net_device_path_type_DEV_PATH_VLAN: net_device_path_type = 1;
    pub const net_device_path_type_DEV_PATH_BRIDGE: net_device_path_type = 2;
    pub const net_device_path_type_DEV_PATH_PPPOE: net_device_path_type = 3;
    pub const net_device_path_type_DEV_PATH_DSA: net_device_path_type = 4;
    pub const net_device_path_type_DEV_PATH_MTK_WDMA: net_device_path_type = 5;
    pub type net_device_path_type = ::cty::c_uint;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct net_device_path {
        pub type_: net_device_path_type,
        pub dev: *const net_device,
        pub __bindgen_anon_1: net_device_path__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union net_device_path__bindgen_ty_1 {
        pub encap: net_device_path__bindgen_ty_1__bindgen_ty_1,
        pub bridge: net_device_path__bindgen_ty_1__bindgen_ty_2,
        pub dsa: net_device_path__bindgen_ty_1__bindgen_ty_3,
        pub mtk_wdma: net_device_path__bindgen_ty_1__bindgen_ty_4,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct net_device_path__bindgen_ty_1__bindgen_ty_1 {
        pub id: _cargo_bpf_u16,
        pub proto: __be16,
        pub h_dest: [_cargo_bpf_u8; 6usize],
    }
    #[test]
    fn bindgen_test_layout_net_device_path__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<net_device_path__bindgen_ty_1__bindgen_ty_1>(),
            10usize,
            concat!(
                "Size of: ",
                stringify!(net_device_path__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<net_device_path__bindgen_ty_1__bindgen_ty_1>(),
            2usize,
            concat!(
                "Alignment of ",
                stringify!(net_device_path__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_path__bindgen_ty_1__bindgen_ty_1>())).id
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_path__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(id)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_path__bindgen_ty_1__bindgen_ty_1>())).proto
                    as *const _ as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_path__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(proto)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_path__bindgen_ty_1__bindgen_ty_1>())).h_dest
                    as *const _ as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_path__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(h_dest)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct net_device_path__bindgen_ty_1__bindgen_ty_2 {
        pub vlan_mode: net_device_path__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
        pub vlan_id: _cargo_bpf_u16,
        pub vlan_proto: __be16,
    }
    pub const net_device_path__bindgen_ty_1__bindgen_ty_2_DEV_PATH_BR_VLAN_KEEP: ::cty::c_uint = 0;
    pub const net_device_path__bindgen_ty_1__bindgen_ty_2_DEV_PATH_BR_VLAN_TAG: ::cty::c_uint = 1;
    pub const net_device_path__bindgen_ty_1__bindgen_ty_2_DEV_PATH_BR_VLAN_UNTAG: ::cty::c_uint = 2;
    pub const net_device_path__bindgen_ty_1__bindgen_ty_2_DEV_PATH_BR_VLAN_UNTAG_HW: ::cty::c_uint =
        3;
    pub type net_device_path__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 = ::cty::c_uint;
    #[test]
    fn bindgen_test_layout_net_device_path__bindgen_ty_1__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<net_device_path__bindgen_ty_1__bindgen_ty_2>(),
            8usize,
            concat!(
                "Size of: ",
                stringify!(net_device_path__bindgen_ty_1__bindgen_ty_2)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<net_device_path__bindgen_ty_1__bindgen_ty_2>(),
            4usize,
            concat!(
                "Alignment of ",
                stringify!(net_device_path__bindgen_ty_1__bindgen_ty_2)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_path__bindgen_ty_1__bindgen_ty_2>())).vlan_mode
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_path__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(vlan_mode)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_path__bindgen_ty_1__bindgen_ty_2>())).vlan_id
                    as *const _ as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_path__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(vlan_id)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_path__bindgen_ty_1__bindgen_ty_2>())).vlan_proto
                    as *const _ as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_path__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(vlan_proto)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct net_device_path__bindgen_ty_1__bindgen_ty_3 {
        pub port: ::cty::c_int,
        pub proto: _cargo_bpf_u16,
    }
    #[test]
    fn bindgen_test_layout_net_device_path__bindgen_ty_1__bindgen_ty_3() {
        assert_eq!(
            ::core::mem::size_of::<net_device_path__bindgen_ty_1__bindgen_ty_3>(),
            8usize,
            concat!(
                "Size of: ",
                stringify!(net_device_path__bindgen_ty_1__bindgen_ty_3)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<net_device_path__bindgen_ty_1__bindgen_ty_3>(),
            4usize,
            concat!(
                "Alignment of ",
                stringify!(net_device_path__bindgen_ty_1__bindgen_ty_3)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_path__bindgen_ty_1__bindgen_ty_3>())).port
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_path__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(port)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_path__bindgen_ty_1__bindgen_ty_3>())).proto
                    as *const _ as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_path__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(proto)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct net_device_path__bindgen_ty_1__bindgen_ty_4 {
        pub wdma_idx: _cargo_bpf_u8,
        pub queue: _cargo_bpf_u8,
        pub wcid: _cargo_bpf_u16,
        pub bss: _cargo_bpf_u8,
    }
    #[test]
    fn bindgen_test_layout_net_device_path__bindgen_ty_1__bindgen_ty_4() {
        assert_eq!(
            ::core::mem::size_of::<net_device_path__bindgen_ty_1__bindgen_ty_4>(),
            6usize,
            concat!(
                "Size of: ",
                stringify!(net_device_path__bindgen_ty_1__bindgen_ty_4)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<net_device_path__bindgen_ty_1__bindgen_ty_4>(),
            2usize,
            concat!(
                "Alignment of ",
                stringify!(net_device_path__bindgen_ty_1__bindgen_ty_4)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_path__bindgen_ty_1__bindgen_ty_4>())).wdma_idx
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_path__bindgen_ty_1__bindgen_ty_4),
                "::",
                stringify!(wdma_idx)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_path__bindgen_ty_1__bindgen_ty_4>())).queue
                    as *const _ as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_path__bindgen_ty_1__bindgen_ty_4),
                "::",
                stringify!(queue)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_path__bindgen_ty_1__bindgen_ty_4>())).wcid
                    as *const _ as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_path__bindgen_ty_1__bindgen_ty_4),
                "::",
                stringify!(wcid)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_path__bindgen_ty_1__bindgen_ty_4>())).bss
                    as *const _ as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_path__bindgen_ty_1__bindgen_ty_4),
                "::",
                stringify!(bss)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_net_device_path__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<net_device_path__bindgen_ty_1>(),
            12usize,
            concat!("Size of: ", stringify!(net_device_path__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<net_device_path__bindgen_ty_1>(),
            4usize,
            concat!("Alignment of ", stringify!(net_device_path__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_path__bindgen_ty_1>())).encap as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_path__bindgen_ty_1),
                "::",
                stringify!(encap)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_path__bindgen_ty_1>())).bridge as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_path__bindgen_ty_1),
                "::",
                stringify!(bridge)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_path__bindgen_ty_1>())).dsa as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_path__bindgen_ty_1),
                "::",
                stringify!(dsa)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_path__bindgen_ty_1>())).mtk_wdma as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_path__bindgen_ty_1),
                "::",
                stringify!(mtk_wdma)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_net_device_path() {
        assert_eq!(
            ::core::mem::size_of::<net_device_path>(),
            32usize,
            concat!("Size of: ", stringify!(net_device_path))
        );
        assert_eq!(
            ::core::mem::align_of::<net_device_path>(),
            8usize,
            concat!("Alignment of ", stringify!(net_device_path))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device_path>())).type_ as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_path),
                "::",
                stringify!(type_)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device_path>())).dev as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_path),
                "::",
                stringify!(dev)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct net_device_path_ctx {
        pub dev: *const net_device,
        pub daddr: [_cargo_bpf_u8; 6usize],
        pub num_vlans: ::cty::c_int,
        pub vlan: [net_device_path_ctx__bindgen_ty_1; 2usize],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct net_device_path_ctx__bindgen_ty_1 {
        pub id: _cargo_bpf_u16,
        pub proto: __be16,
    }
    #[test]
    fn bindgen_test_layout_net_device_path_ctx__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<net_device_path_ctx__bindgen_ty_1>(),
            4usize,
            concat!("Size of: ", stringify!(net_device_path_ctx__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<net_device_path_ctx__bindgen_ty_1>(),
            2usize,
            concat!(
                "Alignment of ",
                stringify!(net_device_path_ctx__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_path_ctx__bindgen_ty_1>())).id as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_path_ctx__bindgen_ty_1),
                "::",
                stringify!(id)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_path_ctx__bindgen_ty_1>())).proto as *const _
                    as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_path_ctx__bindgen_ty_1),
                "::",
                stringify!(proto)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_net_device_path_ctx() {
        assert_eq!(
            ::core::mem::size_of::<net_device_path_ctx>(),
            32usize,
            concat!("Size of: ", stringify!(net_device_path_ctx))
        );
        assert_eq!(
            ::core::mem::align_of::<net_device_path_ctx>(),
            8usize,
            concat!("Alignment of ", stringify!(net_device_path_ctx))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device_path_ctx>())).dev as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_path_ctx),
                "::",
                stringify!(dev)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device_path_ctx>())).daddr as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_path_ctx),
                "::",
                stringify!(daddr)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_path_ctx>())).num_vlans as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_path_ctx),
                "::",
                stringify!(num_vlans)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device_path_ctx>())).vlan as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_path_ctx),
                "::",
                stringify!(vlan)
            )
        );
    }
    pub const tc_setup_type_TC_QUERY_CAPS: tc_setup_type = 0;
    pub const tc_setup_type_TC_SETUP_QDISC_MQPRIO: tc_setup_type = 1;
    pub const tc_setup_type_TC_SETUP_CLSU32: tc_setup_type = 2;
    pub const tc_setup_type_TC_SETUP_CLSFLOWER: tc_setup_type = 3;
    pub const tc_setup_type_TC_SETUP_CLSMATCHALL: tc_setup_type = 4;
    pub const tc_setup_type_TC_SETUP_CLSBPF: tc_setup_type = 5;
    pub const tc_setup_type_TC_SETUP_BLOCK: tc_setup_type = 6;
    pub const tc_setup_type_TC_SETUP_QDISC_CBS: tc_setup_type = 7;
    pub const tc_setup_type_TC_SETUP_QDISC_RED: tc_setup_type = 8;
    pub const tc_setup_type_TC_SETUP_QDISC_PRIO: tc_setup_type = 9;
    pub const tc_setup_type_TC_SETUP_QDISC_MQ: tc_setup_type = 10;
    pub const tc_setup_type_TC_SETUP_QDISC_ETF: tc_setup_type = 11;
    pub const tc_setup_type_TC_SETUP_ROOT_QDISC: tc_setup_type = 12;
    pub const tc_setup_type_TC_SETUP_QDISC_GRED: tc_setup_type = 13;
    pub const tc_setup_type_TC_SETUP_QDISC_TAPRIO: tc_setup_type = 14;
    pub const tc_setup_type_TC_SETUP_FT: tc_setup_type = 15;
    pub const tc_setup_type_TC_SETUP_QDISC_ETS: tc_setup_type = 16;
    pub const tc_setup_type_TC_SETUP_QDISC_TBF: tc_setup_type = 17;
    pub const tc_setup_type_TC_SETUP_QDISC_FIFO: tc_setup_type = 18;
    pub const tc_setup_type_TC_SETUP_QDISC_HTB: tc_setup_type = 19;
    pub const tc_setup_type_TC_SETUP_ACT: tc_setup_type = 20;
    pub type tc_setup_type = ::cty::c_uint;
    pub const bpf_netdev_command_XDP_SETUP_PROG: bpf_netdev_command = 0;
    pub const bpf_netdev_command_XDP_SETUP_PROG_HW: bpf_netdev_command = 1;
    pub const bpf_netdev_command_BPF_OFFLOAD_MAP_ALLOC: bpf_netdev_command = 2;
    pub const bpf_netdev_command_BPF_OFFLOAD_MAP_FREE: bpf_netdev_command = 3;
    pub const bpf_netdev_command_XDP_SETUP_XSK_POOL: bpf_netdev_command = 4;
    pub type bpf_netdev_command = ::cty::c_uint;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_prog_offload_ops {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct xdp_dev_bulk_queue {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_xdp_link {
        _unused: [u8; 0],
    }
    pub const bpf_xdp_mode_XDP_MODE_SKB: bpf_xdp_mode = 0;
    pub const bpf_xdp_mode_XDP_MODE_DRV: bpf_xdp_mode = 1;
    pub const bpf_xdp_mode_XDP_MODE_HW: bpf_xdp_mode = 2;
    pub const bpf_xdp_mode___MAX_XDP_MODE: bpf_xdp_mode = 3;
    pub type bpf_xdp_mode = ::cty::c_uint;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_xdp_entity {
        pub prog: *mut bpf_prog,
        pub link: *mut bpf_xdp_link,
    }
    #[test]
    fn bindgen_test_layout_bpf_xdp_entity() {
        assert_eq!(
            ::core::mem::size_of::<bpf_xdp_entity>(),
            16usize,
            concat!("Size of: ", stringify!(bpf_xdp_entity))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_xdp_entity>(),
            8usize,
            concat!("Alignment of ", stringify!(bpf_xdp_entity))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_xdp_entity>())).prog as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_xdp_entity),
                "::",
                stringify!(prog)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_xdp_entity>())).link as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_xdp_entity),
                "::",
                stringify!(link)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct netdev_bpf {
        pub command: bpf_netdev_command,
        pub __bindgen_anon_1: netdev_bpf__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union netdev_bpf__bindgen_ty_1 {
        pub __bindgen_anon_1: netdev_bpf__bindgen_ty_1__bindgen_ty_1,
        pub __bindgen_anon_2: netdev_bpf__bindgen_ty_1__bindgen_ty_2,
        pub xsk: netdev_bpf__bindgen_ty_1__bindgen_ty_3,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct netdev_bpf__bindgen_ty_1__bindgen_ty_1 {
        pub flags: _cargo_bpf_u32,
        pub prog: *mut bpf_prog,
        pub extack: *mut netlink_ext_ack,
    }
    #[test]
    fn bindgen_test_layout_netdev_bpf__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<netdev_bpf__bindgen_ty_1__bindgen_ty_1>(),
            24usize,
            concat!(
                "Size of: ",
                stringify!(netdev_bpf__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<netdev_bpf__bindgen_ty_1__bindgen_ty_1>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(netdev_bpf__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netdev_bpf__bindgen_ty_1__bindgen_ty_1>())).flags
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(netdev_bpf__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netdev_bpf__bindgen_ty_1__bindgen_ty_1>())).prog as *const _
                    as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(netdev_bpf__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(prog)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netdev_bpf__bindgen_ty_1__bindgen_ty_1>())).extack
                    as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(netdev_bpf__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(extack)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct netdev_bpf__bindgen_ty_1__bindgen_ty_2 {
        pub offmap: *mut bpf_offloaded_map,
    }
    #[test]
    fn bindgen_test_layout_netdev_bpf__bindgen_ty_1__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<netdev_bpf__bindgen_ty_1__bindgen_ty_2>(),
            8usize,
            concat!(
                "Size of: ",
                stringify!(netdev_bpf__bindgen_ty_1__bindgen_ty_2)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<netdev_bpf__bindgen_ty_1__bindgen_ty_2>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(netdev_bpf__bindgen_ty_1__bindgen_ty_2)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netdev_bpf__bindgen_ty_1__bindgen_ty_2>())).offmap
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(netdev_bpf__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(offmap)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct netdev_bpf__bindgen_ty_1__bindgen_ty_3 {
        pub pool: *mut xsk_buff_pool,
        pub queue_id: _cargo_bpf_u16,
    }
    #[test]
    fn bindgen_test_layout_netdev_bpf__bindgen_ty_1__bindgen_ty_3() {
        assert_eq!(
            ::core::mem::size_of::<netdev_bpf__bindgen_ty_1__bindgen_ty_3>(),
            16usize,
            concat!(
                "Size of: ",
                stringify!(netdev_bpf__bindgen_ty_1__bindgen_ty_3)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<netdev_bpf__bindgen_ty_1__bindgen_ty_3>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(netdev_bpf__bindgen_ty_1__bindgen_ty_3)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netdev_bpf__bindgen_ty_1__bindgen_ty_3>())).pool as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(netdev_bpf__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(pool)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netdev_bpf__bindgen_ty_1__bindgen_ty_3>())).queue_id
                    as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(netdev_bpf__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(queue_id)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_netdev_bpf__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<netdev_bpf__bindgen_ty_1>(),
            24usize,
            concat!("Size of: ", stringify!(netdev_bpf__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<netdev_bpf__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(netdev_bpf__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netdev_bpf__bindgen_ty_1>())).xsk as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(netdev_bpf__bindgen_ty_1),
                "::",
                stringify!(xsk)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_netdev_bpf() {
        assert_eq!(
            ::core::mem::size_of::<netdev_bpf>(),
            32usize,
            concat!("Size of: ", stringify!(netdev_bpf))
        );
        assert_eq!(
            ::core::mem::align_of::<netdev_bpf>(),
            8usize,
            concat!("Alignment of ", stringify!(netdev_bpf))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<netdev_bpf>())).command as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(netdev_bpf),
                "::",
                stringify!(command)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct xfrmdev_ops {
        pub xdo_dev_state_add: ::core::option::Option<
            unsafe extern "C" fn(x: *mut xfrm_state, extack: *mut netlink_ext_ack) -> ::cty::c_int,
        >,
        pub xdo_dev_state_delete: ::core::option::Option<unsafe extern "C" fn(x: *mut xfrm_state)>,
        pub xdo_dev_state_free: ::core::option::Option<unsafe extern "C" fn(x: *mut xfrm_state)>,
        pub xdo_dev_offload_ok: ::core::option::Option<
            unsafe extern "C" fn(skb: *mut sk_buff, x: *mut xfrm_state) -> bool_,
        >,
        pub xdo_dev_state_advance_esn:
            ::core::option::Option<unsafe extern "C" fn(x: *mut xfrm_state)>,
        pub xdo_dev_state_update_curlft:
            ::core::option::Option<unsafe extern "C" fn(x: *mut xfrm_state)>,
        pub xdo_dev_policy_add: ::core::option::Option<
            unsafe extern "C" fn(x: *mut xfrm_policy, extack: *mut netlink_ext_ack) -> ::cty::c_int,
        >,
        pub xdo_dev_policy_delete:
            ::core::option::Option<unsafe extern "C" fn(x: *mut xfrm_policy)>,
        pub xdo_dev_policy_free: ::core::option::Option<unsafe extern "C" fn(x: *mut xfrm_policy)>,
    }
    #[test]
    fn bindgen_test_layout_xfrmdev_ops() {
        assert_eq!(
            ::core::mem::size_of::<xfrmdev_ops>(),
            72usize,
            concat!("Size of: ", stringify!(xfrmdev_ops))
        );
        assert_eq!(
            ::core::mem::align_of::<xfrmdev_ops>(),
            8usize,
            concat!("Alignment of ", stringify!(xfrmdev_ops))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<xfrmdev_ops>())).xdo_dev_state_add as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(xfrmdev_ops),
                "::",
                stringify!(xdo_dev_state_add)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<xfrmdev_ops>())).xdo_dev_state_delete as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(xfrmdev_ops),
                "::",
                stringify!(xdo_dev_state_delete)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<xfrmdev_ops>())).xdo_dev_state_free as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(xfrmdev_ops),
                "::",
                stringify!(xdo_dev_state_free)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<xfrmdev_ops>())).xdo_dev_offload_ok as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(xfrmdev_ops),
                "::",
                stringify!(xdo_dev_offload_ok)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<xfrmdev_ops>())).xdo_dev_state_advance_esn as *const _
                    as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(xfrmdev_ops),
                "::",
                stringify!(xdo_dev_state_advance_esn)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<xfrmdev_ops>())).xdo_dev_state_update_curlft as *const _
                    as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(xfrmdev_ops),
                "::",
                stringify!(xdo_dev_state_update_curlft)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<xfrmdev_ops>())).xdo_dev_policy_add as *const _ as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(xfrmdev_ops),
                "::",
                stringify!(xdo_dev_policy_add)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<xfrmdev_ops>())).xdo_dev_policy_delete as *const _ as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(xfrmdev_ops),
                "::",
                stringify!(xdo_dev_policy_delete)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<xfrmdev_ops>())).xdo_dev_policy_free as *const _ as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(xfrmdev_ops),
                "::",
                stringify!(xdo_dev_policy_free)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct dev_ifalias {
        pub rcuhead: callback_head,
        pub ifalias: __IncompleteArrayField<::cty::c_char>,
    }
    #[test]
    fn bindgen_test_layout_dev_ifalias() {
        assert_eq!(
            ::core::mem::size_of::<dev_ifalias>(),
            16usize,
            concat!("Size of: ", stringify!(dev_ifalias))
        );
        assert_eq!(
            ::core::mem::align_of::<dev_ifalias>(),
            8usize,
            concat!("Alignment of ", stringify!(dev_ifalias))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_ifalias>())).rcuhead as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_ifalias),
                "::",
                stringify!(rcuhead)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dev_ifalias>())).ifalias as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(dev_ifalias),
                "::",
                stringify!(ifalias)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct tlsdev_ops {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct net_device_ops {
        pub ndo_init:
            ::core::option::Option<unsafe extern "C" fn(dev: *mut net_device) -> ::cty::c_int>,
        pub ndo_uninit: ::core::option::Option<unsafe extern "C" fn(dev: *mut net_device)>,
        pub ndo_open:
            ::core::option::Option<unsafe extern "C" fn(dev: *mut net_device) -> ::cty::c_int>,
        pub ndo_stop:
            ::core::option::Option<unsafe extern "C" fn(dev: *mut net_device) -> ::cty::c_int>,
        pub ndo_start_xmit: ::core::option::Option<
            unsafe extern "C" fn(skb: *mut sk_buff, dev: *mut net_device) -> netdev_tx_t,
        >,
        pub ndo_features_check: ::core::option::Option<
            unsafe extern "C" fn(
                skb: *mut sk_buff,
                dev: *mut net_device,
                features: netdev_features_t,
            ) -> netdev_features_t,
        >,
        pub ndo_select_queue: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut net_device,
                skb: *mut sk_buff,
                sb_dev: *mut net_device,
            ) -> _cargo_bpf_u16,
        >,
        pub ndo_change_rx_flags:
            ::core::option::Option<unsafe extern "C" fn(dev: *mut net_device, flags: ::cty::c_int)>,
        pub ndo_set_rx_mode: ::core::option::Option<unsafe extern "C" fn(dev: *mut net_device)>,
        pub ndo_set_mac_address: ::core::option::Option<
            unsafe extern "C" fn(dev: *mut net_device, addr: *mut ::cty::c_void) -> ::cty::c_int,
        >,
        pub ndo_validate_addr:
            ::core::option::Option<unsafe extern "C" fn(dev: *mut net_device) -> ::cty::c_int>,
        pub ndo_do_ioctl: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut net_device,
                ifr: *mut ifreq,
                cmd: ::cty::c_int,
            ) -> ::cty::c_int,
        >,
        pub ndo_eth_ioctl: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut net_device,
                ifr: *mut ifreq,
                cmd: ::cty::c_int,
            ) -> ::cty::c_int,
        >,
        pub ndo_siocbond: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut net_device,
                ifr: *mut ifreq,
                cmd: ::cty::c_int,
            ) -> ::cty::c_int,
        >,
        pub ndo_siocwandev: ::core::option::Option<
            unsafe extern "C" fn(dev: *mut net_device, ifs: *mut if_settings) -> ::cty::c_int,
        >,
        pub ndo_siocdevprivate: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut net_device,
                ifr: *mut ifreq,
                data: *mut ::cty::c_void,
                cmd: ::cty::c_int,
            ) -> ::cty::c_int,
        >,
        pub ndo_set_config: ::core::option::Option<
            unsafe extern "C" fn(dev: *mut net_device, map: *mut ifmap) -> ::cty::c_int,
        >,
        pub ndo_change_mtu: ::core::option::Option<
            unsafe extern "C" fn(dev: *mut net_device, new_mtu: ::cty::c_int) -> ::cty::c_int,
        >,
        pub ndo_neigh_setup: ::core::option::Option<
            unsafe extern "C" fn(dev: *mut net_device, arg1: *mut neigh_parms) -> ::cty::c_int,
        >,
        pub ndo_tx_timeout: ::core::option::Option<
            unsafe extern "C" fn(dev: *mut net_device, txqueue: ::cty::c_uint),
        >,
        pub ndo_get_stats64: ::core::option::Option<
            unsafe extern "C" fn(dev: *mut net_device, storage: *mut rtnl_link_stats64),
        >,
        pub ndo_has_offload_stats: ::core::option::Option<
            unsafe extern "C" fn(dev: *const net_device, attr_id: ::cty::c_int) -> bool_,
        >,
        pub ndo_get_offload_stats: ::core::option::Option<
            unsafe extern "C" fn(
                attr_id: ::cty::c_int,
                dev: *const net_device,
                attr_data: *mut ::cty::c_void,
            ) -> ::cty::c_int,
        >,
        pub ndo_get_stats: ::core::option::Option<
            unsafe extern "C" fn(dev: *mut net_device) -> *mut net_device_stats,
        >,
        pub ndo_vlan_rx_add_vid: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut net_device,
                proto: __be16,
                vid: _cargo_bpf_u16,
            ) -> ::cty::c_int,
        >,
        pub ndo_vlan_rx_kill_vid: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut net_device,
                proto: __be16,
                vid: _cargo_bpf_u16,
            ) -> ::cty::c_int,
        >,
        pub ndo_poll_controller: ::core::option::Option<unsafe extern "C" fn(dev: *mut net_device)>,
        pub ndo_netpoll_setup: ::core::option::Option<
            unsafe extern "C" fn(dev: *mut net_device, info: *mut netpoll_info) -> ::cty::c_int,
        >,
        pub ndo_netpoll_cleanup: ::core::option::Option<unsafe extern "C" fn(dev: *mut net_device)>,
        pub ndo_set_vf_mac: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut net_device,
                queue: ::cty::c_int,
                mac: *mut _cargo_bpf_u8,
            ) -> ::cty::c_int,
        >,
        pub ndo_set_vf_vlan: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut net_device,
                queue: ::cty::c_int,
                vlan: _cargo_bpf_u16,
                qos: _cargo_bpf_u8,
                proto: __be16,
            ) -> ::cty::c_int,
        >,
        pub ndo_set_vf_rate: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut net_device,
                vf: ::cty::c_int,
                min_tx_rate: ::cty::c_int,
                max_tx_rate: ::cty::c_int,
            ) -> ::cty::c_int,
        >,
        pub ndo_set_vf_spoofchk: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut net_device,
                vf: ::cty::c_int,
                setting: bool_,
            ) -> ::cty::c_int,
        >,
        pub ndo_set_vf_trust: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut net_device,
                vf: ::cty::c_int,
                setting: bool_,
            ) -> ::cty::c_int,
        >,
        pub ndo_get_vf_config: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut net_device,
                vf: ::cty::c_int,
                ivf: *mut ifla_vf_info,
            ) -> ::cty::c_int,
        >,
        pub ndo_set_vf_link_state: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut net_device,
                vf: ::cty::c_int,
                link_state: ::cty::c_int,
            ) -> ::cty::c_int,
        >,
        pub ndo_get_vf_stats: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut net_device,
                vf: ::cty::c_int,
                vf_stats: *mut ifla_vf_stats,
            ) -> ::cty::c_int,
        >,
        pub ndo_set_vf_port: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut net_device,
                vf: ::cty::c_int,
                port: *mut *mut nlattr,
            ) -> ::cty::c_int,
        >,
        pub ndo_get_vf_port: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut net_device,
                vf: ::cty::c_int,
                skb: *mut sk_buff,
            ) -> ::cty::c_int,
        >,
        pub ndo_get_vf_guid: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut net_device,
                vf: ::cty::c_int,
                node_guid: *mut ifla_vf_guid,
                port_guid: *mut ifla_vf_guid,
            ) -> ::cty::c_int,
        >,
        pub ndo_set_vf_guid: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut net_device,
                vf: ::cty::c_int,
                guid: _cargo_bpf_u64,
                guid_type: ::cty::c_int,
            ) -> ::cty::c_int,
        >,
        pub ndo_set_vf_rss_query_en: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut net_device,
                vf: ::cty::c_int,
                setting: bool_,
            ) -> ::cty::c_int,
        >,
        pub ndo_setup_tc: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut net_device,
                type_: tc_setup_type,
                type_data: *mut ::cty::c_void,
            ) -> ::cty::c_int,
        >,
        pub ndo_fcoe_enable:
            ::core::option::Option<unsafe extern "C" fn(dev: *mut net_device) -> ::cty::c_int>,
        pub ndo_fcoe_disable:
            ::core::option::Option<unsafe extern "C" fn(dev: *mut net_device) -> ::cty::c_int>,
        pub ndo_fcoe_ddp_setup: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut net_device,
                xid: _cargo_bpf_u16,
                sgl: *mut scatterlist,
                sgc: ::cty::c_uint,
            ) -> ::cty::c_int,
        >,
        pub ndo_fcoe_ddp_done: ::core::option::Option<
            unsafe extern "C" fn(dev: *mut net_device, xid: _cargo_bpf_u16) -> ::cty::c_int,
        >,
        pub ndo_fcoe_ddp_target: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut net_device,
                xid: _cargo_bpf_u16,
                sgl: *mut scatterlist,
                sgc: ::cty::c_uint,
            ) -> ::cty::c_int,
        >,
        pub ndo_fcoe_get_hbainfo: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut net_device,
                hbainfo: *mut netdev_fcoe_hbainfo,
            ) -> ::cty::c_int,
        >,
        pub ndo_fcoe_get_wwn: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut net_device,
                wwn: *mut _cargo_bpf_u64,
                type_: ::cty::c_int,
            ) -> ::cty::c_int,
        >,
        pub ndo_rx_flow_steer: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut net_device,
                skb: *const sk_buff,
                rxq_index: _cargo_bpf_u16,
                flow_id: _cargo_bpf_u32,
            ) -> ::cty::c_int,
        >,
        pub ndo_add_slave: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut net_device,
                slave_dev: *mut net_device,
                extack: *mut netlink_ext_ack,
            ) -> ::cty::c_int,
        >,
        pub ndo_del_slave: ::core::option::Option<
            unsafe extern "C" fn(dev: *mut net_device, slave_dev: *mut net_device) -> ::cty::c_int,
        >,
        pub ndo_get_xmit_slave: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut net_device,
                skb: *mut sk_buff,
                all_slaves: bool_,
            ) -> *mut net_device,
        >,
        pub ndo_sk_get_lower_dev: ::core::option::Option<
            unsafe extern "C" fn(dev: *mut net_device, sk: *mut sock) -> *mut net_device,
        >,
        pub ndo_fix_features: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut net_device,
                features: netdev_features_t,
            ) -> netdev_features_t,
        >,
        pub ndo_set_features: ::core::option::Option<
            unsafe extern "C" fn(dev: *mut net_device, features: netdev_features_t) -> ::cty::c_int,
        >,
        pub ndo_neigh_construct: ::core::option::Option<
            unsafe extern "C" fn(dev: *mut net_device, n: *mut neighbour) -> ::cty::c_int,
        >,
        pub ndo_neigh_destroy:
            ::core::option::Option<unsafe extern "C" fn(dev: *mut net_device, n: *mut neighbour)>,
        pub ndo_fdb_add: ::core::option::Option<
            unsafe extern "C" fn(
                ndm: *mut ndmsg,
                tb: *mut *mut nlattr,
                dev: *mut net_device,
                addr: *const ::cty::c_uchar,
                vid: _cargo_bpf_u16,
                flags: _cargo_bpf_u16,
                extack: *mut netlink_ext_ack,
            ) -> ::cty::c_int,
        >,
        pub ndo_fdb_del: ::core::option::Option<
            unsafe extern "C" fn(
                ndm: *mut ndmsg,
                tb: *mut *mut nlattr,
                dev: *mut net_device,
                addr: *const ::cty::c_uchar,
                vid: _cargo_bpf_u16,
                extack: *mut netlink_ext_ack,
            ) -> ::cty::c_int,
        >,
        pub ndo_fdb_del_bulk: ::core::option::Option<
            unsafe extern "C" fn(
                ndm: *mut ndmsg,
                tb: *mut *mut nlattr,
                dev: *mut net_device,
                vid: _cargo_bpf_u16,
                extack: *mut netlink_ext_ack,
            ) -> ::cty::c_int,
        >,
        pub ndo_fdb_dump: ::core::option::Option<
            unsafe extern "C" fn(
                skb: *mut sk_buff,
                cb: *mut netlink_callback,
                dev: *mut net_device,
                filter_dev: *mut net_device,
                idx: *mut ::cty::c_int,
            ) -> ::cty::c_int,
        >,
        pub ndo_fdb_get: ::core::option::Option<
            unsafe extern "C" fn(
                skb: *mut sk_buff,
                tb: *mut *mut nlattr,
                dev: *mut net_device,
                addr: *const ::cty::c_uchar,
                vid: _cargo_bpf_u16,
                portid: _cargo_bpf_u32,
                seq: _cargo_bpf_u32,
                extack: *mut netlink_ext_ack,
            ) -> ::cty::c_int,
        >,
        pub ndo_mdb_add: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut net_device,
                tb: *mut *mut nlattr,
                nlmsg_flags: _cargo_bpf_u16,
                extack: *mut netlink_ext_ack,
            ) -> ::cty::c_int,
        >,
        pub ndo_mdb_del: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut net_device,
                tb: *mut *mut nlattr,
                extack: *mut netlink_ext_ack,
            ) -> ::cty::c_int,
        >,
        pub ndo_mdb_dump: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut net_device,
                skb: *mut sk_buff,
                cb: *mut netlink_callback,
            ) -> ::cty::c_int,
        >,
        pub ndo_bridge_setlink: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut net_device,
                nlh: *mut nlmsghdr,
                flags: _cargo_bpf_u16,
                extack: *mut netlink_ext_ack,
            ) -> ::cty::c_int,
        >,
        pub ndo_bridge_getlink: ::core::option::Option<
            unsafe extern "C" fn(
                skb: *mut sk_buff,
                pid: _cargo_bpf_u32,
                seq: _cargo_bpf_u32,
                dev: *mut net_device,
                filter_mask: _cargo_bpf_u32,
                nlflags: ::cty::c_int,
            ) -> ::cty::c_int,
        >,
        pub ndo_bridge_dellink: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut net_device,
                nlh: *mut nlmsghdr,
                flags: _cargo_bpf_u16,
            ) -> ::cty::c_int,
        >,
        pub ndo_change_carrier: ::core::option::Option<
            unsafe extern "C" fn(dev: *mut net_device, new_carrier: bool_) -> ::cty::c_int,
        >,
        pub ndo_get_phys_port_id: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut net_device,
                ppid: *mut netdev_phys_item_id,
            ) -> ::cty::c_int,
        >,
        pub ndo_get_port_parent_id: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut net_device,
                ppid: *mut netdev_phys_item_id,
            ) -> ::cty::c_int,
        >,
        pub ndo_get_phys_port_name: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut net_device,
                name: *mut ::cty::c_char,
                len: size_t,
            ) -> ::cty::c_int,
        >,
        pub ndo_dfwd_add_station: ::core::option::Option<
            unsafe extern "C" fn(pdev: *mut net_device, dev: *mut net_device) -> *mut ::cty::c_void,
        >,
        pub ndo_dfwd_del_station: ::core::option::Option<
            unsafe extern "C" fn(pdev: *mut net_device, priv_: *mut ::cty::c_void),
        >,
        pub ndo_set_tx_maxrate: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut net_device,
                queue_index: ::cty::c_int,
                maxrate: _cargo_bpf_u32,
            ) -> ::cty::c_int,
        >,
        pub ndo_get_iflink:
            ::core::option::Option<unsafe extern "C" fn(dev: *const net_device) -> ::cty::c_int>,
        pub ndo_fill_metadata_dst: ::core::option::Option<
            unsafe extern "C" fn(dev: *mut net_device, skb: *mut sk_buff) -> ::cty::c_int,
        >,
        pub ndo_set_rx_headroom: ::core::option::Option<
            unsafe extern "C" fn(dev: *mut net_device, needed_headroom: ::cty::c_int),
        >,
        pub ndo_bpf: ::core::option::Option<
            unsafe extern "C" fn(dev: *mut net_device, bpf: *mut netdev_bpf) -> ::cty::c_int,
        >,
        pub ndo_xdp_xmit: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut net_device,
                n: ::cty::c_int,
                xdp: *mut *mut xdp_frame,
                flags: _cargo_bpf_u32,
            ) -> ::cty::c_int,
        >,
        pub ndo_xdp_get_xmit_slave: ::core::option::Option<
            unsafe extern "C" fn(dev: *mut net_device, xdp: *mut xdp_buff) -> *mut net_device,
        >,
        pub ndo_xsk_wakeup: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut net_device,
                queue_id: _cargo_bpf_u32,
                flags: _cargo_bpf_u32,
            ) -> ::cty::c_int,
        >,
        pub ndo_tunnel_ctl: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut net_device,
                p: *mut ip_tunnel_parm,
                cmd: ::cty::c_int,
            ) -> ::cty::c_int,
        >,
        pub ndo_get_peer_dev:
            ::core::option::Option<unsafe extern "C" fn(dev: *mut net_device) -> *mut net_device>,
        pub ndo_fill_forward_path: ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut net_device_path_ctx,
                path: *mut net_device_path,
            ) -> ::cty::c_int,
        >,
        pub ndo_get_tstamp: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut net_device,
                hwtstamps: *const skb_shared_hwtstamps,
                cycles: bool_,
            ) -> ktime_t,
        >,
    }
    #[test]
    fn bindgen_test_layout_net_device_ops() {
        assert_eq!(
            ::core::mem::size_of::<net_device_ops>(),
            704usize,
            concat!("Size of: ", stringify!(net_device_ops))
        );
        assert_eq!(
            ::core::mem::align_of::<net_device_ops>(),
            8usize,
            concat!("Alignment of ", stringify!(net_device_ops))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device_ops>())).ndo_init as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_init)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device_ops>())).ndo_uninit as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_uninit)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device_ops>())).ndo_open as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_open)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device_ops>())).ndo_stop as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_stop)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_start_xmit as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_start_xmit)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_features_check as *const _ as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_features_check)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_select_queue as *const _ as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_select_queue)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_change_rx_flags as *const _ as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_change_rx_flags)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_set_rx_mode as *const _ as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_set_rx_mode)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_set_mac_address as *const _ as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_set_mac_address)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_validate_addr as *const _ as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_validate_addr)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_do_ioctl as *const _ as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_do_ioctl)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_eth_ioctl as *const _ as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_eth_ioctl)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_siocbond as *const _ as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_siocbond)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_siocwandev as *const _ as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_siocwandev)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_siocdevprivate as *const _ as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_siocdevprivate)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_set_config as *const _ as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_set_config)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_change_mtu as *const _ as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_change_mtu)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_neigh_setup as *const _ as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_neigh_setup)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_tx_timeout as *const _ as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_tx_timeout)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_get_stats64 as *const _ as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_get_stats64)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_has_offload_stats as *const _
                    as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_has_offload_stats)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_get_offload_stats as *const _
                    as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_get_offload_stats)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_get_stats as *const _ as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_get_stats)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_vlan_rx_add_vid as *const _ as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_vlan_rx_add_vid)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_vlan_rx_kill_vid as *const _
                    as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_vlan_rx_kill_vid)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_poll_controller as *const _ as usize
            },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_poll_controller)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_netpoll_setup as *const _ as usize
            },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_netpoll_setup)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_netpoll_cleanup as *const _ as usize
            },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_netpoll_cleanup)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_set_vf_mac as *const _ as usize
            },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_set_vf_mac)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_set_vf_vlan as *const _ as usize
            },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_set_vf_vlan)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_set_vf_rate as *const _ as usize
            },
            248usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_set_vf_rate)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_set_vf_spoofchk as *const _ as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_set_vf_spoofchk)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_set_vf_trust as *const _ as usize
            },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_set_vf_trust)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_get_vf_config as *const _ as usize
            },
            272usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_get_vf_config)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_set_vf_link_state as *const _
                    as usize
            },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_set_vf_link_state)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_get_vf_stats as *const _ as usize
            },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_get_vf_stats)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_set_vf_port as *const _ as usize
            },
            296usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_set_vf_port)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_get_vf_port as *const _ as usize
            },
            304usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_get_vf_port)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_get_vf_guid as *const _ as usize
            },
            312usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_get_vf_guid)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_set_vf_guid as *const _ as usize
            },
            320usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_set_vf_guid)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_set_vf_rss_query_en as *const _
                    as usize
            },
            328usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_set_vf_rss_query_en)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_setup_tc as *const _ as usize
            },
            336usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_setup_tc)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_fcoe_enable as *const _ as usize
            },
            344usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_fcoe_enable)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_fcoe_disable as *const _ as usize
            },
            352usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_fcoe_disable)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_fcoe_ddp_setup as *const _ as usize
            },
            360usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_fcoe_ddp_setup)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_fcoe_ddp_done as *const _ as usize
            },
            368usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_fcoe_ddp_done)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_fcoe_ddp_target as *const _ as usize
            },
            376usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_fcoe_ddp_target)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_fcoe_get_hbainfo as *const _
                    as usize
            },
            384usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_fcoe_get_hbainfo)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_fcoe_get_wwn as *const _ as usize
            },
            392usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_fcoe_get_wwn)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_rx_flow_steer as *const _ as usize
            },
            400usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_rx_flow_steer)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_add_slave as *const _ as usize
            },
            408usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_add_slave)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_del_slave as *const _ as usize
            },
            416usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_del_slave)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_get_xmit_slave as *const _ as usize
            },
            424usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_get_xmit_slave)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_sk_get_lower_dev as *const _
                    as usize
            },
            432usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_sk_get_lower_dev)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_fix_features as *const _ as usize
            },
            440usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_fix_features)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_set_features as *const _ as usize
            },
            448usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_set_features)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_neigh_construct as *const _ as usize
            },
            456usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_neigh_construct)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_neigh_destroy as *const _ as usize
            },
            464usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_neigh_destroy)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device_ops>())).ndo_fdb_add as *const _ as usize },
            472usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_fdb_add)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device_ops>())).ndo_fdb_del as *const _ as usize },
            480usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_fdb_del)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_fdb_del_bulk as *const _ as usize
            },
            488usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_fdb_del_bulk)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_fdb_dump as *const _ as usize
            },
            496usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_fdb_dump)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device_ops>())).ndo_fdb_get as *const _ as usize },
            504usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_fdb_get)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device_ops>())).ndo_mdb_add as *const _ as usize },
            512usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_mdb_add)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device_ops>())).ndo_mdb_del as *const _ as usize },
            520usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_mdb_del)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_mdb_dump as *const _ as usize
            },
            528usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_mdb_dump)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_bridge_setlink as *const _ as usize
            },
            536usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_bridge_setlink)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_bridge_getlink as *const _ as usize
            },
            544usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_bridge_getlink)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_bridge_dellink as *const _ as usize
            },
            552usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_bridge_dellink)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_change_carrier as *const _ as usize
            },
            560usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_change_carrier)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_get_phys_port_id as *const _
                    as usize
            },
            568usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_get_phys_port_id)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_get_port_parent_id as *const _
                    as usize
            },
            576usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_get_port_parent_id)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_get_phys_port_name as *const _
                    as usize
            },
            584usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_get_phys_port_name)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_dfwd_add_station as *const _
                    as usize
            },
            592usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_dfwd_add_station)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_dfwd_del_station as *const _
                    as usize
            },
            600usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_dfwd_del_station)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_set_tx_maxrate as *const _ as usize
            },
            608usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_set_tx_maxrate)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_get_iflink as *const _ as usize
            },
            616usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_get_iflink)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_fill_metadata_dst as *const _
                    as usize
            },
            624usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_fill_metadata_dst)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_set_rx_headroom as *const _ as usize
            },
            632usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_set_rx_headroom)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device_ops>())).ndo_bpf as *const _ as usize },
            640usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_bpf)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_xdp_xmit as *const _ as usize
            },
            648usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_xdp_xmit)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_xdp_get_xmit_slave as *const _
                    as usize
            },
            656usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_xdp_get_xmit_slave)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_xsk_wakeup as *const _ as usize
            },
            664usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_xsk_wakeup)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_tunnel_ctl as *const _ as usize
            },
            672usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_tunnel_ctl)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_get_peer_dev as *const _ as usize
            },
            680usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_get_peer_dev)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_fill_forward_path as *const _
                    as usize
            },
            688usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_fill_forward_path)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device_ops>())).ndo_get_tstamp as *const _ as usize
            },
            696usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device_ops),
                "::",
                stringify!(ndo_get_tstamp)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct xdp_metadata_ops {
        pub xmo_rx_timestamp: ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *const xdp_md,
                timestamp: *mut _cargo_bpf_u64,
            ) -> ::cty::c_int,
        >,
        pub xmo_rx_hash: ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *const xdp_md,
                hash: *mut _cargo_bpf_u32,
                rss_type: *mut xdp_rss_hash_type,
            ) -> ::cty::c_int,
        >,
    }
    #[test]
    fn bindgen_test_layout_xdp_metadata_ops() {
        assert_eq!(
            ::core::mem::size_of::<xdp_metadata_ops>(),
            16usize,
            concat!("Size of: ", stringify!(xdp_metadata_ops))
        );
        assert_eq!(
            ::core::mem::align_of::<xdp_metadata_ops>(),
            8usize,
            concat!("Alignment of ", stringify!(xdp_metadata_ops))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<xdp_metadata_ops>())).xmo_rx_timestamp as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(xdp_metadata_ops),
                "::",
                stringify!(xmo_rx_timestamp)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<xdp_metadata_ops>())).xmo_rx_hash as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(xdp_metadata_ops),
                "::",
                stringify!(xmo_rx_hash)
            )
        );
    }
    pub const netdev_ml_priv_type_ML_PRIV_NONE: netdev_ml_priv_type = 0;
    pub const netdev_ml_priv_type_ML_PRIV_CAN: netdev_ml_priv_type = 1;
    pub type netdev_ml_priv_type = ::cty::c_uint;
    #[doc = "\tstruct net_device - The DEVICE structure."]
    #[doc = ""]
    #[doc = "\tActually, this whole structure is a big mistake.  It mixes I/O"]
    #[doc = "\tdata with strictly \"high-level\" data, and it has to know about"]
    #[doc = "\talmost every data structure used in the INET module."]
    #[doc = ""]
    #[doc = "\t@name:\tThis is the first field of the \"visible\" part of this structure"]
    #[doc = "\t\t(i.e. as seen by users in the \"Space.c\" file).  It is the name"]
    #[doc = "\t\tof the interface."]
    #[doc = ""]
    #[doc = "\t@name_node:\tName hashlist node"]
    #[doc = "\t@ifalias:\tSNMP alias"]
    #[doc = "\t@mem_end:\tShared memory end"]
    #[doc = "\t@mem_start:\tShared memory start"]
    #[doc = "\t@base_addr:\tDevice I/O address"]
    #[doc = "\t@irq:\t\tDevice IRQ number"]
    #[doc = ""]
    #[doc = "\t@state:\t\tGeneric network queuing layer state, see netdev_state_t"]
    #[doc = "\t@dev_list:\tThe global list of network devices"]
    #[doc = "\t@napi_list:\tList entry used for polling NAPI devices"]
    #[doc = "\t@unreg_list:\tList entry  when we are unregistering the"]
    #[doc = "\t\t\tdevice; see the function unregister_netdev"]
    #[doc = "\t@close_list:\tList entry used when we are closing the device"]
    #[doc = "\t@ptype_all:     Device-specific packet handlers for all protocols"]
    #[doc = "\t@ptype_specific: Device-specific, protocol-specific packet handlers"]
    #[doc = ""]
    #[doc = "\t@adj_list:\tDirectly linked devices, like slaves for bonding"]
    #[doc = "\t@features:\tCurrently active device features"]
    #[doc = "\t@hw_features:\tUser-changeable features"]
    #[doc = ""]
    #[doc = "\t@wanted_features:\tUser-requested features"]
    #[doc = "\t@vlan_features:\t\tMask of features inheritable by VLAN devices"]
    #[doc = ""]
    #[doc = "\t@hw_enc_features:\tMask of features inherited by encapsulating devices"]
    #[doc = "\t\t\t\tThis field indicates what encapsulation"]
    #[doc = "\t\t\t\toffloads the hardware is capable of doing,"]
    #[doc = "\t\t\t\tand drivers will need to set them appropriately."]
    #[doc = ""]
    #[doc = "\t@mpls_features:\tMask of features inheritable by MPLS"]
    #[doc = "\t@gso_partial_features: value(s) from NETIF_F_GSO\\*"]
    #[doc = ""]
    #[doc = "\t@ifindex:\tinterface index"]
    #[doc = "\t@group:\t\tThe group the device belongs to"]
    #[doc = ""]
    #[doc = "\t@stats:\t\tStatistics struct, which was left as a legacy, use"]
    #[doc = "\t\t\trtnl_link_stats64 instead"]
    #[doc = ""]
    #[doc = "\t@core_stats:\tcore networking counters,"]
    #[doc = "\t\t\tdo not use this in drivers"]
    #[doc = "\t@carrier_up_count:\tNumber of times the carrier has been up"]
    #[doc = "\t@carrier_down_count:\tNumber of times the carrier has been down"]
    #[doc = ""]
    #[doc = "\t@wireless_handlers:\tList of functions to handle Wireless Extensions,"]
    #[doc = "\t\t\t\tinstead of ioctl,"]
    #[doc = "\t\t\t\tsee <net/iw_handler.h> for details."]
    #[doc = "\t@wireless_data:\tInstance data managed by the core of wireless extensions"]
    #[doc = ""]
    #[doc = "\t@netdev_ops:\tIncludes several pointers to callbacks,"]
    #[doc = "\t\t\tif one wants to override the ndo_*() functions"]
    #[doc = "\t@xdp_metadata_ops:\tIncludes pointers to XDP metadata callbacks."]
    #[doc = "\t@ethtool_ops:\tManagement operations"]
    #[doc = "\t@l3mdev_ops:\tLayer 3 master device operations"]
    #[doc = "\t@ndisc_ops:\tIncludes callbacks for different IPv6 neighbour"]
    #[doc = "\t\t\tdiscovery handling. Necessary for e.g. 6LoWPAN."]
    #[doc = "\t@xfrmdev_ops:\tTransformation offload operations"]
    #[doc = "\t@tlsdev_ops:\tTransport Layer Security offload operations"]
    #[doc = "\t@header_ops:\tIncludes callbacks for creating,parsing,caching,etc"]
    #[doc = "\t\t\tof Layer 2 headers."]
    #[doc = ""]
    #[doc = "\t@flags:\t\tInterface flags (a la BSD)"]
    #[doc = "\t@xdp_features:\tXDP capability supported by the device"]
    #[doc = "\t@priv_flags:\tLike 'flags' but invisible to userspace,"]
    #[doc = "\t\t\tsee if.h for the definitions"]
    #[doc = "\t@gflags:\tGlobal flags ( kept as legacy )"]
    #[doc = "\t@padded:\tHow much padding added by alloc_netdev()"]
    #[doc = "\t@operstate:\tRFC2863 operstate"]
    #[doc = "\t@link_mode:\tMapping policy to operstate"]
    #[doc = "\t@if_port:\tSelectable AUI, TP, ..."]
    #[doc = "\t@dma:\t\tDMA channel"]
    #[doc = "\t@mtu:\t\tInterface MTU value"]
    #[doc = "\t@min_mtu:\tInterface Minimum MTU value"]
    #[doc = "\t@max_mtu:\tInterface Maximum MTU value"]
    #[doc = "\t@type:\t\tInterface hardware type"]
    #[doc = "\t@hard_header_len: Maximum hardware header length."]
    #[doc = "\t@min_header_len:  Minimum hardware header length"]
    #[doc = ""]
    #[doc = "\t@needed_headroom: Extra headroom the hardware may need, but not in all"]
    #[doc = "\t\t\t  cases can this be guaranteed"]
    #[doc = "\t@needed_tailroom: Extra tailroom the hardware may need, but not in all"]
    #[doc = "\t\t\t  cases can this be guaranteed. Some cases also use"]
    #[doc = "\t\t\t  LL_MAX_HEADER instead to allocate the skb"]
    #[doc = ""]
    #[doc = "\tinterface address info:"]
    #[doc = ""]
    #[doc = " \t@perm_addr:\t\tPermanent hw address"]
    #[doc = " \t@addr_assign_type:\tHw address assignment type"]
    #[doc = " \t@addr_len:\t\tHardware address length"]
    #[doc = "\t@upper_level:\t\tMaximum depth level of upper devices."]
    #[doc = "\t@lower_level:\t\tMaximum depth level of lower devices."]
    #[doc = "\t@neigh_priv_len:\tUsed in neigh_alloc()"]
    #[doc = " \t@dev_id:\t\tUsed to differentiate devices that share"]
    #[doc = " \t\t\t\tthe same link layer address"]
    #[doc = " \t@dev_port:\t\tUsed to differentiate devices that share"]
    #[doc = " \t\t\t\tthe same function"]
    #[doc = "\t@addr_list_lock:\tXXX: need comments on this one"]
    #[doc = "\t@name_assign_type:\tnetwork interface name assignment type"]
    #[doc = "\t@uc_promisc:\t\tCounter that indicates promiscuous mode"]
    #[doc = "\t\t\t\thas been enabled due to the need to listen to"]
    #[doc = "\t\t\t\tadditional unicast addresses in a device that"]
    #[doc = "\t\t\t\tdoes not implement ndo_set_rx_mode()"]
    #[doc = "\t@uc:\t\t\tunicast mac addresses"]
    #[doc = "\t@mc:\t\t\tmulticast mac addresses"]
    #[doc = "\t@dev_addrs:\t\tlist of device hw addresses"]
    #[doc = "\t@queues_kset:\t\tGroup of all Kobjects in the Tx and RX queues"]
    #[doc = "\t@promiscuity:\t\tNumber of times the NIC is told to work in"]
    #[doc = "\t\t\t\tpromiscuous mode; if it becomes 0 the NIC will"]
    #[doc = "\t\t\t\texit promiscuous mode"]
    #[doc = "\t@allmulti:\t\tCounter, enables or disables allmulticast mode"]
    #[doc = ""]
    #[doc = "\t@vlan_info:\tVLAN info"]
    #[doc = "\t@dsa_ptr:\tdsa specific data"]
    #[doc = "\t@tipc_ptr:\tTIPC specific data"]
    #[doc = "\t@atalk_ptr:\tAppleTalk link"]
    #[doc = "\t@ip_ptr:\tIPv4 specific data"]
    #[doc = "\t@ip6_ptr:\tIPv6 specific data"]
    #[doc = "\t@ax25_ptr:\tAX.25 specific data"]
    #[doc = "\t@ieee80211_ptr:\tIEEE 802.11 specific data, assign before registering"]
    #[doc = "\t@ieee802154_ptr: IEEE 802.15.4 low-rate Wireless Personal Area Network"]
    #[doc = "\t\t\t device struct"]
    #[doc = "\t@mpls_ptr:\tmpls_dev struct pointer"]
    #[doc = "\t@mctp_ptr:\tMCTP specific data"]
    #[doc = ""]
    #[doc = "\t@dev_addr:\tHw address (before bcast,"]
    #[doc = "\t\t\tbecause most packets are unicast)"]
    #[doc = ""]
    #[doc = "\t@_rx:\t\t\tArray of RX queues"]
    #[doc = "\t@num_rx_queues:\t\tNumber of RX queues"]
    #[doc = "\t\t\t\tallocated at register_netdev() time"]
    #[doc = "\t@real_num_rx_queues: \tNumber of RX queues currently active in device"]
    #[doc = "\t@xdp_prog:\t\tXDP sockets filter program pointer"]
    #[doc = "\t@gro_flush_timeout:\ttimeout for GRO layer in NAPI"]
    #[doc = "\t@napi_defer_hard_irqs:\tIf not zero, provides a counter that would"]
    #[doc = "\t\t\t\tallow to avoid NIC hard IRQ, on busy queues."]
    #[doc = ""]
    #[doc = "\t@rx_handler:\t\thandler for received packets"]
    #[doc = "\t@rx_handler_data: \tXXX: need comments on this one"]
    #[doc = "\t@miniq_ingress:\t\tingress/clsact qdisc specific data for"]
    #[doc = "\t\t\t\tingress processing"]
    #[doc = "\t@ingress_queue:\t\tXXX: need comments on this one"]
    #[doc = "\t@nf_hooks_ingress:\tnetfilter hooks executed for ingress packets"]
    #[doc = "\t@broadcast:\t\thw bcast address"]
    #[doc = ""]
    #[doc = "\t@rx_cpu_rmap:\tCPU reverse-mapping for RX completion interrupts,"]
    #[doc = "\t\t\tindexed by RX queue number. Assigned by driver."]
    #[doc = "\t\t\tThis must only be set if the ndo_rx_flow_steer"]
    #[doc = "\t\t\toperation is defined"]
    #[doc = "\t@index_hlist:\t\tDevice index hash chain"]
    #[doc = ""]
    #[doc = "\t@_tx:\t\t\tArray of TX queues"]
    #[doc = "\t@num_tx_queues:\t\tNumber of TX queues allocated at alloc_netdev_mq() time"]
    #[doc = "\t@real_num_tx_queues: \tNumber of TX queues currently active in device"]
    #[doc = "\t@qdisc:\t\t\tRoot qdisc from userspace point of view"]
    #[doc = "\t@tx_queue_len:\t\tMax frames per queue allowed"]
    #[doc = "\t@tx_global_lock: \tXXX: need comments on this one"]
    #[doc = "\t@xdp_bulkq:\t\tXDP device bulk queue"]
    #[doc = "\t@xps_maps:\t\tall CPUs/RXQs maps for XPS device"]
    #[doc = ""]
    #[doc = "\t@xps_maps:\tXXX: need comments on this one"]
    #[doc = "\t@miniq_egress:\t\tclsact qdisc specific data for"]
    #[doc = "\t\t\t\tegress processing"]
    #[doc = "\t@nf_hooks_egress:\tnetfilter hooks executed for egress packets"]
    #[doc = "\t@qdisc_hash:\t\tqdisc hash table"]
    #[doc = "\t@watchdog_timeo:\tRepresents the timeout that is used by"]
    #[doc = "\t\t\t\tthe watchdog (see dev_watchdog())"]
    #[doc = "\t@watchdog_timer:\tList of timers"]
    #[doc = ""]
    #[doc = "\t@proto_down_reason:\treason a netdev interface is held down"]
    #[doc = "\t@pcpu_refcnt:\t\tNumber of references to this device"]
    #[doc = "\t@dev_refcnt:\t\tNumber of references to this device"]
    #[doc = "\t@refcnt_tracker:\tTracker directory for tracked references to this device"]
    #[doc = "\t@todo_list:\t\tDelayed register/unregister"]
    #[doc = "\t@link_watch_list:\tXXX: need comments on this one"]
    #[doc = ""]
    #[doc = "\t@reg_state:\t\tRegister/unregister state machine"]
    #[doc = "\t@dismantle:\t\tDevice is going to be freed"]
    #[doc = "\t@rtnl_link_state:\tThis enum represents the phases of creating"]
    #[doc = "\t\t\t\ta new link"]
    #[doc = ""]
    #[doc = "\t@needs_free_netdev:\tShould unregister perform free_netdev?"]
    #[doc = "\t@priv_destructor:\tCalled from unregister"]
    #[doc = "\t@npinfo:\t\tXXX: need comments on this one"]
    #[doc = " \t@nd_net:\t\tNetwork namespace this network device is inside"]
    #[doc = ""]
    #[doc = " \t@ml_priv:\tMid-layer private"]
    #[doc = "\t@ml_priv_type:  Mid-layer private type"]
    #[doc = " \t@lstats:\tLoopback statistics"]
    #[doc = " \t@tstats:\tTunnel statistics"]
    #[doc = " \t@dstats:\tDummy statistics"]
    #[doc = " \t@vstats:\tVirtual ethernet statistics"]
    #[doc = ""]
    #[doc = "\t@garp_port:\tGARP"]
    #[doc = "\t@mrp_port:\tMRP"]
    #[doc = ""]
    #[doc = "\t@dm_private:\tDrop monitor private"]
    #[doc = ""]
    #[doc = "\t@dev:\t\tClass/net/name entry"]
    #[doc = "\t@sysfs_groups:\tSpace for optional device, statistics and wireless"]
    #[doc = "\t\t\tsysfs groups"]
    #[doc = ""]
    #[doc = "\t@sysfs_rx_queue_group:\tSpace for optional per-rx queue attributes"]
    #[doc = "\t@rtnl_link_ops:\tRtnl_link_ops"]
    #[doc = ""]
    #[doc = "\t@gso_max_size:\tMaximum size of generic segmentation offload"]
    #[doc = "\t@tso_max_size:\tDevice (as in HW) limit on the max TSO request size"]
    #[doc = "\t@gso_max_segs:\tMaximum number of segments that can be passed to the"]
    #[doc = "\t\t\tNIC for GSO"]
    #[doc = "\t@tso_max_segs:\tDevice (as in HW) limit on the max TSO segment count"]
    #[doc = " \t@gso_ipv4_max_size:\tMaximum size of generic segmentation offload,"]
    #[doc = " \t\t\t\tfor IPv4."]
    #[doc = ""]
    #[doc = "\t@dcbnl_ops:\tData Center Bridging netlink ops"]
    #[doc = "\t@num_tc:\tNumber of traffic classes in the net device"]
    #[doc = "\t@tc_to_txq:\tXXX: need comments on this one"]
    #[doc = "\t@prio_tc_map:\tXXX: need comments on this one"]
    #[doc = ""]
    #[doc = "\t@fcoe_ddp_xid:\tMax exchange id for FCoE LRO by ddp"]
    #[doc = ""]
    #[doc = "\t@priomap:\tXXX: need comments on this one"]
    #[doc = "\t@phydev:\tPhysical device may attach itself"]
    #[doc = "\t\t\tfor hardware timestamping"]
    #[doc = "\t@sfp_bus:\tattached &struct sfp_bus structure."]
    #[doc = ""]
    #[doc = "\t@qdisc_tx_busylock: lockdep class annotating Qdisc->busylock spinlock"]
    #[doc = ""]
    #[doc = "\t@proto_down:\tprotocol port state information can be sent to the"]
    #[doc = "\t\t\tswitch driver and used to set the phys state of the"]
    #[doc = "\t\t\tswitch port."]
    #[doc = ""]
    #[doc = "\t@wol_enabled:\tWake-on-LAN is enabled"]
    #[doc = ""]
    #[doc = "\t@threaded:\tnapi threaded mode is enabled"]
    #[doc = ""]
    #[doc = "\t@net_notifier_list:\tList of per-net netdev notifier block"]
    #[doc = "\t\t\t\tthat follow this device when it is moved"]
    #[doc = "\t\t\t\tto another network namespace."]
    #[doc = ""]
    #[doc = "\t@macsec_ops:    MACsec offloading ops"]
    #[doc = ""]
    #[doc = "\t@udp_tunnel_nic_info:\tstatic structure describing the UDP tunnel"]
    #[doc = "\t\t\t\toffload capabilities of the device"]
    #[doc = "\t@udp_tunnel_nic:\tUDP tunnel offload state"]
    #[doc = "\t@xdp_state:\t\tstores info on attached XDP BPF programs"]
    #[doc = ""]
    #[doc = "\t@nested_level:\tUsed as a parameter of spin_lock_nested() of"]
    #[doc = "\t\t\tdev->addr_list_lock."]
    #[doc = "\t@unlink_list:\tAs netif_addr_lock() can be called recursively,"]
    #[doc = "\t\t\tkeep a list of interfaces to be deleted."]
    #[doc = "\t@gro_max_size:\tMaximum size of aggregated packet in generic"]
    #[doc = "\t\t\treceive offload (GRO)"]
    #[doc = " \t@gro_ipv4_max_size:\tMaximum size of aggregated packet in generic"]
    #[doc = " \t\t\t\treceive offload (GRO), for IPv4."]
    #[doc = ""]
    #[doc = "\t@dev_addr_shadow:\tCopy of @dev_addr to catch direct writes."]
    #[doc = "\t@linkwatch_dev_tracker:\trefcount tracker used by linkwatch."]
    #[doc = "\t@watchdog_dev_tracker:\trefcount tracker used by watchdog."]
    #[doc = "\t@dev_registered_tracker:\ttracker for reference held while"]
    #[doc = "\t\t\t\t\tregistered"]
    #[doc = "\t@offload_xstats_l3:\tL3 HW stats for this netdevice."]
    #[doc = ""]
    #[doc = "\t@devlink_port:\tPointer to related devlink port structure."]
    #[doc = "\t\t\tAssigned by a driver before netdev registration using"]
    #[doc = "\t\t\tSET_NETDEV_DEVLINK_PORT macro. This pointer is static"]
    #[doc = "\t\t\tduring the time netdevice is registered."]
    #[doc = ""]
    #[doc = "\tFIXME: cleanup struct net_device such that network protocol info"]
    #[doc = "\tmoves out."]
    #[repr(C)]
    #[repr(align(64))]
    #[derive(Copy, Clone)]
    pub struct net_device {
        pub name: [::cty::c_char; 16usize],
        pub name_node: *mut netdev_name_node,
        pub ifalias: *mut dev_ifalias,
        pub mem_end: ::cty::c_ulong,
        pub mem_start: ::cty::c_ulong,
        pub base_addr: ::cty::c_ulong,
        pub state: ::cty::c_ulong,
        pub dev_list: list_head,
        pub napi_list: list_head,
        pub unreg_list: list_head,
        pub close_list: list_head,
        pub ptype_all: list_head,
        pub ptype_specific: list_head,
        pub adj_list: net_device__bindgen_ty_1,
        pub flags: ::cty::c_uint,
        pub xdp_features: xdp_features_t,
        pub priv_flags: ::cty::c_ulonglong,
        pub netdev_ops: *const net_device_ops,
        pub xdp_metadata_ops: *const xdp_metadata_ops,
        pub ifindex: ::cty::c_int,
        pub gflags: ::cty::c_ushort,
        pub hard_header_len: ::cty::c_ushort,
        pub mtu: ::cty::c_uint,
        pub needed_headroom: ::cty::c_ushort,
        pub needed_tailroom: ::cty::c_ushort,
        pub features: netdev_features_t,
        pub hw_features: netdev_features_t,
        pub wanted_features: netdev_features_t,
        pub vlan_features: netdev_features_t,
        pub hw_enc_features: netdev_features_t,
        pub mpls_features: netdev_features_t,
        pub gso_partial_features: netdev_features_t,
        pub min_mtu: ::cty::c_uint,
        pub max_mtu: ::cty::c_uint,
        pub type_: ::cty::c_ushort,
        pub min_header_len: ::cty::c_uchar,
        pub name_assign_type: ::cty::c_uchar,
        pub group: ::cty::c_int,
        pub stats: net_device_stats,
        pub core_stats: *mut net_device_core_stats,
        pub carrier_up_count: atomic_t,
        pub carrier_down_count: atomic_t,
        pub wireless_handlers: *mut iw_handler_def,
        pub wireless_data: *mut iw_public_data,
        pub ethtool_ops: *const ethtool_ops,
        pub l3mdev_ops: *const l3mdev_ops,
        pub ndisc_ops: *mut ndisc_ops,
        pub xfrmdev_ops: *const xfrmdev_ops,
        pub tlsdev_ops: *const tlsdev_ops,
        pub header_ops: *const header_ops,
        pub operstate: ::cty::c_uchar,
        pub link_mode: ::cty::c_uchar,
        pub if_port: ::cty::c_uchar,
        pub dma: ::cty::c_uchar,
        pub perm_addr: [::cty::c_uchar; 32usize],
        pub addr_assign_type: ::cty::c_uchar,
        pub addr_len: ::cty::c_uchar,
        pub upper_level: ::cty::c_uchar,
        pub lower_level: ::cty::c_uchar,
        pub neigh_priv_len: ::cty::c_ushort,
        pub dev_id: ::cty::c_ushort,
        pub dev_port: ::cty::c_ushort,
        pub padded: ::cty::c_ushort,
        pub addr_list_lock: spinlock_t,
        pub irq: ::cty::c_int,
        pub uc: netdev_hw_addr_list,
        pub mc: netdev_hw_addr_list,
        pub dev_addrs: netdev_hw_addr_list,
        pub queues_kset: *mut kset,
        pub promiscuity: ::cty::c_uint,
        pub allmulti: ::cty::c_uint,
        pub uc_promisc: bool_,
        pub ip_ptr: *mut in_device,
        pub ip6_ptr: *mut inet6_dev,
        pub vlan_info: *mut vlan_info,
        pub dsa_ptr: *mut dsa_port,
        pub tipc_ptr: *mut tipc_bearer,
        pub atalk_ptr: *mut ::cty::c_void,
        pub ax25_ptr: *mut ::cty::c_void,
        pub ieee80211_ptr: *mut wireless_dev,
        pub ieee802154_ptr: *mut wpan_dev,
        pub mpls_ptr: *mut mpls_dev,
        pub mctp_ptr: *mut mctp_dev,
        pub dev_addr: *const ::cty::c_uchar,
        pub _rx: *mut netdev_rx_queue,
        pub num_rx_queues: ::cty::c_uint,
        pub real_num_rx_queues: ::cty::c_uint,
        pub xdp_prog: *mut bpf_prog,
        pub gro_flush_timeout: ::cty::c_ulong,
        pub napi_defer_hard_irqs: ::cty::c_int,
        pub gro_max_size: ::cty::c_uint,
        pub gro_ipv4_max_size: ::cty::c_uint,
        pub rx_handler: rx_handler_func_t,
        pub rx_handler_data: *mut ::cty::c_void,
        pub miniq_ingress: *mut mini_Qdisc,
        pub ingress_queue: *mut netdev_queue,
        pub nf_hooks_ingress: *mut nf_hook_entries,
        pub broadcast: [::cty::c_uchar; 32usize],
        pub rx_cpu_rmap: *mut cpu_rmap,
        pub index_hlist: hlist_node,
        pub __bindgen_padding_0: [u64; 4usize],
        pub _tx: *mut netdev_queue,
        pub num_tx_queues: ::cty::c_uint,
        pub real_num_tx_queues: ::cty::c_uint,
        pub qdisc: *mut Qdisc,
        pub tx_queue_len: ::cty::c_uint,
        pub tx_global_lock: spinlock_t,
        pub xdp_bulkq: *mut xdp_dev_bulk_queue,
        pub xps_maps: [*mut xps_dev_maps; 2usize],
        pub miniq_egress: *mut mini_Qdisc,
        pub nf_hooks_egress: *mut nf_hook_entries,
        pub qdisc_hash: [hlist_head; 16usize],
        pub watchdog_timer: timer_list,
        pub watchdog_timeo: ::cty::c_int,
        pub proto_down_reason: _cargo_bpf_u32,
        pub todo_list: list_head,
        pub pcpu_refcnt: *mut ::cty::c_int,
        pub refcnt_tracker: ref_tracker_dir,
        pub link_watch_list: list_head,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
        pub dismantle: bool_,
        pub _bitfield_align_2: [u16; 0],
        pub _bitfield_2: __BindgenBitfieldUnit<[u8; 2usize]>,
        pub needs_free_netdev: bool_,
        pub priv_destructor: ::core::option::Option<unsafe extern "C" fn(dev: *mut net_device)>,
        pub npinfo: *mut netpoll_info,
        pub nd_net: possible_net_t,
        pub ml_priv: *mut ::cty::c_void,
        pub ml_priv_type: netdev_ml_priv_type,
        pub __bindgen_anon_1: net_device__bindgen_ty_4,
        pub garp_port: *mut garp_port,
        pub mrp_port: *mut mrp_port,
        pub dm_private: *mut dm_hw_stat_delta,
        pub dev: device,
        pub sysfs_groups: [*const attribute_group; 4usize],
        pub sysfs_rx_queue_group: *const attribute_group,
        pub rtnl_link_ops: *const rtnl_link_ops,
        pub gso_max_size: ::cty::c_uint,
        pub tso_max_size: ::cty::c_uint,
        pub gso_max_segs: _cargo_bpf_u16,
        pub tso_max_segs: _cargo_bpf_u16,
        pub gso_ipv4_max_size: ::cty::c_uint,
        pub dcbnl_ops: *const dcbnl_rtnl_ops,
        pub num_tc: s16,
        pub tc_to_txq: [netdev_tc_txq; 16usize],
        pub prio_tc_map: [_cargo_bpf_u8; 16usize],
        pub fcoe_ddp_xid: ::cty::c_uint,
        pub priomap: *mut netprio_map,
        pub phydev: *mut phy_device,
        pub sfp_bus: *mut sfp_bus,
        pub qdisc_tx_busylock: *mut lock_class_key,
        pub proto_down: bool_,
        pub _bitfield_align_3: [u8; 0],
        pub _bitfield_3: __BindgenBitfieldUnit<[u8; 1usize]>,
        pub net_notifier_list: list_head,
        pub macsec_ops: *const macsec_ops,
        pub udp_tunnel_nic_info: *const udp_tunnel_nic_info,
        pub udp_tunnel_nic: *mut udp_tunnel_nic,
        pub xdp_state: [bpf_xdp_entity; 3usize],
        pub dev_addr_shadow: [_cargo_bpf_u8; 32usize],
        pub linkwatch_dev_tracker: netdevice_tracker,
        pub watchdog_dev_tracker: netdevice_tracker,
        pub dev_registered_tracker: netdevice_tracker,
        pub offload_xstats_l3: *mut rtnl_hw_stats64,
        pub devlink_port: *mut devlink_port,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct net_device__bindgen_ty_1 {
        pub upper: list_head,
        pub lower: list_head,
    }
    #[test]
    fn bindgen_test_layout_net_device__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<net_device__bindgen_ty_1>(),
            32usize,
            concat!("Size of: ", stringify!(net_device__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<net_device__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(net_device__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device__bindgen_ty_1>())).upper as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device__bindgen_ty_1),
                "::",
                stringify!(upper)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device__bindgen_ty_1>())).lower as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device__bindgen_ty_1),
                "::",
                stringify!(lower)
            )
        );
    }
    pub const net_device_NETREG_UNINITIALIZED: ::cty::c_uint = 0;
    pub const net_device_NETREG_REGISTERED: ::cty::c_uint = 1;
    pub const net_device_NETREG_UNREGISTERING: ::cty::c_uint = 2;
    pub const net_device_NETREG_UNREGISTERED: ::cty::c_uint = 3;
    pub const net_device_NETREG_RELEASED: ::cty::c_uint = 4;
    pub const net_device_NETREG_DUMMY: ::cty::c_uint = 5;
    pub type net_device__bindgen_ty_2 = ::cty::c_uint;
    pub const net_device_RTNL_LINK_INITIALIZED: ::cty::c_uint = 0;
    pub const net_device_RTNL_LINK_INITIALIZING: ::cty::c_uint = 1;
    pub type net_device__bindgen_ty_3 = ::cty::c_uint;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union net_device__bindgen_ty_4 {
        pub lstats: *mut pcpu_lstats,
        pub tstats: *mut pcpu_sw_netstats,
        pub dstats: *mut pcpu_dstats,
    }
    #[test]
    fn bindgen_test_layout_net_device__bindgen_ty_4() {
        assert_eq!(
            ::core::mem::size_of::<net_device__bindgen_ty_4>(),
            8usize,
            concat!("Size of: ", stringify!(net_device__bindgen_ty_4))
        );
        assert_eq!(
            ::core::mem::align_of::<net_device__bindgen_ty_4>(),
            8usize,
            concat!("Alignment of ", stringify!(net_device__bindgen_ty_4))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device__bindgen_ty_4>())).lstats as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device__bindgen_ty_4),
                "::",
                stringify!(lstats)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device__bindgen_ty_4>())).tstats as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device__bindgen_ty_4),
                "::",
                stringify!(tstats)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device__bindgen_ty_4>())).dstats as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device__bindgen_ty_4),
                "::",
                stringify!(dstats)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_net_device() {
        assert_eq!(
            ::core::mem::size_of::<net_device>(),
            2496usize,
            concat!("Size of: ", stringify!(net_device))
        );
        assert_eq!(
            ::core::mem::align_of::<net_device>(),
            64usize,
            concat!("Alignment of ", stringify!(net_device))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).name as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(name)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).name_node as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(name_node)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).ifalias as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(ifalias)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).mem_end as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(mem_end)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).mem_start as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(mem_start)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).base_addr as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(base_addr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).state as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(state)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).dev_list as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(dev_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).napi_list as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(napi_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).unreg_list as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(unreg_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).close_list as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(close_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).ptype_all as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(ptype_all)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).ptype_specific as *const _ as usize },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(ptype_specific)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).adj_list as *const _ as usize },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(adj_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).flags as *const _ as usize },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).xdp_features as *const _ as usize },
            196usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(xdp_features)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).priv_flags as *const _ as usize },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(priv_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).netdev_ops as *const _ as usize },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(netdev_ops)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device>())).xdp_metadata_ops as *const _ as usize
            },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(xdp_metadata_ops)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).ifindex as *const _ as usize },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(ifindex)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).gflags as *const _ as usize },
            228usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(gflags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).hard_header_len as *const _ as usize },
            230usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(hard_header_len)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).mtu as *const _ as usize },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(mtu)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).needed_headroom as *const _ as usize },
            236usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(needed_headroom)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).needed_tailroom as *const _ as usize },
            238usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(needed_tailroom)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).features as *const _ as usize },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(features)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).hw_features as *const _ as usize },
            248usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(hw_features)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).wanted_features as *const _ as usize },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(wanted_features)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).vlan_features as *const _ as usize },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(vlan_features)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).hw_enc_features as *const _ as usize },
            272usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(hw_enc_features)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).mpls_features as *const _ as usize },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(mpls_features)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device>())).gso_partial_features as *const _ as usize
            },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(gso_partial_features)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).min_mtu as *const _ as usize },
            296usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(min_mtu)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).max_mtu as *const _ as usize },
            300usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(max_mtu)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).type_ as *const _ as usize },
            304usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(type_)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).min_header_len as *const _ as usize },
            306usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(min_header_len)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device>())).name_assign_type as *const _ as usize
            },
            307usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(name_assign_type)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).group as *const _ as usize },
            308usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(group)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).stats as *const _ as usize },
            312usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(stats)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).core_stats as *const _ as usize },
            496usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(core_stats)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device>())).carrier_up_count as *const _ as usize
            },
            504usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(carrier_up_count)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device>())).carrier_down_count as *const _ as usize
            },
            508usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(carrier_down_count)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device>())).wireless_handlers as *const _ as usize
            },
            512usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(wireless_handlers)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).wireless_data as *const _ as usize },
            520usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(wireless_data)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).ethtool_ops as *const _ as usize },
            528usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(ethtool_ops)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).l3mdev_ops as *const _ as usize },
            536usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(l3mdev_ops)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).ndisc_ops as *const _ as usize },
            544usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(ndisc_ops)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).xfrmdev_ops as *const _ as usize },
            552usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(xfrmdev_ops)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).tlsdev_ops as *const _ as usize },
            560usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(tlsdev_ops)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).header_ops as *const _ as usize },
            568usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(header_ops)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).operstate as *const _ as usize },
            576usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(operstate)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).link_mode as *const _ as usize },
            577usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(link_mode)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).if_port as *const _ as usize },
            578usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(if_port)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).dma as *const _ as usize },
            579usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(dma)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).perm_addr as *const _ as usize },
            580usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(perm_addr)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device>())).addr_assign_type as *const _ as usize
            },
            612usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(addr_assign_type)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).addr_len as *const _ as usize },
            613usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(addr_len)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).upper_level as *const _ as usize },
            614usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(upper_level)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).lower_level as *const _ as usize },
            615usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(lower_level)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).neigh_priv_len as *const _ as usize },
            616usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(neigh_priv_len)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).dev_id as *const _ as usize },
            618usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(dev_id)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).dev_port as *const _ as usize },
            620usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(dev_port)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).padded as *const _ as usize },
            622usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(padded)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).addr_list_lock as *const _ as usize },
            624usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(addr_list_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).irq as *const _ as usize },
            628usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(irq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).uc as *const _ as usize },
            632usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(uc)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).mc as *const _ as usize },
            664usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(mc)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).dev_addrs as *const _ as usize },
            696usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(dev_addrs)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).queues_kset as *const _ as usize },
            728usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(queues_kset)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).promiscuity as *const _ as usize },
            736usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(promiscuity)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).allmulti as *const _ as usize },
            740usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(allmulti)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).uc_promisc as *const _ as usize },
            744usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(uc_promisc)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).ip_ptr as *const _ as usize },
            752usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(ip_ptr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).ip6_ptr as *const _ as usize },
            760usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(ip6_ptr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).vlan_info as *const _ as usize },
            768usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(vlan_info)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).dsa_ptr as *const _ as usize },
            776usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(dsa_ptr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).tipc_ptr as *const _ as usize },
            784usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(tipc_ptr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).atalk_ptr as *const _ as usize },
            792usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(atalk_ptr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).ax25_ptr as *const _ as usize },
            800usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(ax25_ptr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).ieee80211_ptr as *const _ as usize },
            808usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(ieee80211_ptr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).ieee802154_ptr as *const _ as usize },
            816usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(ieee802154_ptr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).mpls_ptr as *const _ as usize },
            824usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(mpls_ptr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).mctp_ptr as *const _ as usize },
            832usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(mctp_ptr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).dev_addr as *const _ as usize },
            840usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(dev_addr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>()))._rx as *const _ as usize },
            848usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(_rx)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).num_rx_queues as *const _ as usize },
            856usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(num_rx_queues)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device>())).real_num_rx_queues as *const _ as usize
            },
            860usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(real_num_rx_queues)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).xdp_prog as *const _ as usize },
            864usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(xdp_prog)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device>())).gro_flush_timeout as *const _ as usize
            },
            872usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(gro_flush_timeout)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device>())).napi_defer_hard_irqs as *const _ as usize
            },
            880usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(napi_defer_hard_irqs)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).gro_max_size as *const _ as usize },
            884usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(gro_max_size)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device>())).gro_ipv4_max_size as *const _ as usize
            },
            888usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(gro_ipv4_max_size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).rx_handler as *const _ as usize },
            896usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(rx_handler)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).rx_handler_data as *const _ as usize },
            904usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(rx_handler_data)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).miniq_ingress as *const _ as usize },
            912usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(miniq_ingress)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).ingress_queue as *const _ as usize },
            920usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(ingress_queue)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device>())).nf_hooks_ingress as *const _ as usize
            },
            928usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(nf_hooks_ingress)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).broadcast as *const _ as usize },
            936usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(broadcast)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).rx_cpu_rmap as *const _ as usize },
            968usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(rx_cpu_rmap)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).index_hlist as *const _ as usize },
            976usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(index_hlist)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>()))._tx as *const _ as usize },
            1024usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(_tx)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).num_tx_queues as *const _ as usize },
            1032usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(num_tx_queues)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device>())).real_num_tx_queues as *const _ as usize
            },
            1036usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(real_num_tx_queues)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).qdisc as *const _ as usize },
            1040usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(qdisc)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).tx_queue_len as *const _ as usize },
            1048usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(tx_queue_len)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).tx_global_lock as *const _ as usize },
            1052usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(tx_global_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).xdp_bulkq as *const _ as usize },
            1056usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(xdp_bulkq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).xps_maps as *const _ as usize },
            1064usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(xps_maps)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).miniq_egress as *const _ as usize },
            1080usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(miniq_egress)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).nf_hooks_egress as *const _ as usize },
            1088usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(nf_hooks_egress)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).qdisc_hash as *const _ as usize },
            1096usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(qdisc_hash)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).watchdog_timer as *const _ as usize },
            1224usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(watchdog_timer)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).watchdog_timeo as *const _ as usize },
            1264usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(watchdog_timeo)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device>())).proto_down_reason as *const _ as usize
            },
            1268usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(proto_down_reason)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).todo_list as *const _ as usize },
            1272usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(todo_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).pcpu_refcnt as *const _ as usize },
            1288usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(pcpu_refcnt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).refcnt_tracker as *const _ as usize },
            1296usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(refcnt_tracker)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).link_watch_list as *const _ as usize },
            1296usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(link_watch_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).dismantle as *const _ as usize },
            1313usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(dismantle)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device>())).needs_free_netdev as *const _ as usize
            },
            1316usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(needs_free_netdev)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).priv_destructor as *const _ as usize },
            1320usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(priv_destructor)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).npinfo as *const _ as usize },
            1328usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(npinfo)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).nd_net as *const _ as usize },
            1336usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(nd_net)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).ml_priv as *const _ as usize },
            1344usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(ml_priv)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).ml_priv_type as *const _ as usize },
            1352usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(ml_priv_type)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).garp_port as *const _ as usize },
            1368usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(garp_port)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).mrp_port as *const _ as usize },
            1376usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(mrp_port)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).dm_private as *const _ as usize },
            1384usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(dm_private)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).dev as *const _ as usize },
            1392usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(dev)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).sysfs_groups as *const _ as usize },
            2136usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(sysfs_groups)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device>())).sysfs_rx_queue_group as *const _ as usize
            },
            2168usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(sysfs_rx_queue_group)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).rtnl_link_ops as *const _ as usize },
            2176usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(rtnl_link_ops)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).gso_max_size as *const _ as usize },
            2184usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(gso_max_size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).tso_max_size as *const _ as usize },
            2188usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(tso_max_size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).gso_max_segs as *const _ as usize },
            2192usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(gso_max_segs)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).tso_max_segs as *const _ as usize },
            2194usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(tso_max_segs)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device>())).gso_ipv4_max_size as *const _ as usize
            },
            2196usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(gso_ipv4_max_size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).dcbnl_ops as *const _ as usize },
            2200usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(dcbnl_ops)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).num_tc as *const _ as usize },
            2208usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(num_tc)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).tc_to_txq as *const _ as usize },
            2210usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(tc_to_txq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).prio_tc_map as *const _ as usize },
            2274usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(prio_tc_map)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).fcoe_ddp_xid as *const _ as usize },
            2292usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(fcoe_ddp_xid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).priomap as *const _ as usize },
            2296usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(priomap)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).phydev as *const _ as usize },
            2304usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(phydev)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).sfp_bus as *const _ as usize },
            2312usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(sfp_bus)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device>())).qdisc_tx_busylock as *const _ as usize
            },
            2320usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(qdisc_tx_busylock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).proto_down as *const _ as usize },
            2328usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(proto_down)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device>())).net_notifier_list as *const _ as usize
            },
            2336usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(net_notifier_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).macsec_ops as *const _ as usize },
            2352usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(macsec_ops)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device>())).udp_tunnel_nic_info as *const _ as usize
            },
            2360usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(udp_tunnel_nic_info)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).udp_tunnel_nic as *const _ as usize },
            2368usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(udp_tunnel_nic)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).xdp_state as *const _ as usize },
            2376usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(xdp_state)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).dev_addr_shadow as *const _ as usize },
            2424usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(dev_addr_shadow)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device>())).linkwatch_dev_tracker as *const _ as usize
            },
            2456usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(linkwatch_dev_tracker)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device>())).watchdog_dev_tracker as *const _ as usize
            },
            2456usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(watchdog_dev_tracker)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device>())).dev_registered_tracker as *const _ as usize
            },
            2456usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(dev_registered_tracker)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<net_device>())).offload_xstats_l3 as *const _ as usize
            },
            2456usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(offload_xstats_l3)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<net_device>())).devlink_port as *const _ as usize },
            2464usize,
            concat!(
                "Offset of field: ",
                stringify!(net_device),
                "::",
                stringify!(devlink_port)
            )
        );
    }
    impl net_device {
        #[inline]
        pub fn reg_state(&self) -> net_device__bindgen_ty_2 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
        }
        #[inline]
        pub fn set_reg_state(&mut self, val: net_device__bindgen_ty_2) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 8u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            reg_state: net_device__bindgen_ty_2,
        ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 8u8, {
                let reg_state: u32 = unsafe { ::core::mem::transmute(reg_state) };
                reg_state as u64
            });
            __bindgen_bitfield_unit
        }
        #[inline]
        pub fn rtnl_link_state(&self) -> net_device__bindgen_ty_3 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 16u8) as u32) }
        }
        #[inline]
        pub fn set_rtnl_link_state(&mut self, val: net_device__bindgen_ty_3) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_2.set(0usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_2(
            rtnl_link_state: net_device__bindgen_ty_3,
        ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 16u8, {
                let rtnl_link_state: u32 = unsafe { ::core::mem::transmute(rtnl_link_state) };
                rtnl_link_state as u64
            });
            __bindgen_bitfield_unit
        }
        #[inline]
        pub fn wol_enabled(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_3.get(0usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_wol_enabled(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_3.set(0usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn threaded(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_3.get(1usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_threaded(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_3.set(1usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_3(
            wol_enabled: ::cty::c_uint,
            threaded: ::cty::c_uint,
        ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 1u8, {
                let wol_enabled: u32 = unsafe { ::core::mem::transmute(wol_enabled) };
                wol_enabled as u64
            });
            __bindgen_bitfield_unit.set(1usize, 1u8, {
                let threaded: u32 = unsafe { ::core::mem::transmute(threaded) };
                threaded as u64
            });
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[repr(align(32))]
    #[derive(Debug, Copy, Clone)]
    pub struct pcpu_sw_netstats {
        pub rx_packets: u64_stats_t,
        pub rx_bytes: u64_stats_t,
        pub tx_packets: u64_stats_t,
        pub tx_bytes: u64_stats_t,
        pub syncp: u64_stats_sync,
    }
    #[test]
    fn bindgen_test_layout_pcpu_sw_netstats() {
        assert_eq!(
            ::core::mem::size_of::<pcpu_sw_netstats>(),
            32usize,
            concat!("Size of: ", stringify!(pcpu_sw_netstats))
        );
        assert_eq!(
            ::core::mem::align_of::<pcpu_sw_netstats>(),
            32usize,
            concat!("Alignment of ", stringify!(pcpu_sw_netstats))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<pcpu_sw_netstats>())).rx_packets as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pcpu_sw_netstats),
                "::",
                stringify!(rx_packets)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pcpu_sw_netstats>())).rx_bytes as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(pcpu_sw_netstats),
                "::",
                stringify!(rx_bytes)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<pcpu_sw_netstats>())).tx_packets as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(pcpu_sw_netstats),
                "::",
                stringify!(tx_packets)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pcpu_sw_netstats>())).tx_bytes as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(pcpu_sw_netstats),
                "::",
                stringify!(tx_bytes)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pcpu_sw_netstats>())).syncp as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(pcpu_sw_netstats),
                "::",
                stringify!(syncp)
            )
        );
    }
    #[repr(C)]
    #[repr(align(16))]
    #[derive(Debug, Copy, Clone)]
    pub struct pcpu_lstats {
        pub packets: u64_stats_t,
        pub bytes: u64_stats_t,
        pub syncp: u64_stats_sync,
    }
    #[test]
    fn bindgen_test_layout_pcpu_lstats() {
        assert_eq!(
            ::core::mem::size_of::<pcpu_lstats>(),
            16usize,
            concat!("Size of: ", stringify!(pcpu_lstats))
        );
        assert_eq!(
            ::core::mem::align_of::<pcpu_lstats>(),
            16usize,
            concat!("Alignment of ", stringify!(pcpu_lstats))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pcpu_lstats>())).packets as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pcpu_lstats),
                "::",
                stringify!(packets)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pcpu_lstats>())).bytes as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(pcpu_lstats),
                "::",
                stringify!(bytes)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pcpu_lstats>())).syncp as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(pcpu_lstats),
                "::",
                stringify!(syncp)
            )
        );
    }
    #[repr(C)]
    #[repr(align(64))]
    #[derive(Debug)]
    pub struct page_counter {
        pub usage: atomic_long_t,
        pub __bindgen_padding_0: [u64; 7usize],
        pub _pad1_: cacheline_padding,
        pub emin: ::cty::c_ulong,
        pub min_usage: atomic_long_t,
        pub children_min_usage: atomic_long_t,
        pub elow: ::cty::c_ulong,
        pub low_usage: atomic_long_t,
        pub children_low_usage: atomic_long_t,
        pub watermark: ::cty::c_ulong,
        pub failcnt: ::cty::c_ulong,
        pub _pad2_: cacheline_padding,
        pub min: ::cty::c_ulong,
        pub low: ::cty::c_ulong,
        pub high: ::cty::c_ulong,
        pub max: ::cty::c_ulong,
        pub parent: *mut page_counter,
    }
    #[test]
    fn bindgen_test_layout_page_counter() {
        assert_eq!(
            ::core::mem::size_of::<page_counter>(),
            192usize,
            concat!("Size of: ", stringify!(page_counter))
        );
        assert_eq!(
            ::core::mem::align_of::<page_counter>(),
            64usize,
            concat!("Alignment of ", stringify!(page_counter))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<page_counter>())).usage as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(page_counter),
                "::",
                stringify!(usage)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<page_counter>()))._pad1_ as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(page_counter),
                "::",
                stringify!(_pad1_)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<page_counter>())).emin as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(page_counter),
                "::",
                stringify!(emin)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<page_counter>())).min_usage as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(page_counter),
                "::",
                stringify!(min_usage)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<page_counter>())).children_min_usage as *const _ as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(page_counter),
                "::",
                stringify!(children_min_usage)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<page_counter>())).elow as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(page_counter),
                "::",
                stringify!(elow)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<page_counter>())).low_usage as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(page_counter),
                "::",
                stringify!(low_usage)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<page_counter>())).children_low_usage as *const _ as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(page_counter),
                "::",
                stringify!(children_low_usage)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<page_counter>())).watermark as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(page_counter),
                "::",
                stringify!(watermark)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<page_counter>())).failcnt as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(page_counter),
                "::",
                stringify!(failcnt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<page_counter>()))._pad2_ as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(page_counter),
                "::",
                stringify!(_pad2_)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<page_counter>())).min as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(page_counter),
                "::",
                stringify!(min)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<page_counter>())).low as *const _ as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(page_counter),
                "::",
                stringify!(low)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<page_counter>())).high as *const _ as usize },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(page_counter),
                "::",
                stringify!(high)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<page_counter>())).max as *const _ as usize },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(page_counter),
                "::",
                stringify!(max)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<page_counter>())).parent as *const _ as usize },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(page_counter),
                "::",
                stringify!(parent)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct eventfd_ctx {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct vmpressure {
        pub scanned: ::cty::c_ulong,
        pub reclaimed: ::cty::c_ulong,
        pub tree_scanned: ::cty::c_ulong,
        pub tree_reclaimed: ::cty::c_ulong,
        pub sr_lock: spinlock_t,
        pub events: list_head,
        pub events_lock: mutex,
        pub work: work_struct,
    }
    #[test]
    fn bindgen_test_layout_vmpressure() {
        assert_eq!(
            ::core::mem::size_of::<vmpressure>(),
            120usize,
            concat!("Size of: ", stringify!(vmpressure))
        );
        assert_eq!(
            ::core::mem::align_of::<vmpressure>(),
            8usize,
            concat!("Alignment of ", stringify!(vmpressure))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vmpressure>())).scanned as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(vmpressure),
                "::",
                stringify!(scanned)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vmpressure>())).reclaimed as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(vmpressure),
                "::",
                stringify!(reclaimed)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vmpressure>())).tree_scanned as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(vmpressure),
                "::",
                stringify!(tree_scanned)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vmpressure>())).tree_reclaimed as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(vmpressure),
                "::",
                stringify!(tree_reclaimed)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vmpressure>())).sr_lock as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(vmpressure),
                "::",
                stringify!(sr_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vmpressure>())).events as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(vmpressure),
                "::",
                stringify!(events)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vmpressure>())).events_lock as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(vmpressure),
                "::",
                stringify!(events_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<vmpressure>())).work as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(vmpressure),
                "::",
                stringify!(work)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct fprop_global {
        pub events: percpu_counter,
        pub period: ::cty::c_uint,
        pub sequence: seqcount_t,
    }
    #[test]
    fn bindgen_test_layout_fprop_global() {
        assert_eq!(
            ::core::mem::size_of::<fprop_global>(),
            48usize,
            concat!("Size of: ", stringify!(fprop_global))
        );
        assert_eq!(
            ::core::mem::align_of::<fprop_global>(),
            8usize,
            concat!("Alignment of ", stringify!(fprop_global))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fprop_global>())).events as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fprop_global),
                "::",
                stringify!(events)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fprop_global>())).period as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(fprop_global),
                "::",
                stringify!(period)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fprop_global>())).sequence as *const _ as usize },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(fprop_global),
                "::",
                stringify!(sequence)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct fprop_local_percpu {
        pub events: percpu_counter,
        pub period: ::cty::c_uint,
        pub lock: raw_spinlock_t,
    }
    #[test]
    fn bindgen_test_layout_fprop_local_percpu() {
        assert_eq!(
            ::core::mem::size_of::<fprop_local_percpu>(),
            48usize,
            concat!("Size of: ", stringify!(fprop_local_percpu))
        );
        assert_eq!(
            ::core::mem::align_of::<fprop_local_percpu>(),
            8usize,
            concat!("Alignment of ", stringify!(fprop_local_percpu))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fprop_local_percpu>())).events as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fprop_local_percpu),
                "::",
                stringify!(events)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fprop_local_percpu>())).period as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(fprop_local_percpu),
                "::",
                stringify!(period)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fprop_local_percpu>())).lock as *const _ as usize },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(fprop_local_percpu),
                "::",
                stringify!(lock)
            )
        );
    }
    pub const wb_reason_WB_REASON_BACKGROUND: wb_reason = 0;
    pub const wb_reason_WB_REASON_VMSCAN: wb_reason = 1;
    pub const wb_reason_WB_REASON_SYNC: wb_reason = 2;
    pub const wb_reason_WB_REASON_PERIODIC: wb_reason = 3;
    pub const wb_reason_WB_REASON_LAPTOP_TIMER: wb_reason = 4;
    pub const wb_reason_WB_REASON_FS_FREE_SPACE: wb_reason = 5;
    pub const wb_reason_WB_REASON_FORKER_THREAD: wb_reason = 6;
    pub const wb_reason_WB_REASON_FOREIGN_FLUSH: wb_reason = 7;
    pub const wb_reason_WB_REASON_MAX: wb_reason = 8;
    pub type wb_reason = ::cty::c_uint;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct wb_completion {
        pub cnt: atomic_t,
        pub waitq: *mut wait_queue_head_t,
    }
    #[test]
    fn bindgen_test_layout_wb_completion() {
        assert_eq!(
            ::core::mem::size_of::<wb_completion>(),
            16usize,
            concat!("Size of: ", stringify!(wb_completion))
        );
        assert_eq!(
            ::core::mem::align_of::<wb_completion>(),
            8usize,
            concat!("Alignment of ", stringify!(wb_completion))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<wb_completion>())).cnt as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(wb_completion),
                "::",
                stringify!(cnt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<wb_completion>())).waitq as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(wb_completion),
                "::",
                stringify!(waitq)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct bdi_writeback {
        pub bdi: *mut backing_dev_info,
        pub state: ::cty::c_ulong,
        pub last_old_flush: ::cty::c_ulong,
        pub b_dirty: list_head,
        pub b_io: list_head,
        pub b_more_io: list_head,
        pub b_dirty_time: list_head,
        pub list_lock: spinlock_t,
        pub writeback_inodes: atomic_t,
        pub stat: [percpu_counter; 4usize],
        pub bw_time_stamp: ::cty::c_ulong,
        pub dirtied_stamp: ::cty::c_ulong,
        pub written_stamp: ::cty::c_ulong,
        pub write_bandwidth: ::cty::c_ulong,
        pub avg_write_bandwidth: ::cty::c_ulong,
        pub dirty_ratelimit: ::cty::c_ulong,
        pub balanced_dirty_ratelimit: ::cty::c_ulong,
        pub completions: fprop_local_percpu,
        pub dirty_exceeded: ::cty::c_int,
        pub start_all_reason: wb_reason,
        pub work_lock: spinlock_t,
        pub work_list: list_head,
        pub dwork: delayed_work,
        pub bw_dwork: delayed_work,
        pub dirty_sleep: ::cty::c_ulong,
        pub bdi_node: list_head,
        pub refcnt: percpu_ref,
        pub memcg_completions: fprop_local_percpu,
        pub memcg_css: *mut cgroup_subsys_state,
        pub blkcg_css: *mut cgroup_subsys_state,
        pub memcg_node: list_head,
        pub blkcg_node: list_head,
        pub b_attached: list_head,
        pub offline_node: list_head,
        pub __bindgen_anon_1: bdi_writeback__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union bdi_writeback__bindgen_ty_1 {
        pub release_work: work_struct,
        pub rcu: callback_head,
    }
    #[test]
    fn bindgen_test_layout_bdi_writeback__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<bdi_writeback__bindgen_ty_1>(),
            32usize,
            concat!("Size of: ", stringify!(bdi_writeback__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<bdi_writeback__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(bdi_writeback__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bdi_writeback__bindgen_ty_1>())).release_work as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bdi_writeback__bindgen_ty_1),
                "::",
                stringify!(release_work)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bdi_writeback__bindgen_ty_1>())).rcu as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bdi_writeback__bindgen_ty_1),
                "::",
                stringify!(rcu)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_bdi_writeback() {
        assert_eq!(
            ::core::mem::size_of::<bdi_writeback>(),
            768usize,
            concat!("Size of: ", stringify!(bdi_writeback))
        );
        assert_eq!(
            ::core::mem::align_of::<bdi_writeback>(),
            8usize,
            concat!("Alignment of ", stringify!(bdi_writeback))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bdi_writeback>())).bdi as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bdi_writeback),
                "::",
                stringify!(bdi)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bdi_writeback>())).state as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bdi_writeback),
                "::",
                stringify!(state)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bdi_writeback>())).last_old_flush as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(bdi_writeback),
                "::",
                stringify!(last_old_flush)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bdi_writeback>())).b_dirty as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(bdi_writeback),
                "::",
                stringify!(b_dirty)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bdi_writeback>())).b_io as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(bdi_writeback),
                "::",
                stringify!(b_io)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bdi_writeback>())).b_more_io as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(bdi_writeback),
                "::",
                stringify!(b_more_io)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bdi_writeback>())).b_dirty_time as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(bdi_writeback),
                "::",
                stringify!(b_dirty_time)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bdi_writeback>())).list_lock as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(bdi_writeback),
                "::",
                stringify!(list_lock)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bdi_writeback>())).writeback_inodes as *const _ as usize
            },
            92usize,
            concat!(
                "Offset of field: ",
                stringify!(bdi_writeback),
                "::",
                stringify!(writeback_inodes)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bdi_writeback>())).stat as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(bdi_writeback),
                "::",
                stringify!(stat)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bdi_writeback>())).bw_time_stamp as *const _ as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(bdi_writeback),
                "::",
                stringify!(bw_time_stamp)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bdi_writeback>())).dirtied_stamp as *const _ as usize
            },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(bdi_writeback),
                "::",
                stringify!(dirtied_stamp)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bdi_writeback>())).written_stamp as *const _ as usize
            },
            272usize,
            concat!(
                "Offset of field: ",
                stringify!(bdi_writeback),
                "::",
                stringify!(written_stamp)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bdi_writeback>())).write_bandwidth as *const _ as usize
            },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(bdi_writeback),
                "::",
                stringify!(write_bandwidth)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bdi_writeback>())).avg_write_bandwidth as *const _ as usize
            },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(bdi_writeback),
                "::",
                stringify!(avg_write_bandwidth)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bdi_writeback>())).dirty_ratelimit as *const _ as usize
            },
            296usize,
            concat!(
                "Offset of field: ",
                stringify!(bdi_writeback),
                "::",
                stringify!(dirty_ratelimit)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bdi_writeback>())).balanced_dirty_ratelimit as *const _
                    as usize
            },
            304usize,
            concat!(
                "Offset of field: ",
                stringify!(bdi_writeback),
                "::",
                stringify!(balanced_dirty_ratelimit)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bdi_writeback>())).completions as *const _ as usize },
            312usize,
            concat!(
                "Offset of field: ",
                stringify!(bdi_writeback),
                "::",
                stringify!(completions)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bdi_writeback>())).dirty_exceeded as *const _ as usize
            },
            360usize,
            concat!(
                "Offset of field: ",
                stringify!(bdi_writeback),
                "::",
                stringify!(dirty_exceeded)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bdi_writeback>())).start_all_reason as *const _ as usize
            },
            364usize,
            concat!(
                "Offset of field: ",
                stringify!(bdi_writeback),
                "::",
                stringify!(start_all_reason)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bdi_writeback>())).work_lock as *const _ as usize },
            368usize,
            concat!(
                "Offset of field: ",
                stringify!(bdi_writeback),
                "::",
                stringify!(work_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bdi_writeback>())).work_list as *const _ as usize },
            376usize,
            concat!(
                "Offset of field: ",
                stringify!(bdi_writeback),
                "::",
                stringify!(work_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bdi_writeback>())).dwork as *const _ as usize },
            392usize,
            concat!(
                "Offset of field: ",
                stringify!(bdi_writeback),
                "::",
                stringify!(dwork)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bdi_writeback>())).bw_dwork as *const _ as usize },
            480usize,
            concat!(
                "Offset of field: ",
                stringify!(bdi_writeback),
                "::",
                stringify!(bw_dwork)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bdi_writeback>())).dirty_sleep as *const _ as usize },
            568usize,
            concat!(
                "Offset of field: ",
                stringify!(bdi_writeback),
                "::",
                stringify!(dirty_sleep)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bdi_writeback>())).bdi_node as *const _ as usize },
            576usize,
            concat!(
                "Offset of field: ",
                stringify!(bdi_writeback),
                "::",
                stringify!(bdi_node)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bdi_writeback>())).refcnt as *const _ as usize },
            592usize,
            concat!(
                "Offset of field: ",
                stringify!(bdi_writeback),
                "::",
                stringify!(refcnt)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bdi_writeback>())).memcg_completions as *const _ as usize
            },
            608usize,
            concat!(
                "Offset of field: ",
                stringify!(bdi_writeback),
                "::",
                stringify!(memcg_completions)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bdi_writeback>())).memcg_css as *const _ as usize },
            656usize,
            concat!(
                "Offset of field: ",
                stringify!(bdi_writeback),
                "::",
                stringify!(memcg_css)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bdi_writeback>())).blkcg_css as *const _ as usize },
            664usize,
            concat!(
                "Offset of field: ",
                stringify!(bdi_writeback),
                "::",
                stringify!(blkcg_css)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bdi_writeback>())).memcg_node as *const _ as usize },
            672usize,
            concat!(
                "Offset of field: ",
                stringify!(bdi_writeback),
                "::",
                stringify!(memcg_node)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bdi_writeback>())).blkcg_node as *const _ as usize },
            688usize,
            concat!(
                "Offset of field: ",
                stringify!(bdi_writeback),
                "::",
                stringify!(blkcg_node)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bdi_writeback>())).b_attached as *const _ as usize },
            704usize,
            concat!(
                "Offset of field: ",
                stringify!(bdi_writeback),
                "::",
                stringify!(b_attached)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bdi_writeback>())).offline_node as *const _ as usize },
            720usize,
            concat!(
                "Offset of field: ",
                stringify!(bdi_writeback),
                "::",
                stringify!(offline_node)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct backing_dev_info {
        pub id: _cargo_bpf_u64,
        pub rb_node: rb_node,
        pub bdi_list: list_head,
        pub ra_pages: ::cty::c_ulong,
        pub io_pages: ::cty::c_ulong,
        pub refcnt: kref,
        pub capabilities: ::cty::c_uint,
        pub min_ratio: ::cty::c_uint,
        pub max_ratio: ::cty::c_uint,
        pub max_prop_frac: ::cty::c_uint,
        pub tot_write_bandwidth: atomic_long_t,
        pub wb: bdi_writeback,
        pub wb_list: list_head,
        pub cgwb_tree: xarray,
        pub cgwb_release_mutex: mutex,
        pub wb_switch_rwsem: rw_semaphore,
        pub wb_waitq: wait_queue_head_t,
        pub dev: *mut device,
        pub dev_name: [::cty::c_char; 64usize],
        pub owner: *mut device,
        pub laptop_mode_wb_timer: timer_list,
        pub debug_dir: *mut dentry,
    }
    #[test]
    fn bindgen_test_layout_backing_dev_info() {
        assert_eq!(
            ::core::mem::size_of::<backing_dev_info>(),
            1120usize,
            concat!("Size of: ", stringify!(backing_dev_info))
        );
        assert_eq!(
            ::core::mem::align_of::<backing_dev_info>(),
            8usize,
            concat!("Alignment of ", stringify!(backing_dev_info))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<backing_dev_info>())).id as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(backing_dev_info),
                "::",
                stringify!(id)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<backing_dev_info>())).rb_node as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(backing_dev_info),
                "::",
                stringify!(rb_node)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<backing_dev_info>())).bdi_list as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(backing_dev_info),
                "::",
                stringify!(bdi_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<backing_dev_info>())).ra_pages as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(backing_dev_info),
                "::",
                stringify!(ra_pages)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<backing_dev_info>())).io_pages as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(backing_dev_info),
                "::",
                stringify!(io_pages)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<backing_dev_info>())).refcnt as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(backing_dev_info),
                "::",
                stringify!(refcnt)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<backing_dev_info>())).capabilities as *const _ as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(backing_dev_info),
                "::",
                stringify!(capabilities)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<backing_dev_info>())).min_ratio as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(backing_dev_info),
                "::",
                stringify!(min_ratio)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<backing_dev_info>())).max_ratio as *const _ as usize },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(backing_dev_info),
                "::",
                stringify!(max_ratio)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<backing_dev_info>())).max_prop_frac as *const _ as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(backing_dev_info),
                "::",
                stringify!(max_prop_frac)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<backing_dev_info>())).tot_write_bandwidth as *const _
                    as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(backing_dev_info),
                "::",
                stringify!(tot_write_bandwidth)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<backing_dev_info>())).wb as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(backing_dev_info),
                "::",
                stringify!(wb)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<backing_dev_info>())).wb_list as *const _ as usize },
            864usize,
            concat!(
                "Offset of field: ",
                stringify!(backing_dev_info),
                "::",
                stringify!(wb_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<backing_dev_info>())).cgwb_tree as *const _ as usize },
            880usize,
            concat!(
                "Offset of field: ",
                stringify!(backing_dev_info),
                "::",
                stringify!(cgwb_tree)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<backing_dev_info>())).cgwb_release_mutex as *const _
                    as usize
            },
            896usize,
            concat!(
                "Offset of field: ",
                stringify!(backing_dev_info),
                "::",
                stringify!(cgwb_release_mutex)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<backing_dev_info>())).wb_switch_rwsem as *const _ as usize
            },
            928usize,
            concat!(
                "Offset of field: ",
                stringify!(backing_dev_info),
                "::",
                stringify!(wb_switch_rwsem)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<backing_dev_info>())).wb_waitq as *const _ as usize },
            968usize,
            concat!(
                "Offset of field: ",
                stringify!(backing_dev_info),
                "::",
                stringify!(wb_waitq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<backing_dev_info>())).dev as *const _ as usize },
            992usize,
            concat!(
                "Offset of field: ",
                stringify!(backing_dev_info),
                "::",
                stringify!(dev)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<backing_dev_info>())).dev_name as *const _ as usize },
            1000usize,
            concat!(
                "Offset of field: ",
                stringify!(backing_dev_info),
                "::",
                stringify!(dev_name)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<backing_dev_info>())).owner as *const _ as usize },
            1064usize,
            concat!(
                "Offset of field: ",
                stringify!(backing_dev_info),
                "::",
                stringify!(owner)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<backing_dev_info>())).laptop_mode_wb_timer as *const _
                    as usize
            },
            1072usize,
            concat!(
                "Offset of field: ",
                stringify!(backing_dev_info),
                "::",
                stringify!(laptop_mode_wb_timer)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<backing_dev_info>())).debug_dir as *const _ as usize },
            1112usize,
            concat!(
                "Offset of field: ",
                stringify!(backing_dev_info),
                "::",
                stringify!(debug_dir)
            )
        );
    }
    pub type bio_end_io_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut bio)>;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bio_crypt_ctx {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct block_device {
        pub bd_start_sect: sector_t,
        pub bd_nr_sectors: sector_t,
        pub bd_disk: *mut gendisk,
        pub bd_queue: *mut request_queue,
        pub bd_stats: *mut disk_stats,
        pub bd_stamp: ::cty::c_ulong,
        pub bd_read_only: bool_,
        pub bd_partno: _cargo_bpf_u8,
        pub bd_write_holder: bool_,
        pub bd_has_submit_bio: bool_,
        pub bd_dev: dev_t,
        pub bd_openers: atomic_t,
        pub bd_size_lock: spinlock_t,
        pub bd_inode: *mut inode,
        pub bd_super: *mut super_block,
        pub bd_claiming: *mut ::cty::c_void,
        pub bd_holder: *mut ::cty::c_void,
        pub bd_holder_ops: *mut blk_holder_ops,
        pub bd_holder_lock: mutex,
        pub bd_fsfreeze_count: ::cty::c_int,
        pub bd_holders: ::cty::c_int,
        pub bd_holder_dir: *mut kobject,
        pub bd_fsfreeze_mutex: mutex,
        pub bd_fsfreeze_sb: *mut super_block,
        pub bd_meta_info: *mut partition_meta_info,
        pub bd_device: device,
    }
    #[test]
    fn bindgen_test_layout_block_device() {
        assert_eq!(
            ::core::mem::size_of::<block_device>(),
            944usize,
            concat!("Size of: ", stringify!(block_device))
        );
        assert_eq!(
            ::core::mem::align_of::<block_device>(),
            8usize,
            concat!("Alignment of ", stringify!(block_device))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<block_device>())).bd_start_sect as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(block_device),
                "::",
                stringify!(bd_start_sect)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<block_device>())).bd_nr_sectors as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(block_device),
                "::",
                stringify!(bd_nr_sectors)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<block_device>())).bd_disk as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(block_device),
                "::",
                stringify!(bd_disk)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<block_device>())).bd_queue as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(block_device),
                "::",
                stringify!(bd_queue)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<block_device>())).bd_stats as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(block_device),
                "::",
                stringify!(bd_stats)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<block_device>())).bd_stamp as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(block_device),
                "::",
                stringify!(bd_stamp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<block_device>())).bd_read_only as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(block_device),
                "::",
                stringify!(bd_read_only)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<block_device>())).bd_partno as *const _ as usize },
            49usize,
            concat!(
                "Offset of field: ",
                stringify!(block_device),
                "::",
                stringify!(bd_partno)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<block_device>())).bd_write_holder as *const _ as usize
            },
            50usize,
            concat!(
                "Offset of field: ",
                stringify!(block_device),
                "::",
                stringify!(bd_write_holder)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<block_device>())).bd_has_submit_bio as *const _ as usize
            },
            51usize,
            concat!(
                "Offset of field: ",
                stringify!(block_device),
                "::",
                stringify!(bd_has_submit_bio)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<block_device>())).bd_dev as *const _ as usize },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(block_device),
                "::",
                stringify!(bd_dev)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<block_device>())).bd_openers as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(block_device),
                "::",
                stringify!(bd_openers)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<block_device>())).bd_size_lock as *const _ as usize },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(block_device),
                "::",
                stringify!(bd_size_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<block_device>())).bd_inode as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(block_device),
                "::",
                stringify!(bd_inode)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<block_device>())).bd_super as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(block_device),
                "::",
                stringify!(bd_super)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<block_device>())).bd_claiming as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(block_device),
                "::",
                stringify!(bd_claiming)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<block_device>())).bd_holder as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(block_device),
                "::",
                stringify!(bd_holder)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<block_device>())).bd_holder_ops as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(block_device),
                "::",
                stringify!(bd_holder_ops)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<block_device>())).bd_holder_lock as *const _ as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(block_device),
                "::",
                stringify!(bd_holder_lock)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<block_device>())).bd_fsfreeze_count as *const _ as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(block_device),
                "::",
                stringify!(bd_fsfreeze_count)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<block_device>())).bd_holders as *const _ as usize },
            140usize,
            concat!(
                "Offset of field: ",
                stringify!(block_device),
                "::",
                stringify!(bd_holders)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<block_device>())).bd_holder_dir as *const _ as usize },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(block_device),
                "::",
                stringify!(bd_holder_dir)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<block_device>())).bd_fsfreeze_mutex as *const _ as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(block_device),
                "::",
                stringify!(bd_fsfreeze_mutex)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<block_device>())).bd_fsfreeze_sb as *const _ as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(block_device),
                "::",
                stringify!(bd_fsfreeze_sb)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<block_device>())).bd_meta_info as *const _ as usize },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(block_device),
                "::",
                stringify!(bd_meta_info)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<block_device>())).bd_device as *const _ as usize },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(block_device),
                "::",
                stringify!(bd_device)
            )
        );
    }
    pub type blk_status_t = _cargo_bpf_u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bio_issue {
        pub value: _cargo_bpf_u64,
    }
    #[test]
    fn bindgen_test_layout_bio_issue() {
        assert_eq!(
            ::core::mem::size_of::<bio_issue>(),
            8usize,
            concat!("Size of: ", stringify!(bio_issue))
        );
        assert_eq!(
            ::core::mem::align_of::<bio_issue>(),
            8usize,
            concat!("Alignment of ", stringify!(bio_issue))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bio_issue>())).value as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bio_issue),
                "::",
                stringify!(value)
            )
        );
    }
    pub type blk_opf_t = __u32;
    pub type blk_qc_t = ::cty::c_uint;
    #[repr(C)]
    pub struct bio {
        pub bi_next: *mut bio,
        pub bi_bdev: *mut block_device,
        pub bi_opf: blk_opf_t,
        pub bi_flags: ::cty::c_ushort,
        pub bi_ioprio: ::cty::c_ushort,
        pub bi_status: blk_status_t,
        pub __bi_remaining: atomic_t,
        pub bi_iter: bvec_iter,
        pub bi_cookie: blk_qc_t,
        pub bi_end_io: bio_end_io_t,
        pub bi_private: *mut ::cty::c_void,
        pub bi_blkg: *mut blkcg_gq,
        pub bi_issue: bio_issue,
        pub bi_iocost_cost: _cargo_bpf_u64,
        pub bi_crypt_context: *mut bio_crypt_ctx,
        pub __bindgen_anon_1: bio__bindgen_ty_1,
        pub bi_vcnt: ::cty::c_ushort,
        pub bi_max_vecs: ::cty::c_ushort,
        pub __bi_cnt: atomic_t,
        pub bi_io_vec: *mut bio_vec,
        pub bi_pool: *mut bio_set,
        pub bi_inline_vecs: __IncompleteArrayField<bio_vec>,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union bio__bindgen_ty_1 {
        pub bi_integrity: *mut bio_integrity_payload,
    }
    #[test]
    fn bindgen_test_layout_bio__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<bio__bindgen_ty_1>(),
            8usize,
            concat!("Size of: ", stringify!(bio__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<bio__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(bio__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bio__bindgen_ty_1>())).bi_integrity as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bio__bindgen_ty_1),
                "::",
                stringify!(bi_integrity)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_bio() {
        assert_eq!(
            ::core::mem::size_of::<bio>(),
            136usize,
            concat!("Size of: ", stringify!(bio))
        );
        assert_eq!(
            ::core::mem::align_of::<bio>(),
            8usize,
            concat!("Alignment of ", stringify!(bio))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bio>())).bi_next as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bio),
                "::",
                stringify!(bi_next)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bio>())).bi_bdev as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bio),
                "::",
                stringify!(bi_bdev)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bio>())).bi_opf as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(bio),
                "::",
                stringify!(bi_opf)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bio>())).bi_flags as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(bio),
                "::",
                stringify!(bi_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bio>())).bi_ioprio as *const _ as usize },
            22usize,
            concat!(
                "Offset of field: ",
                stringify!(bio),
                "::",
                stringify!(bi_ioprio)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bio>())).bi_status as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(bio),
                "::",
                stringify!(bi_status)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bio>())).__bi_remaining as *const _ as usize },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(bio),
                "::",
                stringify!(__bi_remaining)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bio>())).bi_iter as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(bio),
                "::",
                stringify!(bi_iter)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bio>())).bi_cookie as *const _ as usize },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(bio),
                "::",
                stringify!(bi_cookie)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bio>())).bi_end_io as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(bio),
                "::",
                stringify!(bi_end_io)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bio>())).bi_private as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(bio),
                "::",
                stringify!(bi_private)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bio>())).bi_blkg as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(bio),
                "::",
                stringify!(bi_blkg)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bio>())).bi_issue as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(bio),
                "::",
                stringify!(bi_issue)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bio>())).bi_iocost_cost as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(bio),
                "::",
                stringify!(bi_iocost_cost)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bio>())).bi_crypt_context as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(bio),
                "::",
                stringify!(bi_crypt_context)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bio>())).bi_vcnt as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(bio),
                "::",
                stringify!(bi_vcnt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bio>())).bi_max_vecs as *const _ as usize },
            114usize,
            concat!(
                "Offset of field: ",
                stringify!(bio),
                "::",
                stringify!(bi_max_vecs)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bio>())).__bi_cnt as *const _ as usize },
            116usize,
            concat!(
                "Offset of field: ",
                stringify!(bio),
                "::",
                stringify!(__bi_cnt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bio>())).bi_io_vec as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(bio),
                "::",
                stringify!(bi_io_vec)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bio>())).bi_pool as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(bio),
                "::",
                stringify!(bi_pool)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bio>())).bi_inline_vecs as *const _ as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(bio),
                "::",
                stringify!(bi_inline_vecs)
            )
        );
    }
    pub const writeback_sync_modes_WB_SYNC_NONE: writeback_sync_modes = 0;
    pub const writeback_sync_modes_WB_SYNC_ALL: writeback_sync_modes = 1;
    pub type writeback_sync_modes = ::cty::c_uint;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct writeback_control {
        pub nr_to_write: ::cty::c_long,
        pub pages_skipped: ::cty::c_long,
        pub range_start: loff_t,
        pub range_end: loff_t,
        pub sync_mode: writeback_sync_modes,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
        pub swap_plug: *mut *mut swap_iocb,
        pub wb: *mut bdi_writeback,
        pub inode: *mut inode,
        pub wb_id: ::cty::c_int,
        pub wb_lcand_id: ::cty::c_int,
        pub wb_tcand_id: ::cty::c_int,
        pub wb_bytes: size_t,
        pub wb_lcand_bytes: size_t,
        pub wb_tcand_bytes: size_t,
    }
    #[test]
    fn bindgen_test_layout_writeback_control() {
        assert_eq!(
            ::core::mem::size_of::<writeback_control>(),
            104usize,
            concat!("Size of: ", stringify!(writeback_control))
        );
        assert_eq!(
            ::core::mem::align_of::<writeback_control>(),
            8usize,
            concat!("Alignment of ", stringify!(writeback_control))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<writeback_control>())).nr_to_write as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(writeback_control),
                "::",
                stringify!(nr_to_write)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<writeback_control>())).pages_skipped as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(writeback_control),
                "::",
                stringify!(pages_skipped)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<writeback_control>())).range_start as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(writeback_control),
                "::",
                stringify!(range_start)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<writeback_control>())).range_end as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(writeback_control),
                "::",
                stringify!(range_end)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<writeback_control>())).sync_mode as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(writeback_control),
                "::",
                stringify!(sync_mode)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<writeback_control>())).swap_plug as *const _ as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(writeback_control),
                "::",
                stringify!(swap_plug)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<writeback_control>())).wb as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(writeback_control),
                "::",
                stringify!(wb)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<writeback_control>())).inode as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(writeback_control),
                "::",
                stringify!(inode)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<writeback_control>())).wb_id as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(writeback_control),
                "::",
                stringify!(wb_id)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<writeback_control>())).wb_lcand_id as *const _ as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(writeback_control),
                "::",
                stringify!(wb_lcand_id)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<writeback_control>())).wb_tcand_id as *const _ as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(writeback_control),
                "::",
                stringify!(wb_tcand_id)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<writeback_control>())).wb_bytes as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(writeback_control),
                "::",
                stringify!(wb_bytes)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<writeback_control>())).wb_lcand_bytes as *const _ as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(writeback_control),
                "::",
                stringify!(wb_lcand_bytes)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<writeback_control>())).wb_tcand_bytes as *const _ as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(writeback_control),
                "::",
                stringify!(wb_tcand_bytes)
            )
        );
    }
    impl writeback_control {
        #[inline]
        pub fn for_kupdate(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_for_kupdate(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn for_background(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_for_background(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(1usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn tagged_writepages(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_tagged_writepages(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(2usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn for_reclaim(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_for_reclaim(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(3usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn range_cyclic(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_range_cyclic(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(4usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn for_sync(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_for_sync(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(5usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn unpinned_fscache_wb(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_unpinned_fscache_wb(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(6usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn no_cgroup_owner(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_no_cgroup_owner(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(7usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            for_kupdate: ::cty::c_uint,
            for_background: ::cty::c_uint,
            tagged_writepages: ::cty::c_uint,
            for_reclaim: ::cty::c_uint,
            range_cyclic: ::cty::c_uint,
            for_sync: ::cty::c_uint,
            unpinned_fscache_wb: ::cty::c_uint,
            no_cgroup_owner: ::cty::c_uint,
        ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 1u8, {
                let for_kupdate: u32 = unsafe { ::core::mem::transmute(for_kupdate) };
                for_kupdate as u64
            });
            __bindgen_bitfield_unit.set(1usize, 1u8, {
                let for_background: u32 = unsafe { ::core::mem::transmute(for_background) };
                for_background as u64
            });
            __bindgen_bitfield_unit.set(2usize, 1u8, {
                let tagged_writepages: u32 = unsafe { ::core::mem::transmute(tagged_writepages) };
                tagged_writepages as u64
            });
            __bindgen_bitfield_unit.set(3usize, 1u8, {
                let for_reclaim: u32 = unsafe { ::core::mem::transmute(for_reclaim) };
                for_reclaim as u64
            });
            __bindgen_bitfield_unit.set(4usize, 1u8, {
                let range_cyclic: u32 = unsafe { ::core::mem::transmute(range_cyclic) };
                range_cyclic as u64
            });
            __bindgen_bitfield_unit.set(5usize, 1u8, {
                let for_sync: u32 = unsafe { ::core::mem::transmute(for_sync) };
                for_sync as u64
            });
            __bindgen_bitfield_unit.set(6usize, 1u8, {
                let unpinned_fscache_wb: u32 =
                    unsafe { ::core::mem::transmute(unpinned_fscache_wb) };
                unpinned_fscache_wb as u64
            });
            __bindgen_bitfield_unit.set(7usize, 1u8, {
                let no_cgroup_owner: u32 = unsafe { ::core::mem::transmute(no_cgroup_owner) };
                no_cgroup_owner as u64
            });
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct wb_domain {
        pub lock: spinlock_t,
        pub completions: fprop_global,
        pub period_timer: timer_list,
        pub period_time: ::cty::c_ulong,
        pub dirty_limit_tstamp: ::cty::c_ulong,
        pub dirty_limit: ::cty::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_wb_domain() {
        assert_eq!(
            ::core::mem::size_of::<wb_domain>(),
            120usize,
            concat!("Size of: ", stringify!(wb_domain))
        );
        assert_eq!(
            ::core::mem::align_of::<wb_domain>(),
            8usize,
            concat!("Alignment of ", stringify!(wb_domain))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<wb_domain>())).lock as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(wb_domain),
                "::",
                stringify!(lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<wb_domain>())).completions as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(wb_domain),
                "::",
                stringify!(completions)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<wb_domain>())).period_timer as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(wb_domain),
                "::",
                stringify!(period_timer)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<wb_domain>())).period_time as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(wb_domain),
                "::",
                stringify!(period_time)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<wb_domain>())).dirty_limit_tstamp as *const _ as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(wb_domain),
                "::",
                stringify!(dirty_limit_tstamp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<wb_domain>())).dirty_limit as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(wb_domain),
                "::",
                stringify!(dirty_limit)
            )
        );
    }
    pub type mempool_alloc_t = ::core::option::Option<
        unsafe extern "C" fn(gfp_mask: gfp_t, pool_data: *mut ::cty::c_void) -> *mut ::cty::c_void,
    >;
    pub type mempool_free_t = ::core::option::Option<
        unsafe extern "C" fn(element: *mut ::cty::c_void, pool_data: *mut ::cty::c_void),
    >;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct mempool_s {
        pub lock: spinlock_t,
        pub min_nr: ::cty::c_int,
        pub curr_nr: ::cty::c_int,
        pub elements: *mut *mut ::cty::c_void,
        pub pool_data: *mut ::cty::c_void,
        pub alloc: mempool_alloc_t,
        pub free: mempool_free_t,
        pub wait: wait_queue_head_t,
    }
    #[test]
    fn bindgen_test_layout_mempool_s() {
        assert_eq!(
            ::core::mem::size_of::<mempool_s>(),
            72usize,
            concat!("Size of: ", stringify!(mempool_s))
        );
        assert_eq!(
            ::core::mem::align_of::<mempool_s>(),
            8usize,
            concat!("Alignment of ", stringify!(mempool_s))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mempool_s>())).lock as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mempool_s),
                "::",
                stringify!(lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mempool_s>())).min_nr as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(mempool_s),
                "::",
                stringify!(min_nr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mempool_s>())).curr_nr as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mempool_s),
                "::",
                stringify!(curr_nr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mempool_s>())).elements as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(mempool_s),
                "::",
                stringify!(elements)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mempool_s>())).pool_data as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(mempool_s),
                "::",
                stringify!(pool_data)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mempool_s>())).alloc as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(mempool_s),
                "::",
                stringify!(alloc)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mempool_s>())).free as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(mempool_s),
                "::",
                stringify!(free)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mempool_s>())).wait as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(mempool_s),
                "::",
                stringify!(wait)
            )
        );
    }
    pub type mempool_t = mempool_s;
    #[repr(C)]
    #[derive(Debug)]
    pub struct bio_integrity_payload {
        pub bip_bio: *mut bio,
        pub bip_iter: bvec_iter,
        pub bip_vcnt: ::cty::c_ushort,
        pub bip_max_vcnt: ::cty::c_ushort,
        pub bip_flags: ::cty::c_ushort,
        pub bio_iter: bvec_iter,
        pub bip_work: work_struct,
        pub bip_vec: *mut bio_vec,
        pub bip_inline_vecs: __IncompleteArrayField<bio_vec>,
    }
    #[test]
    fn bindgen_test_layout_bio_integrity_payload() {
        assert_eq!(
            ::core::mem::size_of::<bio_integrity_payload>(),
            96usize,
            concat!("Size of: ", stringify!(bio_integrity_payload))
        );
        assert_eq!(
            ::core::mem::align_of::<bio_integrity_payload>(),
            8usize,
            concat!("Alignment of ", stringify!(bio_integrity_payload))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bio_integrity_payload>())).bip_bio as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bio_integrity_payload),
                "::",
                stringify!(bip_bio)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bio_integrity_payload>())).bip_iter as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bio_integrity_payload),
                "::",
                stringify!(bip_iter)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bio_integrity_payload>())).bip_vcnt as *const _ as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(bio_integrity_payload),
                "::",
                stringify!(bip_vcnt)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bio_integrity_payload>())).bip_max_vcnt as *const _ as usize
            },
            30usize,
            concat!(
                "Offset of field: ",
                stringify!(bio_integrity_payload),
                "::",
                stringify!(bip_max_vcnt)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bio_integrity_payload>())).bip_flags as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(bio_integrity_payload),
                "::",
                stringify!(bip_flags)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bio_integrity_payload>())).bio_iter as *const _ as usize
            },
            34usize,
            concat!(
                "Offset of field: ",
                stringify!(bio_integrity_payload),
                "::",
                stringify!(bio_iter)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bio_integrity_payload>())).bip_work as *const _ as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(bio_integrity_payload),
                "::",
                stringify!(bip_work)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bio_integrity_payload>())).bip_vec as *const _ as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(bio_integrity_payload),
                "::",
                stringify!(bip_vec)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bio_integrity_payload>())).bip_inline_vecs as *const _
                    as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(bio_integrity_payload),
                "::",
                stringify!(bip_inline_vecs)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct bio_set {
        pub bio_slab: *mut kmem_cache,
        pub front_pad: ::cty::c_uint,
        pub cache: *mut bio_alloc_cache,
        pub bio_pool: mempool_t,
        pub bvec_pool: mempool_t,
        pub bio_integrity_pool: mempool_t,
        pub bvec_integrity_pool: mempool_t,
        pub back_pad: ::cty::c_uint,
        pub rescue_lock: spinlock_t,
        pub rescue_list: bio_list,
        pub rescue_work: work_struct,
        pub rescue_workqueue: *mut workqueue_struct,
        pub cpuhp_dead: hlist_node,
    }
    #[test]
    fn bindgen_test_layout_bio_set() {
        assert_eq!(
            ::core::mem::size_of::<bio_set>(),
            392usize,
            concat!("Size of: ", stringify!(bio_set))
        );
        assert_eq!(
            ::core::mem::align_of::<bio_set>(),
            8usize,
            concat!("Alignment of ", stringify!(bio_set))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bio_set>())).bio_slab as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bio_set),
                "::",
                stringify!(bio_slab)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bio_set>())).front_pad as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bio_set),
                "::",
                stringify!(front_pad)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bio_set>())).cache as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(bio_set),
                "::",
                stringify!(cache)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bio_set>())).bio_pool as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(bio_set),
                "::",
                stringify!(bio_pool)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bio_set>())).bvec_pool as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(bio_set),
                "::",
                stringify!(bvec_pool)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bio_set>())).bio_integrity_pool as *const _ as usize },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(bio_set),
                "::",
                stringify!(bio_integrity_pool)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bio_set>())).bvec_integrity_pool as *const _ as usize
            },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(bio_set),
                "::",
                stringify!(bvec_integrity_pool)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bio_set>())).back_pad as *const _ as usize },
            312usize,
            concat!(
                "Offset of field: ",
                stringify!(bio_set),
                "::",
                stringify!(back_pad)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bio_set>())).rescue_lock as *const _ as usize },
            316usize,
            concat!(
                "Offset of field: ",
                stringify!(bio_set),
                "::",
                stringify!(rescue_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bio_set>())).rescue_list as *const _ as usize },
            320usize,
            concat!(
                "Offset of field: ",
                stringify!(bio_set),
                "::",
                stringify!(rescue_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bio_set>())).rescue_work as *const _ as usize },
            336usize,
            concat!(
                "Offset of field: ",
                stringify!(bio_set),
                "::",
                stringify!(rescue_work)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bio_set>())).rescue_workqueue as *const _ as usize },
            368usize,
            concat!(
                "Offset of field: ",
                stringify!(bio_set),
                "::",
                stringify!(rescue_workqueue)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bio_set>())).cpuhp_dead as *const _ as usize },
            376usize,
            concat!(
                "Offset of field: ",
                stringify!(bio_set),
                "::",
                stringify!(cpuhp_dead)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct request_queue {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bio_list {
        pub head: *mut bio,
        pub tail: *mut bio,
    }
    #[test]
    fn bindgen_test_layout_bio_list() {
        assert_eq!(
            ::core::mem::size_of::<bio_list>(),
            16usize,
            concat!("Size of: ", stringify!(bio_list))
        );
        assert_eq!(
            ::core::mem::align_of::<bio_list>(),
            8usize,
            concat!("Alignment of ", stringify!(bio_list))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bio_list>())).head as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bio_list),
                "::",
                stringify!(head)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bio_list>())).tail as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bio_list),
                "::",
                stringify!(tail)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct mem_cgroup_id {
        pub id: ::cty::c_int,
        pub ref_: refcount_t,
    }
    #[test]
    fn bindgen_test_layout_mem_cgroup_id() {
        assert_eq!(
            ::core::mem::size_of::<mem_cgroup_id>(),
            8usize,
            concat!("Size of: ", stringify!(mem_cgroup_id))
        );
        assert_eq!(
            ::core::mem::align_of::<mem_cgroup_id>(),
            4usize,
            concat!("Alignment of ", stringify!(mem_cgroup_id))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_cgroup_id>())).id as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup_id),
                "::",
                stringify!(id)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_cgroup_id>())).ref_ as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup_id),
                "::",
                stringify!(ref_)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct memcg_vmstats_percpu {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct memcg_vmstats {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct mem_cgroup_reclaim_iter {
        pub position: *mut mem_cgroup,
        pub generation: ::cty::c_uint,
    }
    #[test]
    fn bindgen_test_layout_mem_cgroup_reclaim_iter() {
        assert_eq!(
            ::core::mem::size_of::<mem_cgroup_reclaim_iter>(),
            16usize,
            concat!("Size of: ", stringify!(mem_cgroup_reclaim_iter))
        );
        assert_eq!(
            ::core::mem::align_of::<mem_cgroup_reclaim_iter>(),
            8usize,
            concat!("Alignment of ", stringify!(mem_cgroup_reclaim_iter))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mem_cgroup_reclaim_iter>())).position as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup_reclaim_iter),
                "::",
                stringify!(position)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mem_cgroup_reclaim_iter>())).generation as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup_reclaim_iter),
                "::",
                stringify!(generation)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct shrinker_info {
        pub rcu: callback_head,
        pub nr_deferred: *mut atomic_long_t,
        pub map: *mut ::cty::c_ulong,
        pub map_nr_max: ::cty::c_int,
    }
    #[test]
    fn bindgen_test_layout_shrinker_info() {
        assert_eq!(
            ::core::mem::size_of::<shrinker_info>(),
            40usize,
            concat!("Size of: ", stringify!(shrinker_info))
        );
        assert_eq!(
            ::core::mem::align_of::<shrinker_info>(),
            8usize,
            concat!("Alignment of ", stringify!(shrinker_info))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<shrinker_info>())).rcu as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(shrinker_info),
                "::",
                stringify!(rcu)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<shrinker_info>())).nr_deferred as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(shrinker_info),
                "::",
                stringify!(nr_deferred)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<shrinker_info>())).map as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(shrinker_info),
                "::",
                stringify!(map)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<shrinker_info>())).map_nr_max as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(shrinker_info),
                "::",
                stringify!(map_nr_max)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct lruvec_stats_percpu {
        pub state: [::cty::c_long; 43usize],
        pub state_prev: [::cty::c_long; 43usize],
    }
    #[test]
    fn bindgen_test_layout_lruvec_stats_percpu() {
        assert_eq!(
            ::core::mem::size_of::<lruvec_stats_percpu>(),
            688usize,
            concat!("Size of: ", stringify!(lruvec_stats_percpu))
        );
        assert_eq!(
            ::core::mem::align_of::<lruvec_stats_percpu>(),
            8usize,
            concat!("Alignment of ", stringify!(lruvec_stats_percpu))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<lruvec_stats_percpu>())).state as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(lruvec_stats_percpu),
                "::",
                stringify!(state)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<lruvec_stats_percpu>())).state_prev as *const _ as usize
            },
            344usize,
            concat!(
                "Offset of field: ",
                stringify!(lruvec_stats_percpu),
                "::",
                stringify!(state_prev)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct lruvec_stats {
        pub state: [::cty::c_long; 43usize],
        pub state_pending: [::cty::c_long; 43usize],
    }
    #[test]
    fn bindgen_test_layout_lruvec_stats() {
        assert_eq!(
            ::core::mem::size_of::<lruvec_stats>(),
            688usize,
            concat!("Size of: ", stringify!(lruvec_stats))
        );
        assert_eq!(
            ::core::mem::align_of::<lruvec_stats>(),
            8usize,
            concat!("Alignment of ", stringify!(lruvec_stats))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<lruvec_stats>())).state as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(lruvec_stats),
                "::",
                stringify!(state)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<lruvec_stats>())).state_pending as *const _ as usize },
            344usize,
            concat!(
                "Offset of field: ",
                stringify!(lruvec_stats),
                "::",
                stringify!(state_pending)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct mem_cgroup_per_node {
        pub lruvec: lruvec,
        pub lruvec_stats_percpu: *mut lruvec_stats_percpu,
        pub lruvec_stats: lruvec_stats,
        pub lru_zone_size: [[::cty::c_ulong; 5usize]; 5usize],
        pub iter: mem_cgroup_reclaim_iter,
        pub shrinker_info: *mut shrinker_info,
        pub tree_node: rb_node,
        pub usage_in_excess: ::cty::c_ulong,
        pub on_tree: bool_,
        pub memcg: *mut mem_cgroup,
    }
    #[test]
    fn bindgen_test_layout_mem_cgroup_per_node() {
        assert_eq!(
            ::core::mem::size_of::<mem_cgroup_per_node>(),
            2544usize,
            concat!("Size of: ", stringify!(mem_cgroup_per_node))
        );
        assert_eq!(
            ::core::mem::align_of::<mem_cgroup_per_node>(),
            8usize,
            concat!("Alignment of ", stringify!(mem_cgroup_per_node))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_cgroup_per_node>())).lruvec as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup_per_node),
                "::",
                stringify!(lruvec)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mem_cgroup_per_node>())).lruvec_stats_percpu as *const _
                    as usize
            },
            1576usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup_per_node),
                "::",
                stringify!(lruvec_stats_percpu)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mem_cgroup_per_node>())).lruvec_stats as *const _ as usize
            },
            1584usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup_per_node),
                "::",
                stringify!(lruvec_stats)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mem_cgroup_per_node>())).lru_zone_size as *const _ as usize
            },
            2272usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup_per_node),
                "::",
                stringify!(lru_zone_size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_cgroup_per_node>())).iter as *const _ as usize },
            2472usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup_per_node),
                "::",
                stringify!(iter)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mem_cgroup_per_node>())).shrinker_info as *const _ as usize
            },
            2488usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup_per_node),
                "::",
                stringify!(shrinker_info)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mem_cgroup_per_node>())).tree_node as *const _ as usize
            },
            2496usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup_per_node),
                "::",
                stringify!(tree_node)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mem_cgroup_per_node>())).usage_in_excess as *const _
                    as usize
            },
            2520usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup_per_node),
                "::",
                stringify!(usage_in_excess)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mem_cgroup_per_node>())).on_tree as *const _ as usize
            },
            2528usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup_per_node),
                "::",
                stringify!(on_tree)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_cgroup_per_node>())).memcg as *const _ as usize },
            2536usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup_per_node),
                "::",
                stringify!(memcg)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct mem_cgroup_threshold {
        pub eventfd: *mut eventfd_ctx,
        pub threshold: ::cty::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_mem_cgroup_threshold() {
        assert_eq!(
            ::core::mem::size_of::<mem_cgroup_threshold>(),
            16usize,
            concat!("Size of: ", stringify!(mem_cgroup_threshold))
        );
        assert_eq!(
            ::core::mem::align_of::<mem_cgroup_threshold>(),
            8usize,
            concat!("Alignment of ", stringify!(mem_cgroup_threshold))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mem_cgroup_threshold>())).eventfd as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup_threshold),
                "::",
                stringify!(eventfd)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mem_cgroup_threshold>())).threshold as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup_threshold),
                "::",
                stringify!(threshold)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct mem_cgroup_threshold_ary {
        pub current_threshold: ::cty::c_int,
        pub size: ::cty::c_uint,
        pub entries: __IncompleteArrayField<mem_cgroup_threshold>,
    }
    #[test]
    fn bindgen_test_layout_mem_cgroup_threshold_ary() {
        assert_eq!(
            ::core::mem::size_of::<mem_cgroup_threshold_ary>(),
            8usize,
            concat!("Size of: ", stringify!(mem_cgroup_threshold_ary))
        );
        assert_eq!(
            ::core::mem::align_of::<mem_cgroup_threshold_ary>(),
            8usize,
            concat!("Alignment of ", stringify!(mem_cgroup_threshold_ary))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mem_cgroup_threshold_ary>())).current_threshold as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup_threshold_ary),
                "::",
                stringify!(current_threshold)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mem_cgroup_threshold_ary>())).size as *const _ as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup_threshold_ary),
                "::",
                stringify!(size)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mem_cgroup_threshold_ary>())).entries as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup_threshold_ary),
                "::",
                stringify!(entries)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct mem_cgroup_thresholds {
        pub primary: *mut mem_cgroup_threshold_ary,
        pub spare: *mut mem_cgroup_threshold_ary,
    }
    #[test]
    fn bindgen_test_layout_mem_cgroup_thresholds() {
        assert_eq!(
            ::core::mem::size_of::<mem_cgroup_thresholds>(),
            16usize,
            concat!("Size of: ", stringify!(mem_cgroup_thresholds))
        );
        assert_eq!(
            ::core::mem::align_of::<mem_cgroup_thresholds>(),
            8usize,
            concat!("Alignment of ", stringify!(mem_cgroup_thresholds))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mem_cgroup_thresholds>())).primary as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup_thresholds),
                "::",
                stringify!(primary)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mem_cgroup_thresholds>())).spare as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup_thresholds),
                "::",
                stringify!(spare)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct memcg_cgwb_frn {
        pub bdi_id: _cargo_bpf_u64,
        pub memcg_id: ::cty::c_int,
        pub at: _cargo_bpf_u64,
        pub done: wb_completion,
    }
    #[test]
    fn bindgen_test_layout_memcg_cgwb_frn() {
        assert_eq!(
            ::core::mem::size_of::<memcg_cgwb_frn>(),
            40usize,
            concat!("Size of: ", stringify!(memcg_cgwb_frn))
        );
        assert_eq!(
            ::core::mem::align_of::<memcg_cgwb_frn>(),
            8usize,
            concat!("Alignment of ", stringify!(memcg_cgwb_frn))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<memcg_cgwb_frn>())).bdi_id as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(memcg_cgwb_frn),
                "::",
                stringify!(bdi_id)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<memcg_cgwb_frn>())).memcg_id as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(memcg_cgwb_frn),
                "::",
                stringify!(memcg_id)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<memcg_cgwb_frn>())).at as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(memcg_cgwb_frn),
                "::",
                stringify!(at)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<memcg_cgwb_frn>())).done as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(memcg_cgwb_frn),
                "::",
                stringify!(done)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct obj_cgroup {
        pub refcnt: percpu_ref,
        pub memcg: *mut mem_cgroup,
        pub nr_charged_bytes: atomic_t,
        pub __bindgen_anon_1: obj_cgroup__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union obj_cgroup__bindgen_ty_1 {
        pub list: list_head,
        pub rcu: callback_head,
    }
    #[test]
    fn bindgen_test_layout_obj_cgroup__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<obj_cgroup__bindgen_ty_1>(),
            16usize,
            concat!("Size of: ", stringify!(obj_cgroup__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<obj_cgroup__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(obj_cgroup__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<obj_cgroup__bindgen_ty_1>())).list as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(obj_cgroup__bindgen_ty_1),
                "::",
                stringify!(list)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<obj_cgroup__bindgen_ty_1>())).rcu as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(obj_cgroup__bindgen_ty_1),
                "::",
                stringify!(rcu)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_obj_cgroup() {
        assert_eq!(
            ::core::mem::size_of::<obj_cgroup>(),
            48usize,
            concat!("Size of: ", stringify!(obj_cgroup))
        );
        assert_eq!(
            ::core::mem::align_of::<obj_cgroup>(),
            8usize,
            concat!("Alignment of ", stringify!(obj_cgroup))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<obj_cgroup>())).refcnt as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(obj_cgroup),
                "::",
                stringify!(refcnt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<obj_cgroup>())).memcg as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(obj_cgroup),
                "::",
                stringify!(memcg)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<obj_cgroup>())).nr_charged_bytes as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(obj_cgroup),
                "::",
                stringify!(nr_charged_bytes)
            )
        );
    }
    #[repr(C)]
    #[repr(align(64))]
    pub struct mem_cgroup {
        pub css: cgroup_subsys_state,
        pub id: mem_cgroup_id,
        pub __bindgen_padding_0: [u64; 6usize],
        pub memory: page_counter,
        pub __bindgen_anon_1: mem_cgroup__bindgen_ty_1,
        pub kmem: page_counter,
        pub tcpmem: page_counter,
        pub high_work: work_struct,
        pub zswap_max: ::cty::c_ulong,
        pub soft_limit: ::cty::c_ulong,
        pub vmpressure: vmpressure,
        pub oom_group: bool_,
        pub oom_lock: bool_,
        pub under_oom: ::cty::c_int,
        pub swappiness: ::cty::c_int,
        pub oom_kill_disable: ::cty::c_int,
        pub events_file: cgroup_file,
        pub events_local_file: cgroup_file,
        pub swap_events_file: cgroup_file,
        pub thresholds_lock: mutex,
        pub thresholds: mem_cgroup_thresholds,
        pub memsw_thresholds: mem_cgroup_thresholds,
        pub oom_notify: list_head,
        pub move_charge_at_immigrate: ::cty::c_ulong,
        pub move_lock: spinlock_t,
        pub move_lock_flags: ::cty::c_ulong,
        pub __bindgen_padding_1: [u64; 7usize],
        pub _pad1_: cacheline_padding,
        pub vmstats: *mut memcg_vmstats,
        pub memory_events: [atomic_long_t; 9usize],
        pub memory_events_local: [atomic_long_t; 9usize],
        pub socket_pressure: ::cty::c_ulong,
        pub tcpmem_active: bool_,
        pub tcpmem_pressure: ::cty::c_int,
        pub kmemcg_id: ::cty::c_int,
        pub objcg: *mut obj_cgroup,
        pub objcg_list: list_head,
        pub __bindgen_padding_2: [u64; 7usize],
        pub _pad2_: cacheline_padding,
        pub moving_account: atomic_t,
        pub move_lock_task: *mut task_struct,
        pub vmstats_percpu: *mut memcg_vmstats_percpu,
        pub cgwb_list: list_head,
        pub cgwb_domain: wb_domain,
        pub cgwb_frn: [memcg_cgwb_frn; 4usize],
        pub event_list: list_head,
        pub event_list_lock: spinlock_t,
        pub deferred_split_queue: deferred_split,
        pub mm_list: lru_gen_mm_list,
        pub nodeinfo: __IncompleteArrayField<*mut mem_cgroup_per_node>,
    }
    #[repr(C)]
    #[repr(align(64))]
    pub struct mem_cgroup__bindgen_ty_1 {
        pub swap: __BindgenUnionField<page_counter>,
        pub memsw: __BindgenUnionField<page_counter>,
        pub bindgen_union_field: [u8; 192usize],
    }
    #[test]
    fn bindgen_test_layout_mem_cgroup__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<mem_cgroup__bindgen_ty_1>(),
            192usize,
            concat!("Size of: ", stringify!(mem_cgroup__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<mem_cgroup__bindgen_ty_1>(),
            64usize,
            concat!("Alignment of ", stringify!(mem_cgroup__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mem_cgroup__bindgen_ty_1>())).swap as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup__bindgen_ty_1),
                "::",
                stringify!(swap)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mem_cgroup__bindgen_ty_1>())).memsw as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup__bindgen_ty_1),
                "::",
                stringify!(memsw)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_mem_cgroup() {
        assert_eq!(
            ::core::mem::size_of::<mem_cgroup>(),
            2240usize,
            concat!("Size of: ", stringify!(mem_cgroup))
        );
        assert_eq!(
            ::core::mem::align_of::<mem_cgroup>(),
            64usize,
            concat!("Alignment of ", stringify!(mem_cgroup))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_cgroup>())).css as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup),
                "::",
                stringify!(css)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_cgroup>())).id as *const _ as usize },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup),
                "::",
                stringify!(id)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_cgroup>())).memory as *const _ as usize },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup),
                "::",
                stringify!(memory)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_cgroup>())).kmem as *const _ as usize },
            640usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup),
                "::",
                stringify!(kmem)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_cgroup>())).tcpmem as *const _ as usize },
            832usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup),
                "::",
                stringify!(tcpmem)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_cgroup>())).high_work as *const _ as usize },
            1024usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup),
                "::",
                stringify!(high_work)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_cgroup>())).zswap_max as *const _ as usize },
            1056usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup),
                "::",
                stringify!(zswap_max)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_cgroup>())).soft_limit as *const _ as usize },
            1064usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup),
                "::",
                stringify!(soft_limit)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_cgroup>())).vmpressure as *const _ as usize },
            1072usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup),
                "::",
                stringify!(vmpressure)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_cgroup>())).oom_group as *const _ as usize },
            1192usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup),
                "::",
                stringify!(oom_group)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_cgroup>())).oom_lock as *const _ as usize },
            1193usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup),
                "::",
                stringify!(oom_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_cgroup>())).under_oom as *const _ as usize },
            1196usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup),
                "::",
                stringify!(under_oom)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_cgroup>())).swappiness as *const _ as usize },
            1200usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup),
                "::",
                stringify!(swappiness)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mem_cgroup>())).oom_kill_disable as *const _ as usize
            },
            1204usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup),
                "::",
                stringify!(oom_kill_disable)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_cgroup>())).events_file as *const _ as usize },
            1208usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup),
                "::",
                stringify!(events_file)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mem_cgroup>())).events_local_file as *const _ as usize
            },
            1264usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup),
                "::",
                stringify!(events_local_file)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mem_cgroup>())).swap_events_file as *const _ as usize
            },
            1320usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup),
                "::",
                stringify!(swap_events_file)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_cgroup>())).thresholds_lock as *const _ as usize },
            1376usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup),
                "::",
                stringify!(thresholds_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_cgroup>())).thresholds as *const _ as usize },
            1408usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup),
                "::",
                stringify!(thresholds)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mem_cgroup>())).memsw_thresholds as *const _ as usize
            },
            1424usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup),
                "::",
                stringify!(memsw_thresholds)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_cgroup>())).oom_notify as *const _ as usize },
            1440usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup),
                "::",
                stringify!(oom_notify)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mem_cgroup>())).move_charge_at_immigrate as *const _
                    as usize
            },
            1456usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup),
                "::",
                stringify!(move_charge_at_immigrate)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_cgroup>())).move_lock as *const _ as usize },
            1464usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup),
                "::",
                stringify!(move_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_cgroup>())).move_lock_flags as *const _ as usize },
            1472usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup),
                "::",
                stringify!(move_lock_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_cgroup>()))._pad1_ as *const _ as usize },
            1536usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup),
                "::",
                stringify!(_pad1_)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_cgroup>())).vmstats as *const _ as usize },
            1536usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup),
                "::",
                stringify!(vmstats)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_cgroup>())).memory_events as *const _ as usize },
            1544usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup),
                "::",
                stringify!(memory_events)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mem_cgroup>())).memory_events_local as *const _ as usize
            },
            1616usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup),
                "::",
                stringify!(memory_events_local)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_cgroup>())).socket_pressure as *const _ as usize },
            1688usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup),
                "::",
                stringify!(socket_pressure)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_cgroup>())).tcpmem_active as *const _ as usize },
            1696usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup),
                "::",
                stringify!(tcpmem_active)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_cgroup>())).tcpmem_pressure as *const _ as usize },
            1700usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup),
                "::",
                stringify!(tcpmem_pressure)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_cgroup>())).kmemcg_id as *const _ as usize },
            1704usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup),
                "::",
                stringify!(kmemcg_id)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_cgroup>())).objcg as *const _ as usize },
            1712usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup),
                "::",
                stringify!(objcg)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_cgroup>())).objcg_list as *const _ as usize },
            1720usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup),
                "::",
                stringify!(objcg_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_cgroup>()))._pad2_ as *const _ as usize },
            1792usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup),
                "::",
                stringify!(_pad2_)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_cgroup>())).moving_account as *const _ as usize },
            1792usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup),
                "::",
                stringify!(moving_account)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_cgroup>())).move_lock_task as *const _ as usize },
            1800usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup),
                "::",
                stringify!(move_lock_task)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_cgroup>())).vmstats_percpu as *const _ as usize },
            1808usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup),
                "::",
                stringify!(vmstats_percpu)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_cgroup>())).cgwb_list as *const _ as usize },
            1816usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup),
                "::",
                stringify!(cgwb_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_cgroup>())).cgwb_domain as *const _ as usize },
            1832usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup),
                "::",
                stringify!(cgwb_domain)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_cgroup>())).cgwb_frn as *const _ as usize },
            1952usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup),
                "::",
                stringify!(cgwb_frn)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_cgroup>())).event_list as *const _ as usize },
            2112usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup),
                "::",
                stringify!(event_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_cgroup>())).event_list_lock as *const _ as usize },
            2128usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup),
                "::",
                stringify!(event_list_lock)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<mem_cgroup>())).deferred_split_queue as *const _ as usize
            },
            2136usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup),
                "::",
                stringify!(deferred_split_queue)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_cgroup>())).mm_list as *const _ as usize },
            2168usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup),
                "::",
                stringify!(mm_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<mem_cgroup>())).nodeinfo as *const _ as usize },
            2192usize,
            concat!(
                "Offset of field: ",
                stringify!(mem_cgroup),
                "::",
                stringify!(nodeinfo)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct pollfd {
        pub fd: ::cty::c_int,
        pub events: ::cty::c_short,
        pub revents: ::cty::c_short,
    }
    #[test]
    fn bindgen_test_layout_pollfd() {
        assert_eq!(
            ::core::mem::size_of::<pollfd>(),
            8usize,
            concat!("Size of: ", stringify!(pollfd))
        );
        assert_eq!(
            ::core::mem::align_of::<pollfd>(),
            4usize,
            concat!("Alignment of ", stringify!(pollfd))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pollfd>())).fd as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pollfd),
                "::",
                stringify!(fd)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pollfd>())).events as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(pollfd),
                "::",
                stringify!(events)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pollfd>())).revents as *const _ as usize },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(pollfd),
                "::",
                stringify!(revents)
            )
        );
    }
    pub type poll_queue_proc = ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut wait_queue_head_t,
            arg3: *mut poll_table_struct,
        ),
    >;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct poll_table_struct {
        pub _qproc: poll_queue_proc,
        pub _key: __poll_t,
    }
    #[test]
    fn bindgen_test_layout_poll_table_struct() {
        assert_eq!(
            ::core::mem::size_of::<poll_table_struct>(),
            16usize,
            concat!("Size of: ", stringify!(poll_table_struct))
        );
        assert_eq!(
            ::core::mem::align_of::<poll_table_struct>(),
            8usize,
            concat!("Alignment of ", stringify!(poll_table_struct))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<poll_table_struct>()))._qproc as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(poll_table_struct),
                "::",
                stringify!(_qproc)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<poll_table_struct>()))._key as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(poll_table_struct),
                "::",
                stringify!(_key)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct netlink_range_validation {
        pub min: _cargo_bpf_u64,
        pub max: _cargo_bpf_u64,
    }
    #[test]
    fn bindgen_test_layout_netlink_range_validation() {
        assert_eq!(
            ::core::mem::size_of::<netlink_range_validation>(),
            16usize,
            concat!("Size of: ", stringify!(netlink_range_validation))
        );
        assert_eq!(
            ::core::mem::align_of::<netlink_range_validation>(),
            8usize,
            concat!("Alignment of ", stringify!(netlink_range_validation))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netlink_range_validation>())).min as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(netlink_range_validation),
                "::",
                stringify!(min)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netlink_range_validation>())).max as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(netlink_range_validation),
                "::",
                stringify!(max)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct netlink_range_validation_signed {
        pub min: s64,
        pub max: s64,
    }
    #[test]
    fn bindgen_test_layout_netlink_range_validation_signed() {
        assert_eq!(
            ::core::mem::size_of::<netlink_range_validation_signed>(),
            16usize,
            concat!("Size of: ", stringify!(netlink_range_validation_signed))
        );
        assert_eq!(
            ::core::mem::align_of::<netlink_range_validation_signed>(),
            8usize,
            concat!("Alignment of ", stringify!(netlink_range_validation_signed))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netlink_range_validation_signed>())).min as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(netlink_range_validation_signed),
                "::",
                stringify!(min)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<netlink_range_validation_signed>())).max as *const _
                    as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(netlink_range_validation_signed),
                "::",
                stringify!(max)
            )
        );
    }
    #[doc = " struct nla_policy - attribute validation policy"]
    #[doc = " @type: Type of attribute or NLA_UNSPEC"]
    #[doc = " @validation_type: type of attribute validation done in addition to"]
    #[doc = "\ttype-specific validation (e.g. range, function call), see"]
    #[doc = "\t&enum nla_policy_validation"]
    #[doc = " @len: Type specific length of payload"]
    #[doc = ""]
    #[doc = " Policies are defined as arrays of this struct, the array must be"]
    #[doc = " accessible by attribute type up to the highest identifier to be expected."]
    #[doc = ""]
    #[doc = " Meaning of `len' field:"]
    #[doc = "    NLA_STRING           Maximum length of string"]
    #[doc = "    NLA_NUL_STRING       Maximum length of string (excluding NUL)"]
    #[doc = "    NLA_FLAG             Unused"]
    #[doc = "    NLA_BINARY           Maximum length of attribute payload"]
    #[doc = "                         (but see also below with the validation type)"]
    #[doc = "    NLA_NESTED,"]
    #[doc = "    NLA_NESTED_ARRAY     Length verification is done by checking len of"]
    #[doc = "                         nested header (or empty); len field is used if"]
    #[doc = "                         nested_policy is also used, for the max attr"]
    #[doc = "                         number in the nested policy."]
    #[doc = "    NLA_U8, NLA_U16,"]
    #[doc = "    NLA_U32, NLA_U64,"]
    #[doc = "    NLA_S8, NLA_S16,"]
    #[doc = "    NLA_S32, NLA_S64,"]
    #[doc = "    NLA_BE16, NLA_BE32,"]
    #[doc = "    NLA_MSECS            Leaving the length field zero will verify the"]
    #[doc = "                         given type fits, using it verifies minimum length"]
    #[doc = "                         just like \"All other\""]
    #[doc = "    NLA_BITFIELD32       Unused"]
    #[doc = "    NLA_REJECT           Unused"]
    #[doc = "    All other            Minimum length of attribute payload"]
    #[doc = ""]
    #[doc = " Meaning of validation union:"]
    #[doc = "    NLA_BITFIELD32       This is a 32-bit bitmap/bitselector attribute and"]
    #[doc = "                         `bitfield32_valid' is the u32 value of valid flags"]
    #[doc = "    NLA_REJECT           This attribute is always rejected and `reject_message'"]
    #[doc = "                         may point to a string to report as the error instead"]
    #[doc = "                         of the generic one in extended ACK."]
    #[doc = "    NLA_NESTED           `nested_policy' to a nested policy to validate, must"]
    #[doc = "                         also set `len' to the max attribute number. Use the"]
    #[doc = "                         provided NLA_POLICY_NESTED() macro."]
    #[doc = "                         Note that nla_parse() will validate, but of course not"]
    #[doc = "                         parse, the nested sub-policies."]
    #[doc = "    NLA_NESTED_ARRAY     `nested_policy' points to a nested policy to validate,"]
    #[doc = "                         must also set `len' to the max attribute number. Use"]
    #[doc = "                         the provided NLA_POLICY_NESTED_ARRAY() macro."]
    #[doc = "                         The difference to NLA_NESTED is the structure:"]
    #[doc = "                         NLA_NESTED has the nested attributes directly inside"]
    #[doc = "                         while an array has the nested attributes at another"]
    #[doc = "                         level down and the attribute types directly in the"]
    #[doc = "                         nesting don't matter."]
    #[doc = "    NLA_U8,"]
    #[doc = "    NLA_U16,"]
    #[doc = "    NLA_U32,"]
    #[doc = "    NLA_U64,"]
    #[doc = "    NLA_BE16,"]
    #[doc = "    NLA_BE32,"]
    #[doc = "    NLA_S8,"]
    #[doc = "    NLA_S16,"]
    #[doc = "    NLA_S32,"]
    #[doc = "    NLA_S64              The `min' and `max' fields are used depending on the"]
    #[doc = "                         validation_type field, if that is min/max/range then"]
    #[doc = "                         the min, max or both are used (respectively) to check"]
    #[doc = "                         the value of the integer attribute."]
    #[doc = "                         Note that in the interest of code simplicity and"]
    #[doc = "                         struct size both limits are s16, so you cannot"]
    #[doc = "                         enforce a range that doesn't fall within the range"]
    #[doc = "                         of s16 - do that using the NLA_POLICY_FULL_RANGE()"]
    #[doc = "                         or NLA_POLICY_FULL_RANGE_SIGNED() macros instead."]
    #[doc = "                         Use the NLA_POLICY_MIN(), NLA_POLICY_MAX() and"]
    #[doc = "                         NLA_POLICY_RANGE() macros."]
    #[doc = "    NLA_U8,"]
    #[doc = "    NLA_U16,"]
    #[doc = "    NLA_U32,"]
    #[doc = "    NLA_U64              If the validation_type field instead is set to"]
    #[doc = "                         NLA_VALIDATE_RANGE_PTR, `range' must be a pointer"]
    #[doc = "                         to a struct netlink_range_validation that indicates"]
    #[doc = "                         the min/max values."]
    #[doc = "                         Use NLA_POLICY_FULL_RANGE()."]
    #[doc = "    NLA_S8,"]
    #[doc = "    NLA_S16,"]
    #[doc = "    NLA_S32,"]
    #[doc = "    NLA_S64              If the validation_type field instead is set to"]
    #[doc = "                         NLA_VALIDATE_RANGE_PTR, `range_signed' must be a"]
    #[doc = "                         pointer to a struct netlink_range_validation_signed"]
    #[doc = "                         that indicates the min/max values."]
    #[doc = "                         Use NLA_POLICY_FULL_RANGE_SIGNED()."]
    #[doc = ""]
    #[doc = "    NLA_BINARY           If the validation type is like the ones for integers"]
    #[doc = "                         above, then the min/max length (not value like for"]
    #[doc = "                         integers) of the attribute is enforced."]
    #[doc = ""]
    #[doc = "    All other            Unused - but note that it's a union"]
    #[doc = ""]
    #[doc = " Meaning of `validate' field, use via NLA_POLICY_VALIDATE_FN:"]
    #[doc = "    NLA_BINARY           Validation function called for the attribute."]
    #[doc = "    All other            Unused - but note that it's a union"]
    #[doc = ""]
    #[doc = " Example:"]
    #[doc = ""]
    #[doc = " static const u32 myvalidflags = 0xff231023;"]
    #[doc = ""]
    #[doc = " static const struct nla_policy my_policy[ATTR_MAX+1] = {"]
    #[doc = " \t[ATTR_FOO] = { .type = NLA_U16 },"]
    #[doc = "\t[ATTR_BAR] = { .type = NLA_STRING, .len = BARSIZ },"]
    #[doc = "\t[ATTR_BAZ] = NLA_POLICY_EXACT_LEN(sizeof(struct mystruct)),"]
    #[doc = "\t[ATTR_GOO] = NLA_POLICY_BITFIELD32(myvalidflags),"]
    #[doc = " };"]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct nla_policy {
        pub type_: _cargo_bpf_u8,
        pub validation_type: _cargo_bpf_u8,
        pub len: _cargo_bpf_u16,
        pub __bindgen_anon_1: nla_policy__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union nla_policy__bindgen_ty_1 {
        #[doc = " @strict_start_type: first attribute to validate strictly"]
        #[doc = ""]
        #[doc = " This entry is special, and used for the attribute at index 0"]
        #[doc = " only, and specifies special data about the policy, namely it"]
        #[doc = " specifies the \"boundary type\" where strict length validation"]
        #[doc = " starts for any attribute types >= this value, also, strict"]
        #[doc = " nesting validation starts here."]
        #[doc = ""]
        #[doc = " Additionally, it means that NLA_UNSPEC is actually NLA_REJECT"]
        #[doc = " for any types >= this, so need to use NLA_POLICY_MIN_LEN() to"]
        #[doc = " get the previous pure { .len = xyz } behaviour. The advantage"]
        #[doc = " of this is that types not specified in the policy will be"]
        #[doc = " rejected."]
        #[doc = ""]
        #[doc = " For completely new families it should be set to 1 so that the"]
        #[doc = " validation is enforced for all attributes. For existing ones"]
        #[doc = " it should be set at least when new attributes are added to"]
        #[doc = " the enum used by the policy, and be set to the new value that"]
        #[doc = " was added to enforce strict validation from thereon."]
        pub strict_start_type: _cargo_bpf_u16,
        pub bitfield32_valid: _cargo_bpf_u32,
        pub mask: _cargo_bpf_u32,
        pub reject_message: *const ::cty::c_char,
        pub nested_policy: *const nla_policy,
        pub range: *mut netlink_range_validation,
        pub range_signed: *mut netlink_range_validation_signed,
        pub __bindgen_anon_1: nla_policy__bindgen_ty_1__bindgen_ty_1,
        pub validate: ::core::option::Option<
            unsafe extern "C" fn(attr: *const nlattr, extack: *mut netlink_ext_ack) -> ::cty::c_int,
        >,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nla_policy__bindgen_ty_1__bindgen_ty_1 {
        pub min: s16,
        pub max: s16,
    }
    #[test]
    fn bindgen_test_layout_nla_policy__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<nla_policy__bindgen_ty_1__bindgen_ty_1>(),
            4usize,
            concat!(
                "Size of: ",
                stringify!(nla_policy__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<nla_policy__bindgen_ty_1__bindgen_ty_1>(),
            2usize,
            concat!(
                "Alignment of ",
                stringify!(nla_policy__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<nla_policy__bindgen_ty_1__bindgen_ty_1>())).min as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(nla_policy__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(min)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<nla_policy__bindgen_ty_1__bindgen_ty_1>())).max as *const _
                    as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(nla_policy__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(max)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_nla_policy__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<nla_policy__bindgen_ty_1>(),
            8usize,
            concat!("Size of: ", stringify!(nla_policy__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<nla_policy__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(nla_policy__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<nla_policy__bindgen_ty_1>())).strict_start_type as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(nla_policy__bindgen_ty_1),
                "::",
                stringify!(strict_start_type)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<nla_policy__bindgen_ty_1>())).bitfield32_valid as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(nla_policy__bindgen_ty_1),
                "::",
                stringify!(bitfield32_valid)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<nla_policy__bindgen_ty_1>())).mask as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(nla_policy__bindgen_ty_1),
                "::",
                stringify!(mask)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<nla_policy__bindgen_ty_1>())).reject_message as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(nla_policy__bindgen_ty_1),
                "::",
                stringify!(reject_message)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<nla_policy__bindgen_ty_1>())).nested_policy as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(nla_policy__bindgen_ty_1),
                "::",
                stringify!(nested_policy)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<nla_policy__bindgen_ty_1>())).range as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(nla_policy__bindgen_ty_1),
                "::",
                stringify!(range)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<nla_policy__bindgen_ty_1>())).range_signed as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(nla_policy__bindgen_ty_1),
                "::",
                stringify!(range_signed)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<nla_policy__bindgen_ty_1>())).validate as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(nla_policy__bindgen_ty_1),
                "::",
                stringify!(validate)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_nla_policy() {
        assert_eq!(
            ::core::mem::size_of::<nla_policy>(),
            16usize,
            concat!("Size of: ", stringify!(nla_policy))
        );
        assert_eq!(
            ::core::mem::align_of::<nla_policy>(),
            8usize,
            concat!("Alignment of ", stringify!(nla_policy))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<nla_policy>())).type_ as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(nla_policy),
                "::",
                stringify!(type_)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<nla_policy>())).validation_type as *const _ as usize },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(nla_policy),
                "::",
                stringify!(validation_type)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<nla_policy>())).len as *const _ as usize },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(nla_policy),
                "::",
                stringify!(len)
            )
        );
    }
    #[doc = "\tstruct rtnl_link_ops - rtnetlink link operations"]
    #[doc = ""]
    #[doc = "\t@list: Used internally"]
    #[doc = "\t@kind: Identifier"]
    #[doc = "\t@netns_refund: Physical device, move to init_net on netns exit"]
    #[doc = "\t@maxtype: Highest device specific netlink attribute number"]
    #[doc = "\t@policy: Netlink policy for device specific attribute validation"]
    #[doc = "\t@validate: Optional validation function for netlink/changelink parameters"]
    #[doc = "\t@alloc: netdev allocation function, can be %NULL and is then used"]
    #[doc = "\t\tin place of alloc_netdev_mqs(), in this case @priv_size"]
    #[doc = "\t\tand @setup are unused. Returns a netdev or ERR_PTR()."]
    #[doc = "\t@priv_size: sizeof net_device private space"]
    #[doc = "\t@setup: net_device setup function"]
    #[doc = "\t@newlink: Function for configuring and registering a new device"]
    #[doc = "\t@changelink: Function for changing parameters of an existing device"]
    #[doc = "\t@dellink: Function to remove a device"]
    #[doc = "\t@get_size: Function to calculate required room for dumping device"]
    #[doc = "\t\t   specific netlink attributes"]
    #[doc = "\t@fill_info: Function to dump device specific netlink attributes"]
    #[doc = "\t@get_xstats_size: Function to calculate required room for dumping device"]
    #[doc = "\t\t\t  specific statistics"]
    #[doc = "\t@fill_xstats: Function to dump device specific statistics"]
    #[doc = "\t@get_num_tx_queues: Function to determine number of transmit queues"]
    #[doc = "\t\t\t    to create when creating a new device."]
    #[doc = "\t@get_num_rx_queues: Function to determine number of receive queues"]
    #[doc = "\t\t\t    to create when creating a new device."]
    #[doc = "\t@get_link_net: Function to get the i/o netns of the device"]
    #[doc = "\t@get_linkxstats_size: Function to calculate the required room for"]
    #[doc = "\t\t\t      dumping device-specific extended link stats"]
    #[doc = "\t@fill_linkxstats: Function to dump device-specific extended link stats"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct rtnl_link_ops {
        pub list: list_head,
        pub kind: *const ::cty::c_char,
        pub priv_size: size_t,
        pub alloc: ::core::option::Option<
            unsafe extern "C" fn(
                tb: *mut *mut nlattr,
                ifname: *const ::cty::c_char,
                name_assign_type: ::cty::c_uchar,
                num_tx_queues: ::cty::c_uint,
                num_rx_queues: ::cty::c_uint,
            ) -> *mut net_device,
        >,
        pub setup: ::core::option::Option<unsafe extern "C" fn(dev: *mut net_device)>,
        pub netns_refund: bool_,
        pub maxtype: ::cty::c_uint,
        pub policy: *const nla_policy,
        pub validate: ::core::option::Option<
            unsafe extern "C" fn(
                tb: *mut *mut nlattr,
                data: *mut *mut nlattr,
                extack: *mut netlink_ext_ack,
            ) -> ::cty::c_int,
        >,
        pub newlink: ::core::option::Option<
            unsafe extern "C" fn(
                src_net: *mut net,
                dev: *mut net_device,
                tb: *mut *mut nlattr,
                data: *mut *mut nlattr,
                extack: *mut netlink_ext_ack,
            ) -> ::cty::c_int,
        >,
        pub changelink: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut net_device,
                tb: *mut *mut nlattr,
                data: *mut *mut nlattr,
                extack: *mut netlink_ext_ack,
            ) -> ::cty::c_int,
        >,
        pub dellink: ::core::option::Option<
            unsafe extern "C" fn(dev: *mut net_device, head: *mut list_head),
        >,
        pub get_size:
            ::core::option::Option<unsafe extern "C" fn(dev: *const net_device) -> size_t>,
        pub fill_info: ::core::option::Option<
            unsafe extern "C" fn(skb: *mut sk_buff, dev: *const net_device) -> ::cty::c_int,
        >,
        pub get_xstats_size:
            ::core::option::Option<unsafe extern "C" fn(dev: *const net_device) -> size_t>,
        pub fill_xstats: ::core::option::Option<
            unsafe extern "C" fn(skb: *mut sk_buff, dev: *const net_device) -> ::cty::c_int,
        >,
        pub get_num_tx_queues: ::core::option::Option<unsafe extern "C" fn() -> ::cty::c_uint>,
        pub get_num_rx_queues: ::core::option::Option<unsafe extern "C" fn() -> ::cty::c_uint>,
        pub slave_maxtype: ::cty::c_uint,
        pub slave_policy: *const nla_policy,
        pub slave_changelink: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut net_device,
                slave_dev: *mut net_device,
                tb: *mut *mut nlattr,
                data: *mut *mut nlattr,
                extack: *mut netlink_ext_ack,
            ) -> ::cty::c_int,
        >,
        pub get_slave_size: ::core::option::Option<
            unsafe extern "C" fn(dev: *const net_device, slave_dev: *const net_device) -> size_t,
        >,
        pub fill_slave_info: ::core::option::Option<
            unsafe extern "C" fn(
                skb: *mut sk_buff,
                dev: *const net_device,
                slave_dev: *const net_device,
            ) -> ::cty::c_int,
        >,
        pub get_link_net:
            ::core::option::Option<unsafe extern "C" fn(dev: *const net_device) -> *mut net>,
        pub get_linkxstats_size: ::core::option::Option<
            unsafe extern "C" fn(dev: *const net_device, attr: ::cty::c_int) -> size_t,
        >,
        pub fill_linkxstats: ::core::option::Option<
            unsafe extern "C" fn(
                skb: *mut sk_buff,
                dev: *const net_device,
                prividx: *mut ::cty::c_int,
                attr: ::cty::c_int,
            ) -> ::cty::c_int,
        >,
    }
    #[test]
    fn bindgen_test_layout_rtnl_link_ops() {
        assert_eq!(
            ::core::mem::size_of::<rtnl_link_ops>(),
            208usize,
            concat!("Size of: ", stringify!(rtnl_link_ops))
        );
        assert_eq!(
            ::core::mem::align_of::<rtnl_link_ops>(),
            8usize,
            concat!("Alignment of ", stringify!(rtnl_link_ops))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rtnl_link_ops>())).list as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_link_ops),
                "::",
                stringify!(list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rtnl_link_ops>())).kind as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_link_ops),
                "::",
                stringify!(kind)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rtnl_link_ops>())).priv_size as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_link_ops),
                "::",
                stringify!(priv_size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rtnl_link_ops>())).alloc as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_link_ops),
                "::",
                stringify!(alloc)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rtnl_link_ops>())).setup as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_link_ops),
                "::",
                stringify!(setup)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rtnl_link_ops>())).netns_refund as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_link_ops),
                "::",
                stringify!(netns_refund)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rtnl_link_ops>())).maxtype as *const _ as usize },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_link_ops),
                "::",
                stringify!(maxtype)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rtnl_link_ops>())).policy as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_link_ops),
                "::",
                stringify!(policy)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rtnl_link_ops>())).validate as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_link_ops),
                "::",
                stringify!(validate)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rtnl_link_ops>())).newlink as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_link_ops),
                "::",
                stringify!(newlink)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rtnl_link_ops>())).changelink as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_link_ops),
                "::",
                stringify!(changelink)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rtnl_link_ops>())).dellink as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_link_ops),
                "::",
                stringify!(dellink)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rtnl_link_ops>())).get_size as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_link_ops),
                "::",
                stringify!(get_size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rtnl_link_ops>())).fill_info as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_link_ops),
                "::",
                stringify!(fill_info)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<rtnl_link_ops>())).get_xstats_size as *const _ as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_link_ops),
                "::",
                stringify!(get_xstats_size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rtnl_link_ops>())).fill_xstats as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_link_ops),
                "::",
                stringify!(fill_xstats)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<rtnl_link_ops>())).get_num_tx_queues as *const _ as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_link_ops),
                "::",
                stringify!(get_num_tx_queues)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<rtnl_link_ops>())).get_num_rx_queues as *const _ as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_link_ops),
                "::",
                stringify!(get_num_rx_queues)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<rtnl_link_ops>())).slave_maxtype as *const _ as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_link_ops),
                "::",
                stringify!(slave_maxtype)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rtnl_link_ops>())).slave_policy as *const _ as usize },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_link_ops),
                "::",
                stringify!(slave_policy)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<rtnl_link_ops>())).slave_changelink as *const _ as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_link_ops),
                "::",
                stringify!(slave_changelink)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<rtnl_link_ops>())).get_slave_size as *const _ as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_link_ops),
                "::",
                stringify!(get_slave_size)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<rtnl_link_ops>())).fill_slave_info as *const _ as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_link_ops),
                "::",
                stringify!(fill_slave_info)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<rtnl_link_ops>())).get_link_net as *const _ as usize },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_link_ops),
                "::",
                stringify!(get_link_net)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<rtnl_link_ops>())).get_linkxstats_size as *const _ as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_link_ops),
                "::",
                stringify!(get_linkxstats_size)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<rtnl_link_ops>())).fill_linkxstats as *const _ as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(rtnl_link_ops),
                "::",
                stringify!(fill_linkxstats)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct neigh_parms {
        pub net: possible_net_t,
        pub dev: *mut net_device,
        pub dev_tracker: netdevice_tracker,
        pub list: list_head,
        pub neigh_setup:
            ::core::option::Option<unsafe extern "C" fn(arg1: *mut neighbour) -> ::cty::c_int>,
        pub tbl: *mut neigh_table,
        pub sysctl_table: *mut ::cty::c_void,
        pub dead: ::cty::c_int,
        pub refcnt: refcount_t,
        pub callback_head: callback_head,
        pub reachable_time: ::cty::c_int,
        pub qlen: _cargo_bpf_u32,
        pub data: [::cty::c_int; 14usize],
        pub data_state: [::cty::c_ulong; 1usize],
    }
    #[test]
    fn bindgen_test_layout_neigh_parms() {
        assert_eq!(
            ::core::mem::size_of::<neigh_parms>(),
            152usize,
            concat!("Size of: ", stringify!(neigh_parms))
        );
        assert_eq!(
            ::core::mem::align_of::<neigh_parms>(),
            8usize,
            concat!("Alignment of ", stringify!(neigh_parms))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_parms>())).net as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_parms),
                "::",
                stringify!(net)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_parms>())).dev as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_parms),
                "::",
                stringify!(dev)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_parms>())).dev_tracker as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_parms),
                "::",
                stringify!(dev_tracker)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_parms>())).list as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_parms),
                "::",
                stringify!(list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_parms>())).neigh_setup as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_parms),
                "::",
                stringify!(neigh_setup)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_parms>())).tbl as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_parms),
                "::",
                stringify!(tbl)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_parms>())).sysctl_table as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_parms),
                "::",
                stringify!(sysctl_table)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_parms>())).dead as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_parms),
                "::",
                stringify!(dead)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_parms>())).refcnt as *const _ as usize },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_parms),
                "::",
                stringify!(refcnt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_parms>())).callback_head as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_parms),
                "::",
                stringify!(callback_head)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_parms>())).reachable_time as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_parms),
                "::",
                stringify!(reachable_time)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_parms>())).qlen as *const _ as usize },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_parms),
                "::",
                stringify!(qlen)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_parms>())).data as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_parms),
                "::",
                stringify!(data)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_parms>())).data_state as *const _ as usize },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_parms),
                "::",
                stringify!(data_state)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct neigh_statistics {
        pub allocs: ::cty::c_ulong,
        pub destroys: ::cty::c_ulong,
        pub hash_grows: ::cty::c_ulong,
        pub res_failed: ::cty::c_ulong,
        pub lookups: ::cty::c_ulong,
        pub hits: ::cty::c_ulong,
        pub rcv_probes_mcast: ::cty::c_ulong,
        pub rcv_probes_ucast: ::cty::c_ulong,
        pub periodic_gc_runs: ::cty::c_ulong,
        pub forced_gc_runs: ::cty::c_ulong,
        pub unres_discards: ::cty::c_ulong,
        pub table_fulls: ::cty::c_ulong,
    }
    #[test]
    fn bindgen_test_layout_neigh_statistics() {
        assert_eq!(
            ::core::mem::size_of::<neigh_statistics>(),
            96usize,
            concat!("Size of: ", stringify!(neigh_statistics))
        );
        assert_eq!(
            ::core::mem::align_of::<neigh_statistics>(),
            8usize,
            concat!("Alignment of ", stringify!(neigh_statistics))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_statistics>())).allocs as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_statistics),
                "::",
                stringify!(allocs)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_statistics>())).destroys as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_statistics),
                "::",
                stringify!(destroys)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<neigh_statistics>())).hash_grows as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_statistics),
                "::",
                stringify!(hash_grows)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<neigh_statistics>())).res_failed as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_statistics),
                "::",
                stringify!(res_failed)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_statistics>())).lookups as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_statistics),
                "::",
                stringify!(lookups)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_statistics>())).hits as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_statistics),
                "::",
                stringify!(hits)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<neigh_statistics>())).rcv_probes_mcast as *const _ as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_statistics),
                "::",
                stringify!(rcv_probes_mcast)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<neigh_statistics>())).rcv_probes_ucast as *const _ as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_statistics),
                "::",
                stringify!(rcv_probes_ucast)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<neigh_statistics>())).periodic_gc_runs as *const _ as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_statistics),
                "::",
                stringify!(periodic_gc_runs)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<neigh_statistics>())).forced_gc_runs as *const _ as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_statistics),
                "::",
                stringify!(forced_gc_runs)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<neigh_statistics>())).unres_discards as *const _ as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_statistics),
                "::",
                stringify!(unres_discards)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<neigh_statistics>())).table_fulls as *const _ as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_statistics),
                "::",
                stringify!(table_fulls)
            )
        );
    }
    #[repr(C)]
    pub struct neighbour {
        pub next: *mut neighbour,
        pub tbl: *mut neigh_table,
        pub parms: *mut neigh_parms,
        pub confirmed: ::cty::c_ulong,
        pub updated: ::cty::c_ulong,
        pub lock: rwlock_t,
        pub refcnt: refcount_t,
        pub arp_queue_len_bytes: ::cty::c_uint,
        pub arp_queue: sk_buff_head,
        pub timer: timer_list,
        pub used: ::cty::c_ulong,
        pub probes: atomic_t,
        pub nud_state: _cargo_bpf_u8,
        pub type_: _cargo_bpf_u8,
        pub dead: _cargo_bpf_u8,
        pub protocol: _cargo_bpf_u8,
        pub flags: _cargo_bpf_u32,
        pub ha_lock: seqlock_t,
        pub __bindgen_padding_0: [u8; 4usize],
        pub ha: [::cty::c_uchar; 32usize],
        pub hh: hh_cache,
        pub output: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut neighbour, arg2: *mut sk_buff) -> ::cty::c_int,
        >,
        pub ops: *const neigh_ops,
        pub gc_list: list_head,
        pub managed_list: list_head,
        pub rcu: callback_head,
        pub dev: *mut net_device,
        pub dev_tracker: netdevice_tracker,
        pub primary_key: __IncompleteArrayField<_cargo_bpf_u8>,
    }
    #[test]
    fn bindgen_test_layout_neighbour() {
        assert_eq!(
            ::core::mem::size_of::<neighbour>(),
            400usize,
            concat!("Size of: ", stringify!(neighbour))
        );
        assert_eq!(
            ::core::mem::align_of::<neighbour>(),
            8usize,
            concat!("Alignment of ", stringify!(neighbour))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neighbour>())).next as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(neighbour),
                "::",
                stringify!(next)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neighbour>())).tbl as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(neighbour),
                "::",
                stringify!(tbl)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neighbour>())).parms as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(neighbour),
                "::",
                stringify!(parms)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neighbour>())).confirmed as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(neighbour),
                "::",
                stringify!(confirmed)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neighbour>())).updated as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(neighbour),
                "::",
                stringify!(updated)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neighbour>())).lock as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(neighbour),
                "::",
                stringify!(lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neighbour>())).refcnt as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(neighbour),
                "::",
                stringify!(refcnt)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<neighbour>())).arp_queue_len_bytes as *const _ as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(neighbour),
                "::",
                stringify!(arp_queue_len_bytes)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neighbour>())).arp_queue as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(neighbour),
                "::",
                stringify!(arp_queue)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neighbour>())).timer as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(neighbour),
                "::",
                stringify!(timer)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neighbour>())).used as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(neighbour),
                "::",
                stringify!(used)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neighbour>())).probes as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(neighbour),
                "::",
                stringify!(probes)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neighbour>())).nud_state as *const _ as usize },
            132usize,
            concat!(
                "Offset of field: ",
                stringify!(neighbour),
                "::",
                stringify!(nud_state)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neighbour>())).type_ as *const _ as usize },
            133usize,
            concat!(
                "Offset of field: ",
                stringify!(neighbour),
                "::",
                stringify!(type_)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neighbour>())).dead as *const _ as usize },
            134usize,
            concat!(
                "Offset of field: ",
                stringify!(neighbour),
                "::",
                stringify!(dead)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neighbour>())).protocol as *const _ as usize },
            135usize,
            concat!(
                "Offset of field: ",
                stringify!(neighbour),
                "::",
                stringify!(protocol)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neighbour>())).flags as *const _ as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(neighbour),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neighbour>())).ha_lock as *const _ as usize },
            140usize,
            concat!(
                "Offset of field: ",
                stringify!(neighbour),
                "::",
                stringify!(ha_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neighbour>())).ha as *const _ as usize },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(neighbour),
                "::",
                stringify!(ha)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neighbour>())).hh as *const _ as usize },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(neighbour),
                "::",
                stringify!(hh)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neighbour>())).output as *const _ as usize },
            328usize,
            concat!(
                "Offset of field: ",
                stringify!(neighbour),
                "::",
                stringify!(output)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neighbour>())).ops as *const _ as usize },
            336usize,
            concat!(
                "Offset of field: ",
                stringify!(neighbour),
                "::",
                stringify!(ops)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neighbour>())).gc_list as *const _ as usize },
            344usize,
            concat!(
                "Offset of field: ",
                stringify!(neighbour),
                "::",
                stringify!(gc_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neighbour>())).managed_list as *const _ as usize },
            360usize,
            concat!(
                "Offset of field: ",
                stringify!(neighbour),
                "::",
                stringify!(managed_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neighbour>())).rcu as *const _ as usize },
            376usize,
            concat!(
                "Offset of field: ",
                stringify!(neighbour),
                "::",
                stringify!(rcu)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neighbour>())).dev as *const _ as usize },
            392usize,
            concat!(
                "Offset of field: ",
                stringify!(neighbour),
                "::",
                stringify!(dev)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neighbour>())).dev_tracker as *const _ as usize },
            400usize,
            concat!(
                "Offset of field: ",
                stringify!(neighbour),
                "::",
                stringify!(dev_tracker)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neighbour>())).primary_key as *const _ as usize },
            400usize,
            concat!(
                "Offset of field: ",
                stringify!(neighbour),
                "::",
                stringify!(primary_key)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct neigh_ops {
        pub family: ::cty::c_int,
        pub solicit:
            ::core::option::Option<unsafe extern "C" fn(arg1: *mut neighbour, arg2: *mut sk_buff)>,
        pub error_report:
            ::core::option::Option<unsafe extern "C" fn(arg1: *mut neighbour, arg2: *mut sk_buff)>,
        pub output: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut neighbour, arg2: *mut sk_buff) -> ::cty::c_int,
        >,
        pub connected_output: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut neighbour, arg2: *mut sk_buff) -> ::cty::c_int,
        >,
    }
    #[test]
    fn bindgen_test_layout_neigh_ops() {
        assert_eq!(
            ::core::mem::size_of::<neigh_ops>(),
            40usize,
            concat!("Size of: ", stringify!(neigh_ops))
        );
        assert_eq!(
            ::core::mem::align_of::<neigh_ops>(),
            8usize,
            concat!("Alignment of ", stringify!(neigh_ops))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_ops>())).family as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_ops),
                "::",
                stringify!(family)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_ops>())).solicit as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_ops),
                "::",
                stringify!(solicit)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_ops>())).error_report as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_ops),
                "::",
                stringify!(error_report)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_ops>())).output as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_ops),
                "::",
                stringify!(output)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_ops>())).connected_output as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_ops),
                "::",
                stringify!(connected_output)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct pneigh_entry {
        pub next: *mut pneigh_entry,
        pub net: possible_net_t,
        pub dev: *mut net_device,
        pub dev_tracker: netdevice_tracker,
        pub flags: _cargo_bpf_u32,
        pub protocol: _cargo_bpf_u8,
        pub key: __IncompleteArrayField<_cargo_bpf_u32>,
    }
    #[test]
    fn bindgen_test_layout_pneigh_entry() {
        assert_eq!(
            ::core::mem::size_of::<pneigh_entry>(),
            32usize,
            concat!("Size of: ", stringify!(pneigh_entry))
        );
        assert_eq!(
            ::core::mem::align_of::<pneigh_entry>(),
            8usize,
            concat!("Alignment of ", stringify!(pneigh_entry))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pneigh_entry>())).next as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pneigh_entry),
                "::",
                stringify!(next)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pneigh_entry>())).net as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(pneigh_entry),
                "::",
                stringify!(net)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pneigh_entry>())).dev as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(pneigh_entry),
                "::",
                stringify!(dev)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pneigh_entry>())).dev_tracker as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(pneigh_entry),
                "::",
                stringify!(dev_tracker)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pneigh_entry>())).flags as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(pneigh_entry),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pneigh_entry>())).protocol as *const _ as usize },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(pneigh_entry),
                "::",
                stringify!(protocol)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<pneigh_entry>())).key as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(pneigh_entry),
                "::",
                stringify!(key)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct neigh_hash_table {
        pub hash_buckets: *mut *mut neighbour,
        pub hash_shift: ::cty::c_uint,
        pub hash_rnd: [__u32; 4usize],
        pub rcu: callback_head,
    }
    #[test]
    fn bindgen_test_layout_neigh_hash_table() {
        assert_eq!(
            ::core::mem::size_of::<neigh_hash_table>(),
            48usize,
            concat!("Size of: ", stringify!(neigh_hash_table))
        );
        assert_eq!(
            ::core::mem::align_of::<neigh_hash_table>(),
            8usize,
            concat!("Alignment of ", stringify!(neigh_hash_table))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<neigh_hash_table>())).hash_buckets as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_hash_table),
                "::",
                stringify!(hash_buckets)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<neigh_hash_table>())).hash_shift as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_hash_table),
                "::",
                stringify!(hash_shift)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_hash_table>())).hash_rnd as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_hash_table),
                "::",
                stringify!(hash_rnd)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_hash_table>())).rcu as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_hash_table),
                "::",
                stringify!(rcu)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct neigh_table {
        pub family: ::cty::c_int,
        pub entry_size: ::cty::c_uint,
        pub key_len: ::cty::c_uint,
        pub protocol: __be16,
        pub hash: ::core::option::Option<
            unsafe extern "C" fn(
                pkey: *const ::cty::c_void,
                dev: *const net_device,
                hash_rnd: *mut __u32,
            ) -> __u32,
        >,
        pub key_eq: ::core::option::Option<
            unsafe extern "C" fn(arg1: *const neighbour, pkey: *const ::cty::c_void) -> bool_,
        >,
        pub constructor:
            ::core::option::Option<unsafe extern "C" fn(arg1: *mut neighbour) -> ::cty::c_int>,
        pub pconstructor:
            ::core::option::Option<unsafe extern "C" fn(arg1: *mut pneigh_entry) -> ::cty::c_int>,
        pub pdestructor: ::core::option::Option<unsafe extern "C" fn(arg1: *mut pneigh_entry)>,
        pub proxy_redo: ::core::option::Option<unsafe extern "C" fn(skb: *mut sk_buff)>,
        pub is_multicast: ::core::option::Option<
            unsafe extern "C" fn(pkey: *const ::cty::c_void) -> ::cty::c_int,
        >,
        pub allow_add: ::core::option::Option<
            unsafe extern "C" fn(dev: *const net_device, extack: *mut netlink_ext_ack) -> bool_,
        >,
        pub id: *mut ::cty::c_char,
        pub parms: neigh_parms,
        pub parms_list: list_head,
        pub gc_interval: ::cty::c_int,
        pub gc_thresh1: ::cty::c_int,
        pub gc_thresh2: ::cty::c_int,
        pub gc_thresh3: ::cty::c_int,
        pub last_flush: ::cty::c_ulong,
        pub gc_work: delayed_work,
        pub managed_work: delayed_work,
        pub proxy_timer: timer_list,
        pub proxy_queue: sk_buff_head,
        pub entries: atomic_t,
        pub gc_entries: atomic_t,
        pub gc_list: list_head,
        pub managed_list: list_head,
        pub lock: rwlock_t,
        pub last_rand: ::cty::c_ulong,
        pub stats: *mut neigh_statistics,
        pub nht: *mut neigh_hash_table,
        pub phash_buckets: *mut *mut pneigh_entry,
    }
    #[test]
    fn bindgen_test_layout_neigh_table() {
        assert_eq!(
            ::core::mem::size_of::<neigh_table>(),
            600usize,
            concat!("Size of: ", stringify!(neigh_table))
        );
        assert_eq!(
            ::core::mem::align_of::<neigh_table>(),
            8usize,
            concat!("Alignment of ", stringify!(neigh_table))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_table>())).family as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_table),
                "::",
                stringify!(family)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_table>())).entry_size as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_table),
                "::",
                stringify!(entry_size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_table>())).key_len as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_table),
                "::",
                stringify!(key_len)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_table>())).protocol as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_table),
                "::",
                stringify!(protocol)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_table>())).hash as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_table),
                "::",
                stringify!(hash)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_table>())).key_eq as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_table),
                "::",
                stringify!(key_eq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_table>())).constructor as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_table),
                "::",
                stringify!(constructor)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_table>())).pconstructor as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_table),
                "::",
                stringify!(pconstructor)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_table>())).pdestructor as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_table),
                "::",
                stringify!(pdestructor)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_table>())).proxy_redo as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_table),
                "::",
                stringify!(proxy_redo)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_table>())).is_multicast as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_table),
                "::",
                stringify!(is_multicast)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_table>())).allow_add as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_table),
                "::",
                stringify!(allow_add)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_table>())).id as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_table),
                "::",
                stringify!(id)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_table>())).parms as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_table),
                "::",
                stringify!(parms)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_table>())).parms_list as *const _ as usize },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_table),
                "::",
                stringify!(parms_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_table>())).gc_interval as *const _ as usize },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_table),
                "::",
                stringify!(gc_interval)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_table>())).gc_thresh1 as *const _ as usize },
            260usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_table),
                "::",
                stringify!(gc_thresh1)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_table>())).gc_thresh2 as *const _ as usize },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_table),
                "::",
                stringify!(gc_thresh2)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_table>())).gc_thresh3 as *const _ as usize },
            268usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_table),
                "::",
                stringify!(gc_thresh3)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_table>())).last_flush as *const _ as usize },
            272usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_table),
                "::",
                stringify!(last_flush)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_table>())).gc_work as *const _ as usize },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_table),
                "::",
                stringify!(gc_work)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_table>())).managed_work as *const _ as usize },
            368usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_table),
                "::",
                stringify!(managed_work)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_table>())).proxy_timer as *const _ as usize },
            456usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_table),
                "::",
                stringify!(proxy_timer)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_table>())).proxy_queue as *const _ as usize },
            496usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_table),
                "::",
                stringify!(proxy_queue)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_table>())).entries as *const _ as usize },
            520usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_table),
                "::",
                stringify!(entries)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_table>())).gc_entries as *const _ as usize },
            524usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_table),
                "::",
                stringify!(gc_entries)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_table>())).gc_list as *const _ as usize },
            528usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_table),
                "::",
                stringify!(gc_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_table>())).managed_list as *const _ as usize },
            544usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_table),
                "::",
                stringify!(managed_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_table>())).lock as *const _ as usize },
            560usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_table),
                "::",
                stringify!(lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_table>())).last_rand as *const _ as usize },
            568usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_table),
                "::",
                stringify!(last_rand)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_table>())).stats as *const _ as usize },
            576usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_table),
                "::",
                stringify!(stats)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_table>())).nht as *const _ as usize },
            584usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_table),
                "::",
                stringify!(nht)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<neigh_table>())).phash_buckets as *const _ as usize },
            592usize,
            concat!(
                "Offset of field: ",
                stringify!(neigh_table),
                "::",
                stringify!(phash_buckets)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dst_entry {
        pub dev: *mut net_device,
        pub ops: *mut dst_ops,
        pub _metrics: ::cty::c_ulong,
        pub expires: ::cty::c_ulong,
        pub xfrm: *mut xfrm_state,
        pub input: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sk_buff) -> ::cty::c_int>,
        pub output: ::core::option::Option<
            unsafe extern "C" fn(net: *mut net, sk: *mut sock, skb: *mut sk_buff) -> ::cty::c_int,
        >,
        pub flags: ::cty::c_ushort,
        pub obsolete: ::cty::c_short,
        pub header_len: ::cty::c_ushort,
        pub trailer_len: ::cty::c_ushort,
        pub __rcuref: rcuref_t,
        pub __use: ::cty::c_int,
        pub lastuse: ::cty::c_ulong,
        pub callback_head: callback_head,
        pub error: ::cty::c_short,
        pub __pad: ::cty::c_short,
        pub tclassid: __u32,
        pub dev_tracker: netdevice_tracker,
        pub rt_uncached: list_head,
        pub rt_uncached_list: *mut uncached_list,
        pub lwtstate: *mut lwtunnel_state,
    }
    #[test]
    fn bindgen_test_layout_dst_entry() {
        assert_eq!(
            ::core::mem::size_of::<dst_entry>(),
            136usize,
            concat!("Size of: ", stringify!(dst_entry))
        );
        assert_eq!(
            ::core::mem::align_of::<dst_entry>(),
            8usize,
            concat!("Alignment of ", stringify!(dst_entry))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dst_entry>())).dev as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(dst_entry),
                "::",
                stringify!(dev)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dst_entry>())).ops as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(dst_entry),
                "::",
                stringify!(ops)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dst_entry>()))._metrics as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(dst_entry),
                "::",
                stringify!(_metrics)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dst_entry>())).expires as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(dst_entry),
                "::",
                stringify!(expires)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dst_entry>())).xfrm as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(dst_entry),
                "::",
                stringify!(xfrm)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dst_entry>())).input as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(dst_entry),
                "::",
                stringify!(input)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dst_entry>())).output as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(dst_entry),
                "::",
                stringify!(output)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dst_entry>())).flags as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(dst_entry),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dst_entry>())).obsolete as *const _ as usize },
            58usize,
            concat!(
                "Offset of field: ",
                stringify!(dst_entry),
                "::",
                stringify!(obsolete)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dst_entry>())).header_len as *const _ as usize },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(dst_entry),
                "::",
                stringify!(header_len)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dst_entry>())).trailer_len as *const _ as usize },
            62usize,
            concat!(
                "Offset of field: ",
                stringify!(dst_entry),
                "::",
                stringify!(trailer_len)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dst_entry>())).__rcuref as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(dst_entry),
                "::",
                stringify!(__rcuref)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dst_entry>())).__use as *const _ as usize },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(dst_entry),
                "::",
                stringify!(__use)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dst_entry>())).lastuse as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(dst_entry),
                "::",
                stringify!(lastuse)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dst_entry>())).callback_head as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(dst_entry),
                "::",
                stringify!(callback_head)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dst_entry>())).error as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(dst_entry),
                "::",
                stringify!(error)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dst_entry>())).__pad as *const _ as usize },
            98usize,
            concat!(
                "Offset of field: ",
                stringify!(dst_entry),
                "::",
                stringify!(__pad)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dst_entry>())).tclassid as *const _ as usize },
            100usize,
            concat!(
                "Offset of field: ",
                stringify!(dst_entry),
                "::",
                stringify!(tclassid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dst_entry>())).dev_tracker as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(dst_entry),
                "::",
                stringify!(dev_tracker)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dst_entry>())).rt_uncached as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(dst_entry),
                "::",
                stringify!(rt_uncached)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dst_entry>())).rt_uncached_list as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(dst_entry),
                "::",
                stringify!(rt_uncached_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<dst_entry>())).lwtstate as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(dst_entry),
                "::",
                stringify!(lwtstate)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct fib_rule_hdr {
        pub family: __u8,
        pub dst_len: __u8,
        pub src_len: __u8,
        pub tos: __u8,
        pub table: __u8,
        pub res1: __u8,
        pub res2: __u8,
        pub action: __u8,
        pub flags: __u32,
    }
    #[test]
    fn bindgen_test_layout_fib_rule_hdr() {
        assert_eq!(
            ::core::mem::size_of::<fib_rule_hdr>(),
            12usize,
            concat!("Size of: ", stringify!(fib_rule_hdr))
        );
        assert_eq!(
            ::core::mem::align_of::<fib_rule_hdr>(),
            4usize,
            concat!("Alignment of ", stringify!(fib_rule_hdr))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_rule_hdr>())).family as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rule_hdr),
                "::",
                stringify!(family)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_rule_hdr>())).dst_len as *const _ as usize },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rule_hdr),
                "::",
                stringify!(dst_len)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_rule_hdr>())).src_len as *const _ as usize },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rule_hdr),
                "::",
                stringify!(src_len)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_rule_hdr>())).tos as *const _ as usize },
            3usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rule_hdr),
                "::",
                stringify!(tos)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_rule_hdr>())).table as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rule_hdr),
                "::",
                stringify!(table)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_rule_hdr>())).res1 as *const _ as usize },
            5usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rule_hdr),
                "::",
                stringify!(res1)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_rule_hdr>())).res2 as *const _ as usize },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rule_hdr),
                "::",
                stringify!(res2)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_rule_hdr>())).action as *const _ as usize },
            7usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rule_hdr),
                "::",
                stringify!(action)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_rule_hdr>())).flags as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rule_hdr),
                "::",
                stringify!(flags)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct fib_rule_port_range {
        pub start: __u16,
        pub end: __u16,
    }
    #[test]
    fn bindgen_test_layout_fib_rule_port_range() {
        assert_eq!(
            ::core::mem::size_of::<fib_rule_port_range>(),
            4usize,
            concat!("Size of: ", stringify!(fib_rule_port_range))
        );
        assert_eq!(
            ::core::mem::align_of::<fib_rule_port_range>(),
            2usize,
            concat!("Alignment of ", stringify!(fib_rule_port_range))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_rule_port_range>())).start as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rule_port_range),
                "::",
                stringify!(start)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_rule_port_range>())).end as *const _ as usize },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rule_port_range),
                "::",
                stringify!(end)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct fib_notifier_ops {
        pub family: ::cty::c_int,
        pub list: list_head,
        pub fib_seq_read:
            ::core::option::Option<unsafe extern "C" fn(net: *mut net) -> ::cty::c_uint>,
        pub fib_dump: ::core::option::Option<
            unsafe extern "C" fn(
                net: *mut net,
                nb: *mut notifier_block,
                extack: *mut netlink_ext_ack,
            ) -> ::cty::c_int,
        >,
        pub owner: *mut module,
        pub rcu: callback_head,
    }
    #[test]
    fn bindgen_test_layout_fib_notifier_ops() {
        assert_eq!(
            ::core::mem::size_of::<fib_notifier_ops>(),
            64usize,
            concat!("Size of: ", stringify!(fib_notifier_ops))
        );
        assert_eq!(
            ::core::mem::align_of::<fib_notifier_ops>(),
            8usize,
            concat!("Alignment of ", stringify!(fib_notifier_ops))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_notifier_ops>())).family as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_notifier_ops),
                "::",
                stringify!(family)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_notifier_ops>())).list as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_notifier_ops),
                "::",
                stringify!(list)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<fib_notifier_ops>())).fib_seq_read as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_notifier_ops),
                "::",
                stringify!(fib_seq_read)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_notifier_ops>())).fib_dump as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_notifier_ops),
                "::",
                stringify!(fib_dump)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_notifier_ops>())).owner as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_notifier_ops),
                "::",
                stringify!(owner)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_notifier_ops>())).rcu as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_notifier_ops),
                "::",
                stringify!(rcu)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct fib_kuid_range {
        pub start: kuid_t,
        pub end: kuid_t,
    }
    #[test]
    fn bindgen_test_layout_fib_kuid_range() {
        assert_eq!(
            ::core::mem::size_of::<fib_kuid_range>(),
            8usize,
            concat!("Size of: ", stringify!(fib_kuid_range))
        );
        assert_eq!(
            ::core::mem::align_of::<fib_kuid_range>(),
            4usize,
            concat!("Alignment of ", stringify!(fib_kuid_range))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_kuid_range>())).start as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_kuid_range),
                "::",
                stringify!(start)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_kuid_range>())).end as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_kuid_range),
                "::",
                stringify!(end)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct fib_rule {
        pub list: list_head,
        pub iifindex: ::cty::c_int,
        pub oifindex: ::cty::c_int,
        pub mark: _cargo_bpf_u32,
        pub mark_mask: _cargo_bpf_u32,
        pub flags: _cargo_bpf_u32,
        pub table: _cargo_bpf_u32,
        pub action: _cargo_bpf_u8,
        pub l3mdev: _cargo_bpf_u8,
        pub proto: _cargo_bpf_u8,
        pub ip_proto: _cargo_bpf_u8,
        pub target: _cargo_bpf_u32,
        pub tun_id: __be64,
        pub ctarget: *mut fib_rule,
        pub fr_net: *mut net,
        pub refcnt: refcount_t,
        pub pref: _cargo_bpf_u32,
        pub suppress_ifgroup: ::cty::c_int,
        pub suppress_prefixlen: ::cty::c_int,
        pub iifname: [::cty::c_char; 16usize],
        pub oifname: [::cty::c_char; 16usize],
        pub uid_range: fib_kuid_range,
        pub sport_range: fib_rule_port_range,
        pub dport_range: fib_rule_port_range,
        pub rcu: callback_head,
    }
    #[test]
    fn bindgen_test_layout_fib_rule() {
        assert_eq!(
            ::core::mem::size_of::<fib_rule>(),
            152usize,
            concat!("Size of: ", stringify!(fib_rule))
        );
        assert_eq!(
            ::core::mem::align_of::<fib_rule>(),
            8usize,
            concat!("Alignment of ", stringify!(fib_rule))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_rule>())).list as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rule),
                "::",
                stringify!(list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_rule>())).iifindex as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rule),
                "::",
                stringify!(iifindex)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_rule>())).oifindex as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rule),
                "::",
                stringify!(oifindex)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_rule>())).mark as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rule),
                "::",
                stringify!(mark)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_rule>())).mark_mask as *const _ as usize },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rule),
                "::",
                stringify!(mark_mask)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_rule>())).flags as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rule),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_rule>())).table as *const _ as usize },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rule),
                "::",
                stringify!(table)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_rule>())).action as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rule),
                "::",
                stringify!(action)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_rule>())).l3mdev as *const _ as usize },
            41usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rule),
                "::",
                stringify!(l3mdev)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_rule>())).proto as *const _ as usize },
            42usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rule),
                "::",
                stringify!(proto)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_rule>())).ip_proto as *const _ as usize },
            43usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rule),
                "::",
                stringify!(ip_proto)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_rule>())).target as *const _ as usize },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rule),
                "::",
                stringify!(target)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_rule>())).tun_id as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rule),
                "::",
                stringify!(tun_id)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_rule>())).ctarget as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rule),
                "::",
                stringify!(ctarget)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_rule>())).fr_net as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rule),
                "::",
                stringify!(fr_net)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_rule>())).refcnt as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rule),
                "::",
                stringify!(refcnt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_rule>())).pref as *const _ as usize },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rule),
                "::",
                stringify!(pref)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_rule>())).suppress_ifgroup as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rule),
                "::",
                stringify!(suppress_ifgroup)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<fib_rule>())).suppress_prefixlen as *const _ as usize
            },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rule),
                "::",
                stringify!(suppress_prefixlen)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_rule>())).iifname as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rule),
                "::",
                stringify!(iifname)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_rule>())).oifname as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rule),
                "::",
                stringify!(oifname)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_rule>())).uid_range as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rule),
                "::",
                stringify!(uid_range)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_rule>())).sport_range as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rule),
                "::",
                stringify!(sport_range)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_rule>())).dport_range as *const _ as usize },
            132usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rule),
                "::",
                stringify!(dport_range)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_rule>())).rcu as *const _ as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rule),
                "::",
                stringify!(rcu)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct fib_lookup_arg {
        pub lookup_ptr: *mut ::cty::c_void,
        pub lookup_data: *const ::cty::c_void,
        pub result: *mut ::cty::c_void,
        pub rule: *mut fib_rule,
        pub table: _cargo_bpf_u32,
        pub flags: ::cty::c_int,
    }
    #[test]
    fn bindgen_test_layout_fib_lookup_arg() {
        assert_eq!(
            ::core::mem::size_of::<fib_lookup_arg>(),
            40usize,
            concat!("Size of: ", stringify!(fib_lookup_arg))
        );
        assert_eq!(
            ::core::mem::align_of::<fib_lookup_arg>(),
            8usize,
            concat!("Alignment of ", stringify!(fib_lookup_arg))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_lookup_arg>())).lookup_ptr as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_lookup_arg),
                "::",
                stringify!(lookup_ptr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_lookup_arg>())).lookup_data as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_lookup_arg),
                "::",
                stringify!(lookup_data)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_lookup_arg>())).result as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_lookup_arg),
                "::",
                stringify!(result)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_lookup_arg>())).rule as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_lookup_arg),
                "::",
                stringify!(rule)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_lookup_arg>())).table as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_lookup_arg),
                "::",
                stringify!(table)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_lookup_arg>())).flags as *const _ as usize },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_lookup_arg),
                "::",
                stringify!(flags)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct fib_rules_ops {
        pub family: ::cty::c_int,
        pub list: list_head,
        pub rule_size: ::cty::c_int,
        pub addr_size: ::cty::c_int,
        pub unresolved_rules: ::cty::c_int,
        pub nr_goto_rules: ::cty::c_int,
        pub fib_rules_seq: ::cty::c_uint,
        pub action: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut fib_rule,
                arg2: *mut flowi,
                arg3: ::cty::c_int,
                arg4: *mut fib_lookup_arg,
            ) -> ::cty::c_int,
        >,
        pub suppress: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut fib_rule,
                arg2: ::cty::c_int,
                arg3: *mut fib_lookup_arg,
            ) -> bool_,
        >,
        pub match_: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut fib_rule,
                arg2: *mut flowi,
                arg3: ::cty::c_int,
            ) -> ::cty::c_int,
        >,
        pub configure: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut fib_rule,
                arg2: *mut sk_buff,
                arg3: *mut fib_rule_hdr,
                arg4: *mut *mut nlattr,
                arg5: *mut netlink_ext_ack,
            ) -> ::cty::c_int,
        >,
        pub delete:
            ::core::option::Option<unsafe extern "C" fn(arg1: *mut fib_rule) -> ::cty::c_int>,
        pub compare: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut fib_rule,
                arg2: *mut fib_rule_hdr,
                arg3: *mut *mut nlattr,
            ) -> ::cty::c_int,
        >,
        pub fill: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut fib_rule,
                arg2: *mut sk_buff,
                arg3: *mut fib_rule_hdr,
            ) -> ::cty::c_int,
        >,
        pub nlmsg_payload:
            ::core::option::Option<unsafe extern "C" fn(arg1: *mut fib_rule) -> size_t>,
        pub flush_cache: ::core::option::Option<unsafe extern "C" fn(ops: *mut fib_rules_ops)>,
        pub nlgroup: ::cty::c_int,
        pub rules_list: list_head,
        pub owner: *mut module,
        pub fro_net: *mut net,
        pub rcu: callback_head,
    }
    #[test]
    fn bindgen_test_layout_fib_rules_ops() {
        assert_eq!(
            ::core::mem::size_of::<fib_rules_ops>(),
            176usize,
            concat!("Size of: ", stringify!(fib_rules_ops))
        );
        assert_eq!(
            ::core::mem::align_of::<fib_rules_ops>(),
            8usize,
            concat!("Alignment of ", stringify!(fib_rules_ops))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_rules_ops>())).family as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rules_ops),
                "::",
                stringify!(family)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_rules_ops>())).list as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rules_ops),
                "::",
                stringify!(list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_rules_ops>())).rule_size as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rules_ops),
                "::",
                stringify!(rule_size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_rules_ops>())).addr_size as *const _ as usize },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rules_ops),
                "::",
                stringify!(addr_size)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<fib_rules_ops>())).unresolved_rules as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rules_ops),
                "::",
                stringify!(unresolved_rules)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<fib_rules_ops>())).nr_goto_rules as *const _ as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rules_ops),
                "::",
                stringify!(nr_goto_rules)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<fib_rules_ops>())).fib_rules_seq as *const _ as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rules_ops),
                "::",
                stringify!(fib_rules_seq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_rules_ops>())).action as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rules_ops),
                "::",
                stringify!(action)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_rules_ops>())).suppress as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rules_ops),
                "::",
                stringify!(suppress)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_rules_ops>())).match_ as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rules_ops),
                "::",
                stringify!(match_)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_rules_ops>())).configure as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rules_ops),
                "::",
                stringify!(configure)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_rules_ops>())).delete as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rules_ops),
                "::",
                stringify!(delete)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_rules_ops>())).compare as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rules_ops),
                "::",
                stringify!(compare)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_rules_ops>())).fill as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rules_ops),
                "::",
                stringify!(fill)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<fib_rules_ops>())).nlmsg_payload as *const _ as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rules_ops),
                "::",
                stringify!(nlmsg_payload)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_rules_ops>())).flush_cache as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rules_ops),
                "::",
                stringify!(flush_cache)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_rules_ops>())).nlgroup as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rules_ops),
                "::",
                stringify!(nlgroup)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_rules_ops>())).rules_list as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rules_ops),
                "::",
                stringify!(rules_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_rules_ops>())).owner as *const _ as usize },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rules_ops),
                "::",
                stringify!(owner)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_rules_ops>())).fro_net as *const _ as usize },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rules_ops),
                "::",
                stringify!(fro_net)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fib_rules_ops>())).rcu as *const _ as usize },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(fib_rules_ops),
                "::",
                stringify!(rcu)
            )
        );
    }
    #[doc = " struct l3mdev_ops - l3mdev operations"]
    #[doc = ""]
    #[doc = " @l3mdev_fib_table: Get FIB table id to use for lookups"]
    #[doc = ""]
    #[doc = " @l3mdev_l3_rcv:    Hook in L3 receive path"]
    #[doc = ""]
    #[doc = " @l3mdev_l3_out:    Hook in L3 output path"]
    #[doc = ""]
    #[doc = " @l3mdev_link_scope_lookup: IPv6 lookup for linklocal and mcast destinations"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct l3mdev_ops {
        pub l3mdev_fib_table:
            ::core::option::Option<unsafe extern "C" fn(dev: *const net_device) -> _cargo_bpf_u32>,
        pub l3mdev_l3_rcv: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut net_device,
                skb: *mut sk_buff,
                proto: _cargo_bpf_u16,
            ) -> *mut sk_buff,
        >,
        pub l3mdev_l3_out: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut net_device,
                sk: *mut sock,
                skb: *mut sk_buff,
                proto: _cargo_bpf_u16,
            ) -> *mut sk_buff,
        >,
        pub l3mdev_link_scope_lookup: ::core::option::Option<
            unsafe extern "C" fn(dev: *const net_device, fl6: *mut flowi6) -> *mut dst_entry,
        >,
    }
    #[test]
    fn bindgen_test_layout_l3mdev_ops() {
        assert_eq!(
            ::core::mem::size_of::<l3mdev_ops>(),
            32usize,
            concat!("Size of: ", stringify!(l3mdev_ops))
        );
        assert_eq!(
            ::core::mem::align_of::<l3mdev_ops>(),
            8usize,
            concat!("Alignment of ", stringify!(l3mdev_ops))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<l3mdev_ops>())).l3mdev_fib_table as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(l3mdev_ops),
                "::",
                stringify!(l3mdev_fib_table)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<l3mdev_ops>())).l3mdev_l3_rcv as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(l3mdev_ops),
                "::",
                stringify!(l3mdev_l3_rcv)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<l3mdev_ops>())).l3mdev_l3_out as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(l3mdev_ops),
                "::",
                stringify!(l3mdev_l3_out)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<l3mdev_ops>())).l3mdev_link_scope_lookup as *const _
                    as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(l3mdev_ops),
                "::",
                stringify!(l3mdev_link_scope_lookup)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct socket_lock_t {
        pub slock: spinlock_t,
        pub owned: ::cty::c_int,
        pub wq: wait_queue_head_t,
    }
    #[test]
    fn bindgen_test_layout_socket_lock_t() {
        assert_eq!(
            ::core::mem::size_of::<socket_lock_t>(),
            32usize,
            concat!("Size of: ", stringify!(socket_lock_t))
        );
        assert_eq!(
            ::core::mem::align_of::<socket_lock_t>(),
            8usize,
            concat!("Alignment of ", stringify!(socket_lock_t))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<socket_lock_t>())).slock as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(socket_lock_t),
                "::",
                stringify!(slock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<socket_lock_t>())).owned as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(socket_lock_t),
                "::",
                stringify!(owned)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<socket_lock_t>())).wq as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(socket_lock_t),
                "::",
                stringify!(wq)
            )
        );
    }
    pub type __portpair = __u32;
    pub type __addrpair = __u64;
    #[doc = "\tstruct sock_common - minimal network layer representation of sockets"]
    #[doc = "\t@skc_daddr: Foreign IPv4 addr"]
    #[doc = "\t@skc_rcv_saddr: Bound local IPv4 addr"]
    #[doc = "\t@skc_addrpair: 8-byte-aligned __u64 union of @skc_daddr & @skc_rcv_saddr"]
    #[doc = "\t@skc_hash: hash value used with various protocol lookup tables"]
    #[doc = "\t@skc_u16hashes: two u16 hash values used by UDP lookup tables"]
    #[doc = "\t@skc_dport: placeholder for inet_dport/tw_dport"]
    #[doc = "\t@skc_num: placeholder for inet_num/tw_num"]
    #[doc = "\t@skc_portpair: __u32 union of @skc_dport & @skc_num"]
    #[doc = "\t@skc_family: network address family"]
    #[doc = "\t@skc_state: Connection state"]
    #[doc = "\t@skc_reuse: %SO_REUSEADDR setting"]
    #[doc = "\t@skc_reuseport: %SO_REUSEPORT setting"]
    #[doc = "\t@skc_ipv6only: socket is IPV6 only"]
    #[doc = "\t@skc_net_refcnt: socket is using net ref counting"]
    #[doc = "\t@skc_bound_dev_if: bound device index if != 0"]
    #[doc = "\t@skc_bind_node: bind hash linkage for various protocol lookup tables"]
    #[doc = "\t@skc_portaddr_node: second hash linkage for UDP/UDP-Lite protocol"]
    #[doc = "\t@skc_prot: protocol handlers inside a network family"]
    #[doc = "\t@skc_net: reference to the network namespace of this socket"]
    #[doc = "\t@skc_v6_daddr: IPV6 destination address"]
    #[doc = "\t@skc_v6_rcv_saddr: IPV6 source address"]
    #[doc = "\t@skc_cookie: socket's cookie value"]
    #[doc = "\t@skc_node: main hash linkage for various protocol lookup tables"]
    #[doc = "\t@skc_nulls_node: main hash linkage for TCP/UDP/UDP-Lite protocol"]
    #[doc = "\t@skc_tx_queue_mapping: tx queue number for this connection"]
    #[doc = "\t@skc_rx_queue_mapping: rx queue number for this connection"]
    #[doc = "\t@skc_flags: place holder for sk_flags"]
    #[doc = "\t\t%SO_LINGER (l_onoff), %SO_BROADCAST, %SO_KEEPALIVE,"]
    #[doc = "\t\t%SO_OOBINLINE settings, %SO_TIMESTAMPING settings"]
    #[doc = "\t@skc_listener: connection request listener socket (aka rsk_listener)"]
    #[doc = "\t\t[union with @skc_flags]"]
    #[doc = "\t@skc_tw_dr: (aka tw_dr) ptr to &struct inet_timewait_death_row"]
    #[doc = "\t\t[union with @skc_flags]"]
    #[doc = "\t@skc_incoming_cpu: record/match cpu processing incoming packets"]
    #[doc = "\t@skc_rcv_wnd: (aka rsk_rcv_wnd) TCP receive window size (possibly scaled)"]
    #[doc = "\t\t[union with @skc_incoming_cpu]"]
    #[doc = "\t@skc_tw_rcv_nxt: (aka tw_rcv_nxt) TCP window next expected seq number"]
    #[doc = "\t\t[union with @skc_incoming_cpu]"]
    #[doc = "\t@skc_refcnt: reference count"]
    #[doc = ""]
    #[doc = "\tThis is the minimal network layer representation of sockets, the header"]
    #[doc = "\tfor struct sock and struct inet_timewait_sock."]
    #[repr(C)]
    pub struct sock_common {
        pub __bindgen_anon_1: sock_common__bindgen_ty_1,
        pub __bindgen_anon_2: sock_common__bindgen_ty_2,
        pub __bindgen_anon_3: sock_common__bindgen_ty_3,
        pub skc_family: ::cty::c_ushort,
        pub skc_state: ::cty::c_uchar,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
        pub skc_bound_dev_if: ::cty::c_int,
        pub __bindgen_anon_4: sock_common__bindgen_ty_4,
        pub skc_prot: *mut proto,
        pub skc_net: possible_net_t,
        pub skc_v6_daddr: in6_addr,
        pub skc_v6_rcv_saddr: in6_addr,
        pub skc_cookie: atomic64_t,
        pub __bindgen_anon_5: sock_common__bindgen_ty_5,
        pub skc_dontcopy_begin: __IncompleteArrayField<::cty::c_int>,
        pub __bindgen_anon_6: sock_common__bindgen_ty_6,
        pub skc_tx_queue_mapping: ::cty::c_ushort,
        pub skc_rx_queue_mapping: ::cty::c_ushort,
        pub __bindgen_anon_7: sock_common__bindgen_ty_7,
        pub skc_refcnt: refcount_t,
        pub skc_dontcopy_end: __IncompleteArrayField<::cty::c_int>,
        pub __bindgen_anon_8: sock_common__bindgen_ty_8,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union sock_common__bindgen_ty_1 {
        pub skc_addrpair: __addrpair,
        pub __bindgen_anon_1: sock_common__bindgen_ty_1__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct sock_common__bindgen_ty_1__bindgen_ty_1 {
        pub skc_daddr: __be32,
        pub skc_rcv_saddr: __be32,
    }
    #[test]
    fn bindgen_test_layout_sock_common__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<sock_common__bindgen_ty_1__bindgen_ty_1>(),
            8usize,
            concat!(
                "Size of: ",
                stringify!(sock_common__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<sock_common__bindgen_ty_1__bindgen_ty_1>(),
            4usize,
            concat!(
                "Alignment of ",
                stringify!(sock_common__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sock_common__bindgen_ty_1__bindgen_ty_1>())).skc_daddr
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sock_common__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(skc_daddr)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sock_common__bindgen_ty_1__bindgen_ty_1>())).skc_rcv_saddr
                    as *const _ as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(sock_common__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(skc_rcv_saddr)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_sock_common__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<sock_common__bindgen_ty_1>(),
            8usize,
            concat!("Size of: ", stringify!(sock_common__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<sock_common__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(sock_common__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sock_common__bindgen_ty_1>())).skc_addrpair as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sock_common__bindgen_ty_1),
                "::",
                stringify!(skc_addrpair)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union sock_common__bindgen_ty_2 {
        pub skc_hash: ::cty::c_uint,
        pub skc_u16hashes: [__u16; 2usize],
    }
    #[test]
    fn bindgen_test_layout_sock_common__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<sock_common__bindgen_ty_2>(),
            4usize,
            concat!("Size of: ", stringify!(sock_common__bindgen_ty_2))
        );
        assert_eq!(
            ::core::mem::align_of::<sock_common__bindgen_ty_2>(),
            4usize,
            concat!("Alignment of ", stringify!(sock_common__bindgen_ty_2))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sock_common__bindgen_ty_2>())).skc_hash as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sock_common__bindgen_ty_2),
                "::",
                stringify!(skc_hash)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sock_common__bindgen_ty_2>())).skc_u16hashes as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sock_common__bindgen_ty_2),
                "::",
                stringify!(skc_u16hashes)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union sock_common__bindgen_ty_3 {
        pub skc_portpair: __portpair,
        pub __bindgen_anon_1: sock_common__bindgen_ty_3__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct sock_common__bindgen_ty_3__bindgen_ty_1 {
        pub skc_dport: __be16,
        pub skc_num: __u16,
    }
    #[test]
    fn bindgen_test_layout_sock_common__bindgen_ty_3__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<sock_common__bindgen_ty_3__bindgen_ty_1>(),
            4usize,
            concat!(
                "Size of: ",
                stringify!(sock_common__bindgen_ty_3__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<sock_common__bindgen_ty_3__bindgen_ty_1>(),
            2usize,
            concat!(
                "Alignment of ",
                stringify!(sock_common__bindgen_ty_3__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sock_common__bindgen_ty_3__bindgen_ty_1>())).skc_dport
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sock_common__bindgen_ty_3__bindgen_ty_1),
                "::",
                stringify!(skc_dport)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sock_common__bindgen_ty_3__bindgen_ty_1>())).skc_num
                    as *const _ as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(sock_common__bindgen_ty_3__bindgen_ty_1),
                "::",
                stringify!(skc_num)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_sock_common__bindgen_ty_3() {
        assert_eq!(
            ::core::mem::size_of::<sock_common__bindgen_ty_3>(),
            4usize,
            concat!("Size of: ", stringify!(sock_common__bindgen_ty_3))
        );
        assert_eq!(
            ::core::mem::align_of::<sock_common__bindgen_ty_3>(),
            4usize,
            concat!("Alignment of ", stringify!(sock_common__bindgen_ty_3))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sock_common__bindgen_ty_3>())).skc_portpair as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sock_common__bindgen_ty_3),
                "::",
                stringify!(skc_portpair)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union sock_common__bindgen_ty_4 {
        pub skc_bind_node: hlist_node,
        pub skc_portaddr_node: hlist_node,
    }
    #[test]
    fn bindgen_test_layout_sock_common__bindgen_ty_4() {
        assert_eq!(
            ::core::mem::size_of::<sock_common__bindgen_ty_4>(),
            16usize,
            concat!("Size of: ", stringify!(sock_common__bindgen_ty_4))
        );
        assert_eq!(
            ::core::mem::align_of::<sock_common__bindgen_ty_4>(),
            8usize,
            concat!("Alignment of ", stringify!(sock_common__bindgen_ty_4))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sock_common__bindgen_ty_4>())).skc_bind_node as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sock_common__bindgen_ty_4),
                "::",
                stringify!(skc_bind_node)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sock_common__bindgen_ty_4>())).skc_portaddr_node as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sock_common__bindgen_ty_4),
                "::",
                stringify!(skc_portaddr_node)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union sock_common__bindgen_ty_5 {
        pub skc_flags: ::cty::c_ulong,
        pub skc_listener: *mut sock,
        pub skc_tw_dr: *mut inet_timewait_death_row,
    }
    #[test]
    fn bindgen_test_layout_sock_common__bindgen_ty_5() {
        assert_eq!(
            ::core::mem::size_of::<sock_common__bindgen_ty_5>(),
            8usize,
            concat!("Size of: ", stringify!(sock_common__bindgen_ty_5))
        );
        assert_eq!(
            ::core::mem::align_of::<sock_common__bindgen_ty_5>(),
            8usize,
            concat!("Alignment of ", stringify!(sock_common__bindgen_ty_5))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sock_common__bindgen_ty_5>())).skc_flags as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sock_common__bindgen_ty_5),
                "::",
                stringify!(skc_flags)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sock_common__bindgen_ty_5>())).skc_listener as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sock_common__bindgen_ty_5),
                "::",
                stringify!(skc_listener)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sock_common__bindgen_ty_5>())).skc_tw_dr as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sock_common__bindgen_ty_5),
                "::",
                stringify!(skc_tw_dr)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union sock_common__bindgen_ty_6 {
        pub skc_node: hlist_node,
        pub skc_nulls_node: hlist_nulls_node,
    }
    #[test]
    fn bindgen_test_layout_sock_common__bindgen_ty_6() {
        assert_eq!(
            ::core::mem::size_of::<sock_common__bindgen_ty_6>(),
            16usize,
            concat!("Size of: ", stringify!(sock_common__bindgen_ty_6))
        );
        assert_eq!(
            ::core::mem::align_of::<sock_common__bindgen_ty_6>(),
            8usize,
            concat!("Alignment of ", stringify!(sock_common__bindgen_ty_6))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sock_common__bindgen_ty_6>())).skc_node as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sock_common__bindgen_ty_6),
                "::",
                stringify!(skc_node)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sock_common__bindgen_ty_6>())).skc_nulls_node as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sock_common__bindgen_ty_6),
                "::",
                stringify!(skc_nulls_node)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union sock_common__bindgen_ty_7 {
        pub skc_incoming_cpu: ::cty::c_int,
        pub skc_rcv_wnd: _cargo_bpf_u32,
        pub skc_tw_rcv_nxt: _cargo_bpf_u32,
    }
    #[test]
    fn bindgen_test_layout_sock_common__bindgen_ty_7() {
        assert_eq!(
            ::core::mem::size_of::<sock_common__bindgen_ty_7>(),
            4usize,
            concat!("Size of: ", stringify!(sock_common__bindgen_ty_7))
        );
        assert_eq!(
            ::core::mem::align_of::<sock_common__bindgen_ty_7>(),
            4usize,
            concat!("Alignment of ", stringify!(sock_common__bindgen_ty_7))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sock_common__bindgen_ty_7>())).skc_incoming_cpu as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sock_common__bindgen_ty_7),
                "::",
                stringify!(skc_incoming_cpu)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sock_common__bindgen_ty_7>())).skc_rcv_wnd as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sock_common__bindgen_ty_7),
                "::",
                stringify!(skc_rcv_wnd)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sock_common__bindgen_ty_7>())).skc_tw_rcv_nxt as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sock_common__bindgen_ty_7),
                "::",
                stringify!(skc_tw_rcv_nxt)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union sock_common__bindgen_ty_8 {
        pub skc_rxhash: _cargo_bpf_u32,
        pub skc_window_clamp: _cargo_bpf_u32,
        pub skc_tw_snd_nxt: _cargo_bpf_u32,
    }
    #[test]
    fn bindgen_test_layout_sock_common__bindgen_ty_8() {
        assert_eq!(
            ::core::mem::size_of::<sock_common__bindgen_ty_8>(),
            4usize,
            concat!("Size of: ", stringify!(sock_common__bindgen_ty_8))
        );
        assert_eq!(
            ::core::mem::align_of::<sock_common__bindgen_ty_8>(),
            4usize,
            concat!("Alignment of ", stringify!(sock_common__bindgen_ty_8))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sock_common__bindgen_ty_8>())).skc_rxhash as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sock_common__bindgen_ty_8),
                "::",
                stringify!(skc_rxhash)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sock_common__bindgen_ty_8>())).skc_window_clamp as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sock_common__bindgen_ty_8),
                "::",
                stringify!(skc_window_clamp)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sock_common__bindgen_ty_8>())).skc_tw_snd_nxt as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sock_common__bindgen_ty_8),
                "::",
                stringify!(skc_tw_snd_nxt)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_sock_common() {
        assert_eq!(
            ::core::mem::size_of::<sock_common>(),
            136usize,
            concat!("Size of: ", stringify!(sock_common))
        );
        assert_eq!(
            ::core::mem::align_of::<sock_common>(),
            8usize,
            concat!("Alignment of ", stringify!(sock_common))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock_common>())).skc_family as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(sock_common),
                "::",
                stringify!(skc_family)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock_common>())).skc_state as *const _ as usize },
            18usize,
            concat!(
                "Offset of field: ",
                stringify!(sock_common),
                "::",
                stringify!(skc_state)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sock_common>())).skc_bound_dev_if as *const _ as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(sock_common),
                "::",
                stringify!(skc_bound_dev_if)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock_common>())).skc_prot as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(sock_common),
                "::",
                stringify!(skc_prot)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock_common>())).skc_net as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(sock_common),
                "::",
                stringify!(skc_net)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock_common>())).skc_v6_daddr as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(sock_common),
                "::",
                stringify!(skc_v6_daddr)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sock_common>())).skc_v6_rcv_saddr as *const _ as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(sock_common),
                "::",
                stringify!(skc_v6_rcv_saddr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock_common>())).skc_cookie as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(sock_common),
                "::",
                stringify!(skc_cookie)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sock_common>())).skc_dontcopy_begin as *const _ as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(sock_common),
                "::",
                stringify!(skc_dontcopy_begin)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sock_common>())).skc_tx_queue_mapping as *const _ as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(sock_common),
                "::",
                stringify!(skc_tx_queue_mapping)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sock_common>())).skc_rx_queue_mapping as *const _ as usize
            },
            122usize,
            concat!(
                "Offset of field: ",
                stringify!(sock_common),
                "::",
                stringify!(skc_rx_queue_mapping)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock_common>())).skc_refcnt as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(sock_common),
                "::",
                stringify!(skc_refcnt)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sock_common>())).skc_dontcopy_end as *const _ as usize
            },
            132usize,
            concat!(
                "Offset of field: ",
                stringify!(sock_common),
                "::",
                stringify!(skc_dontcopy_end)
            )
        );
    }
    impl sock_common {
        #[inline]
        pub fn skc_reuse(&self) -> ::cty::c_uchar {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
        }
        #[inline]
        pub fn set_skc_reuse(&mut self, val: ::cty::c_uchar) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 4u8, val as u64)
            }
        }
        #[inline]
        pub fn skc_reuseport(&self) -> ::cty::c_uchar {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_skc_reuseport(&mut self, val: ::cty::c_uchar) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(4usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn skc_ipv6only(&self) -> ::cty::c_uchar {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_skc_ipv6only(&mut self, val: ::cty::c_uchar) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(5usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn skc_net_refcnt(&self) -> ::cty::c_uchar {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_skc_net_refcnt(&mut self, val: ::cty::c_uchar) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(6usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            skc_reuse: ::cty::c_uchar,
            skc_reuseport: ::cty::c_uchar,
            skc_ipv6only: ::cty::c_uchar,
            skc_net_refcnt: ::cty::c_uchar,
        ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 4u8, {
                let skc_reuse: u8 = unsafe { ::core::mem::transmute(skc_reuse) };
                skc_reuse as u64
            });
            __bindgen_bitfield_unit.set(4usize, 1u8, {
                let skc_reuseport: u8 = unsafe { ::core::mem::transmute(skc_reuseport) };
                skc_reuseport as u64
            });
            __bindgen_bitfield_unit.set(5usize, 1u8, {
                let skc_ipv6only: u8 = unsafe { ::core::mem::transmute(skc_ipv6only) };
                skc_ipv6only as u64
            });
            __bindgen_bitfield_unit.set(6usize, 1u8, {
                let skc_net_refcnt: u8 = unsafe { ::core::mem::transmute(skc_net_refcnt) };
                skc_net_refcnt as u64
            });
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct sk_filter {
        _unused: [u8; 0],
    }
    #[doc = "\tstruct sock - network layer representation of sockets"]
    #[doc = "\t@__sk_common: shared layout with inet_timewait_sock"]
    #[doc = "\t@sk_shutdown: mask of %SEND_SHUTDOWN and/or %RCV_SHUTDOWN"]
    #[doc = "\t@sk_userlocks: %SO_SNDBUF and %SO_RCVBUF settings"]
    #[doc = "\t@sk_lock:\tsynchronizer"]
    #[doc = "\t@sk_kern_sock: True if sock is using kernel lock classes"]
    #[doc = "\t@sk_rcvbuf: size of receive buffer in bytes"]
    #[doc = "\t@sk_wq: sock wait queue and async head"]
    #[doc = "\t@sk_rx_dst: receive input route used by early demux"]
    #[doc = "\t@sk_rx_dst_ifindex: ifindex for @sk_rx_dst"]
    #[doc = "\t@sk_rx_dst_cookie: cookie for @sk_rx_dst"]
    #[doc = "\t@sk_dst_cache: destination cache"]
    #[doc = "\t@sk_dst_pending_confirm: need to confirm neighbour"]
    #[doc = "\t@sk_policy: flow policy"]
    #[doc = "\t@sk_receive_queue: incoming packets"]
    #[doc = "\t@sk_wmem_alloc: transmit queue bytes committed"]
    #[doc = "\t@sk_tsq_flags: TCP Small Queues flags"]
    #[doc = "\t@sk_write_queue: Packet sending queue"]
    #[doc = "\t@sk_omem_alloc: \"o\" is \"option\" or \"other\""]
    #[doc = "\t@sk_wmem_queued: persistent queue size"]
    #[doc = "\t@sk_forward_alloc: space allocated forward"]
    #[doc = "\t@sk_reserved_mem: space reserved and non-reclaimable for the socket"]
    #[doc = "\t@sk_napi_id: id of the last napi context to receive data for sk"]
    #[doc = "\t@sk_ll_usec: usecs to busypoll when there is no data"]
    #[doc = "\t@sk_allocation: allocation mode"]
    #[doc = "\t@sk_pacing_rate: Pacing rate (if supported by transport/packet scheduler)"]
    #[doc = "\t@sk_pacing_status: Pacing status (requested, handled by sch_fq)"]
    #[doc = "\t@sk_max_pacing_rate: Maximum pacing rate (%SO_MAX_PACING_RATE)"]
    #[doc = "\t@sk_sndbuf: size of send buffer in bytes"]
    #[doc = "\t@__sk_flags_offset: empty field used to determine location of bitfield"]
    #[doc = "\t@sk_padding: unused element for alignment"]
    #[doc = "\t@sk_no_check_tx: %SO_NO_CHECK setting, set checksum in TX packets"]
    #[doc = "\t@sk_no_check_rx: allow zero checksum in RX packets"]
    #[doc = "\t@sk_route_caps: route capabilities (e.g. %NETIF_F_TSO)"]
    #[doc = "\t@sk_gso_disabled: if set, NETIF_F_GSO_MASK is forbidden."]
    #[doc = "\t@sk_gso_type: GSO type (e.g. %SKB_GSO_TCPV4)"]
    #[doc = "\t@sk_gso_max_size: Maximum GSO segment size to build"]
    #[doc = "\t@sk_gso_max_segs: Maximum number of GSO segments"]
    #[doc = "\t@sk_pacing_shift: scaling factor for TCP Small Queues"]
    #[doc = "\t@sk_lingertime: %SO_LINGER l_linger setting"]
    #[doc = "\t@sk_backlog: always used with the per-socket spinlock held"]
    #[doc = "\t@sk_callback_lock: used with the callbacks in the end of this struct"]
    #[doc = "\t@sk_error_queue: rarely used"]
    #[doc = "\t@sk_prot_creator: sk_prot of original sock creator (see ipv6_setsockopt,"]
    #[doc = "\t\t\t  IPV6_ADDRFORM for instance)"]
    #[doc = "\t@sk_err: last error"]
    #[doc = "\t@sk_err_soft: errors that don't cause failure but are the cause of a"]
    #[doc = "\t\t      persistent failure not just 'timed out'"]
    #[doc = "\t@sk_drops: raw/udp drops counter"]
    #[doc = "\t@sk_ack_backlog: current listen backlog"]
    #[doc = "\t@sk_max_ack_backlog: listen backlog set in listen()"]
    #[doc = "\t@sk_uid: user id of owner"]
    #[doc = "\t@sk_prefer_busy_poll: prefer busypolling over softirq processing"]
    #[doc = "\t@sk_busy_poll_budget: napi processing budget when busypolling"]
    #[doc = "\t@sk_priority: %SO_PRIORITY setting"]
    #[doc = "\t@sk_type: socket type (%SOCK_STREAM, etc)"]
    #[doc = "\t@sk_protocol: which protocol this socket belongs in this network family"]
    #[doc = "\t@sk_peer_lock: lock protecting @sk_peer_pid and @sk_peer_cred"]
    #[doc = "\t@sk_peer_pid: &struct pid for this socket's peer"]
    #[doc = "\t@sk_peer_cred: %SO_PEERCRED setting"]
    #[doc = "\t@sk_rcvlowat: %SO_RCVLOWAT setting"]
    #[doc = "\t@sk_rcvtimeo: %SO_RCVTIMEO setting"]
    #[doc = "\t@sk_sndtimeo: %SO_SNDTIMEO setting"]
    #[doc = "\t@sk_txhash: computed flow hash for use on transmit"]
    #[doc = "\t@sk_txrehash: enable TX hash rethink"]
    #[doc = "\t@sk_filter: socket filtering instructions"]
    #[doc = "\t@sk_timer: sock cleanup timer"]
    #[doc = "\t@sk_stamp: time stamp of last packet received"]
    #[doc = "\t@sk_stamp_seq: lock for accessing sk_stamp on 32 bit architectures only"]
    #[doc = "\t@sk_tsflags: SO_TIMESTAMPING flags"]
    #[doc = "\t@sk_use_task_frag: allow sk_page_frag() to use current->task_frag."]
    #[doc = "\t\t\t   Sockets that can be used under memory reclaim should"]
    #[doc = "\t\t\t   set this to false."]
    #[doc = "\t@sk_bind_phc: SO_TIMESTAMPING bind PHC index of PTP virtual clock"]
    #[doc = "\t              for timestamping"]
    #[doc = "\t@sk_tskey: counter to disambiguate concurrent tstamp requests"]
    #[doc = "\t@sk_zckey: counter to order MSG_ZEROCOPY notifications"]
    #[doc = "\t@sk_socket: Identd and reporting IO signals"]
    #[doc = "\t@sk_user_data: RPC layer private data. Write-protected by @sk_callback_lock."]
    #[doc = "\t@sk_frag: cached page frag"]
    #[doc = "\t@sk_peek_off: current peek_offset value"]
    #[doc = "\t@sk_send_head: front of stuff to transmit"]
    #[doc = "\t@tcp_rtx_queue: TCP re-transmit queue [union with @sk_send_head]"]
    #[doc = "\t@sk_security: used by security modules"]
    #[doc = "\t@sk_mark: generic packet mark"]
    #[doc = "\t@sk_cgrp_data: cgroup data for this cgroup"]
    #[doc = "\t@sk_memcg: this socket's memory cgroup association"]
    #[doc = "\t@sk_write_pending: a write to stream socket waits to start"]
    #[doc = "\t@sk_wait_pending: number of threads blocked on this socket"]
    #[doc = "\t@sk_state_change: callback to indicate change in the state of the sock"]
    #[doc = "\t@sk_data_ready: callback to indicate there is data to be processed"]
    #[doc = "\t@sk_write_space: callback to indicate there is bf sending space available"]
    #[doc = "\t@sk_error_report: callback to indicate errors (e.g. %MSG_ERRQUEUE)"]
    #[doc = "\t@sk_backlog_rcv: callback to process the backlog"]
    #[doc = "\t@sk_validate_xmit_skb: ptr to an optional validate function"]
    #[doc = "\t@sk_destruct: called at sock freeing time, i.e. when all refcnt == 0"]
    #[doc = "\t@sk_reuseport_cb: reuseport group container"]
    #[doc = "\t@sk_bpf_storage: ptr to cache and control for bpf_sk_storage"]
    #[doc = "\t@sk_rcu: used during RCU grace period"]
    #[doc = "\t@sk_clockid: clockid used by time-based scheduling (SO_TXTIME)"]
    #[doc = "\t@sk_txtime_deadline_mode: set deadline mode for SO_TXTIME"]
    #[doc = "\t@sk_txtime_report_errors: set report errors mode for SO_TXTIME"]
    #[doc = "\t@sk_txtime_unused: unused txtime flags"]
    #[doc = "\t@ns_tracker: tracker for netns reference"]
    #[doc = "\t@sk_bind2_node: bind node in the bhash2 table"]
    #[repr(C)]
    pub struct sock {
        pub __sk_common: sock_common,
        pub sk_rx_dst: *mut dst_entry,
        pub sk_rx_dst_ifindex: ::cty::c_int,
        pub sk_rx_dst_cookie: _cargo_bpf_u32,
        pub sk_lock: socket_lock_t,
        pub sk_drops: atomic_t,
        pub sk_rcvlowat: ::cty::c_int,
        pub sk_error_queue: sk_buff_head,
        pub sk_receive_queue: sk_buff_head,
        pub sk_backlog: sock__bindgen_ty_1,
        pub sk_forward_alloc: ::cty::c_int,
        pub sk_reserved_mem: _cargo_bpf_u32,
        pub sk_ll_usec: ::cty::c_uint,
        pub sk_napi_id: ::cty::c_uint,
        pub sk_rcvbuf: ::cty::c_int,
        pub sk_wait_pending: ::cty::c_int,
        pub sk_filter: *mut sk_filter,
        pub __bindgen_anon_1: sock__bindgen_ty_2,
        pub sk_policy: [*mut xfrm_policy; 2usize],
        pub sk_dst_cache: *mut dst_entry,
        pub sk_omem_alloc: atomic_t,
        pub sk_sndbuf: ::cty::c_int,
        pub sk_wmem_queued: ::cty::c_int,
        pub sk_wmem_alloc: refcount_t,
        pub sk_tsq_flags: ::cty::c_ulong,
        pub __bindgen_anon_2: sock__bindgen_ty_3,
        pub sk_write_queue: sk_buff_head,
        pub sk_peek_off: __s32,
        pub sk_write_pending: ::cty::c_int,
        pub sk_dst_pending_confirm: __u32,
        pub sk_pacing_status: _cargo_bpf_u32,
        pub sk_sndtimeo: ::cty::c_long,
        pub sk_timer: timer_list,
        pub sk_priority: __u32,
        pub sk_mark: __u32,
        pub sk_pacing_rate: ::cty::c_ulong,
        pub sk_max_pacing_rate: ::cty::c_ulong,
        pub sk_frag: page_frag,
        pub sk_route_caps: netdev_features_t,
        pub sk_gso_type: ::cty::c_int,
        pub sk_gso_max_size: ::cty::c_uint,
        pub sk_allocation: gfp_t,
        pub sk_txhash: __u32,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
        pub sk_pacing_shift: _cargo_bpf_u8,
        pub sk_type: _cargo_bpf_u16,
        pub sk_protocol: _cargo_bpf_u16,
        pub sk_gso_max_segs: _cargo_bpf_u16,
        pub sk_lingertime: ::cty::c_ulong,
        pub sk_prot_creator: *mut proto,
        pub sk_callback_lock: rwlock_t,
        pub sk_err: ::cty::c_int,
        pub sk_err_soft: ::cty::c_int,
        pub sk_ack_backlog: _cargo_bpf_u32,
        pub sk_max_ack_backlog: _cargo_bpf_u32,
        pub sk_uid: kuid_t,
        pub sk_txrehash: _cargo_bpf_u8,
        pub sk_prefer_busy_poll: _cargo_bpf_u8,
        pub sk_busy_poll_budget: _cargo_bpf_u16,
        pub sk_peer_lock: spinlock_t,
        pub sk_bind_phc: ::cty::c_int,
        pub sk_peer_pid: *mut pid,
        pub sk_peer_cred: *const cred,
        pub sk_rcvtimeo: ::cty::c_long,
        pub sk_stamp: ktime_t,
        pub sk_tskey: atomic_t,
        pub sk_zckey: atomic_t,
        pub sk_tsflags: _cargo_bpf_u32,
        pub sk_shutdown: _cargo_bpf_u8,
        pub sk_clockid: _cargo_bpf_u8,
        pub _bitfield_align_2: [u8; 0],
        pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
        pub sk_use_task_frag: bool_,
        pub sk_socket: *mut socket,
        pub sk_user_data: *mut ::cty::c_void,
        pub sk_security: *mut ::cty::c_void,
        pub sk_cgrp_data: sock_cgroup_data,
        pub sk_memcg: *mut mem_cgroup,
        pub sk_state_change: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock)>,
        pub sk_data_ready: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock)>,
        pub sk_write_space: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock)>,
        pub sk_error_report: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock)>,
        pub sk_backlog_rcv: ::core::option::Option<
            unsafe extern "C" fn(sk: *mut sock, skb: *mut sk_buff) -> ::cty::c_int,
        >,
        pub sk_validate_xmit_skb: ::core::option::Option<
            unsafe extern "C" fn(
                sk: *mut sock,
                dev: *mut net_device,
                skb: *mut sk_buff,
            ) -> *mut sk_buff,
        >,
        pub sk_destruct: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock)>,
        pub sk_reuseport_cb: *mut sock_reuseport,
        pub sk_bpf_storage: *mut bpf_local_storage,
        pub sk_rcu: callback_head,
        pub ns_tracker: netns_tracker,
        pub sk_bind2_node: hlist_node,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct sock__bindgen_ty_1 {
        pub rmem_alloc: atomic_t,
        pub len: ::cty::c_int,
        pub head: *mut sk_buff,
        pub tail: *mut sk_buff,
    }
    #[test]
    fn bindgen_test_layout_sock__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<sock__bindgen_ty_1>(),
            24usize,
            concat!("Size of: ", stringify!(sock__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<sock__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(sock__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sock__bindgen_ty_1>())).rmem_alloc as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sock__bindgen_ty_1),
                "::",
                stringify!(rmem_alloc)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock__bindgen_ty_1>())).len as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(sock__bindgen_ty_1),
                "::",
                stringify!(len)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock__bindgen_ty_1>())).head as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sock__bindgen_ty_1),
                "::",
                stringify!(head)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock__bindgen_ty_1>())).tail as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(sock__bindgen_ty_1),
                "::",
                stringify!(tail)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union sock__bindgen_ty_2 {
        pub sk_wq: *mut socket_wq,
        pub sk_wq_raw: *mut socket_wq,
    }
    #[test]
    fn bindgen_test_layout_sock__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<sock__bindgen_ty_2>(),
            8usize,
            concat!("Size of: ", stringify!(sock__bindgen_ty_2))
        );
        assert_eq!(
            ::core::mem::align_of::<sock__bindgen_ty_2>(),
            8usize,
            concat!("Alignment of ", stringify!(sock__bindgen_ty_2))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock__bindgen_ty_2>())).sk_wq as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sock__bindgen_ty_2),
                "::",
                stringify!(sk_wq)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sock__bindgen_ty_2>())).sk_wq_raw as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sock__bindgen_ty_2),
                "::",
                stringify!(sk_wq_raw)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union sock__bindgen_ty_3 {
        pub sk_send_head: *mut sk_buff,
        pub tcp_rtx_queue: rb_root,
    }
    #[test]
    fn bindgen_test_layout_sock__bindgen_ty_3() {
        assert_eq!(
            ::core::mem::size_of::<sock__bindgen_ty_3>(),
            8usize,
            concat!("Size of: ", stringify!(sock__bindgen_ty_3))
        );
        assert_eq!(
            ::core::mem::align_of::<sock__bindgen_ty_3>(),
            8usize,
            concat!("Alignment of ", stringify!(sock__bindgen_ty_3))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sock__bindgen_ty_3>())).sk_send_head as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sock__bindgen_ty_3),
                "::",
                stringify!(sk_send_head)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sock__bindgen_ty_3>())).tcp_rtx_queue as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sock__bindgen_ty_3),
                "::",
                stringify!(tcp_rtx_queue)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_sock() {
        assert_eq!(
            ::core::mem::size_of::<sock>(),
            776usize,
            concat!("Size of: ", stringify!(sock))
        );
        assert_eq!(
            ::core::mem::align_of::<sock>(),
            8usize,
            concat!("Alignment of ", stringify!(sock))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).__sk_common as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(__sk_common)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_rx_dst as *const _ as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_rx_dst)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_rx_dst_ifindex as *const _ as usize },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_rx_dst_ifindex)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_rx_dst_cookie as *const _ as usize },
            148usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_rx_dst_cookie)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_lock as *const _ as usize },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_drops as *const _ as usize },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_drops)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_rcvlowat as *const _ as usize },
            188usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_rcvlowat)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_error_queue as *const _ as usize },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_error_queue)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_receive_queue as *const _ as usize },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_receive_queue)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_backlog as *const _ as usize },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_backlog)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_forward_alloc as *const _ as usize },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_forward_alloc)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_reserved_mem as *const _ as usize },
            268usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_reserved_mem)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_ll_usec as *const _ as usize },
            272usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_ll_usec)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_napi_id as *const _ as usize },
            276usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_napi_id)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_rcvbuf as *const _ as usize },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_rcvbuf)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_wait_pending as *const _ as usize },
            284usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_wait_pending)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_filter as *const _ as usize },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_filter)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_policy as *const _ as usize },
            304usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_policy)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_dst_cache as *const _ as usize },
            320usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_dst_cache)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_omem_alloc as *const _ as usize },
            328usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_omem_alloc)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_sndbuf as *const _ as usize },
            332usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_sndbuf)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_wmem_queued as *const _ as usize },
            336usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_wmem_queued)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_wmem_alloc as *const _ as usize },
            340usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_wmem_alloc)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_tsq_flags as *const _ as usize },
            344usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_tsq_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_write_queue as *const _ as usize },
            360usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_write_queue)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_peek_off as *const _ as usize },
            384usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_peek_off)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_write_pending as *const _ as usize },
            388usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_write_pending)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<sock>())).sk_dst_pending_confirm as *const _ as usize
            },
            392usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_dst_pending_confirm)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_pacing_status as *const _ as usize },
            396usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_pacing_status)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_sndtimeo as *const _ as usize },
            400usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_sndtimeo)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_timer as *const _ as usize },
            408usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_timer)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_priority as *const _ as usize },
            448usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_priority)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_mark as *const _ as usize },
            452usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_mark)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_pacing_rate as *const _ as usize },
            456usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_pacing_rate)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_max_pacing_rate as *const _ as usize },
            464usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_max_pacing_rate)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_frag as *const _ as usize },
            472usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_frag)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_route_caps as *const _ as usize },
            488usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_route_caps)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_gso_type as *const _ as usize },
            496usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_gso_type)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_gso_max_size as *const _ as usize },
            500usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_gso_max_size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_allocation as *const _ as usize },
            504usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_allocation)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_txhash as *const _ as usize },
            508usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_txhash)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_pacing_shift as *const _ as usize },
            513usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_pacing_shift)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_type as *const _ as usize },
            514usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_type)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_protocol as *const _ as usize },
            516usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_protocol)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_gso_max_segs as *const _ as usize },
            518usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_gso_max_segs)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_lingertime as *const _ as usize },
            520usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_lingertime)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_prot_creator as *const _ as usize },
            528usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_prot_creator)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_callback_lock as *const _ as usize },
            536usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_callback_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_err as *const _ as usize },
            544usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_err)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_err_soft as *const _ as usize },
            548usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_err_soft)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_ack_backlog as *const _ as usize },
            552usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_ack_backlog)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_max_ack_backlog as *const _ as usize },
            556usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_max_ack_backlog)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_uid as *const _ as usize },
            560usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_uid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_txrehash as *const _ as usize },
            564usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_txrehash)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_prefer_busy_poll as *const _ as usize },
            565usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_prefer_busy_poll)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_busy_poll_budget as *const _ as usize },
            566usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_busy_poll_budget)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_peer_lock as *const _ as usize },
            568usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_peer_lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_bind_phc as *const _ as usize },
            572usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_bind_phc)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_peer_pid as *const _ as usize },
            576usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_peer_pid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_peer_cred as *const _ as usize },
            584usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_peer_cred)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_rcvtimeo as *const _ as usize },
            592usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_rcvtimeo)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_stamp as *const _ as usize },
            600usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_stamp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_tskey as *const _ as usize },
            608usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_tskey)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_zckey as *const _ as usize },
            612usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_zckey)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_tsflags as *const _ as usize },
            616usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_tsflags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_shutdown as *const _ as usize },
            620usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_shutdown)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_clockid as *const _ as usize },
            621usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_clockid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_use_task_frag as *const _ as usize },
            623usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_use_task_frag)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_socket as *const _ as usize },
            624usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_socket)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_user_data as *const _ as usize },
            632usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_user_data)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_security as *const _ as usize },
            640usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_security)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_cgrp_data as *const _ as usize },
            648usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_cgrp_data)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_memcg as *const _ as usize },
            664usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_memcg)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_state_change as *const _ as usize },
            672usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_state_change)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_data_ready as *const _ as usize },
            680usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_data_ready)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_write_space as *const _ as usize },
            688usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_write_space)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_error_report as *const _ as usize },
            696usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_error_report)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_backlog_rcv as *const _ as usize },
            704usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_backlog_rcv)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_validate_xmit_skb as *const _ as usize },
            712usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_validate_xmit_skb)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_destruct as *const _ as usize },
            720usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_destruct)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_reuseport_cb as *const _ as usize },
            728usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_reuseport_cb)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_bpf_storage as *const _ as usize },
            736usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_bpf_storage)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_rcu as *const _ as usize },
            744usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_rcu)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).ns_tracker as *const _ as usize },
            760usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(ns_tracker)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<sock>())).sk_bind2_node as *const _ as usize },
            760usize,
            concat!(
                "Offset of field: ",
                stringify!(sock),
                "::",
                stringify!(sk_bind2_node)
            )
        );
    }
    impl sock {
        #[inline]
        pub fn sk_gso_disabled(&self) -> _cargo_bpf_u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_sk_gso_disabled(&mut self, val: _cargo_bpf_u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn sk_kern_sock(&self) -> _cargo_bpf_u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_sk_kern_sock(&mut self, val: _cargo_bpf_u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(1usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn sk_no_check_tx(&self) -> _cargo_bpf_u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_sk_no_check_tx(&mut self, val: _cargo_bpf_u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(2usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn sk_no_check_rx(&self) -> _cargo_bpf_u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_sk_no_check_rx(&mut self, val: _cargo_bpf_u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(3usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn sk_userlocks(&self) -> _cargo_bpf_u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
        }
        #[inline]
        pub fn set_sk_userlocks(&mut self, val: _cargo_bpf_u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(4usize, 4u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            sk_gso_disabled: _cargo_bpf_u8,
            sk_kern_sock: _cargo_bpf_u8,
            sk_no_check_tx: _cargo_bpf_u8,
            sk_no_check_rx: _cargo_bpf_u8,
            sk_userlocks: _cargo_bpf_u8,
        ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 1u8, {
                let sk_gso_disabled: u8 = unsafe { ::core::mem::transmute(sk_gso_disabled) };
                sk_gso_disabled as u64
            });
            __bindgen_bitfield_unit.set(1usize, 1u8, {
                let sk_kern_sock: u8 = unsafe { ::core::mem::transmute(sk_kern_sock) };
                sk_kern_sock as u64
            });
            __bindgen_bitfield_unit.set(2usize, 1u8, {
                let sk_no_check_tx: u8 = unsafe { ::core::mem::transmute(sk_no_check_tx) };
                sk_no_check_tx as u64
            });
            __bindgen_bitfield_unit.set(3usize, 1u8, {
                let sk_no_check_rx: u8 = unsafe { ::core::mem::transmute(sk_no_check_rx) };
                sk_no_check_rx as u64
            });
            __bindgen_bitfield_unit.set(4usize, 4u8, {
                let sk_userlocks: u8 = unsafe { ::core::mem::transmute(sk_userlocks) };
                sk_userlocks as u64
            });
            __bindgen_bitfield_unit
        }
        #[inline]
        pub fn sk_txtime_deadline_mode(&self) -> _cargo_bpf_u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_sk_txtime_deadline_mode(&mut self, val: _cargo_bpf_u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(0usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn sk_txtime_report_errors(&self) -> _cargo_bpf_u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_sk_txtime_report_errors(&mut self, val: _cargo_bpf_u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(1usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn sk_txtime_unused(&self) -> _cargo_bpf_u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(2usize, 6u8) as u8) }
        }
        #[inline]
        pub fn set_sk_txtime_unused(&mut self, val: _cargo_bpf_u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(2usize, 6u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_2(
            sk_txtime_deadline_mode: _cargo_bpf_u8,
            sk_txtime_report_errors: _cargo_bpf_u8,
            sk_txtime_unused: _cargo_bpf_u8,
        ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 1u8, {
                let sk_txtime_deadline_mode: u8 =
                    unsafe { ::core::mem::transmute(sk_txtime_deadline_mode) };
                sk_txtime_deadline_mode as u64
            });
            __bindgen_bitfield_unit.set(1usize, 1u8, {
                let sk_txtime_report_errors: u8 =
                    unsafe { ::core::mem::transmute(sk_txtime_report_errors) };
                sk_txtime_report_errors as u64
            });
            __bindgen_bitfield_unit.set(2usize, 6u8, {
                let sk_txtime_unused: u8 = unsafe { ::core::mem::transmute(sk_txtime_unused) };
                sk_txtime_unused as u64
            });
            __bindgen_bitfield_unit
        }
    }
    pub const sk_pacing_SK_PACING_NONE: sk_pacing = 0;
    pub const sk_pacing_SK_PACING_NEEDED: sk_pacing = 1;
    pub const sk_pacing_SK_PACING_FQ: sk_pacing = 2;
    pub type sk_pacing = ::cty::c_uint;
    pub const sock_flags_SOCK_DEAD: sock_flags = 0;
    pub const sock_flags_SOCK_DONE: sock_flags = 1;
    pub const sock_flags_SOCK_URGINLINE: sock_flags = 2;
    pub const sock_flags_SOCK_KEEPOPEN: sock_flags = 3;
    pub const sock_flags_SOCK_LINGER: sock_flags = 4;
    pub const sock_flags_SOCK_DESTROY: sock_flags = 5;
    pub const sock_flags_SOCK_BROADCAST: sock_flags = 6;
    pub const sock_flags_SOCK_TIMESTAMP: sock_flags = 7;
    pub const sock_flags_SOCK_ZAPPED: sock_flags = 8;
    pub const sock_flags_SOCK_USE_WRITE_QUEUE: sock_flags = 9;
    pub const sock_flags_SOCK_DBG: sock_flags = 10;
    pub const sock_flags_SOCK_RCVTSTAMP: sock_flags = 11;
    pub const sock_flags_SOCK_RCVTSTAMPNS: sock_flags = 12;
    pub const sock_flags_SOCK_LOCALROUTE: sock_flags = 13;
    pub const sock_flags_SOCK_MEMALLOC: sock_flags = 14;
    pub const sock_flags_SOCK_TIMESTAMPING_RX_SOFTWARE: sock_flags = 15;
    pub const sock_flags_SOCK_FASYNC: sock_flags = 16;
    pub const sock_flags_SOCK_RXQ_OVFL: sock_flags = 17;
    pub const sock_flags_SOCK_ZEROCOPY: sock_flags = 18;
    pub const sock_flags_SOCK_WIFI_STATUS: sock_flags = 19;
    pub const sock_flags_SOCK_NOFCS: sock_flags = 20;
    pub const sock_flags_SOCK_FILTER_LOCKED: sock_flags = 21;
    pub const sock_flags_SOCK_SELECT_ERR_QUEUE: sock_flags = 22;
    pub const sock_flags_SOCK_RCU_FREE: sock_flags = 23;
    pub const sock_flags_SOCK_TXTIME: sock_flags = 24;
    pub const sock_flags_SOCK_XDP: sock_flags = 25;
    pub const sock_flags_SOCK_TSTAMP_NEW: sock_flags = 26;
    pub const sock_flags_SOCK_RCVMARK: sock_flags = 27;
    pub type sock_flags = ::cty::c_uint;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct raw_hashinfo {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct smc_hashinfo {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct sk_psock {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct proto {
        pub close:
            ::core::option::Option<unsafe extern "C" fn(sk: *mut sock, timeout: ::cty::c_long)>,
        pub pre_connect: ::core::option::Option<
            unsafe extern "C" fn(
                sk: *mut sock,
                uaddr: *mut sockaddr,
                addr_len: ::cty::c_int,
            ) -> ::cty::c_int,
        >,
        pub connect: ::core::option::Option<
            unsafe extern "C" fn(
                sk: *mut sock,
                uaddr: *mut sockaddr,
                addr_len: ::cty::c_int,
            ) -> ::cty::c_int,
        >,
        pub disconnect: ::core::option::Option<
            unsafe extern "C" fn(sk: *mut sock, flags: ::cty::c_int) -> ::cty::c_int,
        >,
        pub accept: ::core::option::Option<
            unsafe extern "C" fn(
                sk: *mut sock,
                flags: ::cty::c_int,
                err: *mut ::cty::c_int,
                kern: bool_,
            ) -> *mut sock,
        >,
        pub ioctl: ::core::option::Option<
            unsafe extern "C" fn(
                sk: *mut sock,
                cmd: ::cty::c_int,
                karg: *mut ::cty::c_int,
            ) -> ::cty::c_int,
        >,
        pub init: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock) -> ::cty::c_int>,
        pub destroy: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock)>,
        pub shutdown:
            ::core::option::Option<unsafe extern "C" fn(sk: *mut sock, how: ::cty::c_int)>,
        pub setsockopt: ::core::option::Option<
            unsafe extern "C" fn(
                sk: *mut sock,
                level: ::cty::c_int,
                optname: ::cty::c_int,
                optval: sockptr_t,
                optlen: ::cty::c_uint,
            ) -> ::cty::c_int,
        >,
        pub getsockopt: ::core::option::Option<
            unsafe extern "C" fn(
                sk: *mut sock,
                level: ::cty::c_int,
                optname: ::cty::c_int,
                optval: *mut ::cty::c_char,
                option: *mut ::cty::c_int,
            ) -> ::cty::c_int,
        >,
        pub keepalive:
            ::core::option::Option<unsafe extern "C" fn(sk: *mut sock, valbool: ::cty::c_int)>,
        pub compat_ioctl: ::core::option::Option<
            unsafe extern "C" fn(
                sk: *mut sock,
                cmd: ::cty::c_uint,
                arg: ::cty::c_ulong,
            ) -> ::cty::c_int,
        >,
        pub sendmsg: ::core::option::Option<
            unsafe extern "C" fn(sk: *mut sock, msg: *mut msghdr, len: size_t) -> ::cty::c_int,
        >,
        pub recvmsg: ::core::option::Option<
            unsafe extern "C" fn(
                sk: *mut sock,
                msg: *mut msghdr,
                len: size_t,
                flags: ::cty::c_int,
                addr_len: *mut ::cty::c_int,
            ) -> ::cty::c_int,
        >,
        pub splice_eof: ::core::option::Option<unsafe extern "C" fn(sock: *mut socket)>,
        pub bind: ::core::option::Option<
            unsafe extern "C" fn(
                sk: *mut sock,
                addr: *mut sockaddr,
                addr_len: ::cty::c_int,
            ) -> ::cty::c_int,
        >,
        pub bind_add: ::core::option::Option<
            unsafe extern "C" fn(
                sk: *mut sock,
                addr: *mut sockaddr,
                addr_len: ::cty::c_int,
            ) -> ::cty::c_int,
        >,
        pub backlog_rcv: ::core::option::Option<
            unsafe extern "C" fn(sk: *mut sock, skb: *mut sk_buff) -> ::cty::c_int,
        >,
        pub bpf_bypass_getsockopt: ::core::option::Option<
            unsafe extern "C" fn(level: ::cty::c_int, optname: ::cty::c_int) -> bool_,
        >,
        pub release_cb: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock)>,
        pub hash: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock) -> ::cty::c_int>,
        pub unhash: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock)>,
        pub rehash: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock)>,
        pub get_port: ::core::option::Option<
            unsafe extern "C" fn(sk: *mut sock, snum: ::cty::c_ushort) -> ::cty::c_int,
        >,
        pub put_port: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock)>,
        pub psock_update_sk_prot: ::core::option::Option<
            unsafe extern "C" fn(
                sk: *mut sock,
                psock: *mut sk_psock,
                restore: bool_,
            ) -> ::cty::c_int,
        >,
        pub inuse_idx: ::cty::c_uint,
        pub forward_alloc_get:
            ::core::option::Option<unsafe extern "C" fn(sk: *const sock) -> ::cty::c_int>,
        pub stream_memory_free: ::core::option::Option<
            unsafe extern "C" fn(sk: *const sock, wake: ::cty::c_int) -> bool_,
        >,
        pub sock_is_readable: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock) -> bool_>,
        pub enter_memory_pressure: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock)>,
        pub leave_memory_pressure: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock)>,
        pub memory_allocated: *mut atomic_long_t,
        pub per_cpu_fw_alloc: *mut ::cty::c_int,
        pub sockets_allocated: *mut percpu_counter,
        pub memory_pressure: *mut ::cty::c_ulong,
        pub sysctl_mem: *mut ::cty::c_long,
        pub sysctl_wmem: *mut ::cty::c_int,
        pub sysctl_rmem: *mut ::cty::c_int,
        pub sysctl_wmem_offset: _cargo_bpf_u32,
        pub sysctl_rmem_offset: _cargo_bpf_u32,
        pub max_header: ::cty::c_int,
        pub no_autobind: bool_,
        pub slab: *mut kmem_cache,
        pub obj_size: ::cty::c_uint,
        pub ipv6_pinfo_offset: ::cty::c_uint,
        pub slab_flags: slab_flags_t,
        pub useroffset: ::cty::c_uint,
        pub usersize: ::cty::c_uint,
        pub orphan_count: *mut ::cty::c_uint,
        pub rsk_prot: *mut request_sock_ops,
        pub twsk_prot: *mut timewait_sock_ops,
        pub h: proto__bindgen_ty_1,
        pub owner: *mut module,
        pub name: [::cty::c_char; 32usize],
        pub node: list_head,
        pub diag_destroy: ::core::option::Option<
            unsafe extern "C" fn(sk: *mut sock, err: ::cty::c_int) -> ::cty::c_int,
        >,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union proto__bindgen_ty_1 {
        pub hashinfo: *mut inet_hashinfo,
        pub udp_table: *mut udp_table,
        pub raw_hash: *mut raw_hashinfo,
        pub smc_hash: *mut smc_hashinfo,
    }
    #[test]
    fn bindgen_test_layout_proto__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<proto__bindgen_ty_1>(),
            8usize,
            concat!("Size of: ", stringify!(proto__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<proto__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(proto__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<proto__bindgen_ty_1>())).hashinfo as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(proto__bindgen_ty_1),
                "::",
                stringify!(hashinfo)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<proto__bindgen_ty_1>())).udp_table as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(proto__bindgen_ty_1),
                "::",
                stringify!(udp_table)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<proto__bindgen_ty_1>())).raw_hash as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(proto__bindgen_ty_1),
                "::",
                stringify!(raw_hash)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<proto__bindgen_ty_1>())).smc_hash as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(proto__bindgen_ty_1),
                "::",
                stringify!(smc_hash)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_proto() {
        assert_eq!(
            ::core::mem::size_of::<proto>(),
            464usize,
            concat!("Size of: ", stringify!(proto))
        );
        assert_eq!(
            ::core::mem::align_of::<proto>(),
            8usize,
            concat!("Alignment of ", stringify!(proto))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).close as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(close)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).pre_connect as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(pre_connect)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).connect as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(connect)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).disconnect as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(disconnect)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).accept as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(accept)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).ioctl as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(ioctl)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).init as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(init)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).destroy as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(destroy)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).shutdown as *const _ as usize },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(shutdown)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).setsockopt as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(setsockopt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).getsockopt as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(getsockopt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).keepalive as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(keepalive)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).compat_ioctl as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(compat_ioctl)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).sendmsg as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(sendmsg)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).recvmsg as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(recvmsg)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).splice_eof as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(splice_eof)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).bind as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(bind)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).bind_add as *const _ as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(bind_add)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).backlog_rcv as *const _ as usize },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(backlog_rcv)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<proto>())).bpf_bypass_getsockopt as *const _ as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(bpf_bypass_getsockopt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).release_cb as *const _ as usize },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(release_cb)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).hash as *const _ as usize },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(hash)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).unhash as *const _ as usize },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(unhash)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).rehash as *const _ as usize },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(rehash)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).get_port as *const _ as usize },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(get_port)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).put_port as *const _ as usize },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(put_port)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).psock_update_sk_prot as *const _ as usize },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(psock_update_sk_prot)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).inuse_idx as *const _ as usize },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(inuse_idx)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).forward_alloc_get as *const _ as usize },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(forward_alloc_get)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).stream_memory_free as *const _ as usize },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(stream_memory_free)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).sock_is_readable as *const _ as usize },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(sock_is_readable)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<proto>())).enter_memory_pressure as *const _ as usize
            },
            248usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(enter_memory_pressure)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<proto>())).leave_memory_pressure as *const _ as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(leave_memory_pressure)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).memory_allocated as *const _ as usize },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(memory_allocated)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).per_cpu_fw_alloc as *const _ as usize },
            272usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(per_cpu_fw_alloc)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).sockets_allocated as *const _ as usize },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(sockets_allocated)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).memory_pressure as *const _ as usize },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(memory_pressure)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).sysctl_mem as *const _ as usize },
            296usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(sysctl_mem)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).sysctl_wmem as *const _ as usize },
            304usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(sysctl_wmem)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).sysctl_rmem as *const _ as usize },
            312usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(sysctl_rmem)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).sysctl_wmem_offset as *const _ as usize },
            320usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(sysctl_wmem_offset)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).sysctl_rmem_offset as *const _ as usize },
            324usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(sysctl_rmem_offset)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).max_header as *const _ as usize },
            328usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(max_header)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).no_autobind as *const _ as usize },
            332usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(no_autobind)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).slab as *const _ as usize },
            336usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(slab)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).obj_size as *const _ as usize },
            344usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(obj_size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).ipv6_pinfo_offset as *const _ as usize },
            348usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(ipv6_pinfo_offset)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).slab_flags as *const _ as usize },
            352usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(slab_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).useroffset as *const _ as usize },
            356usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(useroffset)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).usersize as *const _ as usize },
            360usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(usersize)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).orphan_count as *const _ as usize },
            368usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(orphan_count)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).rsk_prot as *const _ as usize },
            376usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(rsk_prot)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).twsk_prot as *const _ as usize },
            384usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(twsk_prot)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).h as *const _ as usize },
            392usize,
            concat!("Offset of field: ", stringify!(proto), "::", stringify!(h))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).owner as *const _ as usize },
            400usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(owner)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).name as *const _ as usize },
            408usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(name)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).node as *const _ as usize },
            440usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(node)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<proto>())).diag_destroy as *const _ as usize },
            456usize,
            concat!(
                "Offset of field: ",
                stringify!(proto),
                "::",
                stringify!(diag_destroy)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct prot_inuse {
        pub all: ::cty::c_int,
        pub val: [::cty::c_int; 64usize],
    }
    #[test]
    fn bindgen_test_layout_prot_inuse() {
        assert_eq!(
            ::core::mem::size_of::<prot_inuse>(),
            260usize,
            concat!("Size of: ", stringify!(prot_inuse))
        );
        assert_eq!(
            ::core::mem::align_of::<prot_inuse>(),
            4usize,
            concat!("Alignment of ", stringify!(prot_inuse))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<prot_inuse>())).all as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(prot_inuse),
                "::",
                stringify!(all)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<prot_inuse>())).val as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(prot_inuse),
                "::",
                stringify!(val)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct request_sock_ops {
        pub family: ::cty::c_int,
        pub obj_size: ::cty::c_uint,
        pub slab: *mut kmem_cache,
        pub slab_name: *mut ::cty::c_char,
        pub rtx_syn_ack: ::core::option::Option<
            unsafe extern "C" fn(sk: *const sock, req: *mut request_sock) -> ::cty::c_int,
        >,
        pub send_ack: ::core::option::Option<
            unsafe extern "C" fn(sk: *const sock, skb: *mut sk_buff, req: *mut request_sock),
        >,
        pub send_reset:
            ::core::option::Option<unsafe extern "C" fn(sk: *const sock, skb: *mut sk_buff)>,
        pub destructor: ::core::option::Option<unsafe extern "C" fn(req: *mut request_sock)>,
        pub syn_ack_timeout: ::core::option::Option<unsafe extern "C" fn(req: *const request_sock)>,
    }
    #[test]
    fn bindgen_test_layout_request_sock_ops() {
        assert_eq!(
            ::core::mem::size_of::<request_sock_ops>(),
            64usize,
            concat!("Size of: ", stringify!(request_sock_ops))
        );
        assert_eq!(
            ::core::mem::align_of::<request_sock_ops>(),
            8usize,
            concat!("Alignment of ", stringify!(request_sock_ops))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<request_sock_ops>())).family as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(request_sock_ops),
                "::",
                stringify!(family)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<request_sock_ops>())).obj_size as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(request_sock_ops),
                "::",
                stringify!(obj_size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<request_sock_ops>())).slab as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(request_sock_ops),
                "::",
                stringify!(slab)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<request_sock_ops>())).slab_name as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(request_sock_ops),
                "::",
                stringify!(slab_name)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<request_sock_ops>())).rtx_syn_ack as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(request_sock_ops),
                "::",
                stringify!(rtx_syn_ack)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<request_sock_ops>())).send_ack as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(request_sock_ops),
                "::",
                stringify!(send_ack)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<request_sock_ops>())).send_reset as *const _ as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(request_sock_ops),
                "::",
                stringify!(send_reset)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<request_sock_ops>())).destructor as *const _ as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(request_sock_ops),
                "::",
                stringify!(destructor)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<request_sock_ops>())).syn_ack_timeout as *const _ as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(request_sock_ops),
                "::",
                stringify!(syn_ack_timeout)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct saved_syn {
        pub mac_hdrlen: _cargo_bpf_u32,
        pub network_hdrlen: _cargo_bpf_u32,
        pub tcp_hdrlen: _cargo_bpf_u32,
        pub data: __IncompleteArrayField<_cargo_bpf_u8>,
    }
    #[test]
    fn bindgen_test_layout_saved_syn() {
        assert_eq!(
            ::core::mem::size_of::<saved_syn>(),
            12usize,
            concat!("Size of: ", stringify!(saved_syn))
        );
        assert_eq!(
            ::core::mem::align_of::<saved_syn>(),
            4usize,
            concat!("Alignment of ", stringify!(saved_syn))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<saved_syn>())).mac_hdrlen as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(saved_syn),
                "::",
                stringify!(mac_hdrlen)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<saved_syn>())).network_hdrlen as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(saved_syn),
                "::",
                stringify!(network_hdrlen)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<saved_syn>())).tcp_hdrlen as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(saved_syn),
                "::",
                stringify!(tcp_hdrlen)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<saved_syn>())).data as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(saved_syn),
                "::",
                stringify!(data)
            )
        );
    }
    #[repr(C)]
    pub struct request_sock {
        pub __req_common: sock_common,
        pub dl_next: *mut request_sock,
        pub mss: _cargo_bpf_u16,
        pub num_retrans: _cargo_bpf_u8,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
        pub ts_recent: _cargo_bpf_u32,
        pub rsk_timer: timer_list,
        pub rsk_ops: *const request_sock_ops,
        pub sk: *mut sock,
        pub saved_syn: *mut saved_syn,
        pub secid: _cargo_bpf_u32,
        pub peer_secid: _cargo_bpf_u32,
        pub timeout: _cargo_bpf_u32,
    }
    #[test]
    fn bindgen_test_layout_request_sock() {
        assert_eq!(
            ::core::mem::size_of::<request_sock>(),
            232usize,
            concat!("Size of: ", stringify!(request_sock))
        );
        assert_eq!(
            ::core::mem::align_of::<request_sock>(),
            8usize,
            concat!("Alignment of ", stringify!(request_sock))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<request_sock>())).__req_common as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(request_sock),
                "::",
                stringify!(__req_common)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<request_sock>())).dl_next as *const _ as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(request_sock),
                "::",
                stringify!(dl_next)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<request_sock>())).mss as *const _ as usize },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(request_sock),
                "::",
                stringify!(mss)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<request_sock>())).num_retrans as *const _ as usize },
            146usize,
            concat!(
                "Offset of field: ",
                stringify!(request_sock),
                "::",
                stringify!(num_retrans)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<request_sock>())).ts_recent as *const _ as usize },
            148usize,
            concat!(
                "Offset of field: ",
                stringify!(request_sock),
                "::",
                stringify!(ts_recent)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<request_sock>())).rsk_timer as *const _ as usize },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(request_sock),
                "::",
                stringify!(rsk_timer)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<request_sock>())).rsk_ops as *const _ as usize },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(request_sock),
                "::",
                stringify!(rsk_ops)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<request_sock>())).sk as *const _ as usize },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(request_sock),
                "::",
                stringify!(sk)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<request_sock>())).saved_syn as *const _ as usize },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(request_sock),
                "::",
                stringify!(saved_syn)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<request_sock>())).secid as *const _ as usize },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(request_sock),
                "::",
                stringify!(secid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<request_sock>())).peer_secid as *const _ as usize },
            220usize,
            concat!(
                "Offset of field: ",
                stringify!(request_sock),
                "::",
                stringify!(peer_secid)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<request_sock>())).timeout as *const _ as usize },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(request_sock),
                "::",
                stringify!(timeout)
            )
        );
    }
    impl request_sock {
        #[inline]
        pub fn syncookie(&self) -> _cargo_bpf_u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_syncookie(&mut self, val: _cargo_bpf_u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn num_timeout(&self) -> _cargo_bpf_u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
        }
        #[inline]
        pub fn set_num_timeout(&mut self, val: _cargo_bpf_u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(1usize, 7u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            syncookie: _cargo_bpf_u8,
            num_timeout: _cargo_bpf_u8,
        ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 1u8, {
                let syncookie: u8 = unsafe { ::core::mem::transmute(syncookie) };
                syncookie as u64
            });
            __bindgen_bitfield_unit.set(1usize, 7u8, {
                let num_timeout: u8 = unsafe { ::core::mem::transmute(num_timeout) };
                num_timeout as u64
            });
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct fastopen_queue {
        pub rskq_rst_head: *mut request_sock,
        pub rskq_rst_tail: *mut request_sock,
        pub lock: spinlock_t,
        pub qlen: ::cty::c_int,
        pub max_qlen: ::cty::c_int,
        pub ctx: *mut tcp_fastopen_context,
    }
    #[test]
    fn bindgen_test_layout_fastopen_queue() {
        assert_eq!(
            ::core::mem::size_of::<fastopen_queue>(),
            40usize,
            concat!("Size of: ", stringify!(fastopen_queue))
        );
        assert_eq!(
            ::core::mem::align_of::<fastopen_queue>(),
            8usize,
            concat!("Alignment of ", stringify!(fastopen_queue))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<fastopen_queue>())).rskq_rst_head as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fastopen_queue),
                "::",
                stringify!(rskq_rst_head)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<fastopen_queue>())).rskq_rst_tail as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fastopen_queue),
                "::",
                stringify!(rskq_rst_tail)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fastopen_queue>())).lock as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fastopen_queue),
                "::",
                stringify!(lock)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fastopen_queue>())).qlen as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(fastopen_queue),
                "::",
                stringify!(qlen)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fastopen_queue>())).max_qlen as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(fastopen_queue),
                "::",
                stringify!(max_qlen)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<fastopen_queue>())).ctx as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(fastopen_queue),
                "::",
                stringify!(ctx)
            )
        );
    }
    #[doc = " struct request_sock_queue - queue of request_socks"]
    #[doc = ""]
    #[doc = " @rskq_accept_head - FIFO head of established children"]
    #[doc = " @rskq_accept_tail - FIFO tail of established children"]
    #[doc = " @rskq_defer_accept - User waits for some data after accept()"]
    #[doc = ""]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct request_sock_queue {
        pub rskq_lock: spinlock_t,
        pub rskq_defer_accept: _cargo_bpf_u8,
        pub synflood_warned: _cargo_bpf_u32,
        pub qlen: atomic_t,
        pub young: atomic_t,
        pub rskq_accept_head: *mut request_sock,
        pub rskq_accept_tail: *mut request_sock,
        pub fastopenq: fastopen_queue,
    }
    #[test]
    fn bindgen_test_layout_request_sock_queue() {
        assert_eq!(
            ::core::mem::size_of::<request_sock_queue>(),
            80usize,
            concat!("Size of: ", stringify!(request_sock_queue))
        );
        assert_eq!(
            ::core::mem::align_of::<request_sock_queue>(),
            8usize,
            concat!("Alignment of ", stringify!(request_sock_queue))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<request_sock_queue>())).rskq_lock as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(request_sock_queue),
                "::",
                stringify!(rskq_lock)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<request_sock_queue>())).rskq_defer_accept as *const _
                    as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(request_sock_queue),
                "::",
                stringify!(rskq_defer_accept)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<request_sock_queue>())).synflood_warned as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(request_sock_queue),
                "::",
                stringify!(synflood_warned)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<request_sock_queue>())).qlen as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(request_sock_queue),
                "::",
                stringify!(qlen)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<request_sock_queue>())).young as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(request_sock_queue),
                "::",
                stringify!(young)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<request_sock_queue>())).rskq_accept_head as *const _
                    as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(request_sock_queue),
                "::",
                stringify!(rskq_accept_head)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<request_sock_queue>())).rskq_accept_tail as *const _
                    as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(request_sock_queue),
                "::",
                stringify!(rskq_accept_tail)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<request_sock_queue>())).fastopenq as *const _ as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(request_sock_queue),
                "::",
                stringify!(fastopenq)
            )
        );
    }
    #[doc = " struct ip_options - IP Options"]
    #[doc = ""]
    #[doc = " @faddr - Saved first hop address"]
    #[doc = " @nexthop - Saved nexthop address in LSRR and SSRR"]
    #[doc = " @is_strictroute - Strict source route"]
    #[doc = " @srr_is_hit - Packet destination addr was our one"]
    #[doc = " @is_changed - IP checksum more not valid"]
    #[doc = " @rr_needaddr - Need to record addr of outgoing dev"]
    #[doc = " @ts_needtime - Need to record timestamp"]
    #[doc = " @ts_needaddr - Need to record addr of outgoing dev"]
    #[repr(C)]
    #[derive(Debug)]
    pub struct ip_options {
        pub faddr: __be32,
        pub nexthop: __be32,
        pub optlen: ::cty::c_uchar,
        pub srr: ::cty::c_uchar,
        pub rr: ::cty::c_uchar,
        pub ts: ::cty::c_uchar,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
        pub router_alert: ::cty::c_uchar,
        pub cipso: ::cty::c_uchar,
        pub __pad2: ::cty::c_uchar,
        pub __data: __IncompleteArrayField<::cty::c_uchar>,
    }
    #[test]
    fn bindgen_test_layout_ip_options() {
        assert_eq!(
            ::core::mem::size_of::<ip_options>(),
            16usize,
            concat!("Size of: ", stringify!(ip_options))
        );
        assert_eq!(
            ::core::mem::align_of::<ip_options>(),
            4usize,
            concat!("Alignment of ", stringify!(ip_options))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ip_options>())).faddr as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ip_options),
                "::",
                stringify!(faddr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ip_options>())).nexthop as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(ip_options),
                "::",
                stringify!(nexthop)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ip_options>())).optlen as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ip_options),
                "::",
                stringify!(optlen)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ip_options>())).srr as *const _ as usize },
            9usize,
            concat!(
                "Offset of field: ",
                stringify!(ip_options),
                "::",
                stringify!(srr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ip_options>())).rr as *const _ as usize },
            10usize,
            concat!(
                "Offset of field: ",
                stringify!(ip_options),
                "::",
                stringify!(rr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ip_options>())).ts as *const _ as usize },
            11usize,
            concat!(
                "Offset of field: ",
                stringify!(ip_options),
                "::",
                stringify!(ts)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ip_options>())).router_alert as *const _ as usize },
            13usize,
            concat!(
                "Offset of field: ",
                stringify!(ip_options),
                "::",
                stringify!(router_alert)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ip_options>())).cipso as *const _ as usize },
            14usize,
            concat!(
                "Offset of field: ",
                stringify!(ip_options),
                "::",
                stringify!(cipso)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ip_options>())).__pad2 as *const _ as usize },
            15usize,
            concat!(
                "Offset of field: ",
                stringify!(ip_options),
                "::",
                stringify!(__pad2)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ip_options>())).__data as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ip_options),
                "::",
                stringify!(__data)
            )
        );
    }
    impl ip_options {
        #[inline]
        pub fn is_strictroute(&self) -> ::cty::c_uchar {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_is_strictroute(&mut self, val: ::cty::c_uchar) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn srr_is_hit(&self) -> ::cty::c_uchar {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_srr_is_hit(&mut self, val: ::cty::c_uchar) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(1usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn is_changed(&self) -> ::cty::c_uchar {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_is_changed(&mut self, val: ::cty::c_uchar) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(2usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn rr_needaddr(&self) -> ::cty::c_uchar {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_rr_needaddr(&mut self, val: ::cty::c_uchar) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(3usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn ts_needtime(&self) -> ::cty::c_uchar {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_ts_needtime(&mut self, val: ::cty::c_uchar) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(4usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn ts_needaddr(&self) -> ::cty::c_uchar {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_ts_needaddr(&mut self, val: ::cty::c_uchar) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(5usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            is_strictroute: ::cty::c_uchar,
            srr_is_hit: ::cty::c_uchar,
            is_changed: ::cty::c_uchar,
            rr_needaddr: ::cty::c_uchar,
            ts_needtime: ::cty::c_uchar,
            ts_needaddr: ::cty::c_uchar,
        ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 1u8, {
                let is_strictroute: u8 = unsafe { ::core::mem::transmute(is_strictroute) };
                is_strictroute as u64
            });
            __bindgen_bitfield_unit.set(1usize, 1u8, {
                let srr_is_hit: u8 = unsafe { ::core::mem::transmute(srr_is_hit) };
                srr_is_hit as u64
            });
            __bindgen_bitfield_unit.set(2usize, 1u8, {
                let is_changed: u8 = unsafe { ::core::mem::transmute(is_changed) };
                is_changed as u64
            });
            __bindgen_bitfield_unit.set(3usize, 1u8, {
                let rr_needaddr: u8 = unsafe { ::core::mem::transmute(rr_needaddr) };
                rr_needaddr as u64
            });
            __bindgen_bitfield_unit.set(4usize, 1u8, {
                let ts_needtime: u8 = unsafe { ::core::mem::transmute(ts_needtime) };
                ts_needtime as u64
            });
            __bindgen_bitfield_unit.set(5usize, 1u8, {
                let ts_needaddr: u8 = unsafe { ::core::mem::transmute(ts_needaddr) };
                ts_needaddr as u64
            });
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct ip_options_rcu {
        pub rcu: callback_head,
        pub opt: ip_options,
    }
    #[test]
    fn bindgen_test_layout_ip_options_rcu() {
        assert_eq!(
            ::core::mem::size_of::<ip_options_rcu>(),
            32usize,
            concat!("Size of: ", stringify!(ip_options_rcu))
        );
        assert_eq!(
            ::core::mem::align_of::<ip_options_rcu>(),
            8usize,
            concat!("Alignment of ", stringify!(ip_options_rcu))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ip_options_rcu>())).rcu as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ip_options_rcu),
                "::",
                stringify!(rcu)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ip_options_rcu>())).opt as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ip_options_rcu),
                "::",
                stringify!(opt)
            )
        );
    }
    #[repr(C)]
    pub struct inet_request_sock {
        pub req: request_sock,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
        pub ir_mark: _cargo_bpf_u32,
        pub __bindgen_anon_1: inet_request_sock__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union inet_request_sock__bindgen_ty_1 {
        pub ireq_opt: *mut ip_options_rcu,
        pub __bindgen_anon_1: inet_request_sock__bindgen_ty_1__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct inet_request_sock__bindgen_ty_1__bindgen_ty_1 {
        pub ipv6_opt: *mut ipv6_txoptions,
        pub pktopts: *mut sk_buff,
    }
    #[test]
    fn bindgen_test_layout_inet_request_sock__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<inet_request_sock__bindgen_ty_1__bindgen_ty_1>(),
            16usize,
            concat!(
                "Size of: ",
                stringify!(inet_request_sock__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<inet_request_sock__bindgen_ty_1__bindgen_ty_1>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(inet_request_sock__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_request_sock__bindgen_ty_1__bindgen_ty_1>())).ipv6_opt
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_request_sock__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(ipv6_opt)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_request_sock__bindgen_ty_1__bindgen_ty_1>())).pktopts
                    as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_request_sock__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(pktopts)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_inet_request_sock__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<inet_request_sock__bindgen_ty_1>(),
            16usize,
            concat!("Size of: ", stringify!(inet_request_sock__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<inet_request_sock__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(inet_request_sock__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_request_sock__bindgen_ty_1>())).ireq_opt as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_request_sock__bindgen_ty_1),
                "::",
                stringify!(ireq_opt)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_inet_request_sock() {
        assert_eq!(
            ::core::mem::size_of::<inet_request_sock>(),
            256usize,
            concat!("Size of: ", stringify!(inet_request_sock))
        );
        assert_eq!(
            ::core::mem::align_of::<inet_request_sock>(),
            8usize,
            concat!("Alignment of ", stringify!(inet_request_sock))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_request_sock>())).req as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_request_sock),
                "::",
                stringify!(req)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_request_sock>())).ir_mark as *const _ as usize },
            236usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_request_sock),
                "::",
                stringify!(ir_mark)
            )
        );
    }
    impl inet_request_sock {
        #[inline]
        pub fn snd_wscale(&self) -> _cargo_bpf_u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
        }
        #[inline]
        pub fn set_snd_wscale(&mut self, val: _cargo_bpf_u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 4u8, val as u64)
            }
        }
        #[inline]
        pub fn rcv_wscale(&self) -> _cargo_bpf_u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u16) }
        }
        #[inline]
        pub fn set_rcv_wscale(&mut self, val: _cargo_bpf_u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(4usize, 4u8, val as u64)
            }
        }
        #[inline]
        pub fn tstamp_ok(&self) -> _cargo_bpf_u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_tstamp_ok(&mut self, val: _cargo_bpf_u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(8usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn sack_ok(&self) -> _cargo_bpf_u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_sack_ok(&mut self, val: _cargo_bpf_u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(9usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn wscale_ok(&self) -> _cargo_bpf_u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_wscale_ok(&mut self, val: _cargo_bpf_u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(10usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn ecn_ok(&self) -> _cargo_bpf_u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_ecn_ok(&mut self, val: _cargo_bpf_u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(11usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn acked(&self) -> _cargo_bpf_u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_acked(&mut self, val: _cargo_bpf_u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(12usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn no_srccheck(&self) -> _cargo_bpf_u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_no_srccheck(&mut self, val: _cargo_bpf_u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(13usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn smc_ok(&self) -> _cargo_bpf_u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_smc_ok(&mut self, val: _cargo_bpf_u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(14usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            snd_wscale: _cargo_bpf_u16,
            rcv_wscale: _cargo_bpf_u16,
            tstamp_ok: _cargo_bpf_u16,
            sack_ok: _cargo_bpf_u16,
            wscale_ok: _cargo_bpf_u16,
            ecn_ok: _cargo_bpf_u16,
            acked: _cargo_bpf_u16,
            no_srccheck: _cargo_bpf_u16,
            smc_ok: _cargo_bpf_u16,
        ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 4u8, {
                let snd_wscale: u16 = unsafe { ::core::mem::transmute(snd_wscale) };
                snd_wscale as u64
            });
            __bindgen_bitfield_unit.set(4usize, 4u8, {
                let rcv_wscale: u16 = unsafe { ::core::mem::transmute(rcv_wscale) };
                rcv_wscale as u64
            });
            __bindgen_bitfield_unit.set(8usize, 1u8, {
                let tstamp_ok: u16 = unsafe { ::core::mem::transmute(tstamp_ok) };
                tstamp_ok as u64
            });
            __bindgen_bitfield_unit.set(9usize, 1u8, {
                let sack_ok: u16 = unsafe { ::core::mem::transmute(sack_ok) };
                sack_ok as u64
            });
            __bindgen_bitfield_unit.set(10usize, 1u8, {
                let wscale_ok: u16 = unsafe { ::core::mem::transmute(wscale_ok) };
                wscale_ok as u64
            });
            __bindgen_bitfield_unit.set(11usize, 1u8, {
                let ecn_ok: u16 = unsafe { ::core::mem::transmute(ecn_ok) };
                ecn_ok as u64
            });
            __bindgen_bitfield_unit.set(12usize, 1u8, {
                let acked: u16 = unsafe { ::core::mem::transmute(acked) };
                acked as u64
            });
            __bindgen_bitfield_unit.set(13usize, 1u8, {
                let no_srccheck: u16 = unsafe { ::core::mem::transmute(no_srccheck) };
                no_srccheck as u64
            });
            __bindgen_bitfield_unit.set(14usize, 1u8, {
                let smc_ok: u16 = unsafe { ::core::mem::transmute(smc_ok) };
                smc_ok as u64
            });
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct inet_cork {
        pub flags: ::cty::c_uint,
        pub addr: __be32,
        pub opt: *mut ip_options,
        pub fragsize: ::cty::c_uint,
        pub length: ::cty::c_int,
        pub dst: *mut dst_entry,
        pub tx_flags: _cargo_bpf_u8,
        pub ttl: __u8,
        pub tos: __s16,
        pub priority: ::cty::c_char,
        pub gso_size: __u16,
        pub transmit_time: _cargo_bpf_u64,
        pub mark: _cargo_bpf_u32,
    }
    #[test]
    fn bindgen_test_layout_inet_cork() {
        assert_eq!(
            ::core::mem::size_of::<inet_cork>(),
            56usize,
            concat!("Size of: ", stringify!(inet_cork))
        );
        assert_eq!(
            ::core::mem::align_of::<inet_cork>(),
            8usize,
            concat!("Alignment of ", stringify!(inet_cork))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_cork>())).flags as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_cork),
                "::",
                stringify!(flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_cork>())).addr as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_cork),
                "::",
                stringify!(addr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_cork>())).opt as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_cork),
                "::",
                stringify!(opt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_cork>())).fragsize as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_cork),
                "::",
                stringify!(fragsize)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_cork>())).length as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_cork),
                "::",
                stringify!(length)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_cork>())).dst as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_cork),
                "::",
                stringify!(dst)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_cork>())).tx_flags as *const _ as usize },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_cork),
                "::",
                stringify!(tx_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_cork>())).ttl as *const _ as usize },
            33usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_cork),
                "::",
                stringify!(ttl)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_cork>())).tos as *const _ as usize },
            34usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_cork),
                "::",
                stringify!(tos)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_cork>())).priority as *const _ as usize },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_cork),
                "::",
                stringify!(priority)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_cork>())).gso_size as *const _ as usize },
            38usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_cork),
                "::",
                stringify!(gso_size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_cork>())).transmit_time as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_cork),
                "::",
                stringify!(transmit_time)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_cork>())).mark as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_cork),
                "::",
                stringify!(mark)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct inet_cork_full {
        pub base: inet_cork,
        pub fl: flowi,
    }
    #[test]
    fn bindgen_test_layout_inet_cork_full() {
        assert_eq!(
            ::core::mem::size_of::<inet_cork_full>(),
            152usize,
            concat!("Size of: ", stringify!(inet_cork_full))
        );
        assert_eq!(
            ::core::mem::align_of::<inet_cork_full>(),
            8usize,
            concat!("Alignment of ", stringify!(inet_cork_full))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_cork_full>())).base as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_cork_full),
                "::",
                stringify!(base)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_cork_full>())).fl as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_cork_full),
                "::",
                stringify!(fl)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ip_mc_socklist {
        _unused: [u8; 0],
    }
    #[doc = " struct inet_sock - representation of INET sockets"]
    #[doc = ""]
    #[doc = " @sk - ancestor class"]
    #[doc = " @pinet6 - pointer to IPv6 control block"]
    #[doc = " @inet_daddr - Foreign IPv4 addr"]
    #[doc = " @inet_rcv_saddr - Bound local IPv4 addr"]
    #[doc = " @inet_dport - Destination port"]
    #[doc = " @inet_num - Local port"]
    #[doc = " @inet_saddr - Sending source"]
    #[doc = " @uc_ttl - Unicast TTL"]
    #[doc = " @inet_sport - Source port"]
    #[doc = " @inet_id - ID counter for DF pkts"]
    #[doc = " @tos - TOS"]
    #[doc = " @mc_ttl - Multicasting TTL"]
    #[doc = " @is_icsk - is this an inet_connection_sock?"]
    #[doc = " @uc_index - Unicast outgoing device index"]
    #[doc = " @mc_index - Multicast device index"]
    #[doc = " @mc_list - Group array"]
    #[doc = " @cork - info to build ip hdr on each ip frag while socket is corked"]
    #[repr(C)]
    pub struct inet_sock {
        pub sk: sock,
        pub pinet6: *mut ipv6_pinfo,
        pub inet_saddr: __be32,
        pub uc_ttl: __s16,
        pub cmsg_flags: __u16,
        pub inet_opt: *mut ip_options_rcu,
        pub inet_id: atomic_t,
        pub inet_sport: __be16,
        pub tos: __u8,
        pub min_ttl: __u8,
        pub mc_ttl: __u8,
        pub pmtudisc: __u8,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
        pub rcv_tos: __u8,
        pub convert_csum: __u8,
        pub uc_index: ::cty::c_int,
        pub mc_index: ::cty::c_int,
        pub mc_addr: __be32,
        pub mc_list: *mut ip_mc_socklist,
        pub cork: inet_cork_full,
        pub local_port_range: inet_sock__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct inet_sock__bindgen_ty_1 {
        pub lo: __u16,
        pub hi: __u16,
    }
    #[test]
    fn bindgen_test_layout_inet_sock__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<inet_sock__bindgen_ty_1>(),
            4usize,
            concat!("Size of: ", stringify!(inet_sock__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<inet_sock__bindgen_ty_1>(),
            2usize,
            concat!("Alignment of ", stringify!(inet_sock__bindgen_ty_1))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_sock__bindgen_ty_1>())).lo as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_sock__bindgen_ty_1),
                "::",
                stringify!(lo)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_sock__bindgen_ty_1>())).hi as *const _ as usize },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_sock__bindgen_ty_1),
                "::",
                stringify!(hi)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_inet_sock() {
        assert_eq!(
            ::core::mem::size_of::<inet_sock>(),
            1000usize,
            concat!("Size of: ", stringify!(inet_sock))
        );
        assert_eq!(
            ::core::mem::align_of::<inet_sock>(),
            8usize,
            concat!("Alignment of ", stringify!(inet_sock))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_sock>())).sk as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_sock),
                "::",
                stringify!(sk)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_sock>())).pinet6 as *const _ as usize },
            776usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_sock),
                "::",
                stringify!(pinet6)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_sock>())).inet_saddr as *const _ as usize },
            784usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_sock),
                "::",
                stringify!(inet_saddr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_sock>())).uc_ttl as *const _ as usize },
            788usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_sock),
                "::",
                stringify!(uc_ttl)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_sock>())).cmsg_flags as *const _ as usize },
            790usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_sock),
                "::",
                stringify!(cmsg_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_sock>())).inet_opt as *const _ as usize },
            792usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_sock),
                "::",
                stringify!(inet_opt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_sock>())).inet_id as *const _ as usize },
            800usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_sock),
                "::",
                stringify!(inet_id)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_sock>())).inet_sport as *const _ as usize },
            804usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_sock),
                "::",
                stringify!(inet_sport)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_sock>())).tos as *const _ as usize },
            806usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_sock),
                "::",
                stringify!(tos)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_sock>())).min_ttl as *const _ as usize },
            807usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_sock),
                "::",
                stringify!(min_ttl)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_sock>())).mc_ttl as *const _ as usize },
            808usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_sock),
                "::",
                stringify!(mc_ttl)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_sock>())).pmtudisc as *const _ as usize },
            809usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_sock),
                "::",
                stringify!(pmtudisc)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_sock>())).rcv_tos as *const _ as usize },
            812usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_sock),
                "::",
                stringify!(rcv_tos)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_sock>())).convert_csum as *const _ as usize },
            813usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_sock),
                "::",
                stringify!(convert_csum)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_sock>())).uc_index as *const _ as usize },
            816usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_sock),
                "::",
                stringify!(uc_index)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_sock>())).mc_index as *const _ as usize },
            820usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_sock),
                "::",
                stringify!(mc_index)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_sock>())).mc_addr as *const _ as usize },
            824usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_sock),
                "::",
                stringify!(mc_addr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_sock>())).mc_list as *const _ as usize },
            832usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_sock),
                "::",
                stringify!(mc_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_sock>())).cork as *const _ as usize },
            840usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_sock),
                "::",
                stringify!(cork)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_sock>())).local_port_range as *const _ as usize },
            992usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_sock),
                "::",
                stringify!(local_port_range)
            )
        );
    }
    impl inet_sock {
        #[inline]
        pub fn recverr(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_recverr(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn is_icsk(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_is_icsk(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(1usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn freebind(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_freebind(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(2usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn hdrincl(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_hdrincl(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(3usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn mc_loop(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_mc_loop(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(4usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn transparent(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_transparent(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(5usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn mc_all(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_mc_all(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(6usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn nodefrag(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_nodefrag(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(7usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn bind_address_no_port(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_bind_address_no_port(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(8usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn recverr_rfc4884(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_recverr_rfc4884(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(9usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn defer_connect(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_defer_connect(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(10usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            recverr: __u8,
            is_icsk: __u8,
            freebind: __u8,
            hdrincl: __u8,
            mc_loop: __u8,
            transparent: __u8,
            mc_all: __u8,
            nodefrag: __u8,
            bind_address_no_port: __u8,
            recverr_rfc4884: __u8,
            defer_connect: __u8,
        ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 1u8, {
                let recverr: u8 = unsafe { ::core::mem::transmute(recverr) };
                recverr as u64
            });
            __bindgen_bitfield_unit.set(1usize, 1u8, {
                let is_icsk: u8 = unsafe { ::core::mem::transmute(is_icsk) };
                is_icsk as u64
            });
            __bindgen_bitfield_unit.set(2usize, 1u8, {
                let freebind: u8 = unsafe { ::core::mem::transmute(freebind) };
                freebind as u64
            });
            __bindgen_bitfield_unit.set(3usize, 1u8, {
                let hdrincl: u8 = unsafe { ::core::mem::transmute(hdrincl) };
                hdrincl as u64
            });
            __bindgen_bitfield_unit.set(4usize, 1u8, {
                let mc_loop: u8 = unsafe { ::core::mem::transmute(mc_loop) };
                mc_loop as u64
            });
            __bindgen_bitfield_unit.set(5usize, 1u8, {
                let transparent: u8 = unsafe { ::core::mem::transmute(transparent) };
                transparent as u64
            });
            __bindgen_bitfield_unit.set(6usize, 1u8, {
                let mc_all: u8 = unsafe { ::core::mem::transmute(mc_all) };
                mc_all as u64
            });
            __bindgen_bitfield_unit.set(7usize, 1u8, {
                let nodefrag: u8 = unsafe { ::core::mem::transmute(nodefrag) };
                nodefrag as u64
            });
            __bindgen_bitfield_unit.set(8usize, 1u8, {
                let bind_address_no_port: u8 =
                    unsafe { ::core::mem::transmute(bind_address_no_port) };
                bind_address_no_port as u64
            });
            __bindgen_bitfield_unit.set(9usize, 1u8, {
                let recverr_rfc4884: u8 = unsafe { ::core::mem::transmute(recverr_rfc4884) };
                recverr_rfc4884 as u64
            });
            __bindgen_bitfield_unit.set(10usize, 1u8, {
                let defer_connect: u8 = unsafe { ::core::mem::transmute(defer_connect) };
                defer_connect as u64
            });
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct in6_pktinfo {
        pub ipi6_addr: in6_addr,
        pub ipi6_ifindex: ::cty::c_int,
    }
    #[test]
    fn bindgen_test_layout_in6_pktinfo() {
        assert_eq!(
            ::core::mem::size_of::<in6_pktinfo>(),
            20usize,
            concat!("Size of: ", stringify!(in6_pktinfo))
        );
        assert_eq!(
            ::core::mem::align_of::<in6_pktinfo>(),
            4usize,
            concat!("Alignment of ", stringify!(in6_pktinfo))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<in6_pktinfo>())).ipi6_addr as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(in6_pktinfo),
                "::",
                stringify!(ipi6_addr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<in6_pktinfo>())).ipi6_ifindex as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(in6_pktinfo),
                "::",
                stringify!(ipi6_ifindex)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct ipv6hdr {
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
        pub flow_lbl: [__u8; 3usize],
        pub payload_len: __be16,
        pub nexthdr: __u8,
        pub hop_limit: __u8,
        pub __bindgen_anon_1: ipv6hdr__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union ipv6hdr__bindgen_ty_1 {
        pub __bindgen_anon_1: ipv6hdr__bindgen_ty_1__bindgen_ty_1,
        pub addrs: ipv6hdr__bindgen_ty_1__bindgen_ty_2,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct ipv6hdr__bindgen_ty_1__bindgen_ty_1 {
        pub saddr: in6_addr,
        pub daddr: in6_addr,
    }
    #[test]
    fn bindgen_test_layout_ipv6hdr__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<ipv6hdr__bindgen_ty_1__bindgen_ty_1>(),
            32usize,
            concat!("Size of: ", stringify!(ipv6hdr__bindgen_ty_1__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<ipv6hdr__bindgen_ty_1__bindgen_ty_1>(),
            4usize,
            concat!(
                "Alignment of ",
                stringify!(ipv6hdr__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ipv6hdr__bindgen_ty_1__bindgen_ty_1>())).saddr as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6hdr__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(saddr)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ipv6hdr__bindgen_ty_1__bindgen_ty_1>())).daddr as *const _
                    as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6hdr__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(daddr)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct ipv6hdr__bindgen_ty_1__bindgen_ty_2 {
        pub saddr: in6_addr,
        pub daddr: in6_addr,
    }
    #[test]
    fn bindgen_test_layout_ipv6hdr__bindgen_ty_1__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<ipv6hdr__bindgen_ty_1__bindgen_ty_2>(),
            32usize,
            concat!("Size of: ", stringify!(ipv6hdr__bindgen_ty_1__bindgen_ty_2))
        );
        assert_eq!(
            ::core::mem::align_of::<ipv6hdr__bindgen_ty_1__bindgen_ty_2>(),
            4usize,
            concat!(
                "Alignment of ",
                stringify!(ipv6hdr__bindgen_ty_1__bindgen_ty_2)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ipv6hdr__bindgen_ty_1__bindgen_ty_2>())).saddr as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6hdr__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(saddr)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ipv6hdr__bindgen_ty_1__bindgen_ty_2>())).daddr as *const _
                    as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6hdr__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(daddr)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_ipv6hdr__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<ipv6hdr__bindgen_ty_1>(),
            32usize,
            concat!("Size of: ", stringify!(ipv6hdr__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<ipv6hdr__bindgen_ty_1>(),
            4usize,
            concat!("Alignment of ", stringify!(ipv6hdr__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ipv6hdr__bindgen_ty_1>())).addrs as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6hdr__bindgen_ty_1),
                "::",
                stringify!(addrs)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_ipv6hdr() {
        assert_eq!(
            ::core::mem::size_of::<ipv6hdr>(),
            40usize,
            concat!("Size of: ", stringify!(ipv6hdr))
        );
        assert_eq!(
            ::core::mem::align_of::<ipv6hdr>(),
            4usize,
            concat!("Alignment of ", stringify!(ipv6hdr))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ipv6hdr>())).flow_lbl as *const _ as usize },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6hdr),
                "::",
                stringify!(flow_lbl)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ipv6hdr>())).payload_len as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6hdr),
                "::",
                stringify!(payload_len)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ipv6hdr>())).nexthdr as *const _ as usize },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6hdr),
                "::",
                stringify!(nexthdr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ipv6hdr>())).hop_limit as *const _ as usize },
            7usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6hdr),
                "::",
                stringify!(hop_limit)
            )
        );
    }
    impl ipv6hdr {
        #[inline]
        pub fn priority(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
        }
        #[inline]
        pub fn set_priority(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 4u8, val as u64)
            }
        }
        #[inline]
        pub fn version(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
        }
        #[inline]
        pub fn set_version(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(4usize, 4u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            priority: __u8,
            version: __u8,
        ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 4u8, {
                let priority: u8 = unsafe { ::core::mem::transmute(priority) };
                priority as u64
            });
            __bindgen_bitfield_unit.set(4usize, 4u8, {
                let version: u8 = unsafe { ::core::mem::transmute(version) };
                version as u64
            });
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct ipv6_devconf {
        pub forwarding: __s32,
        pub hop_limit: __s32,
        pub mtu6: __s32,
        pub accept_ra: __s32,
        pub accept_redirects: __s32,
        pub autoconf: __s32,
        pub dad_transmits: __s32,
        pub rtr_solicits: __s32,
        pub rtr_solicit_interval: __s32,
        pub rtr_solicit_max_interval: __s32,
        pub rtr_solicit_delay: __s32,
        pub force_mld_version: __s32,
        pub mldv1_unsolicited_report_interval: __s32,
        pub mldv2_unsolicited_report_interval: __s32,
        pub use_tempaddr: __s32,
        pub temp_valid_lft: __s32,
        pub temp_prefered_lft: __s32,
        pub regen_max_retry: __s32,
        pub max_desync_factor: __s32,
        pub max_addresses: __s32,
        pub accept_ra_defrtr: __s32,
        pub ra_defrtr_metric: __u32,
        pub accept_ra_min_hop_limit: __s32,
        pub accept_ra_min_lft: __s32,
        pub accept_ra_pinfo: __s32,
        pub ignore_routes_with_linkdown: __s32,
        pub accept_ra_rtr_pref: __s32,
        pub rtr_probe_interval: __s32,
        pub accept_ra_rt_info_min_plen: __s32,
        pub accept_ra_rt_info_max_plen: __s32,
        pub proxy_ndp: __s32,
        pub accept_source_route: __s32,
        pub accept_ra_from_local: __s32,
        pub mc_forwarding: atomic_t,
        pub disable_ipv6: __s32,
        pub drop_unicast_in_l2_multicast: __s32,
        pub accept_dad: __s32,
        pub force_tllao: __s32,
        pub ndisc_notify: __s32,
        pub suppress_frag_ndisc: __s32,
        pub accept_ra_mtu: __s32,
        pub drop_unsolicited_na: __s32,
        pub accept_untracked_na: __s32,
        pub stable_secret: ipv6_devconf_ipv6_stable_secret,
        pub use_oif_addrs_only: __s32,
        pub keep_addr_on_down: __s32,
        pub seg6_enabled: __s32,
        pub seg6_require_hmac: __s32,
        pub enhanced_dad: __u32,
        pub addr_gen_mode: __u32,
        pub disable_policy: __s32,
        pub ndisc_tclass: __s32,
        pub rpl_seg_enabled: __s32,
        pub ioam6_id: __u32,
        pub ioam6_id_wide: __u32,
        pub ioam6_enabled: __u8,
        pub ndisc_evict_nocarrier: __u8,
        pub sysctl_header: *mut ctl_table_header,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct ipv6_devconf_ipv6_stable_secret {
        pub initialized: bool_,
        pub secret: in6_addr,
    }
    #[test]
    fn bindgen_test_layout_ipv6_devconf_ipv6_stable_secret() {
        assert_eq!(
            ::core::mem::size_of::<ipv6_devconf_ipv6_stable_secret>(),
            20usize,
            concat!("Size of: ", stringify!(ipv6_devconf_ipv6_stable_secret))
        );
        assert_eq!(
            ::core::mem::align_of::<ipv6_devconf_ipv6_stable_secret>(),
            4usize,
            concat!("Alignment of ", stringify!(ipv6_devconf_ipv6_stable_secret))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ipv6_devconf_ipv6_stable_secret>())).initialized as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf_ipv6_stable_secret),
                "::",
                stringify!(initialized)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ipv6_devconf_ipv6_stable_secret>())).secret as *const _
                    as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf_ipv6_stable_secret),
                "::",
                stringify!(secret)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_ipv6_devconf() {
        assert_eq!(
            ::core::mem::size_of::<ipv6_devconf>(),
            248usize,
            concat!("Size of: ", stringify!(ipv6_devconf))
        );
        assert_eq!(
            ::core::mem::align_of::<ipv6_devconf>(),
            8usize,
            concat!("Alignment of ", stringify!(ipv6_devconf))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ipv6_devconf>())).forwarding as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(forwarding)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ipv6_devconf>())).hop_limit as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(hop_limit)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ipv6_devconf>())).mtu6 as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(mtu6)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ipv6_devconf>())).accept_ra as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(accept_ra)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ipv6_devconf>())).accept_redirects as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(accept_redirects)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ipv6_devconf>())).autoconf as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(autoconf)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ipv6_devconf>())).dad_transmits as *const _ as usize },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(dad_transmits)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ipv6_devconf>())).rtr_solicits as *const _ as usize },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(rtr_solicits)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ipv6_devconf>())).rtr_solicit_interval as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(rtr_solicit_interval)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ipv6_devconf>())).rtr_solicit_max_interval as *const _
                    as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(rtr_solicit_max_interval)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ipv6_devconf>())).rtr_solicit_delay as *const _ as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(rtr_solicit_delay)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ipv6_devconf>())).force_mld_version as *const _ as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(force_mld_version)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ipv6_devconf>())).mldv1_unsolicited_report_interval
                    as *const _ as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(mldv1_unsolicited_report_interval)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ipv6_devconf>())).mldv2_unsolicited_report_interval
                    as *const _ as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(mldv2_unsolicited_report_interval)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ipv6_devconf>())).use_tempaddr as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(use_tempaddr)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ipv6_devconf>())).temp_valid_lft as *const _ as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(temp_valid_lft)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ipv6_devconf>())).temp_prefered_lft as *const _ as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(temp_prefered_lft)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ipv6_devconf>())).regen_max_retry as *const _ as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(regen_max_retry)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ipv6_devconf>())).max_desync_factor as *const _ as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(max_desync_factor)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ipv6_devconf>())).max_addresses as *const _ as usize },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(max_addresses)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ipv6_devconf>())).accept_ra_defrtr as *const _ as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(accept_ra_defrtr)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ipv6_devconf>())).ra_defrtr_metric as *const _ as usize
            },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(ra_defrtr_metric)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ipv6_devconf>())).accept_ra_min_hop_limit as *const _
                    as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(accept_ra_min_hop_limit)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ipv6_devconf>())).accept_ra_min_lft as *const _ as usize
            },
            92usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(accept_ra_min_lft)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ipv6_devconf>())).accept_ra_pinfo as *const _ as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(accept_ra_pinfo)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ipv6_devconf>())).ignore_routes_with_linkdown as *const _
                    as usize
            },
            100usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(ignore_routes_with_linkdown)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ipv6_devconf>())).accept_ra_rtr_pref as *const _ as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(accept_ra_rtr_pref)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ipv6_devconf>())).rtr_probe_interval as *const _ as usize
            },
            108usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(rtr_probe_interval)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ipv6_devconf>())).accept_ra_rt_info_min_plen as *const _
                    as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(accept_ra_rt_info_min_plen)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ipv6_devconf>())).accept_ra_rt_info_max_plen as *const _
                    as usize
            },
            116usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(accept_ra_rt_info_max_plen)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ipv6_devconf>())).proxy_ndp as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(proxy_ndp)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ipv6_devconf>())).accept_source_route as *const _ as usize
            },
            124usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(accept_source_route)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ipv6_devconf>())).accept_ra_from_local as *const _ as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(accept_ra_from_local)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ipv6_devconf>())).mc_forwarding as *const _ as usize },
            132usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(mc_forwarding)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ipv6_devconf>())).disable_ipv6 as *const _ as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(disable_ipv6)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ipv6_devconf>())).drop_unicast_in_l2_multicast as *const _
                    as usize
            },
            140usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(drop_unicast_in_l2_multicast)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ipv6_devconf>())).accept_dad as *const _ as usize },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(accept_dad)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ipv6_devconf>())).force_tllao as *const _ as usize },
            148usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(force_tllao)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ipv6_devconf>())).ndisc_notify as *const _ as usize },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(ndisc_notify)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ipv6_devconf>())).suppress_frag_ndisc as *const _ as usize
            },
            156usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(suppress_frag_ndisc)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ipv6_devconf>())).accept_ra_mtu as *const _ as usize },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(accept_ra_mtu)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ipv6_devconf>())).drop_unsolicited_na as *const _ as usize
            },
            164usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(drop_unsolicited_na)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ipv6_devconf>())).accept_untracked_na as *const _ as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(accept_untracked_na)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ipv6_devconf>())).stable_secret as *const _ as usize },
            172usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(stable_secret)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ipv6_devconf>())).use_oif_addrs_only as *const _ as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(use_oif_addrs_only)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ipv6_devconf>())).keep_addr_on_down as *const _ as usize
            },
            196usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(keep_addr_on_down)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ipv6_devconf>())).seg6_enabled as *const _ as usize },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(seg6_enabled)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ipv6_devconf>())).seg6_require_hmac as *const _ as usize
            },
            204usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(seg6_require_hmac)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ipv6_devconf>())).enhanced_dad as *const _ as usize },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(enhanced_dad)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ipv6_devconf>())).addr_gen_mode as *const _ as usize },
            212usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(addr_gen_mode)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ipv6_devconf>())).disable_policy as *const _ as usize
            },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(disable_policy)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ipv6_devconf>())).ndisc_tclass as *const _ as usize },
            220usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(ndisc_tclass)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ipv6_devconf>())).rpl_seg_enabled as *const _ as usize
            },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(rpl_seg_enabled)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ipv6_devconf>())).ioam6_id as *const _ as usize },
            228usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(ioam6_id)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ipv6_devconf>())).ioam6_id_wide as *const _ as usize },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(ioam6_id_wide)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ipv6_devconf>())).ioam6_enabled as *const _ as usize },
            236usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(ioam6_enabled)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ipv6_devconf>())).ndisc_evict_nocarrier as *const _ as usize
            },
            237usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(ndisc_evict_nocarrier)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ipv6_devconf>())).sysctl_header as *const _ as usize },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_devconf),
                "::",
                stringify!(sysctl_header)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct minmax_sample {
        pub t: _cargo_bpf_u32,
        pub v: _cargo_bpf_u32,
    }
    #[test]
    fn bindgen_test_layout_minmax_sample() {
        assert_eq!(
            ::core::mem::size_of::<minmax_sample>(),
            8usize,
            concat!("Size of: ", stringify!(minmax_sample))
        );
        assert_eq!(
            ::core::mem::align_of::<minmax_sample>(),
            4usize,
            concat!("Alignment of ", stringify!(minmax_sample))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<minmax_sample>())).t as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(minmax_sample),
                "::",
                stringify!(t)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<minmax_sample>())).v as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(minmax_sample),
                "::",
                stringify!(v)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct minmax {
        pub s: [minmax_sample; 3usize],
    }
    #[test]
    fn bindgen_test_layout_minmax() {
        assert_eq!(
            ::core::mem::size_of::<minmax>(),
            24usize,
            concat!("Size of: ", stringify!(minmax))
        );
        assert_eq!(
            ::core::mem::align_of::<minmax>(),
            4usize,
            concat!("Alignment of ", stringify!(minmax))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<minmax>())).s as *const _ as usize },
            0usize,
            concat!("Offset of field: ", stringify!(minmax), "::", stringify!(s))
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct inet_bind_bucket {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct inet_bind2_bucket {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct tcp_congestion_ops {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct inet_connection_sock_af_ops {
        pub queue_xmit: ::core::option::Option<
            unsafe extern "C" fn(sk: *mut sock, skb: *mut sk_buff, fl: *mut flowi) -> ::cty::c_int,
        >,
        pub send_check:
            ::core::option::Option<unsafe extern "C" fn(sk: *mut sock, skb: *mut sk_buff)>,
        pub rebuild_header:
            ::core::option::Option<unsafe extern "C" fn(sk: *mut sock) -> ::cty::c_int>,
        pub sk_rx_dst_set:
            ::core::option::Option<unsafe extern "C" fn(sk: *mut sock, skb: *const sk_buff)>,
        pub conn_request: ::core::option::Option<
            unsafe extern "C" fn(sk: *mut sock, skb: *mut sk_buff) -> ::cty::c_int,
        >,
        pub syn_recv_sock: ::core::option::Option<
            unsafe extern "C" fn(
                sk: *const sock,
                skb: *mut sk_buff,
                req: *mut request_sock,
                dst: *mut dst_entry,
                req_unhash: *mut request_sock,
                own_req: *mut bool_,
            ) -> *mut sock,
        >,
        pub net_header_len: _cargo_bpf_u16,
        pub net_frag_header_len: _cargo_bpf_u16,
        pub sockaddr_len: _cargo_bpf_u16,
        pub setsockopt: ::core::option::Option<
            unsafe extern "C" fn(
                sk: *mut sock,
                level: ::cty::c_int,
                optname: ::cty::c_int,
                optval: sockptr_t,
                optlen: ::cty::c_uint,
            ) -> ::cty::c_int,
        >,
        pub getsockopt: ::core::option::Option<
            unsafe extern "C" fn(
                sk: *mut sock,
                level: ::cty::c_int,
                optname: ::cty::c_int,
                optval: *mut ::cty::c_char,
                optlen: *mut ::cty::c_int,
            ) -> ::cty::c_int,
        >,
        pub addr2sockaddr:
            ::core::option::Option<unsafe extern "C" fn(sk: *mut sock, arg1: *mut sockaddr)>,
        pub mtu_reduced: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock)>,
    }
    #[test]
    fn bindgen_test_layout_inet_connection_sock_af_ops() {
        assert_eq!(
            ::core::mem::size_of::<inet_connection_sock_af_ops>(),
            88usize,
            concat!("Size of: ", stringify!(inet_connection_sock_af_ops))
        );
        assert_eq!(
            ::core::mem::align_of::<inet_connection_sock_af_ops>(),
            8usize,
            concat!("Alignment of ", stringify!(inet_connection_sock_af_ops))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock_af_ops>())).queue_xmit as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock_af_ops),
                "::",
                stringify!(queue_xmit)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock_af_ops>())).send_check as *const _
                    as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock_af_ops),
                "::",
                stringify!(send_check)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock_af_ops>())).rebuild_header as *const _
                    as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock_af_ops),
                "::",
                stringify!(rebuild_header)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock_af_ops>())).sk_rx_dst_set as *const _
                    as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock_af_ops),
                "::",
                stringify!(sk_rx_dst_set)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock_af_ops>())).conn_request as *const _
                    as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock_af_ops),
                "::",
                stringify!(conn_request)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock_af_ops>())).syn_recv_sock as *const _
                    as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock_af_ops),
                "::",
                stringify!(syn_recv_sock)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock_af_ops>())).net_header_len as *const _
                    as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock_af_ops),
                "::",
                stringify!(net_header_len)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock_af_ops>())).net_frag_header_len
                    as *const _ as usize
            },
            50usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock_af_ops),
                "::",
                stringify!(net_frag_header_len)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock_af_ops>())).sockaddr_len as *const _
                    as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock_af_ops),
                "::",
                stringify!(sockaddr_len)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock_af_ops>())).setsockopt as *const _
                    as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock_af_ops),
                "::",
                stringify!(setsockopt)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock_af_ops>())).getsockopt as *const _
                    as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock_af_ops),
                "::",
                stringify!(getsockopt)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock_af_ops>())).addr2sockaddr as *const _
                    as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock_af_ops),
                "::",
                stringify!(addr2sockaddr)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock_af_ops>())).mtu_reduced as *const _
                    as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock_af_ops),
                "::",
                stringify!(mtu_reduced)
            )
        );
    }
    #[doc = " inet_connection_sock - INET connection oriented sock"]
    #[doc = ""]
    #[doc = " @icsk_accept_queue:\t   FIFO of established children"]
    #[doc = " @icsk_bind_hash:\t   Bind node"]
    #[doc = " @icsk_bind2_hash:\t   Bind node in the bhash2 table"]
    #[doc = " @icsk_timeout:\t   Timeout"]
    #[doc = " @icsk_retransmit_timer: Resend (no ack)"]
    #[doc = " @icsk_rto:\t\t   Retransmit timeout"]
    #[doc = " @icsk_pmtu_cookie\t   Last pmtu seen by socket"]
    #[doc = " @icsk_ca_ops\t\t   Pluggable congestion control hook"]
    #[doc = " @icsk_af_ops\t\t   Operations which are AF_INET{4,6} specific"]
    #[doc = " @icsk_ulp_ops\t   Pluggable ULP control hook"]
    #[doc = " @icsk_ulp_data\t   ULP private data"]
    #[doc = " @icsk_clean_acked\t   Clean acked data hook"]
    #[doc = " @icsk_ca_state:\t   Congestion control state"]
    #[doc = " @icsk_retransmits:\t   Number of unrecovered [RTO] timeouts"]
    #[doc = " @icsk_pending:\t   Scheduled timer event"]
    #[doc = " @icsk_backoff:\t   Backoff"]
    #[doc = " @icsk_syn_retries:      Number of allowed SYN (or equivalent) retries"]
    #[doc = " @icsk_probes_out:\t   unanswered 0 window probes"]
    #[doc = " @icsk_ext_hdr_len:\t   Network protocol overhead (IP/IPv6 options)"]
    #[doc = " @icsk_ack:\t\t   Delayed ACK control data"]
    #[doc = " @icsk_mtup;\t\t   MTU probing control data"]
    #[doc = " @icsk_probes_tstamp:    Probe timestamp (cleared by non-zero window ack)"]
    #[doc = " @icsk_user_timeout:\t   TCP_USER_TIMEOUT value"]
    #[repr(C)]
    pub struct inet_connection_sock {
        pub icsk_inet: inet_sock,
        pub icsk_accept_queue: request_sock_queue,
        pub icsk_bind_hash: *mut inet_bind_bucket,
        pub icsk_bind2_hash: *mut inet_bind2_bucket,
        pub icsk_timeout: ::cty::c_ulong,
        pub icsk_retransmit_timer: timer_list,
        pub icsk_delack_timer: timer_list,
        pub icsk_rto: __u32,
        pub icsk_rto_min: __u32,
        pub icsk_delack_max: __u32,
        pub icsk_pmtu_cookie: __u32,
        pub icsk_ca_ops: *const tcp_congestion_ops,
        pub icsk_af_ops: *const inet_connection_sock_af_ops,
        pub icsk_ulp_ops: *mut tcp_ulp_ops,
        pub icsk_ulp_data: *mut ::cty::c_void,
        pub icsk_clean_acked:
            ::core::option::Option<unsafe extern "C" fn(sk: *mut sock, acked_seq: _cargo_bpf_u32)>,
        pub icsk_sync_mss: ::core::option::Option<
            unsafe extern "C" fn(sk: *mut sock, pmtu: _cargo_bpf_u32) -> ::cty::c_uint,
        >,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
        pub icsk_retransmits: __u8,
        pub icsk_pending: __u8,
        pub icsk_backoff: __u8,
        pub icsk_syn_retries: __u8,
        pub icsk_probes_out: __u8,
        pub icsk_ext_hdr_len: __u16,
        pub icsk_ack: inet_connection_sock__bindgen_ty_1,
        pub icsk_mtup: inet_connection_sock__bindgen_ty_2,
        pub icsk_probes_tstamp: _cargo_bpf_u32,
        pub icsk_user_timeout: _cargo_bpf_u32,
        pub icsk_ca_priv: [_cargo_bpf_u64; 13usize],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct inet_connection_sock__bindgen_ty_1 {
        pub pending: __u8,
        pub quick: __u8,
        pub pingpong: __u8,
        pub retry: __u8,
        pub ato: __u32,
        pub timeout: ::cty::c_ulong,
        pub lrcvtime: __u32,
        pub last_seg_size: __u16,
        pub rcv_mss: __u16,
    }
    #[test]
    fn bindgen_test_layout_inet_connection_sock__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<inet_connection_sock__bindgen_ty_1>(),
            24usize,
            concat!("Size of: ", stringify!(inet_connection_sock__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<inet_connection_sock__bindgen_ty_1>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(inet_connection_sock__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock__bindgen_ty_1>())).pending as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock__bindgen_ty_1),
                "::",
                stringify!(pending)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock__bindgen_ty_1>())).quick as *const _
                    as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock__bindgen_ty_1),
                "::",
                stringify!(quick)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock__bindgen_ty_1>())).pingpong as *const _
                    as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock__bindgen_ty_1),
                "::",
                stringify!(pingpong)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock__bindgen_ty_1>())).retry as *const _
                    as usize
            },
            3usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock__bindgen_ty_1),
                "::",
                stringify!(retry)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock__bindgen_ty_1>())).ato as *const _
                    as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock__bindgen_ty_1),
                "::",
                stringify!(ato)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock__bindgen_ty_1>())).timeout as *const _
                    as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock__bindgen_ty_1),
                "::",
                stringify!(timeout)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock__bindgen_ty_1>())).lrcvtime as *const _
                    as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock__bindgen_ty_1),
                "::",
                stringify!(lrcvtime)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock__bindgen_ty_1>())).last_seg_size
                    as *const _ as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock__bindgen_ty_1),
                "::",
                stringify!(last_seg_size)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock__bindgen_ty_1>())).rcv_mss as *const _
                    as usize
            },
            22usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock__bindgen_ty_1),
                "::",
                stringify!(rcv_mss)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct inet_connection_sock__bindgen_ty_2 {
        pub search_high: ::cty::c_int,
        pub search_low: ::cty::c_int,
        pub _bitfield_align_1: [u32; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
        pub probe_timestamp: _cargo_bpf_u32,
    }
    #[test]
    fn bindgen_test_layout_inet_connection_sock__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<inet_connection_sock__bindgen_ty_2>(),
            16usize,
            concat!("Size of: ", stringify!(inet_connection_sock__bindgen_ty_2))
        );
        assert_eq!(
            ::core::mem::align_of::<inet_connection_sock__bindgen_ty_2>(),
            4usize,
            concat!(
                "Alignment of ",
                stringify!(inet_connection_sock__bindgen_ty_2)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock__bindgen_ty_2>())).search_high
                    as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock__bindgen_ty_2),
                "::",
                stringify!(search_high)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock__bindgen_ty_2>())).search_low
                    as *const _ as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock__bindgen_ty_2),
                "::",
                stringify!(search_low)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock__bindgen_ty_2>())).probe_timestamp
                    as *const _ as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock__bindgen_ty_2),
                "::",
                stringify!(probe_timestamp)
            )
        );
    }
    impl inet_connection_sock__bindgen_ty_2 {
        #[inline]
        pub fn probe_size(&self) -> _cargo_bpf_u32 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 31u8) as u32) }
        }
        #[inline]
        pub fn set_probe_size(&mut self, val: _cargo_bpf_u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 31u8, val as u64)
            }
        }
        #[inline]
        pub fn enabled(&self) -> _cargo_bpf_u32 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_enabled(&mut self, val: _cargo_bpf_u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(31usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            probe_size: _cargo_bpf_u32,
            enabled: _cargo_bpf_u32,
        ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 31u8, {
                let probe_size: u32 = unsafe { ::core::mem::transmute(probe_size) };
                probe_size as u64
            });
            __bindgen_bitfield_unit.set(31usize, 1u8, {
                let enabled: u32 = unsafe { ::core::mem::transmute(enabled) };
                enabled as u64
            });
            __bindgen_bitfield_unit
        }
    }
    #[test]
    fn bindgen_test_layout_inet_connection_sock() {
        assert_eq!(
            ::core::mem::size_of::<inet_connection_sock>(),
            1408usize,
            concat!("Size of: ", stringify!(inet_connection_sock))
        );
        assert_eq!(
            ::core::mem::align_of::<inet_connection_sock>(),
            8usize,
            concat!("Alignment of ", stringify!(inet_connection_sock))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock>())).icsk_inet as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock),
                "::",
                stringify!(icsk_inet)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock>())).icsk_accept_queue as *const _
                    as usize
            },
            1000usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock),
                "::",
                stringify!(icsk_accept_queue)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock>())).icsk_bind_hash as *const _
                    as usize
            },
            1080usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock),
                "::",
                stringify!(icsk_bind_hash)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock>())).icsk_bind2_hash as *const _
                    as usize
            },
            1088usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock),
                "::",
                stringify!(icsk_bind2_hash)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock>())).icsk_timeout as *const _ as usize
            },
            1096usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock),
                "::",
                stringify!(icsk_timeout)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock>())).icsk_retransmit_timer as *const _
                    as usize
            },
            1104usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock),
                "::",
                stringify!(icsk_retransmit_timer)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock>())).icsk_delack_timer as *const _
                    as usize
            },
            1144usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock),
                "::",
                stringify!(icsk_delack_timer)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock>())).icsk_rto as *const _ as usize
            },
            1184usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock),
                "::",
                stringify!(icsk_rto)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock>())).icsk_rto_min as *const _ as usize
            },
            1188usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock),
                "::",
                stringify!(icsk_rto_min)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock>())).icsk_delack_max as *const _
                    as usize
            },
            1192usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock),
                "::",
                stringify!(icsk_delack_max)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock>())).icsk_pmtu_cookie as *const _
                    as usize
            },
            1196usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock),
                "::",
                stringify!(icsk_pmtu_cookie)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock>())).icsk_ca_ops as *const _ as usize
            },
            1200usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock),
                "::",
                stringify!(icsk_ca_ops)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock>())).icsk_af_ops as *const _ as usize
            },
            1208usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock),
                "::",
                stringify!(icsk_af_ops)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock>())).icsk_ulp_ops as *const _ as usize
            },
            1216usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock),
                "::",
                stringify!(icsk_ulp_ops)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock>())).icsk_ulp_data as *const _ as usize
            },
            1224usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock),
                "::",
                stringify!(icsk_ulp_data)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock>())).icsk_clean_acked as *const _
                    as usize
            },
            1232usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock),
                "::",
                stringify!(icsk_clean_acked)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock>())).icsk_sync_mss as *const _ as usize
            },
            1240usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock),
                "::",
                stringify!(icsk_sync_mss)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock>())).icsk_retransmits as *const _
                    as usize
            },
            1249usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock),
                "::",
                stringify!(icsk_retransmits)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock>())).icsk_pending as *const _ as usize
            },
            1250usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock),
                "::",
                stringify!(icsk_pending)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock>())).icsk_backoff as *const _ as usize
            },
            1251usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock),
                "::",
                stringify!(icsk_backoff)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock>())).icsk_syn_retries as *const _
                    as usize
            },
            1252usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock),
                "::",
                stringify!(icsk_syn_retries)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock>())).icsk_probes_out as *const _
                    as usize
            },
            1253usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock),
                "::",
                stringify!(icsk_probes_out)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock>())).icsk_ext_hdr_len as *const _
                    as usize
            },
            1254usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock),
                "::",
                stringify!(icsk_ext_hdr_len)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock>())).icsk_ack as *const _ as usize
            },
            1256usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock),
                "::",
                stringify!(icsk_ack)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock>())).icsk_mtup as *const _ as usize
            },
            1280usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock),
                "::",
                stringify!(icsk_mtup)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock>())).icsk_probes_tstamp as *const _
                    as usize
            },
            1296usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock),
                "::",
                stringify!(icsk_probes_tstamp)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock>())).icsk_user_timeout as *const _
                    as usize
            },
            1300usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock),
                "::",
                stringify!(icsk_user_timeout)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_connection_sock>())).icsk_ca_priv as *const _ as usize
            },
            1304usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_connection_sock),
                "::",
                stringify!(icsk_ca_priv)
            )
        );
    }
    impl inet_connection_sock {
        #[inline]
        pub fn icsk_ca_state(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u8) }
        }
        #[inline]
        pub fn set_icsk_ca_state(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 5u8, val as u64)
            }
        }
        #[inline]
        pub fn icsk_ca_initialized(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_icsk_ca_initialized(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(5usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn icsk_ca_setsockopt(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_icsk_ca_setsockopt(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(6usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn icsk_ca_dst_locked(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_icsk_ca_dst_locked(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(7usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            icsk_ca_state: __u8,
            icsk_ca_initialized: __u8,
            icsk_ca_setsockopt: __u8,
            icsk_ca_dst_locked: __u8,
        ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 5u8, {
                let icsk_ca_state: u8 = unsafe { ::core::mem::transmute(icsk_ca_state) };
                icsk_ca_state as u64
            });
            __bindgen_bitfield_unit.set(5usize, 1u8, {
                let icsk_ca_initialized: u8 =
                    unsafe { ::core::mem::transmute(icsk_ca_initialized) };
                icsk_ca_initialized as u64
            });
            __bindgen_bitfield_unit.set(6usize, 1u8, {
                let icsk_ca_setsockopt: u8 = unsafe { ::core::mem::transmute(icsk_ca_setsockopt) };
                icsk_ca_setsockopt as u64
            });
            __bindgen_bitfield_unit.set(7usize, 1u8, {
                let icsk_ca_dst_locked: u8 = unsafe { ::core::mem::transmute(icsk_ca_dst_locked) };
                icsk_ca_dst_locked as u64
            });
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct timewait_sock_ops {
        pub twsk_slab: *mut kmem_cache,
        pub twsk_slab_name: *mut ::cty::c_char,
        pub twsk_obj_size: ::cty::c_uint,
        pub twsk_unique: ::core::option::Option<
            unsafe extern "C" fn(
                sk: *mut sock,
                sktw: *mut sock,
                twp: *mut ::cty::c_void,
            ) -> ::cty::c_int,
        >,
        pub twsk_destructor: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock)>,
    }
    #[test]
    fn bindgen_test_layout_timewait_sock_ops() {
        assert_eq!(
            ::core::mem::size_of::<timewait_sock_ops>(),
            40usize,
            concat!("Size of: ", stringify!(timewait_sock_ops))
        );
        assert_eq!(
            ::core::mem::align_of::<timewait_sock_ops>(),
            8usize,
            concat!("Alignment of ", stringify!(timewait_sock_ops))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<timewait_sock_ops>())).twsk_slab as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(timewait_sock_ops),
                "::",
                stringify!(twsk_slab)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<timewait_sock_ops>())).twsk_slab_name as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(timewait_sock_ops),
                "::",
                stringify!(twsk_slab_name)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<timewait_sock_ops>())).twsk_obj_size as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(timewait_sock_ops),
                "::",
                stringify!(twsk_obj_size)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<timewait_sock_ops>())).twsk_unique as *const _ as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(timewait_sock_ops),
                "::",
                stringify!(twsk_unique)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<timewait_sock_ops>())).twsk_destructor as *const _ as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(timewait_sock_ops),
                "::",
                stringify!(twsk_destructor)
            )
        );
    }
    #[repr(C)]
    pub struct inet_timewait_sock {
        pub __tw_common: sock_common,
        pub tw_mark: __u32,
        pub tw_substate: ::cty::c_uchar,
        pub tw_rcv_wscale: ::cty::c_uchar,
        pub tw_sport: __be16,
        pub _bitfield_align_1: [u32; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
        pub tw_txhash: _cargo_bpf_u32,
        pub tw_priority: _cargo_bpf_u32,
        pub tw_timer: timer_list,
        pub tw_tb: *mut inet_bind_bucket,
        pub tw_tb2: *mut inet_bind2_bucket,
        pub tw_bind2_node: hlist_node,
    }
    #[test]
    fn bindgen_test_layout_inet_timewait_sock() {
        assert_eq!(
            ::core::mem::size_of::<inet_timewait_sock>(),
            232usize,
            concat!("Size of: ", stringify!(inet_timewait_sock))
        );
        assert_eq!(
            ::core::mem::align_of::<inet_timewait_sock>(),
            8usize,
            concat!("Alignment of ", stringify!(inet_timewait_sock))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_timewait_sock>())).__tw_common as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_timewait_sock),
                "::",
                stringify!(__tw_common)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_timewait_sock>())).tw_mark as *const _ as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_timewait_sock),
                "::",
                stringify!(tw_mark)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_timewait_sock>())).tw_substate as *const _ as usize
            },
            140usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_timewait_sock),
                "::",
                stringify!(tw_substate)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_timewait_sock>())).tw_rcv_wscale as *const _ as usize
            },
            141usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_timewait_sock),
                "::",
                stringify!(tw_rcv_wscale)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_timewait_sock>())).tw_sport as *const _ as usize
            },
            142usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_timewait_sock),
                "::",
                stringify!(tw_sport)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_timewait_sock>())).tw_txhash as *const _ as usize
            },
            148usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_timewait_sock),
                "::",
                stringify!(tw_txhash)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_timewait_sock>())).tw_priority as *const _ as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_timewait_sock),
                "::",
                stringify!(tw_priority)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_timewait_sock>())).tw_timer as *const _ as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_timewait_sock),
                "::",
                stringify!(tw_timer)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_timewait_sock>())).tw_tb as *const _ as usize },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_timewait_sock),
                "::",
                stringify!(tw_tb)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet_timewait_sock>())).tw_tb2 as *const _ as usize },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_timewait_sock),
                "::",
                stringify!(tw_tb2)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<inet_timewait_sock>())).tw_bind2_node as *const _ as usize
            },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(inet_timewait_sock),
                "::",
                stringify!(tw_bind2_node)
            )
        );
    }
    impl inet_timewait_sock {
        #[inline]
        pub fn tw_transparent(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_tw_transparent(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn tw_flowlabel(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 20u8) as u32) }
        }
        #[inline]
        pub fn set_tw_flowlabel(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(1usize, 20u8, val as u64)
            }
        }
        #[inline]
        pub fn tw_pad(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 3u8) as u32) }
        }
        #[inline]
        pub fn set_tw_pad(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(21usize, 3u8, val as u64)
            }
        }
        #[inline]
        pub fn tw_tos(&self) -> ::cty::c_uint {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
        }
        #[inline]
        pub fn set_tw_tos(&mut self, val: ::cty::c_uint) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(24usize, 8u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            tw_transparent: ::cty::c_uint,
            tw_flowlabel: ::cty::c_uint,
            tw_pad: ::cty::c_uint,
            tw_tos: ::cty::c_uint,
        ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 1u8, {
                let tw_transparent: u32 = unsafe { ::core::mem::transmute(tw_transparent) };
                tw_transparent as u64
            });
            __bindgen_bitfield_unit.set(1usize, 20u8, {
                let tw_flowlabel: u32 = unsafe { ::core::mem::transmute(tw_flowlabel) };
                tw_flowlabel as u64
            });
            __bindgen_bitfield_unit.set(21usize, 3u8, {
                let tw_pad: u32 = unsafe { ::core::mem::transmute(tw_pad) };
                tw_pad as u64
            });
            __bindgen_bitfield_unit.set(24usize, 8u8, {
                let tw_tos: u32 = unsafe { ::core::mem::transmute(tw_tos) };
                tw_tos as u64
            });
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct tcphdr {
        pub source: __be16,
        pub dest: __be16,
        pub seq: __be32,
        pub ack_seq: __be32,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
        pub window: __be16,
        pub check: __sum16,
        pub urg_ptr: __be16,
    }
    #[test]
    fn bindgen_test_layout_tcphdr() {
        assert_eq!(
            ::core::mem::size_of::<tcphdr>(),
            20usize,
            concat!("Size of: ", stringify!(tcphdr))
        );
        assert_eq!(
            ::core::mem::align_of::<tcphdr>(),
            4usize,
            concat!("Alignment of ", stringify!(tcphdr))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcphdr>())).source as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(tcphdr),
                "::",
                stringify!(source)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcphdr>())).dest as *const _ as usize },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(tcphdr),
                "::",
                stringify!(dest)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcphdr>())).seq as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(tcphdr),
                "::",
                stringify!(seq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcphdr>())).ack_seq as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(tcphdr),
                "::",
                stringify!(ack_seq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcphdr>())).window as *const _ as usize },
            14usize,
            concat!(
                "Offset of field: ",
                stringify!(tcphdr),
                "::",
                stringify!(window)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcphdr>())).check as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(tcphdr),
                "::",
                stringify!(check)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcphdr>())).urg_ptr as *const _ as usize },
            18usize,
            concat!(
                "Offset of field: ",
                stringify!(tcphdr),
                "::",
                stringify!(urg_ptr)
            )
        );
    }
    impl tcphdr {
        #[inline]
        pub fn res1(&self) -> __u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
        }
        #[inline]
        pub fn set_res1(&mut self, val: __u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 4u8, val as u64)
            }
        }
        #[inline]
        pub fn doff(&self) -> __u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u16) }
        }
        #[inline]
        pub fn set_doff(&mut self, val: __u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(4usize, 4u8, val as u64)
            }
        }
        #[inline]
        pub fn fin(&self) -> __u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_fin(&mut self, val: __u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(8usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn syn(&self) -> __u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_syn(&mut self, val: __u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(9usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn rst(&self) -> __u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_rst(&mut self, val: __u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(10usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn psh(&self) -> __u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_psh(&mut self, val: __u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(11usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn ack(&self) -> __u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_ack(&mut self, val: __u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(12usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn urg(&self) -> __u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_urg(&mut self, val: __u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(13usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn ece(&self) -> __u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_ece(&mut self, val: __u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(14usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn cwr(&self) -> __u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_cwr(&mut self, val: __u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(15usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            res1: __u16,
            doff: __u16,
            fin: __u16,
            syn: __u16,
            rst: __u16,
            psh: __u16,
            ack: __u16,
            urg: __u16,
            ece: __u16,
            cwr: __u16,
        ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 4u8, {
                let res1: u16 = unsafe { ::core::mem::transmute(res1) };
                res1 as u64
            });
            __bindgen_bitfield_unit.set(4usize, 4u8, {
                let doff: u16 = unsafe { ::core::mem::transmute(doff) };
                doff as u64
            });
            __bindgen_bitfield_unit.set(8usize, 1u8, {
                let fin: u16 = unsafe { ::core::mem::transmute(fin) };
                fin as u64
            });
            __bindgen_bitfield_unit.set(9usize, 1u8, {
                let syn: u16 = unsafe { ::core::mem::transmute(syn) };
                syn as u64
            });
            __bindgen_bitfield_unit.set(10usize, 1u8, {
                let rst: u16 = unsafe { ::core::mem::transmute(rst) };
                rst as u64
            });
            __bindgen_bitfield_unit.set(11usize, 1u8, {
                let psh: u16 = unsafe { ::core::mem::transmute(psh) };
                psh as u64
            });
            __bindgen_bitfield_unit.set(12usize, 1u8, {
                let ack: u16 = unsafe { ::core::mem::transmute(ack) };
                ack as u64
            });
            __bindgen_bitfield_unit.set(13usize, 1u8, {
                let urg: u16 = unsafe { ::core::mem::transmute(urg) };
                urg as u64
            });
            __bindgen_bitfield_unit.set(14usize, 1u8, {
                let ece: u16 = unsafe { ::core::mem::transmute(ece) };
                ece as u64
            });
            __bindgen_bitfield_unit.set(15usize, 1u8, {
                let cwr: u16 = unsafe { ::core::mem::transmute(cwr) };
                cwr as u64
            });
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct tcp_sack_block {
        pub start_seq: _cargo_bpf_u32,
        pub end_seq: _cargo_bpf_u32,
    }
    #[test]
    fn bindgen_test_layout_tcp_sack_block() {
        assert_eq!(
            ::core::mem::size_of::<tcp_sack_block>(),
            8usize,
            concat!("Size of: ", stringify!(tcp_sack_block))
        );
        assert_eq!(
            ::core::mem::align_of::<tcp_sack_block>(),
            4usize,
            concat!("Alignment of ", stringify!(tcp_sack_block))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sack_block>())).start_seq as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sack_block),
                "::",
                stringify!(start_seq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sack_block>())).end_seq as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sack_block),
                "::",
                stringify!(end_seq)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct tcp_options_received {
        pub ts_recent_stamp: ::cty::c_int,
        pub ts_recent: _cargo_bpf_u32,
        pub rcv_tsval: _cargo_bpf_u32,
        pub rcv_tsecr: _cargo_bpf_u32,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
        pub num_sacks: _cargo_bpf_u8,
        pub user_mss: _cargo_bpf_u16,
        pub mss_clamp: _cargo_bpf_u16,
    }
    #[test]
    fn bindgen_test_layout_tcp_options_received() {
        assert_eq!(
            ::core::mem::size_of::<tcp_options_received>(),
            24usize,
            concat!("Size of: ", stringify!(tcp_options_received))
        );
        assert_eq!(
            ::core::mem::align_of::<tcp_options_received>(),
            4usize,
            concat!("Alignment of ", stringify!(tcp_options_received))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<tcp_options_received>())).ts_recent_stamp as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_options_received),
                "::",
                stringify!(ts_recent_stamp)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<tcp_options_received>())).ts_recent as *const _ as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_options_received),
                "::",
                stringify!(ts_recent)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<tcp_options_received>())).rcv_tsval as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_options_received),
                "::",
                stringify!(rcv_tsval)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<tcp_options_received>())).rcv_tsecr as *const _ as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_options_received),
                "::",
                stringify!(rcv_tsecr)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<tcp_options_received>())).num_sacks as *const _ as usize
            },
            19usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_options_received),
                "::",
                stringify!(num_sacks)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<tcp_options_received>())).user_mss as *const _ as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_options_received),
                "::",
                stringify!(user_mss)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<tcp_options_received>())).mss_clamp as *const _ as usize
            },
            22usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_options_received),
                "::",
                stringify!(mss_clamp)
            )
        );
    }
    impl tcp_options_received {
        #[inline]
        pub fn saw_tstamp(&self) -> _cargo_bpf_u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_saw_tstamp(&mut self, val: _cargo_bpf_u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn tstamp_ok(&self) -> _cargo_bpf_u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_tstamp_ok(&mut self, val: _cargo_bpf_u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(1usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn dsack(&self) -> _cargo_bpf_u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_dsack(&mut self, val: _cargo_bpf_u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(2usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn wscale_ok(&self) -> _cargo_bpf_u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_wscale_ok(&mut self, val: _cargo_bpf_u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(3usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn sack_ok(&self) -> _cargo_bpf_u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u16) }
        }
        #[inline]
        pub fn set_sack_ok(&mut self, val: _cargo_bpf_u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(4usize, 3u8, val as u64)
            }
        }
        #[inline]
        pub fn smc_ok(&self) -> _cargo_bpf_u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_smc_ok(&mut self, val: _cargo_bpf_u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(7usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn snd_wscale(&self) -> _cargo_bpf_u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u16) }
        }
        #[inline]
        pub fn set_snd_wscale(&mut self, val: _cargo_bpf_u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(8usize, 4u8, val as u64)
            }
        }
        #[inline]
        pub fn rcv_wscale(&self) -> _cargo_bpf_u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u16) }
        }
        #[inline]
        pub fn set_rcv_wscale(&mut self, val: _cargo_bpf_u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(12usize, 4u8, val as u64)
            }
        }
        #[inline]
        pub fn saw_unknown(&self) -> _cargo_bpf_u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_saw_unknown(&mut self, val: _cargo_bpf_u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(16usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn unused(&self) -> _cargo_bpf_u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 7u8) as u8) }
        }
        #[inline]
        pub fn set_unused(&mut self, val: _cargo_bpf_u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(17usize, 7u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            saw_tstamp: _cargo_bpf_u16,
            tstamp_ok: _cargo_bpf_u16,
            dsack: _cargo_bpf_u16,
            wscale_ok: _cargo_bpf_u16,
            sack_ok: _cargo_bpf_u16,
            smc_ok: _cargo_bpf_u16,
            snd_wscale: _cargo_bpf_u16,
            rcv_wscale: _cargo_bpf_u16,
            saw_unknown: _cargo_bpf_u8,
            unused: _cargo_bpf_u8,
        ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 1u8, {
                let saw_tstamp: u16 = unsafe { ::core::mem::transmute(saw_tstamp) };
                saw_tstamp as u64
            });
            __bindgen_bitfield_unit.set(1usize, 1u8, {
                let tstamp_ok: u16 = unsafe { ::core::mem::transmute(tstamp_ok) };
                tstamp_ok as u64
            });
            __bindgen_bitfield_unit.set(2usize, 1u8, {
                let dsack: u16 = unsafe { ::core::mem::transmute(dsack) };
                dsack as u64
            });
            __bindgen_bitfield_unit.set(3usize, 1u8, {
                let wscale_ok: u16 = unsafe { ::core::mem::transmute(wscale_ok) };
                wscale_ok as u64
            });
            __bindgen_bitfield_unit.set(4usize, 3u8, {
                let sack_ok: u16 = unsafe { ::core::mem::transmute(sack_ok) };
                sack_ok as u64
            });
            __bindgen_bitfield_unit.set(7usize, 1u8, {
                let smc_ok: u16 = unsafe { ::core::mem::transmute(smc_ok) };
                smc_ok as u64
            });
            __bindgen_bitfield_unit.set(8usize, 4u8, {
                let snd_wscale: u16 = unsafe { ::core::mem::transmute(snd_wscale) };
                snd_wscale as u64
            });
            __bindgen_bitfield_unit.set(12usize, 4u8, {
                let rcv_wscale: u16 = unsafe { ::core::mem::transmute(rcv_wscale) };
                rcv_wscale as u64
            });
            __bindgen_bitfield_unit.set(16usize, 1u8, {
                let saw_unknown: u8 = unsafe { ::core::mem::transmute(saw_unknown) };
                saw_unknown as u64
            });
            __bindgen_bitfield_unit.set(17usize, 7u8, {
                let unused: u8 = unsafe { ::core::mem::transmute(unused) };
                unused as u64
            });
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct tcp_request_sock_ops {
        _unused: [u8; 0],
    }
    #[repr(C)]
    pub struct tcp_request_sock {
        pub req: inet_request_sock,
        pub af_specific: *const tcp_request_sock_ops,
        pub snt_synack: _cargo_bpf_u64,
        pub tfo_listener: bool_,
        pub is_mptcp: bool_,
        pub drop_req: bool_,
        pub txhash: _cargo_bpf_u32,
        pub rcv_isn: _cargo_bpf_u32,
        pub snt_isn: _cargo_bpf_u32,
        pub ts_off: _cargo_bpf_u32,
        pub last_oow_ack_time: _cargo_bpf_u32,
        pub rcv_nxt: _cargo_bpf_u32,
        pub syn_tos: _cargo_bpf_u8,
    }
    #[test]
    fn bindgen_test_layout_tcp_request_sock() {
        assert_eq!(
            ::core::mem::size_of::<tcp_request_sock>(),
            304usize,
            concat!("Size of: ", stringify!(tcp_request_sock))
        );
        assert_eq!(
            ::core::mem::align_of::<tcp_request_sock>(),
            8usize,
            concat!("Alignment of ", stringify!(tcp_request_sock))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_request_sock>())).req as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_request_sock),
                "::",
                stringify!(req)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<tcp_request_sock>())).af_specific as *const _ as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_request_sock),
                "::",
                stringify!(af_specific)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<tcp_request_sock>())).snt_synack as *const _ as usize
            },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_request_sock),
                "::",
                stringify!(snt_synack)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<tcp_request_sock>())).tfo_listener as *const _ as usize
            },
            272usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_request_sock),
                "::",
                stringify!(tfo_listener)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_request_sock>())).is_mptcp as *const _ as usize },
            273usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_request_sock),
                "::",
                stringify!(is_mptcp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_request_sock>())).drop_req as *const _ as usize },
            274usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_request_sock),
                "::",
                stringify!(drop_req)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_request_sock>())).txhash as *const _ as usize },
            276usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_request_sock),
                "::",
                stringify!(txhash)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_request_sock>())).rcv_isn as *const _ as usize },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_request_sock),
                "::",
                stringify!(rcv_isn)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_request_sock>())).snt_isn as *const _ as usize },
            284usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_request_sock),
                "::",
                stringify!(snt_isn)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_request_sock>())).ts_off as *const _ as usize },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_request_sock),
                "::",
                stringify!(ts_off)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<tcp_request_sock>())).last_oow_ack_time as *const _ as usize
            },
            292usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_request_sock),
                "::",
                stringify!(last_oow_ack_time)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_request_sock>())).rcv_nxt as *const _ as usize },
            296usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_request_sock),
                "::",
                stringify!(rcv_nxt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_request_sock>())).syn_tos as *const _ as usize },
            300usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_request_sock),
                "::",
                stringify!(syn_tos)
            )
        );
    }
    #[repr(C)]
    pub struct tcp_sock {
        pub inet_conn: inet_connection_sock,
        pub tcp_header_len: _cargo_bpf_u16,
        pub gso_segs: _cargo_bpf_u16,
        pub pred_flags: __be32,
        pub bytes_received: _cargo_bpf_u64,
        pub segs_in: _cargo_bpf_u32,
        pub data_segs_in: _cargo_bpf_u32,
        pub rcv_nxt: _cargo_bpf_u32,
        pub copied_seq: _cargo_bpf_u32,
        pub rcv_wup: _cargo_bpf_u32,
        pub snd_nxt: _cargo_bpf_u32,
        pub segs_out: _cargo_bpf_u32,
        pub data_segs_out: _cargo_bpf_u32,
        pub bytes_sent: _cargo_bpf_u64,
        pub bytes_acked: _cargo_bpf_u64,
        pub dsack_dups: _cargo_bpf_u32,
        pub snd_una: _cargo_bpf_u32,
        pub snd_sml: _cargo_bpf_u32,
        pub rcv_tstamp: _cargo_bpf_u32,
        pub lsndtime: _cargo_bpf_u32,
        pub last_oow_ack_time: _cargo_bpf_u32,
        pub compressed_ack_rcv_nxt: _cargo_bpf_u32,
        pub tsoffset: _cargo_bpf_u32,
        pub tsq_node: list_head,
        pub tsorted_sent_queue: list_head,
        pub snd_wl1: _cargo_bpf_u32,
        pub snd_wnd: _cargo_bpf_u32,
        pub max_window: _cargo_bpf_u32,
        pub mss_cache: _cargo_bpf_u32,
        pub window_clamp: _cargo_bpf_u32,
        pub rcv_ssthresh: _cargo_bpf_u32,
        pub rack: tcp_sock_tcp_rack,
        pub advmss: _cargo_bpf_u16,
        pub compressed_ack: _cargo_bpf_u8,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
        pub chrono_start: _cargo_bpf_u32,
        pub chrono_stat: [_cargo_bpf_u32; 3usize],
        pub _bitfield_align_2: [u8; 0],
        pub _bitfield_2: __BindgenBitfieldUnit<[u8; 2usize]>,
        pub repair_queue: _cargo_bpf_u8,
        pub _bitfield_align_3: [u8; 0],
        pub _bitfield_3: __BindgenBitfieldUnit<[u8; 1usize]>,
        pub tlp_high_seq: _cargo_bpf_u32,
        pub tcp_tx_delay: _cargo_bpf_u32,
        pub tcp_wstamp_ns: _cargo_bpf_u64,
        pub tcp_clock_cache: _cargo_bpf_u64,
        pub tcp_mstamp: _cargo_bpf_u64,
        pub srtt_us: _cargo_bpf_u32,
        pub mdev_us: _cargo_bpf_u32,
        pub mdev_max_us: _cargo_bpf_u32,
        pub rttvar_us: _cargo_bpf_u32,
        pub rtt_seq: _cargo_bpf_u32,
        pub rtt_min: minmax,
        pub packets_out: _cargo_bpf_u32,
        pub retrans_out: _cargo_bpf_u32,
        pub max_packets_out: _cargo_bpf_u32,
        pub cwnd_usage_seq: _cargo_bpf_u32,
        pub urg_data: _cargo_bpf_u16,
        pub ecn_flags: _cargo_bpf_u8,
        pub keepalive_probes: _cargo_bpf_u8,
        pub reordering: _cargo_bpf_u32,
        pub reord_seen: _cargo_bpf_u32,
        pub snd_up: _cargo_bpf_u32,
        pub rx_opt: tcp_options_received,
        pub snd_ssthresh: _cargo_bpf_u32,
        pub snd_cwnd: _cargo_bpf_u32,
        pub snd_cwnd_cnt: _cargo_bpf_u32,
        pub snd_cwnd_clamp: _cargo_bpf_u32,
        pub snd_cwnd_used: _cargo_bpf_u32,
        pub snd_cwnd_stamp: _cargo_bpf_u32,
        pub prior_cwnd: _cargo_bpf_u32,
        pub prr_delivered: _cargo_bpf_u32,
        pub prr_out: _cargo_bpf_u32,
        pub delivered: _cargo_bpf_u32,
        pub delivered_ce: _cargo_bpf_u32,
        pub lost: _cargo_bpf_u32,
        pub app_limited: _cargo_bpf_u32,
        pub first_tx_mstamp: _cargo_bpf_u64,
        pub delivered_mstamp: _cargo_bpf_u64,
        pub rate_delivered: _cargo_bpf_u32,
        pub rate_interval_us: _cargo_bpf_u32,
        pub rcv_wnd: _cargo_bpf_u32,
        pub write_seq: _cargo_bpf_u32,
        pub notsent_lowat: _cargo_bpf_u32,
        pub pushed_seq: _cargo_bpf_u32,
        pub lost_out: _cargo_bpf_u32,
        pub sacked_out: _cargo_bpf_u32,
        pub pacing_timer: hrtimer,
        pub compressed_ack_timer: hrtimer,
        pub lost_skb_hint: *mut sk_buff,
        pub retransmit_skb_hint: *mut sk_buff,
        pub out_of_order_queue: rb_root,
        pub ooo_last_skb: *mut sk_buff,
        pub duplicate_sack: [tcp_sack_block; 1usize],
        pub selective_acks: [tcp_sack_block; 4usize],
        pub recv_sack_cache: [tcp_sack_block; 4usize],
        pub highest_sack: *mut sk_buff,
        pub lost_cnt_hint: ::cty::c_int,
        pub prior_ssthresh: _cargo_bpf_u32,
        pub high_seq: _cargo_bpf_u32,
        pub retrans_stamp: _cargo_bpf_u32,
        pub undo_marker: _cargo_bpf_u32,
        pub undo_retrans: ::cty::c_int,
        pub bytes_retrans: _cargo_bpf_u64,
        pub total_retrans: _cargo_bpf_u32,
        pub urg_seq: _cargo_bpf_u32,
        pub keepalive_time: ::cty::c_uint,
        pub keepalive_intvl: ::cty::c_uint,
        pub linger2: ::cty::c_int,
        pub bpf_sock_ops_cb_flags: _cargo_bpf_u8,
        pub _bitfield_align_4: [u8; 0],
        pub _bitfield_4: __BindgenBitfieldUnit<[u8; 1usize]>,
        pub timeout_rehash: _cargo_bpf_u16,
        pub rcv_ooopack: _cargo_bpf_u32,
        pub rcv_rtt_last_tsecr: _cargo_bpf_u32,
        pub rcv_rtt_est: tcp_sock__bindgen_ty_1,
        pub rcvq_space: tcp_sock__bindgen_ty_2,
        pub mtu_probe: tcp_sock__bindgen_ty_3,
        pub plb_rehash: _cargo_bpf_u32,
        pub mtu_info: _cargo_bpf_u32,
        pub is_mptcp: bool_,
        pub smc_hs_congested:
            ::core::option::Option<unsafe extern "C" fn(sk: *const sock) -> bool_>,
        pub syn_smc: bool_,
        pub af_specific: *mut tcp_sock_af_ops,
        pub md5sig_info: *mut tcp_md5sig_info,
        pub fastopen_req: *mut tcp_fastopen_request,
        pub fastopen_rsk: *mut request_sock,
        pub saved_syn: *mut saved_syn,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct tcp_sock_tcp_rack {
        pub mstamp: _cargo_bpf_u64,
        pub rtt_us: _cargo_bpf_u32,
        pub end_seq: _cargo_bpf_u32,
        pub last_delivered: _cargo_bpf_u32,
        pub reo_wnd_steps: _cargo_bpf_u8,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
        pub __bindgen_padding_0: u16,
    }
    #[test]
    fn bindgen_test_layout_tcp_sock_tcp_rack() {
        assert_eq!(
            ::core::mem::size_of::<tcp_sock_tcp_rack>(),
            24usize,
            concat!("Size of: ", stringify!(tcp_sock_tcp_rack))
        );
        assert_eq!(
            ::core::mem::align_of::<tcp_sock_tcp_rack>(),
            8usize,
            concat!("Alignment of ", stringify!(tcp_sock_tcp_rack))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock_tcp_rack>())).mstamp as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock_tcp_rack),
                "::",
                stringify!(mstamp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock_tcp_rack>())).rtt_us as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock_tcp_rack),
                "::",
                stringify!(rtt_us)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock_tcp_rack>())).end_seq as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock_tcp_rack),
                "::",
                stringify!(end_seq)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<tcp_sock_tcp_rack>())).last_delivered as *const _ as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock_tcp_rack),
                "::",
                stringify!(last_delivered)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<tcp_sock_tcp_rack>())).reo_wnd_steps as *const _ as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock_tcp_rack),
                "::",
                stringify!(reo_wnd_steps)
            )
        );
    }
    impl tcp_sock_tcp_rack {
        #[inline]
        pub fn reo_wnd_persist(&self) -> _cargo_bpf_u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u8) }
        }
        #[inline]
        pub fn set_reo_wnd_persist(&mut self, val: _cargo_bpf_u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 5u8, val as u64)
            }
        }
        #[inline]
        pub fn dsack_seen(&self) -> _cargo_bpf_u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_dsack_seen(&mut self, val: _cargo_bpf_u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(5usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn advanced(&self) -> _cargo_bpf_u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_advanced(&mut self, val: _cargo_bpf_u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(6usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            reo_wnd_persist: _cargo_bpf_u8,
            dsack_seen: _cargo_bpf_u8,
            advanced: _cargo_bpf_u8,
        ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 5u8, {
                let reo_wnd_persist: u8 = unsafe { ::core::mem::transmute(reo_wnd_persist) };
                reo_wnd_persist as u64
            });
            __bindgen_bitfield_unit.set(5usize, 1u8, {
                let dsack_seen: u8 = unsafe { ::core::mem::transmute(dsack_seen) };
                dsack_seen as u64
            });
            __bindgen_bitfield_unit.set(6usize, 1u8, {
                let advanced: u8 = unsafe { ::core::mem::transmute(advanced) };
                advanced as u64
            });
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct tcp_sock__bindgen_ty_1 {
        pub rtt_us: _cargo_bpf_u32,
        pub seq: _cargo_bpf_u32,
        pub time: _cargo_bpf_u64,
    }
    #[test]
    fn bindgen_test_layout_tcp_sock__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<tcp_sock__bindgen_ty_1>(),
            16usize,
            concat!("Size of: ", stringify!(tcp_sock__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<tcp_sock__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(tcp_sock__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<tcp_sock__bindgen_ty_1>())).rtt_us as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock__bindgen_ty_1),
                "::",
                stringify!(rtt_us)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock__bindgen_ty_1>())).seq as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock__bindgen_ty_1),
                "::",
                stringify!(seq)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<tcp_sock__bindgen_ty_1>())).time as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock__bindgen_ty_1),
                "::",
                stringify!(time)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct tcp_sock__bindgen_ty_2 {
        pub space: _cargo_bpf_u32,
        pub seq: _cargo_bpf_u32,
        pub time: _cargo_bpf_u64,
    }
    #[test]
    fn bindgen_test_layout_tcp_sock__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<tcp_sock__bindgen_ty_2>(),
            16usize,
            concat!("Size of: ", stringify!(tcp_sock__bindgen_ty_2))
        );
        assert_eq!(
            ::core::mem::align_of::<tcp_sock__bindgen_ty_2>(),
            8usize,
            concat!("Alignment of ", stringify!(tcp_sock__bindgen_ty_2))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<tcp_sock__bindgen_ty_2>())).space as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock__bindgen_ty_2),
                "::",
                stringify!(space)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock__bindgen_ty_2>())).seq as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock__bindgen_ty_2),
                "::",
                stringify!(seq)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<tcp_sock__bindgen_ty_2>())).time as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock__bindgen_ty_2),
                "::",
                stringify!(time)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct tcp_sock__bindgen_ty_3 {
        pub probe_seq_start: _cargo_bpf_u32,
        pub probe_seq_end: _cargo_bpf_u32,
    }
    #[test]
    fn bindgen_test_layout_tcp_sock__bindgen_ty_3() {
        assert_eq!(
            ::core::mem::size_of::<tcp_sock__bindgen_ty_3>(),
            8usize,
            concat!("Size of: ", stringify!(tcp_sock__bindgen_ty_3))
        );
        assert_eq!(
            ::core::mem::align_of::<tcp_sock__bindgen_ty_3>(),
            4usize,
            concat!("Alignment of ", stringify!(tcp_sock__bindgen_ty_3))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<tcp_sock__bindgen_ty_3>())).probe_seq_start as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock__bindgen_ty_3),
                "::",
                stringify!(probe_seq_start)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<tcp_sock__bindgen_ty_3>())).probe_seq_end as *const _
                    as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock__bindgen_ty_3),
                "::",
                stringify!(probe_seq_end)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_tcp_sock() {
        assert_eq!(
            ::core::mem::size_of::<tcp_sock>(),
            2256usize,
            concat!("Size of: ", stringify!(tcp_sock))
        );
        assert_eq!(
            ::core::mem::align_of::<tcp_sock>(),
            8usize,
            concat!("Alignment of ", stringify!(tcp_sock))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).inet_conn as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(inet_conn)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).tcp_header_len as *const _ as usize },
            1408usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(tcp_header_len)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).gso_segs as *const _ as usize },
            1410usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(gso_segs)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).pred_flags as *const _ as usize },
            1412usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(pred_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).bytes_received as *const _ as usize },
            1416usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(bytes_received)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).segs_in as *const _ as usize },
            1424usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(segs_in)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).data_segs_in as *const _ as usize },
            1428usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(data_segs_in)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).rcv_nxt as *const _ as usize },
            1432usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(rcv_nxt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).copied_seq as *const _ as usize },
            1436usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(copied_seq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).rcv_wup as *const _ as usize },
            1440usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(rcv_wup)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).snd_nxt as *const _ as usize },
            1444usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(snd_nxt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).segs_out as *const _ as usize },
            1448usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(segs_out)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).data_segs_out as *const _ as usize },
            1452usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(data_segs_out)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).bytes_sent as *const _ as usize },
            1456usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(bytes_sent)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).bytes_acked as *const _ as usize },
            1464usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(bytes_acked)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).dsack_dups as *const _ as usize },
            1472usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(dsack_dups)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).snd_una as *const _ as usize },
            1476usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(snd_una)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).snd_sml as *const _ as usize },
            1480usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(snd_sml)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).rcv_tstamp as *const _ as usize },
            1484usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(rcv_tstamp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).lsndtime as *const _ as usize },
            1488usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(lsndtime)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).last_oow_ack_time as *const _ as usize },
            1492usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(last_oow_ack_time)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<tcp_sock>())).compressed_ack_rcv_nxt as *const _ as usize
            },
            1496usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(compressed_ack_rcv_nxt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).tsoffset as *const _ as usize },
            1500usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(tsoffset)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).tsq_node as *const _ as usize },
            1504usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(tsq_node)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<tcp_sock>())).tsorted_sent_queue as *const _ as usize
            },
            1520usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(tsorted_sent_queue)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).snd_wl1 as *const _ as usize },
            1536usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(snd_wl1)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).snd_wnd as *const _ as usize },
            1540usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(snd_wnd)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).max_window as *const _ as usize },
            1544usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(max_window)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).mss_cache as *const _ as usize },
            1548usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(mss_cache)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).window_clamp as *const _ as usize },
            1552usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(window_clamp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).rcv_ssthresh as *const _ as usize },
            1556usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(rcv_ssthresh)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).rack as *const _ as usize },
            1560usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(rack)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).advmss as *const _ as usize },
            1584usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(advmss)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).compressed_ack as *const _ as usize },
            1586usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(compressed_ack)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).chrono_start as *const _ as usize },
            1588usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(chrono_start)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).chrono_stat as *const _ as usize },
            1592usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(chrono_stat)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).repair_queue as *const _ as usize },
            1606usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(repair_queue)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).tlp_high_seq as *const _ as usize },
            1608usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(tlp_high_seq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).tcp_tx_delay as *const _ as usize },
            1612usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(tcp_tx_delay)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).tcp_wstamp_ns as *const _ as usize },
            1616usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(tcp_wstamp_ns)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).tcp_clock_cache as *const _ as usize },
            1624usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(tcp_clock_cache)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).tcp_mstamp as *const _ as usize },
            1632usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(tcp_mstamp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).srtt_us as *const _ as usize },
            1640usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(srtt_us)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).mdev_us as *const _ as usize },
            1644usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(mdev_us)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).mdev_max_us as *const _ as usize },
            1648usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(mdev_max_us)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).rttvar_us as *const _ as usize },
            1652usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(rttvar_us)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).rtt_seq as *const _ as usize },
            1656usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(rtt_seq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).rtt_min as *const _ as usize },
            1660usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(rtt_min)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).packets_out as *const _ as usize },
            1684usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(packets_out)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).retrans_out as *const _ as usize },
            1688usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(retrans_out)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).max_packets_out as *const _ as usize },
            1692usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(max_packets_out)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).cwnd_usage_seq as *const _ as usize },
            1696usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(cwnd_usage_seq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).urg_data as *const _ as usize },
            1700usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(urg_data)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).ecn_flags as *const _ as usize },
            1702usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(ecn_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).keepalive_probes as *const _ as usize },
            1703usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(keepalive_probes)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).reordering as *const _ as usize },
            1704usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(reordering)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).reord_seen as *const _ as usize },
            1708usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(reord_seen)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).snd_up as *const _ as usize },
            1712usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(snd_up)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).rx_opt as *const _ as usize },
            1716usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(rx_opt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).snd_ssthresh as *const _ as usize },
            1740usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(snd_ssthresh)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).snd_cwnd as *const _ as usize },
            1744usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(snd_cwnd)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).snd_cwnd_cnt as *const _ as usize },
            1748usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(snd_cwnd_cnt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).snd_cwnd_clamp as *const _ as usize },
            1752usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(snd_cwnd_clamp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).snd_cwnd_used as *const _ as usize },
            1756usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(snd_cwnd_used)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).snd_cwnd_stamp as *const _ as usize },
            1760usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(snd_cwnd_stamp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).prior_cwnd as *const _ as usize },
            1764usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(prior_cwnd)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).prr_delivered as *const _ as usize },
            1768usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(prr_delivered)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).prr_out as *const _ as usize },
            1772usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(prr_out)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).delivered as *const _ as usize },
            1776usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(delivered)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).delivered_ce as *const _ as usize },
            1780usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(delivered_ce)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).lost as *const _ as usize },
            1784usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(lost)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).app_limited as *const _ as usize },
            1788usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(app_limited)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).first_tx_mstamp as *const _ as usize },
            1792usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(first_tx_mstamp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).delivered_mstamp as *const _ as usize },
            1800usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(delivered_mstamp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).rate_delivered as *const _ as usize },
            1808usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(rate_delivered)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).rate_interval_us as *const _ as usize },
            1812usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(rate_interval_us)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).rcv_wnd as *const _ as usize },
            1816usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(rcv_wnd)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).write_seq as *const _ as usize },
            1820usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(write_seq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).notsent_lowat as *const _ as usize },
            1824usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(notsent_lowat)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).pushed_seq as *const _ as usize },
            1828usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(pushed_seq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).lost_out as *const _ as usize },
            1832usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(lost_out)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).sacked_out as *const _ as usize },
            1836usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(sacked_out)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).pacing_timer as *const _ as usize },
            1840usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(pacing_timer)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<tcp_sock>())).compressed_ack_timer as *const _ as usize
            },
            1904usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(compressed_ack_timer)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).lost_skb_hint as *const _ as usize },
            1968usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(lost_skb_hint)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<tcp_sock>())).retransmit_skb_hint as *const _ as usize
            },
            1976usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(retransmit_skb_hint)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<tcp_sock>())).out_of_order_queue as *const _ as usize
            },
            1984usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(out_of_order_queue)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).ooo_last_skb as *const _ as usize },
            1992usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(ooo_last_skb)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).duplicate_sack as *const _ as usize },
            2000usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(duplicate_sack)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).selective_acks as *const _ as usize },
            2008usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(selective_acks)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).recv_sack_cache as *const _ as usize },
            2040usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(recv_sack_cache)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).highest_sack as *const _ as usize },
            2072usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(highest_sack)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).lost_cnt_hint as *const _ as usize },
            2080usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(lost_cnt_hint)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).prior_ssthresh as *const _ as usize },
            2084usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(prior_ssthresh)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).high_seq as *const _ as usize },
            2088usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(high_seq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).retrans_stamp as *const _ as usize },
            2092usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(retrans_stamp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).undo_marker as *const _ as usize },
            2096usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(undo_marker)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).undo_retrans as *const _ as usize },
            2100usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(undo_retrans)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).bytes_retrans as *const _ as usize },
            2104usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(bytes_retrans)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).total_retrans as *const _ as usize },
            2112usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(total_retrans)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).urg_seq as *const _ as usize },
            2116usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(urg_seq)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).keepalive_time as *const _ as usize },
            2120usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(keepalive_time)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).keepalive_intvl as *const _ as usize },
            2124usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(keepalive_intvl)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).linger2 as *const _ as usize },
            2128usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(linger2)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<tcp_sock>())).bpf_sock_ops_cb_flags as *const _ as usize
            },
            2132usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(bpf_sock_ops_cb_flags)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).timeout_rehash as *const _ as usize },
            2134usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(timeout_rehash)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).rcv_ooopack as *const _ as usize },
            2136usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(rcv_ooopack)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<tcp_sock>())).rcv_rtt_last_tsecr as *const _ as usize
            },
            2140usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(rcv_rtt_last_tsecr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).rcv_rtt_est as *const _ as usize },
            2144usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(rcv_rtt_est)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).rcvq_space as *const _ as usize },
            2160usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(rcvq_space)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).mtu_probe as *const _ as usize },
            2176usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(mtu_probe)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).plb_rehash as *const _ as usize },
            2184usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(plb_rehash)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).mtu_info as *const _ as usize },
            2188usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(mtu_info)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).is_mptcp as *const _ as usize },
            2192usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(is_mptcp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).smc_hs_congested as *const _ as usize },
            2200usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(smc_hs_congested)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).syn_smc as *const _ as usize },
            2208usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(syn_smc)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).af_specific as *const _ as usize },
            2216usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(af_specific)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).md5sig_info as *const _ as usize },
            2224usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(md5sig_info)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).fastopen_req as *const _ as usize },
            2232usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(fastopen_req)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).fastopen_rsk as *const _ as usize },
            2240usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(fastopen_rsk)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_sock>())).saved_syn as *const _ as usize },
            2248usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_sock),
                "::",
                stringify!(saved_syn)
            )
        );
    }
    impl tcp_sock {
        #[inline]
        pub fn dup_ack_counter(&self) -> _cargo_bpf_u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
        }
        #[inline]
        pub fn set_dup_ack_counter(&mut self, val: _cargo_bpf_u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 2u8, val as u64)
            }
        }
        #[inline]
        pub fn tlp_retrans(&self) -> _cargo_bpf_u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_tlp_retrans(&mut self, val: _cargo_bpf_u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(2usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn unused(&self) -> _cargo_bpf_u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u8) }
        }
        #[inline]
        pub fn set_unused(&mut self, val: _cargo_bpf_u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(3usize, 5u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            dup_ack_counter: _cargo_bpf_u8,
            tlp_retrans: _cargo_bpf_u8,
            unused: _cargo_bpf_u8,
        ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 2u8, {
                let dup_ack_counter: u8 = unsafe { ::core::mem::transmute(dup_ack_counter) };
                dup_ack_counter as u64
            });
            __bindgen_bitfield_unit.set(2usize, 1u8, {
                let tlp_retrans: u8 = unsafe { ::core::mem::transmute(tlp_retrans) };
                tlp_retrans as u64
            });
            __bindgen_bitfield_unit.set(3usize, 5u8, {
                let unused: u8 = unsafe { ::core::mem::transmute(unused) };
                unused as u64
            });
            __bindgen_bitfield_unit
        }
        #[inline]
        pub fn chrono_type(&self) -> _cargo_bpf_u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 2u8) as u8) }
        }
        #[inline]
        pub fn set_chrono_type(&mut self, val: _cargo_bpf_u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(0usize, 2u8, val as u64)
            }
        }
        #[inline]
        pub fn rate_app_limited(&self) -> _cargo_bpf_u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(2usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_rate_app_limited(&mut self, val: _cargo_bpf_u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(2usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn fastopen_connect(&self) -> _cargo_bpf_u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(3usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_fastopen_connect(&mut self, val: _cargo_bpf_u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(3usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn fastopen_no_cookie(&self) -> _cargo_bpf_u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(4usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_fastopen_no_cookie(&mut self, val: _cargo_bpf_u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(4usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn is_sack_reneg(&self) -> _cargo_bpf_u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(5usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_is_sack_reneg(&mut self, val: _cargo_bpf_u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(5usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn fastopen_client_fail(&self) -> _cargo_bpf_u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(6usize, 2u8) as u8) }
        }
        #[inline]
        pub fn set_fastopen_client_fail(&mut self, val: _cargo_bpf_u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(6usize, 2u8, val as u64)
            }
        }
        #[inline]
        pub fn nonagle(&self) -> _cargo_bpf_u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(8usize, 4u8) as u8) }
        }
        #[inline]
        pub fn set_nonagle(&mut self, val: _cargo_bpf_u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(8usize, 4u8, val as u64)
            }
        }
        #[inline]
        pub fn thin_lto(&self) -> _cargo_bpf_u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(12usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_thin_lto(&mut self, val: _cargo_bpf_u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(12usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn recvmsg_inq(&self) -> _cargo_bpf_u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(13usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_recvmsg_inq(&mut self, val: _cargo_bpf_u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(13usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn repair(&self) -> _cargo_bpf_u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(14usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_repair(&mut self, val: _cargo_bpf_u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(14usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn frto(&self) -> _cargo_bpf_u8 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(15usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_frto(&mut self, val: _cargo_bpf_u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_2.set(15usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_2(
            chrono_type: _cargo_bpf_u8,
            rate_app_limited: _cargo_bpf_u8,
            fastopen_connect: _cargo_bpf_u8,
            fastopen_no_cookie: _cargo_bpf_u8,
            is_sack_reneg: _cargo_bpf_u8,
            fastopen_client_fail: _cargo_bpf_u8,
            nonagle: _cargo_bpf_u8,
            thin_lto: _cargo_bpf_u8,
            recvmsg_inq: _cargo_bpf_u8,
            repair: _cargo_bpf_u8,
            frto: _cargo_bpf_u8,
        ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 2u8, {
                let chrono_type: u8 = unsafe { ::core::mem::transmute(chrono_type) };
                chrono_type as u64
            });
            __bindgen_bitfield_unit.set(2usize, 1u8, {
                let rate_app_limited: u8 = unsafe { ::core::mem::transmute(rate_app_limited) };
                rate_app_limited as u64
            });
            __bindgen_bitfield_unit.set(3usize, 1u8, {
                let fastopen_connect: u8 = unsafe { ::core::mem::transmute(fastopen_connect) };
                fastopen_connect as u64
            });
            __bindgen_bitfield_unit.set(4usize, 1u8, {
                let fastopen_no_cookie: u8 = unsafe { ::core::mem::transmute(fastopen_no_cookie) };
                fastopen_no_cookie as u64
            });
            __bindgen_bitfield_unit.set(5usize, 1u8, {
                let is_sack_reneg: u8 = unsafe { ::core::mem::transmute(is_sack_reneg) };
                is_sack_reneg as u64
            });
            __bindgen_bitfield_unit.set(6usize, 2u8, {
                let fastopen_client_fail: u8 =
                    unsafe { ::core::mem::transmute(fastopen_client_fail) };
                fastopen_client_fail as u64
            });
            __bindgen_bitfield_unit.set(8usize, 4u8, {
                let nonagle: u8 = unsafe { ::core::mem::transmute(nonagle) };
                nonagle as u64
            });
            __bindgen_bitfield_unit.set(12usize, 1u8, {
                let thin_lto: u8 = unsafe { ::core::mem::transmute(thin_lto) };
                thin_lto as u64
            });
            __bindgen_bitfield_unit.set(13usize, 1u8, {
                let recvmsg_inq: u8 = unsafe { ::core::mem::transmute(recvmsg_inq) };
                recvmsg_inq as u64
            });
            __bindgen_bitfield_unit.set(14usize, 1u8, {
                let repair: u8 = unsafe { ::core::mem::transmute(repair) };
                repair as u64
            });
            __bindgen_bitfield_unit.set(15usize, 1u8, {
                let frto: u8 = unsafe { ::core::mem::transmute(frto) };
                frto as u64
            });
            __bindgen_bitfield_unit
        }
        #[inline]
        pub fn save_syn(&self) -> _cargo_bpf_u8 {
            unsafe { ::core::mem::transmute(self._bitfield_3.get(0usize, 2u8) as u8) }
        }
        #[inline]
        pub fn set_save_syn(&mut self, val: _cargo_bpf_u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_3.set(0usize, 2u8, val as u64)
            }
        }
        #[inline]
        pub fn syn_data(&self) -> _cargo_bpf_u8 {
            unsafe { ::core::mem::transmute(self._bitfield_3.get(2usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_syn_data(&mut self, val: _cargo_bpf_u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_3.set(2usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn syn_fastopen(&self) -> _cargo_bpf_u8 {
            unsafe { ::core::mem::transmute(self._bitfield_3.get(3usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_syn_fastopen(&mut self, val: _cargo_bpf_u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_3.set(3usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn syn_fastopen_exp(&self) -> _cargo_bpf_u8 {
            unsafe { ::core::mem::transmute(self._bitfield_3.get(4usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_syn_fastopen_exp(&mut self, val: _cargo_bpf_u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_3.set(4usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn syn_fastopen_ch(&self) -> _cargo_bpf_u8 {
            unsafe { ::core::mem::transmute(self._bitfield_3.get(5usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_syn_fastopen_ch(&mut self, val: _cargo_bpf_u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_3.set(5usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn syn_data_acked(&self) -> _cargo_bpf_u8 {
            unsafe { ::core::mem::transmute(self._bitfield_3.get(6usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_syn_data_acked(&mut self, val: _cargo_bpf_u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_3.set(6usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn is_cwnd_limited(&self) -> _cargo_bpf_u8 {
            unsafe { ::core::mem::transmute(self._bitfield_3.get(7usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_is_cwnd_limited(&mut self, val: _cargo_bpf_u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_3.set(7usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_3(
            save_syn: _cargo_bpf_u8,
            syn_data: _cargo_bpf_u8,
            syn_fastopen: _cargo_bpf_u8,
            syn_fastopen_exp: _cargo_bpf_u8,
            syn_fastopen_ch: _cargo_bpf_u8,
            syn_data_acked: _cargo_bpf_u8,
            is_cwnd_limited: _cargo_bpf_u8,
        ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 2u8, {
                let save_syn: u8 = unsafe { ::core::mem::transmute(save_syn) };
                save_syn as u64
            });
            __bindgen_bitfield_unit.set(2usize, 1u8, {
                let syn_data: u8 = unsafe { ::core::mem::transmute(syn_data) };
                syn_data as u64
            });
            __bindgen_bitfield_unit.set(3usize, 1u8, {
                let syn_fastopen: u8 = unsafe { ::core::mem::transmute(syn_fastopen) };
                syn_fastopen as u64
            });
            __bindgen_bitfield_unit.set(4usize, 1u8, {
                let syn_fastopen_exp: u8 = unsafe { ::core::mem::transmute(syn_fastopen_exp) };
                syn_fastopen_exp as u64
            });
            __bindgen_bitfield_unit.set(5usize, 1u8, {
                let syn_fastopen_ch: u8 = unsafe { ::core::mem::transmute(syn_fastopen_ch) };
                syn_fastopen_ch as u64
            });
            __bindgen_bitfield_unit.set(6usize, 1u8, {
                let syn_data_acked: u8 = unsafe { ::core::mem::transmute(syn_data_acked) };
                syn_data_acked as u64
            });
            __bindgen_bitfield_unit.set(7usize, 1u8, {
                let is_cwnd_limited: u8 = unsafe { ::core::mem::transmute(is_cwnd_limited) };
                is_cwnd_limited as u64
            });
            __bindgen_bitfield_unit
        }
        #[inline]
        pub fn bpf_chg_cc_inprogress(&self) -> _cargo_bpf_u8 {
            unsafe { ::core::mem::transmute(self._bitfield_4.get(0usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_bpf_chg_cc_inprogress(&mut self, val: _cargo_bpf_u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_4.set(0usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_4(
            bpf_chg_cc_inprogress: _cargo_bpf_u8,
        ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 1u8, {
                let bpf_chg_cc_inprogress: u8 =
                    unsafe { ::core::mem::transmute(bpf_chg_cc_inprogress) };
                bpf_chg_cc_inprogress as u64
            });
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    pub struct tcp_timewait_sock {
        pub tw_sk: inet_timewait_sock,
        pub tw_rcv_wnd: _cargo_bpf_u32,
        pub tw_ts_offset: _cargo_bpf_u32,
        pub tw_ts_recent: _cargo_bpf_u32,
        pub tw_last_oow_ack_time: _cargo_bpf_u32,
        pub tw_ts_recent_stamp: ::cty::c_int,
        pub tw_tx_delay: _cargo_bpf_u32,
        pub tw_md5_key: *mut tcp_md5sig_key,
    }
    #[test]
    fn bindgen_test_layout_tcp_timewait_sock() {
        assert_eq!(
            ::core::mem::size_of::<tcp_timewait_sock>(),
            264usize,
            concat!("Size of: ", stringify!(tcp_timewait_sock))
        );
        assert_eq!(
            ::core::mem::align_of::<tcp_timewait_sock>(),
            8usize,
            concat!("Alignment of ", stringify!(tcp_timewait_sock))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp_timewait_sock>())).tw_sk as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_timewait_sock),
                "::",
                stringify!(tw_sk)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<tcp_timewait_sock>())).tw_rcv_wnd as *const _ as usize
            },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_timewait_sock),
                "::",
                stringify!(tw_rcv_wnd)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<tcp_timewait_sock>())).tw_ts_offset as *const _ as usize
            },
            236usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_timewait_sock),
                "::",
                stringify!(tw_ts_offset)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<tcp_timewait_sock>())).tw_ts_recent as *const _ as usize
            },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_timewait_sock),
                "::",
                stringify!(tw_ts_recent)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<tcp_timewait_sock>())).tw_last_oow_ack_time as *const _
                    as usize
            },
            244usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_timewait_sock),
                "::",
                stringify!(tw_last_oow_ack_time)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<tcp_timewait_sock>())).tw_ts_recent_stamp as *const _
                    as usize
            },
            248usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_timewait_sock),
                "::",
                stringify!(tw_ts_recent_stamp)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<tcp_timewait_sock>())).tw_tx_delay as *const _ as usize
            },
            252usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_timewait_sock),
                "::",
                stringify!(tw_tx_delay)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<tcp_timewait_sock>())).tw_md5_key as *const _ as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_timewait_sock),
                "::",
                stringify!(tw_md5_key)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct udphdr {
        pub source: __be16,
        pub dest: __be16,
        pub len: __be16,
        pub check: __sum16,
    }
    #[test]
    fn bindgen_test_layout_udphdr() {
        assert_eq!(
            ::core::mem::size_of::<udphdr>(),
            8usize,
            concat!("Size of: ", stringify!(udphdr))
        );
        assert_eq!(
            ::core::mem::align_of::<udphdr>(),
            2usize,
            concat!("Alignment of ", stringify!(udphdr))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<udphdr>())).source as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(udphdr),
                "::",
                stringify!(source)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<udphdr>())).dest as *const _ as usize },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(udphdr),
                "::",
                stringify!(dest)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<udphdr>())).len as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(udphdr),
                "::",
                stringify!(len)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<udphdr>())).check as *const _ as usize },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(udphdr),
                "::",
                stringify!(check)
            )
        );
    }
    #[repr(C)]
    #[repr(align(64))]
    pub struct udp_sock {
        pub inet: inet_sock,
        pub pending: ::cty::c_int,
        pub corkflag: ::cty::c_uint,
        pub encap_type: __u8,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
        pub len: __u16,
        pub gso_size: __u16,
        pub pcslen: __u16,
        pub pcrlen: __u16,
        pub pcflag: __u8,
        pub unused: [__u8; 3usize],
        pub encap_rcv: ::core::option::Option<
            unsafe extern "C" fn(sk: *mut sock, skb: *mut sk_buff) -> ::cty::c_int,
        >,
        pub encap_err_rcv: ::core::option::Option<
            unsafe extern "C" fn(
                sk: *mut sock,
                skb: *mut sk_buff,
                err: ::cty::c_int,
                port: __be16,
                info: _cargo_bpf_u32,
                payload: *mut _cargo_bpf_u8,
            ),
        >,
        pub encap_err_lookup: ::core::option::Option<
            unsafe extern "C" fn(sk: *mut sock, skb: *mut sk_buff) -> ::cty::c_int,
        >,
        pub encap_destroy: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock)>,
        pub gro_receive: ::core::option::Option<
            unsafe extern "C" fn(
                sk: *mut sock,
                head: *mut list_head,
                skb: *mut sk_buff,
            ) -> *mut sk_buff,
        >,
        pub gro_complete: ::core::option::Option<
            unsafe extern "C" fn(
                sk: *mut sock,
                skb: *mut sk_buff,
                nhoff: ::cty::c_int,
            ) -> ::cty::c_int,
        >,
        pub __bindgen_padding_0: [u64; 2usize],
        pub reader_queue: sk_buff_head,
        pub forward_deficit: ::cty::c_int,
        pub forward_threshold: ::cty::c_int,
    }
    #[test]
    fn bindgen_test_layout_udp_sock() {
        assert_eq!(
            ::core::mem::size_of::<udp_sock>(),
            1152usize,
            concat!("Size of: ", stringify!(udp_sock))
        );
        assert_eq!(
            ::core::mem::align_of::<udp_sock>(),
            64usize,
            concat!("Alignment of ", stringify!(udp_sock))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<udp_sock>())).inet as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(udp_sock),
                "::",
                stringify!(inet)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<udp_sock>())).pending as *const _ as usize },
            1000usize,
            concat!(
                "Offset of field: ",
                stringify!(udp_sock),
                "::",
                stringify!(pending)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<udp_sock>())).corkflag as *const _ as usize },
            1004usize,
            concat!(
                "Offset of field: ",
                stringify!(udp_sock),
                "::",
                stringify!(corkflag)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<udp_sock>())).encap_type as *const _ as usize },
            1008usize,
            concat!(
                "Offset of field: ",
                stringify!(udp_sock),
                "::",
                stringify!(encap_type)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<udp_sock>())).len as *const _ as usize },
            1010usize,
            concat!(
                "Offset of field: ",
                stringify!(udp_sock),
                "::",
                stringify!(len)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<udp_sock>())).gso_size as *const _ as usize },
            1012usize,
            concat!(
                "Offset of field: ",
                stringify!(udp_sock),
                "::",
                stringify!(gso_size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<udp_sock>())).pcslen as *const _ as usize },
            1014usize,
            concat!(
                "Offset of field: ",
                stringify!(udp_sock),
                "::",
                stringify!(pcslen)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<udp_sock>())).pcrlen as *const _ as usize },
            1016usize,
            concat!(
                "Offset of field: ",
                stringify!(udp_sock),
                "::",
                stringify!(pcrlen)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<udp_sock>())).pcflag as *const _ as usize },
            1018usize,
            concat!(
                "Offset of field: ",
                stringify!(udp_sock),
                "::",
                stringify!(pcflag)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<udp_sock>())).unused as *const _ as usize },
            1019usize,
            concat!(
                "Offset of field: ",
                stringify!(udp_sock),
                "::",
                stringify!(unused)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<udp_sock>())).encap_rcv as *const _ as usize },
            1024usize,
            concat!(
                "Offset of field: ",
                stringify!(udp_sock),
                "::",
                stringify!(encap_rcv)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<udp_sock>())).encap_err_rcv as *const _ as usize },
            1032usize,
            concat!(
                "Offset of field: ",
                stringify!(udp_sock),
                "::",
                stringify!(encap_err_rcv)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<udp_sock>())).encap_err_lookup as *const _ as usize },
            1040usize,
            concat!(
                "Offset of field: ",
                stringify!(udp_sock),
                "::",
                stringify!(encap_err_lookup)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<udp_sock>())).encap_destroy as *const _ as usize },
            1048usize,
            concat!(
                "Offset of field: ",
                stringify!(udp_sock),
                "::",
                stringify!(encap_destroy)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<udp_sock>())).gro_receive as *const _ as usize },
            1056usize,
            concat!(
                "Offset of field: ",
                stringify!(udp_sock),
                "::",
                stringify!(gro_receive)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<udp_sock>())).gro_complete as *const _ as usize },
            1064usize,
            concat!(
                "Offset of field: ",
                stringify!(udp_sock),
                "::",
                stringify!(gro_complete)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<udp_sock>())).reader_queue as *const _ as usize },
            1088usize,
            concat!(
                "Offset of field: ",
                stringify!(udp_sock),
                "::",
                stringify!(reader_queue)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<udp_sock>())).forward_deficit as *const _ as usize },
            1112usize,
            concat!(
                "Offset of field: ",
                stringify!(udp_sock),
                "::",
                stringify!(forward_deficit)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<udp_sock>())).forward_threshold as *const _ as usize },
            1116usize,
            concat!(
                "Offset of field: ",
                stringify!(udp_sock),
                "::",
                stringify!(forward_threshold)
            )
        );
    }
    impl udp_sock {
        #[inline]
        pub fn no_check6_tx(&self) -> ::cty::c_uchar {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_no_check6_tx(&mut self, val: ::cty::c_uchar) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn no_check6_rx(&self) -> ::cty::c_uchar {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_no_check6_rx(&mut self, val: ::cty::c_uchar) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(1usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn encap_enabled(&self) -> ::cty::c_uchar {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_encap_enabled(&mut self, val: ::cty::c_uchar) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(2usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn gro_enabled(&self) -> ::cty::c_uchar {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_gro_enabled(&mut self, val: ::cty::c_uchar) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(3usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn accept_udp_l4(&self) -> ::cty::c_uchar {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_accept_udp_l4(&mut self, val: ::cty::c_uchar) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(4usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn accept_udp_fraglist(&self) -> ::cty::c_uchar {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_accept_udp_fraglist(&mut self, val: ::cty::c_uchar) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(5usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            no_check6_tx: ::cty::c_uchar,
            no_check6_rx: ::cty::c_uchar,
            encap_enabled: ::cty::c_uchar,
            gro_enabled: ::cty::c_uchar,
            accept_udp_l4: ::cty::c_uchar,
            accept_udp_fraglist: ::cty::c_uchar,
        ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 1u8, {
                let no_check6_tx: u8 = unsafe { ::core::mem::transmute(no_check6_tx) };
                no_check6_tx as u64
            });
            __bindgen_bitfield_unit.set(1usize, 1u8, {
                let no_check6_rx: u8 = unsafe { ::core::mem::transmute(no_check6_rx) };
                no_check6_rx as u64
            });
            __bindgen_bitfield_unit.set(2usize, 1u8, {
                let encap_enabled: u8 = unsafe { ::core::mem::transmute(encap_enabled) };
                encap_enabled as u64
            });
            __bindgen_bitfield_unit.set(3usize, 1u8, {
                let gro_enabled: u8 = unsafe { ::core::mem::transmute(gro_enabled) };
                gro_enabled as u64
            });
            __bindgen_bitfield_unit.set(4usize, 1u8, {
                let accept_udp_l4: u8 = unsafe { ::core::mem::transmute(accept_udp_l4) };
                accept_udp_l4 as u64
            });
            __bindgen_bitfield_unit.set(5usize, 1u8, {
                let accept_udp_fraglist: u8 =
                    unsafe { ::core::mem::transmute(accept_udp_fraglist) };
                accept_udp_fraglist as u64
            });
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    pub struct tcp6_request_sock {
        pub tcp6rsk_tcp: tcp_request_sock,
    }
    #[test]
    fn bindgen_test_layout_tcp6_request_sock() {
        assert_eq!(
            ::core::mem::size_of::<tcp6_request_sock>(),
            304usize,
            concat!("Size of: ", stringify!(tcp6_request_sock))
        );
        assert_eq!(
            ::core::mem::align_of::<tcp6_request_sock>(),
            8usize,
            concat!("Alignment of ", stringify!(tcp6_request_sock))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<tcp6_request_sock>())).tcp6rsk_tcp as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp6_request_sock),
                "::",
                stringify!(tcp6rsk_tcp)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ipv6_mc_socklist {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ipv6_ac_socklist {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ipv6_fl_socklist {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct inet6_cork {
        pub opt: *mut ipv6_txoptions,
        pub hop_limit: _cargo_bpf_u8,
        pub tclass: _cargo_bpf_u8,
    }
    #[test]
    fn bindgen_test_layout_inet6_cork() {
        assert_eq!(
            ::core::mem::size_of::<inet6_cork>(),
            16usize,
            concat!("Size of: ", stringify!(inet6_cork))
        );
        assert_eq!(
            ::core::mem::align_of::<inet6_cork>(),
            8usize,
            concat!("Alignment of ", stringify!(inet6_cork))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet6_cork>())).opt as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(inet6_cork),
                "::",
                stringify!(opt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet6_cork>())).hop_limit as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(inet6_cork),
                "::",
                stringify!(hop_limit)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<inet6_cork>())).tclass as *const _ as usize },
            9usize,
            concat!(
                "Offset of field: ",
                stringify!(inet6_cork),
                "::",
                stringify!(tclass)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct ipv6_pinfo {
        pub saddr: in6_addr,
        pub sticky_pktinfo: in6_pktinfo,
        pub daddr_cache: *const in6_addr,
        pub saddr_cache: *const in6_addr,
        pub flow_label: __be32,
        pub frag_size: __u32,
        pub _bitfield_align_1: [u16; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
        pub ucast_oif: ::cty::c_int,
        pub mcast_oif: ::cty::c_int,
        pub rxopt: ipv6_pinfo__bindgen_ty_1,
        pub _bitfield_align_2: [u8; 0],
        pub _bitfield_2: __BindgenBitfieldUnit<[u8; 2usize]>,
        pub min_hopcount: __u8,
        pub tclass: __u8,
        pub rcv_flowinfo: __be32,
        pub dst_cookie: __u32,
        pub ipv6_mc_list: *mut ipv6_mc_socklist,
        pub ipv6_ac_list: *mut ipv6_ac_socklist,
        pub ipv6_fl_list: *mut ipv6_fl_socklist,
        pub opt: *mut ipv6_txoptions,
        pub pktoptions: *mut sk_buff,
        pub rxpmtu: *mut sk_buff,
        pub cork: inet6_cork,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union ipv6_pinfo__bindgen_ty_1 {
        pub bits: ipv6_pinfo__bindgen_ty_1__bindgen_ty_1,
        pub all: __u16,
    }
    #[repr(C)]
    #[repr(align(2))]
    #[derive(Debug, Copy, Clone)]
    pub struct ipv6_pinfo__bindgen_ty_1__bindgen_ty_1 {
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    }
    #[test]
    fn bindgen_test_layout_ipv6_pinfo__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<ipv6_pinfo__bindgen_ty_1__bindgen_ty_1>(),
            2usize,
            concat!(
                "Size of: ",
                stringify!(ipv6_pinfo__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            ::core::mem::align_of::<ipv6_pinfo__bindgen_ty_1__bindgen_ty_1>(),
            2usize,
            concat!(
                "Alignment of ",
                stringify!(ipv6_pinfo__bindgen_ty_1__bindgen_ty_1)
            )
        );
    }
    impl ipv6_pinfo__bindgen_ty_1__bindgen_ty_1 {
        #[inline]
        pub fn srcrt(&self) -> __u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_srcrt(&mut self, val: __u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn osrcrt(&self) -> __u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_osrcrt(&mut self, val: __u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(1usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn rxinfo(&self) -> __u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_rxinfo(&mut self, val: __u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(2usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn rxoinfo(&self) -> __u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_rxoinfo(&mut self, val: __u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(3usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn rxhlim(&self) -> __u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_rxhlim(&mut self, val: __u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(4usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn rxohlim(&self) -> __u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_rxohlim(&mut self, val: __u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(5usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn hopopts(&self) -> __u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_hopopts(&mut self, val: __u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(6usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn ohopopts(&self) -> __u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_ohopopts(&mut self, val: __u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(7usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn dstopts(&self) -> __u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_dstopts(&mut self, val: __u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(8usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn odstopts(&self) -> __u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_odstopts(&mut self, val: __u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(9usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn rxflow(&self) -> __u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_rxflow(&mut self, val: __u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(10usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn rxtclass(&self) -> __u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_rxtclass(&mut self, val: __u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(11usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn rxpmtu(&self) -> __u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_rxpmtu(&mut self, val: __u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(12usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn rxorigdstaddr(&self) -> __u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_rxorigdstaddr(&mut self, val: __u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(13usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn recvfragsize(&self) -> __u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_recvfragsize(&mut self, val: __u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(14usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            srcrt: __u16,
            osrcrt: __u16,
            rxinfo: __u16,
            rxoinfo: __u16,
            rxhlim: __u16,
            rxohlim: __u16,
            hopopts: __u16,
            ohopopts: __u16,
            dstopts: __u16,
            odstopts: __u16,
            rxflow: __u16,
            rxtclass: __u16,
            rxpmtu: __u16,
            rxorigdstaddr: __u16,
            recvfragsize: __u16,
        ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 1u8, {
                let srcrt: u16 = unsafe { ::core::mem::transmute(srcrt) };
                srcrt as u64
            });
            __bindgen_bitfield_unit.set(1usize, 1u8, {
                let osrcrt: u16 = unsafe { ::core::mem::transmute(osrcrt) };
                osrcrt as u64
            });
            __bindgen_bitfield_unit.set(2usize, 1u8, {
                let rxinfo: u16 = unsafe { ::core::mem::transmute(rxinfo) };
                rxinfo as u64
            });
            __bindgen_bitfield_unit.set(3usize, 1u8, {
                let rxoinfo: u16 = unsafe { ::core::mem::transmute(rxoinfo) };
                rxoinfo as u64
            });
            __bindgen_bitfield_unit.set(4usize, 1u8, {
                let rxhlim: u16 = unsafe { ::core::mem::transmute(rxhlim) };
                rxhlim as u64
            });
            __bindgen_bitfield_unit.set(5usize, 1u8, {
                let rxohlim: u16 = unsafe { ::core::mem::transmute(rxohlim) };
                rxohlim as u64
            });
            __bindgen_bitfield_unit.set(6usize, 1u8, {
                let hopopts: u16 = unsafe { ::core::mem::transmute(hopopts) };
                hopopts as u64
            });
            __bindgen_bitfield_unit.set(7usize, 1u8, {
                let ohopopts: u16 = unsafe { ::core::mem::transmute(ohopopts) };
                ohopopts as u64
            });
            __bindgen_bitfield_unit.set(8usize, 1u8, {
                let dstopts: u16 = unsafe { ::core::mem::transmute(dstopts) };
                dstopts as u64
            });
            __bindgen_bitfield_unit.set(9usize, 1u8, {
                let odstopts: u16 = unsafe { ::core::mem::transmute(odstopts) };
                odstopts as u64
            });
            __bindgen_bitfield_unit.set(10usize, 1u8, {
                let rxflow: u16 = unsafe { ::core::mem::transmute(rxflow) };
                rxflow as u64
            });
            __bindgen_bitfield_unit.set(11usize, 1u8, {
                let rxtclass: u16 = unsafe { ::core::mem::transmute(rxtclass) };
                rxtclass as u64
            });
            __bindgen_bitfield_unit.set(12usize, 1u8, {
                let rxpmtu: u16 = unsafe { ::core::mem::transmute(rxpmtu) };
                rxpmtu as u64
            });
            __bindgen_bitfield_unit.set(13usize, 1u8, {
                let rxorigdstaddr: u16 = unsafe { ::core::mem::transmute(rxorigdstaddr) };
                rxorigdstaddr as u64
            });
            __bindgen_bitfield_unit.set(14usize, 1u8, {
                let recvfragsize: u16 = unsafe { ::core::mem::transmute(recvfragsize) };
                recvfragsize as u64
            });
            __bindgen_bitfield_unit
        }
    }
    #[test]
    fn bindgen_test_layout_ipv6_pinfo__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<ipv6_pinfo__bindgen_ty_1>(),
            2usize,
            concat!("Size of: ", stringify!(ipv6_pinfo__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<ipv6_pinfo__bindgen_ty_1>(),
            2usize,
            concat!("Alignment of ", stringify!(ipv6_pinfo__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ipv6_pinfo__bindgen_ty_1>())).bits as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_pinfo__bindgen_ty_1),
                "::",
                stringify!(bits)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<ipv6_pinfo__bindgen_ty_1>())).all as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_pinfo__bindgen_ty_1),
                "::",
                stringify!(all)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_ipv6_pinfo() {
        assert_eq!(
            ::core::mem::size_of::<ipv6_pinfo>(),
            160usize,
            concat!("Size of: ", stringify!(ipv6_pinfo))
        );
        assert_eq!(
            ::core::mem::align_of::<ipv6_pinfo>(),
            8usize,
            concat!("Alignment of ", stringify!(ipv6_pinfo))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ipv6_pinfo>())).saddr as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_pinfo),
                "::",
                stringify!(saddr)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ipv6_pinfo>())).sticky_pktinfo as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_pinfo),
                "::",
                stringify!(sticky_pktinfo)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ipv6_pinfo>())).daddr_cache as *const _ as usize },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_pinfo),
                "::",
                stringify!(daddr_cache)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ipv6_pinfo>())).saddr_cache as *const _ as usize },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_pinfo),
                "::",
                stringify!(saddr_cache)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ipv6_pinfo>())).flow_label as *const _ as usize },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_pinfo),
                "::",
                stringify!(flow_label)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ipv6_pinfo>())).frag_size as *const _ as usize },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_pinfo),
                "::",
                stringify!(frag_size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ipv6_pinfo>())).ucast_oif as *const _ as usize },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_pinfo),
                "::",
                stringify!(ucast_oif)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ipv6_pinfo>())).mcast_oif as *const _ as usize },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_pinfo),
                "::",
                stringify!(mcast_oif)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ipv6_pinfo>())).rxopt as *const _ as usize },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_pinfo),
                "::",
                stringify!(rxopt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ipv6_pinfo>())).min_hopcount as *const _ as usize },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_pinfo),
                "::",
                stringify!(min_hopcount)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ipv6_pinfo>())).tclass as *const _ as usize },
            81usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_pinfo),
                "::",
                stringify!(tclass)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ipv6_pinfo>())).rcv_flowinfo as *const _ as usize },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_pinfo),
                "::",
                stringify!(rcv_flowinfo)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ipv6_pinfo>())).dst_cookie as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_pinfo),
                "::",
                stringify!(dst_cookie)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ipv6_pinfo>())).ipv6_mc_list as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_pinfo),
                "::",
                stringify!(ipv6_mc_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ipv6_pinfo>())).ipv6_ac_list as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_pinfo),
                "::",
                stringify!(ipv6_ac_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ipv6_pinfo>())).ipv6_fl_list as *const _ as usize },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_pinfo),
                "::",
                stringify!(ipv6_fl_list)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ipv6_pinfo>())).opt as *const _ as usize },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_pinfo),
                "::",
                stringify!(opt)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ipv6_pinfo>())).pktoptions as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_pinfo),
                "::",
                stringify!(pktoptions)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ipv6_pinfo>())).rxpmtu as *const _ as usize },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_pinfo),
                "::",
                stringify!(rxpmtu)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<ipv6_pinfo>())).cork as *const _ as usize },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_pinfo),
                "::",
                stringify!(cork)
            )
        );
    }
    impl ipv6_pinfo {
        #[inline]
        pub fn __unused_1(&self) -> __u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u16) }
        }
        #[inline]
        pub fn set___unused_1(&mut self, val: __u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 7u8, val as u64)
            }
        }
        #[inline]
        pub fn hop_limit(&self) -> __s16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 9u8) as u16) }
        }
        #[inline]
        pub fn set_hop_limit(&mut self, val: __s16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(7usize, 9u8, val as u64)
            }
        }
        #[inline]
        pub fn mc_loop(&self) -> __u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_mc_loop(&mut self, val: __u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(16usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn __unused_2(&self) -> __u16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 6u8) as u16) }
        }
        #[inline]
        pub fn set___unused_2(&mut self, val: __u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(17usize, 6u8, val as u64)
            }
        }
        #[inline]
        pub fn mcast_hops(&self) -> __s16 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 9u8) as u16) }
        }
        #[inline]
        pub fn set_mcast_hops(&mut self, val: __s16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_1.set(23usize, 9u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            __unused_1: __u16,
            hop_limit: __s16,
            mc_loop: __u16,
            __unused_2: __u16,
            mcast_hops: __s16,
        ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 7u8, {
                let __unused_1: u16 = unsafe { ::core::mem::transmute(__unused_1) };
                __unused_1 as u64
            });
            __bindgen_bitfield_unit.set(7usize, 9u8, {
                let hop_limit: u16 = unsafe { ::core::mem::transmute(hop_limit) };
                hop_limit as u64
            });
            __bindgen_bitfield_unit.set(16usize, 1u8, {
                let mc_loop: u16 = unsafe { ::core::mem::transmute(mc_loop) };
                mc_loop as u64
            });
            __bindgen_bitfield_unit.set(17usize, 6u8, {
                let __unused_2: u16 = unsafe { ::core::mem::transmute(__unused_2) };
                __unused_2 as u64
            });
            __bindgen_bitfield_unit.set(23usize, 9u8, {
                let mcast_hops: u16 = unsafe { ::core::mem::transmute(mcast_hops) };
                mcast_hops as u64
            });
            __bindgen_bitfield_unit
        }
        #[inline]
        pub fn recverr(&self) -> __u16 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_recverr(&mut self, val: __u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_2.set(0usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn sndflow(&self) -> __u16 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_sndflow(&mut self, val: __u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_2.set(1usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn repflow(&self) -> __u16 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(2usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_repflow(&mut self, val: __u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_2.set(2usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn pmtudisc(&self) -> __u16 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(3usize, 3u8) as u16) }
        }
        #[inline]
        pub fn set_pmtudisc(&mut self, val: __u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_2.set(3usize, 3u8, val as u64)
            }
        }
        #[inline]
        pub fn padding(&self) -> __u16 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(6usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_padding(&mut self, val: __u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_2.set(6usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn srcprefs(&self) -> __u16 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(7usize, 3u8) as u16) }
        }
        #[inline]
        pub fn set_srcprefs(&mut self, val: __u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_2.set(7usize, 3u8, val as u64)
            }
        }
        #[inline]
        pub fn dontfrag(&self) -> __u16 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(10usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_dontfrag(&mut self, val: __u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_2.set(10usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn autoflowlabel(&self) -> __u16 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(11usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_autoflowlabel(&mut self, val: __u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_2.set(11usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn autoflowlabel_set(&self) -> __u16 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(12usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_autoflowlabel_set(&mut self, val: __u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_2.set(12usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn mc_all(&self) -> __u16 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(13usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_mc_all(&mut self, val: __u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_2.set(13usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn recverr_rfc4884(&self) -> __u16 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(14usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_recverr_rfc4884(&mut self, val: __u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_2.set(14usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn rtalert_isolate(&self) -> __u16 {
            unsafe { ::core::mem::transmute(self._bitfield_2.get(15usize, 1u8) as u16) }
        }
        #[inline]
        pub fn set_rtalert_isolate(&mut self, val: __u16) {
            unsafe {
                let val: u16 = ::core::mem::transmute(val);
                self._bitfield_2.set(15usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_2(
            recverr: __u16,
            sndflow: __u16,
            repflow: __u16,
            pmtudisc: __u16,
            padding: __u16,
            srcprefs: __u16,
            dontfrag: __u16,
            autoflowlabel: __u16,
            autoflowlabel_set: __u16,
            mc_all: __u16,
            recverr_rfc4884: __u16,
            rtalert_isolate: __u16,
        ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 1u8, {
                let recverr: u16 = unsafe { ::core::mem::transmute(recverr) };
                recverr as u64
            });
            __bindgen_bitfield_unit.set(1usize, 1u8, {
                let sndflow: u16 = unsafe { ::core::mem::transmute(sndflow) };
                sndflow as u64
            });
            __bindgen_bitfield_unit.set(2usize, 1u8, {
                let repflow: u16 = unsafe { ::core::mem::transmute(repflow) };
                repflow as u64
            });
            __bindgen_bitfield_unit.set(3usize, 3u8, {
                let pmtudisc: u16 = unsafe { ::core::mem::transmute(pmtudisc) };
                pmtudisc as u64
            });
            __bindgen_bitfield_unit.set(6usize, 1u8, {
                let padding: u16 = unsafe { ::core::mem::transmute(padding) };
                padding as u64
            });
            __bindgen_bitfield_unit.set(7usize, 3u8, {
                let srcprefs: u16 = unsafe { ::core::mem::transmute(srcprefs) };
                srcprefs as u64
            });
            __bindgen_bitfield_unit.set(10usize, 1u8, {
                let dontfrag: u16 = unsafe { ::core::mem::transmute(dontfrag) };
                dontfrag as u64
            });
            __bindgen_bitfield_unit.set(11usize, 1u8, {
                let autoflowlabel: u16 = unsafe { ::core::mem::transmute(autoflowlabel) };
                autoflowlabel as u64
            });
            __bindgen_bitfield_unit.set(12usize, 1u8, {
                let autoflowlabel_set: u16 = unsafe { ::core::mem::transmute(autoflowlabel_set) };
                autoflowlabel_set as u64
            });
            __bindgen_bitfield_unit.set(13usize, 1u8, {
                let mc_all: u16 = unsafe { ::core::mem::transmute(mc_all) };
                mc_all as u64
            });
            __bindgen_bitfield_unit.set(14usize, 1u8, {
                let recverr_rfc4884: u16 = unsafe { ::core::mem::transmute(recverr_rfc4884) };
                recverr_rfc4884 as u64
            });
            __bindgen_bitfield_unit.set(15usize, 1u8, {
                let rtalert_isolate: u16 = unsafe { ::core::mem::transmute(rtalert_isolate) };
                rtalert_isolate as u64
            });
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[repr(align(64))]
    pub struct udp6_sock {
        pub udp: udp_sock,
        pub inet6: ipv6_pinfo,
    }
    #[test]
    fn bindgen_test_layout_udp6_sock() {
        assert_eq!(
            ::core::mem::size_of::<udp6_sock>(),
            1344usize,
            concat!("Size of: ", stringify!(udp6_sock))
        );
        assert_eq!(
            ::core::mem::align_of::<udp6_sock>(),
            64usize,
            concat!("Alignment of ", stringify!(udp6_sock))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<udp6_sock>())).udp as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(udp6_sock),
                "::",
                stringify!(udp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<udp6_sock>())).inet6 as *const _ as usize },
            1152usize,
            concat!(
                "Offset of field: ",
                stringify!(udp6_sock),
                "::",
                stringify!(inet6)
            )
        );
    }
    #[repr(C)]
    pub struct tcp6_sock {
        pub tcp: tcp_sock,
        pub inet6: ipv6_pinfo,
    }
    #[test]
    fn bindgen_test_layout_tcp6_sock() {
        assert_eq!(
            ::core::mem::size_of::<tcp6_sock>(),
            2416usize,
            concat!("Size of: ", stringify!(tcp6_sock))
        );
        assert_eq!(
            ::core::mem::align_of::<tcp6_sock>(),
            8usize,
            concat!("Alignment of ", stringify!(tcp6_sock))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp6_sock>())).tcp as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp6_sock),
                "::",
                stringify!(tcp)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<tcp6_sock>())).inet6 as *const _ as usize },
            2256usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp6_sock),
                "::",
                stringify!(inet6)
            )
        );
    }
    #[repr(C)]
    pub struct tcp6_timewait_sock {
        pub tcp6tw_tcp: tcp_timewait_sock,
    }
    #[test]
    fn bindgen_test_layout_tcp6_timewait_sock() {
        assert_eq!(
            ::core::mem::size_of::<tcp6_timewait_sock>(),
            264usize,
            concat!("Size of: ", stringify!(tcp6_timewait_sock))
        );
        assert_eq!(
            ::core::mem::align_of::<tcp6_timewait_sock>(),
            8usize,
            concat!("Alignment of ", stringify!(tcp6_timewait_sock))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<tcp6_timewait_sock>())).tcp6tw_tcp as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp6_timewait_sock),
                "::",
                stringify!(tcp6tw_tcp)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct iphdr {
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
        pub tos: __u8,
        pub tot_len: __be16,
        pub id: __be16,
        pub frag_off: __be16,
        pub ttl: __u8,
        pub protocol: __u8,
        pub check: __sum16,
        pub __bindgen_anon_1: iphdr__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union iphdr__bindgen_ty_1 {
        pub __bindgen_anon_1: iphdr__bindgen_ty_1__bindgen_ty_1,
        pub addrs: iphdr__bindgen_ty_1__bindgen_ty_2,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct iphdr__bindgen_ty_1__bindgen_ty_1 {
        pub saddr: __be32,
        pub daddr: __be32,
    }
    #[test]
    fn bindgen_test_layout_iphdr__bindgen_ty_1__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<iphdr__bindgen_ty_1__bindgen_ty_1>(),
            8usize,
            concat!("Size of: ", stringify!(iphdr__bindgen_ty_1__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<iphdr__bindgen_ty_1__bindgen_ty_1>(),
            4usize,
            concat!(
                "Alignment of ",
                stringify!(iphdr__bindgen_ty_1__bindgen_ty_1)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<iphdr__bindgen_ty_1__bindgen_ty_1>())).saddr as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(iphdr__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(saddr)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<iphdr__bindgen_ty_1__bindgen_ty_1>())).daddr as *const _
                    as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(iphdr__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(daddr)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct iphdr__bindgen_ty_1__bindgen_ty_2 {
        pub saddr: __be32,
        pub daddr: __be32,
    }
    #[test]
    fn bindgen_test_layout_iphdr__bindgen_ty_1__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<iphdr__bindgen_ty_1__bindgen_ty_2>(),
            8usize,
            concat!("Size of: ", stringify!(iphdr__bindgen_ty_1__bindgen_ty_2))
        );
        assert_eq!(
            ::core::mem::align_of::<iphdr__bindgen_ty_1__bindgen_ty_2>(),
            4usize,
            concat!(
                "Alignment of ",
                stringify!(iphdr__bindgen_ty_1__bindgen_ty_2)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<iphdr__bindgen_ty_1__bindgen_ty_2>())).saddr as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(iphdr__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(saddr)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<iphdr__bindgen_ty_1__bindgen_ty_2>())).daddr as *const _
                    as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(iphdr__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(daddr)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_iphdr__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<iphdr__bindgen_ty_1>(),
            8usize,
            concat!("Size of: ", stringify!(iphdr__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<iphdr__bindgen_ty_1>(),
            4usize,
            concat!("Alignment of ", stringify!(iphdr__bindgen_ty_1))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<iphdr__bindgen_ty_1>())).addrs as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(iphdr__bindgen_ty_1),
                "::",
                stringify!(addrs)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_iphdr() {
        assert_eq!(
            ::core::mem::size_of::<iphdr>(),
            20usize,
            concat!("Size of: ", stringify!(iphdr))
        );
        assert_eq!(
            ::core::mem::align_of::<iphdr>(),
            4usize,
            concat!("Alignment of ", stringify!(iphdr))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<iphdr>())).tos as *const _ as usize },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(iphdr),
                "::",
                stringify!(tos)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<iphdr>())).tot_len as *const _ as usize },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(iphdr),
                "::",
                stringify!(tot_len)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<iphdr>())).id as *const _ as usize },
            4usize,
            concat!("Offset of field: ", stringify!(iphdr), "::", stringify!(id))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<iphdr>())).frag_off as *const _ as usize },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(iphdr),
                "::",
                stringify!(frag_off)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<iphdr>())).ttl as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(iphdr),
                "::",
                stringify!(ttl)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<iphdr>())).protocol as *const _ as usize },
            9usize,
            concat!(
                "Offset of field: ",
                stringify!(iphdr),
                "::",
                stringify!(protocol)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<iphdr>())).check as *const _ as usize },
            10usize,
            concat!(
                "Offset of field: ",
                stringify!(iphdr),
                "::",
                stringify!(check)
            )
        );
    }
    impl iphdr {
        #[inline]
        pub fn ihl(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
        }
        #[inline]
        pub fn set_ihl(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 4u8, val as u64)
            }
        }
        #[inline]
        pub fn version(&self) -> __u8 {
            unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
        }
        #[inline]
        pub fn set_version(&mut self, val: __u8) {
            unsafe {
                let val: u8 = ::core::mem::transmute(val);
                self._bitfield_1.set(4usize, 4u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(ihl: __u8, version: __u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
            let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 4u8, {
                let ihl: u8 = unsafe { ::core::mem::transmute(ihl) };
                ihl as u64
            });
            __bindgen_bitfield_unit.set(4usize, 4u8, {
                let version: u8 = unsafe { ::core::mem::transmute(version) };
                version as u64
            });
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct bpf_iter__task {
        pub __bindgen_anon_1: bpf_iter__task__bindgen_ty_1,
        pub __bindgen_anon_2: bpf_iter__task__bindgen_ty_2,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union bpf_iter__task__bindgen_ty_1 {
        pub meta: *mut bpf_iter_meta,
    }
    #[test]
    fn bindgen_test_layout_bpf_iter__task__bindgen_ty_1() {
        assert_eq!(
            ::core::mem::size_of::<bpf_iter__task__bindgen_ty_1>(),
            8usize,
            concat!("Size of: ", stringify!(bpf_iter__task__bindgen_ty_1))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_iter__task__bindgen_ty_1>(),
            8usize,
            concat!("Alignment of ", stringify!(bpf_iter__task__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_iter__task__bindgen_ty_1>())).meta as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_iter__task__bindgen_ty_1),
                "::",
                stringify!(meta)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union bpf_iter__task__bindgen_ty_2 {
        pub task: *mut task_struct,
    }
    #[test]
    fn bindgen_test_layout_bpf_iter__task__bindgen_ty_2() {
        assert_eq!(
            ::core::mem::size_of::<bpf_iter__task__bindgen_ty_2>(),
            8usize,
            concat!("Size of: ", stringify!(bpf_iter__task__bindgen_ty_2))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_iter__task__bindgen_ty_2>(),
            8usize,
            concat!("Alignment of ", stringify!(bpf_iter__task__bindgen_ty_2))
        );
        assert_eq!(
            unsafe {
                &(*(::core::ptr::null::<bpf_iter__task__bindgen_ty_2>())).task as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_iter__task__bindgen_ty_2),
                "::",
                stringify!(task)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_bpf_iter__task() {
        assert_eq!(
            ::core::mem::size_of::<bpf_iter__task>(),
            16usize,
            concat!("Size of: ", stringify!(bpf_iter__task))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_iter__task>(),
            8usize,
            concat!("Alignment of ", stringify!(bpf_iter__task))
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_perf_event_data {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_map_def {
        pub type_: ::cty::c_uint,
        pub key_size: ::cty::c_uint,
        pub value_size: ::cty::c_uint,
        pub max_entries: ::cty::c_uint,
        pub map_flags: ::cty::c_uint,
    }
    #[test]
    fn bindgen_test_layout_bpf_map_def() {
        assert_eq!(
            ::core::mem::size_of::<bpf_map_def>(),
            20usize,
            concat!("Size of: ", stringify!(bpf_map_def))
        );
        assert_eq!(
            ::core::mem::align_of::<bpf_map_def>(),
            4usize,
            concat!("Alignment of ", stringify!(bpf_map_def))
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_map_def>())).type_ as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_map_def),
                "::",
                stringify!(type_)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_map_def>())).key_size as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_map_def),
                "::",
                stringify!(key_size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_map_def>())).value_size as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_map_def),
                "::",
                stringify!(value_size)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_map_def>())).max_entries as *const _ as usize },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_map_def),
                "::",
                stringify!(max_entries)
            )
        );
        assert_eq!(
            unsafe { &(*(::core::ptr::null::<bpf_map_def>())).map_flags as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(bpf_map_def),
                "::",
                stringify!(map_flags)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct static_key_mod {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct static_call_mod {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct sched_class {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct files_struct {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct rt_mutex_waiter {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct numa_group {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ftrace_ret_stack {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct gendisk {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct mptcp_mib {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct udp_table {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ip_ra_chain {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct inet_peer_base {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct fib6_info {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct rt6_info {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct rt6_statistics {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct fib6_table {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct seg6_pernet_data {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ioam6_pernet_data {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct uprobe {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ldt_struct {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct userfaultfd_ctx {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct linux_binfmt {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct mmu_notifier_subscriptions {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nf_hook_entries {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nf_ct_event_notifier {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct memory_tier {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct assoc_array_ptr {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct watch_list {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct key_user {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct tty_struct {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct autogroup {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct tty_audit_buf {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct wait_page_queue {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct file_lock_context {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cdev {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct xattr_handler {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct fscrypt_keyring {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct unicode_map {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct mtd_info {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct kernfs_root {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dev_pm_qos {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct module_param_attrs {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct kernel_symbol {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct module_sect_attrs {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct module_notes_attrs {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct trace_event_call {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct trace_eval_map {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct of_device_id {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct acpi_device_id {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dma_map_ops {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bus_dma_region {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct io_tlb_mem {
        pub _address: u8,
    }
    pub type dev_dma_attr = i32;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct time_namespace {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Qdisc {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct xsk_buff_pool {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_offloaded_map {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct iw_handler_def {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct iw_public_data {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ndisc_ops {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct in_device {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct inet6_dev {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct vlan_info {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct tipc_bearer {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct mctp_dev {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct mini_Qdisc {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cpu_rmap {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct pcpu_dstats {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct garp_port {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct mrp_port {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dm_hw_stat_delta {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct devlink_port {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct disk_stats {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct blk_holder_ops {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct partition_meta_info {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct blkcg_gq {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct swap_iocb {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bio_alloc_cache {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct uncached_list {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct lwtunnel_state {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct sock_reuseport {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct ipv6_txoptions {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct tcp_ulp_ops {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct tcp_sock_af_ops {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct tcp_md5sig_info {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct tcp_fastopen_request {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct tcp_md5sig_key {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct bpf_iter_meta {
        pub _address: u8,
    }
    use crate::helpers::bpf_probe_read;
    #[doc = r" Auto-generated read-accessors by cargo_bpf::accessors::generate_read_accessors"]
    impl sockaddr {
        pub fn sa_data_min(&self) -> Option<__BindgenUnionField<[::cty::c_char; 14usize]>> {
            unsafe { bpf_probe_read(&self.__bindgen_anon_1.sa_data_min) }.ok()
        }
        pub fn bindgen_union_field(&self) -> Option<[u8; 14usize]> {
            unsafe { bpf_probe_read(&self.__bindgen_anon_1.bindgen_union_field) }.ok()
        }
        pub fn sa_family(&self) -> Option<sa_family_t> {
            unsafe { bpf_probe_read(&self.sa_family) }.ok()
        }
    }
    #[doc = r" Auto-generated read-accessors by cargo_bpf::accessors::generate_read_accessors"]
    impl inode {
        pub fn i_mapping(&self) -> Option<*mut address_space> {
            let v = unsafe { bpf_probe_read(&self.i_mapping) }.ok()?;
            if v.is_null() {
                None
            } else {
                Some(v)
            }
        }
        pub fn i_uid(&self) -> Option<kuid_t> {
            unsafe { bpf_probe_read(&self.i_uid) }.ok()
        }
        pub fn i_version(&self) -> Option<atomic64_t> {
            unsafe { bpf_probe_read(&self.i_version) }.ok()
        }
        pub fn i_bytes(&self) -> Option<::cty::c_ushort> {
            unsafe { bpf_probe_read(&self.i_bytes) }.ok()
        }
        pub fn i_write_hint(&self) -> Option<_cargo_bpf_u8> {
            unsafe { bpf_probe_read(&self.i_write_hint) }.ok()
        }
        pub fn i_count(&self) -> Option<atomic_t> {
            unsafe { bpf_probe_read(&self.i_count) }.ok()
        }
        pub fn i_acl(&self) -> Option<*mut posix_acl> {
            let v = unsafe { bpf_probe_read(&self.i_acl) }.ok()?;
            if v.is_null() {
                None
            } else {
                Some(v)
            }
        }
        pub fn i_wb(&self) -> Option<*mut bdi_writeback> {
            let v = unsafe { bpf_probe_read(&self.i_wb) }.ok()?;
            if v.is_null() {
                None
            } else {
                Some(v)
            }
        }
        pub fn i_rdev(&self) -> Option<dev_t> {
            unsafe { bpf_probe_read(&self.i_rdev) }.ok()
        }
        pub fn i_private(&self) -> Option<*mut ::cty::c_void> {
            let v = unsafe { bpf_probe_read(&self.i_private) }.ok()?;
            if v.is_null() {
                None
            } else {
                Some(v)
            }
        }
        pub fn i_mode(&self) -> Option<umode_t> {
            unsafe { bpf_probe_read(&self.i_mode) }.ok()
        }
        pub fn i_gid(&self) -> Option<kgid_t> {
            unsafe { bpf_probe_read(&self.i_gid) }.ok()
        }
        pub fn i_default_acl(&self) -> Option<*mut posix_acl> {
            let v = unsafe { bpf_probe_read(&self.i_default_acl) }.ok()?;
            if v.is_null() {
                None
            } else {
                Some(v)
            }
        }
        pub fn i_nlink(&self) -> Option<::cty::c_uint> {
            unsafe { bpf_probe_read(&self.__bindgen_anon_1.i_nlink) }.ok()
        }
        pub fn __i_nlink(&self) -> Option<::cty::c_uint> {
            unsafe { bpf_probe_read(&self.__bindgen_anon_1.__i_nlink) }.ok()
        }
        pub fn i_readcount(&self) -> Option<atomic_t> {
            unsafe { bpf_probe_read(&self.i_readcount) }.ok()
        }
        pub fn i_lock(&self) -> Option<spinlock_t> {
            unsafe { bpf_probe_read(&self.i_lock) }.ok()
        }
        pub fn i_opflags(&self) -> Option<::cty::c_ushort> {
            unsafe { bpf_probe_read(&self.i_opflags) }.ok()
        }
        pub fn i_flctx(&self) -> Option<*mut file_lock_context> {
            let v = unsafe { bpf_probe_read(&self.i_flctx) }.ok()?;
            if v.is_null() {
                None
            } else {
                Some(v)
            }
        }
        pub fn i_rwsem(&self) -> Option<rw_semaphore> {
            unsafe { bpf_probe_read(&self.i_rwsem) }.ok()
        }
        pub fn i_fsnotify_marks(&self) -> Option<*mut fsnotify_mark_connector> {
            let v = unsafe { bpf_probe_read(&self.i_fsnotify_marks) }.ok()?;
            if v.is_null() {
                None
            } else {
                Some(v)
            }
        }
        pub fn i_ino(&self) -> Option<::cty::c_ulong> {
            unsafe { bpf_probe_read(&self.i_ino) }.ok()
        }
        pub fn i_atime(&self) -> Option<timespec64> {
            unsafe { bpf_probe_read(&self.i_atime) }.ok()
        }
        pub fn i_devices(&self) -> Option<list_head> {
            unsafe { bpf_probe_read(&self.i_devices) }.ok()
        }
        pub fn i_security(&self) -> Option<*mut ::cty::c_void> {
            let v = unsafe { bpf_probe_read(&self.i_security) }.ok()?;
            if v.is_null() {
                None
            } else {
                Some(v)
            }
        }
        pub fn i_state(&self) -> Option<::cty::c_ulong> {
            unsafe { bpf_probe_read(&self.i_state) }.ok()
        }
        pub fn i_blkbits(&self) -> Option<_cargo_bpf_u8> {
            unsafe { bpf_probe_read(&self.i_blkbits) }.ok()
        }
        pub fn i_sequence(&self) -> Option<atomic64_t> {
            unsafe { bpf_probe_read(&self.i_sequence) }.ok()
        }
        pub fn i_pipe(&self) -> Option<*mut pipe_inode_info> {
            let v = unsafe { bpf_probe_read(&self.__bindgen_anon_4.i_pipe) }.ok()?;
            if v.is_null() {
                None
            } else {
                Some(v)
            }
        }
        pub fn i_wb_frn_avg_time(&self) -> Option<_cargo_bpf_u16> {
            unsafe { bpf_probe_read(&self.i_wb_frn_avg_time) }.ok()
        }
        pub fn i_dentry(&self) -> Option<hlist_head> {
            unsafe { bpf_probe_read(&self.__bindgen_anon_2.i_dentry) }.ok()
        }
        pub fn i_link(&self) -> Option<*mut ::cty::c_char> {
            let v = unsafe { bpf_probe_read(&self.__bindgen_anon_4.i_link) }.ok()?;
            if v.is_null() {
                None
            } else {
                Some(v)
            }
        }
        pub fn i_fsnotify_mask(&self) -> Option<__u32> {
            unsafe { bpf_probe_read(&self.i_fsnotify_mask) }.ok()
        }
        pub fn i_io_list(&self) -> Option<list_head> {
            unsafe { bpf_probe_read(&self.i_io_list) }.ok()
        }
        pub fn i_fop(&self) -> Option<*const file_operations> {
            let v = unsafe { bpf_probe_read(&self.__bindgen_anon_3.i_fop) }.ok()?;
            if v.is_null() {
                None
            } else {
                Some(v)
            }
        }
        pub fn i_size(&self) -> Option<loff_t> {
            unsafe { bpf_probe_read(&self.i_size) }.ok()
        }
        pub fn i_ctime(&self) -> Option<timespec64> {
            unsafe { bpf_probe_read(&self.i_ctime) }.ok()
        }
        pub fn i_wb_frn_history(&self) -> Option<_cargo_bpf_u16> {
            unsafe { bpf_probe_read(&self.i_wb_frn_history) }.ok()
        }
        pub fn i_verity_info(&self) -> Option<*mut fsverity_info> {
            let v = unsafe { bpf_probe_read(&self.i_verity_info) }.ok()?;
            if v.is_null() {
                None
            } else {
                Some(v)
            }
        }
        pub fn dirtied_when(&self) -> Option<::cty::c_ulong> {
            unsafe { bpf_probe_read(&self.dirtied_when) }.ok()
        }
        pub fn i_mtime(&self) -> Option<timespec64> {
            unsafe { bpf_probe_read(&self.i_mtime) }.ok()
        }
        pub fn i_dir_seq(&self) -> Option<::cty::c_uint> {
            unsafe { bpf_probe_read(&self.__bindgen_anon_4.i_dir_seq) }.ok()
        }
        pub fn i_lru(&self) -> Option<list_head> {
            unsafe { bpf_probe_read(&self.i_lru) }.ok()
        }
        pub fn i_wb_frn_winner(&self) -> Option<::cty::c_int> {
            unsafe { bpf_probe_read(&self.i_wb_frn_winner) }.ok()
        }
        pub fn i_sb(&self) -> Option<*mut super_block> {
            let v = unsafe { bpf_probe_read(&self.i_sb) }.ok()?;
            if v.is_null() {
                None
            } else {
                Some(v)
            }
        }
        pub fn i_wb_list(&self) -> Option<list_head> {
            unsafe { bpf_probe_read(&self.i_wb_list) }.ok()
        }
        pub fn dirtied_time_when(&self) -> Option<::cty::c_ulong> {
            unsafe { bpf_probe_read(&self.dirtied_time_when) }.ok()
        }
        pub fn i_sb_list(&self) -> Option<list_head> {
            unsafe { bpf_probe_read(&self.i_sb_list) }.ok()
        }
        pub fn i_hash(&self) -> Option<hlist_node> {
            unsafe { bpf_probe_read(&self.i_hash) }.ok()
        }
        pub fn i_writecount(&self) -> Option<atomic_t> {
            unsafe { bpf_probe_read(&self.i_writecount) }.ok()
        }
        pub fn i_blocks(&self) -> Option<blkcnt_t> {
            unsafe { bpf_probe_read(&self.i_blocks) }.ok()
        }
        pub fn i_dio_count(&self) -> Option<atomic_t> {
            unsafe { bpf_probe_read(&self.i_dio_count) }.ok()
        }
        pub fn free_inode(
            &self,
        ) -> Option<::core::option::Option<unsafe extern "C" fn(arg1: *mut inode)>> {
            unsafe { bpf_probe_read(&self.__bindgen_anon_3.free_inode) }.ok()
        }
        pub fn i_generation(&self) -> Option<__u32> {
            unsafe { bpf_probe_read(&self.i_generation) }.ok()
        }
        pub fn i_crypt_info(&self) -> Option<*mut fscrypt_info> {
            let v = unsafe { bpf_probe_read(&self.i_crypt_info) }.ok()?;
            if v.is_null() {
                None
            } else {
                Some(v)
            }
        }
        pub fn i_data(&self) -> Option<address_space> {
            unsafe { bpf_probe_read(&self.i_data) }.ok()
        }
        pub fn i_op(&self) -> Option<*const inode_operations> {
            let v = unsafe { bpf_probe_read(&self.i_op) }.ok()?;
            if v.is_null() {
                None
            } else {
                Some(v)
            }
        }
        pub fn i_flags(&self) -> Option<::cty::c_uint> {
            unsafe { bpf_probe_read(&self.i_flags) }.ok()
        }
        pub fn i_rcu(&self) -> Option<callback_head> {
            unsafe { bpf_probe_read(&self.__bindgen_anon_2.i_rcu) }.ok()
        }
        pub fn i_cdev(&self) -> Option<*mut cdev> {
            let v = unsafe { bpf_probe_read(&self.__bindgen_anon_4.i_cdev) }.ok()?;
            if v.is_null() {
                None
            } else {
                Some(v)
            }
        }
    }
    #[doc = r" Auto-generated read-accessors by cargo_bpf::accessors::generate_read_accessors"]
    impl sock {
        pub fn skc_window_clamp(&self) -> Option<_cargo_bpf_u32> {
            unsafe { bpf_probe_read(&self.__sk_common.__bindgen_anon_8.skc_window_clamp) }.ok()
        }
        pub fn sk_destruct(
            &self,
        ) -> Option<::core::option::Option<unsafe extern "C" fn(sk: *mut sock)>> {
            unsafe { bpf_probe_read(&self.sk_destruct) }.ok()
        }
        pub fn skc_dport(&self) -> Option<__be16> {
            unsafe { bpf_probe_read(&self.__sk_common.__bindgen_anon_3.__bindgen_anon_1.skc_dport) }
                .ok()
        }
        pub fn sk_txrehash(&self) -> Option<_cargo_bpf_u8> {
            unsafe { bpf_probe_read(&self.sk_txrehash) }.ok()
        }
        pub fn sk_rcvbuf(&self) -> Option<::cty::c_int> {
            unsafe { bpf_probe_read(&self.sk_rcvbuf) }.ok()
        }
        pub fn sk_lock(&self) -> Option<socket_lock_t> {
            unsafe { bpf_probe_read(&self.sk_lock) }.ok()
        }
        pub fn sk_filter(&self) -> Option<*mut sk_filter> {
            let v = unsafe { bpf_probe_read(&self.sk_filter) }.ok()?;
            if v.is_null() {
                None
            } else {
                Some(v)
            }
        }
        pub fn sk_write_pending(&self) -> Option<::cty::c_int> {
            unsafe { bpf_probe_read(&self.sk_write_pending) }.ok()
        }
        pub fn skc_portpair(&self) -> Option<__portpair> {
            unsafe { bpf_probe_read(&self.__sk_common.__bindgen_anon_3.skc_portpair) }.ok()
        }
        pub fn skc_net(&self) -> Option<possible_net_t> {
            unsafe { bpf_probe_read(&self.__sk_common.skc_net) }.ok()
        }
        pub fn sk_dst_cache(&self) -> Option<*mut dst_entry> {
            let v = unsafe { bpf_probe_read(&self.sk_dst_cache) }.ok()?;
            if v.is_null() {
                None
            } else {
                Some(v)
            }
        }
        pub fn sk_busy_poll_budget(&self) -> Option<_cargo_bpf_u16> {
            unsafe { bpf_probe_read(&self.sk_busy_poll_budget) }.ok()
        }
        pub fn skc_bound_dev_if(&self) -> Option<::cty::c_int> {
            unsafe { bpf_probe_read(&self.__sk_common.skc_bound_dev_if) }.ok()
        }
        pub fn sk_peek_off(&self) -> Option<__s32> {
            unsafe { bpf_probe_read(&self.sk_peek_off) }.ok()
        }
        pub fn tcp_rtx_queue(&self) -> Option<rb_root> {
            unsafe { bpf_probe_read(&self.__bindgen_anon_2.tcp_rtx_queue) }.ok()
        }
        pub fn sk_rx_dst_cookie(&self) -> Option<_cargo_bpf_u32> {
            unsafe { bpf_probe_read(&self.sk_rx_dst_cookie) }.ok()
        }
        pub fn sk_pacing_rate(&self) -> Option<::cty::c_ulong> {
            unsafe { bpf_probe_read(&self.sk_pacing_rate) }.ok()
        }
        pub fn sk_wmem_alloc(&self) -> Option<refcount_t> {
            unsafe { bpf_probe_read(&self.sk_wmem_alloc) }.ok()
        }
        pub fn sk_frag(&self) -> Option<page_frag> {
            unsafe { bpf_probe_read(&self.sk_frag) }.ok()
        }
        pub fn sk_memcg(&self) -> Option<*mut mem_cgroup> {
            let v = unsafe { bpf_probe_read(&self.sk_memcg) }.ok()?;
            if v.is_null() {
                None
            } else {
                Some(v)
            }
        }
        pub fn sk_mark(&self) -> Option<__u32> {
            unsafe { bpf_probe_read(&self.sk_mark) }.ok()
        }
        pub fn sk_protocol(&self) -> Option<_cargo_bpf_u16> {
            unsafe { bpf_probe_read(&self.sk_protocol) }.ok()
        }
        pub fn sk_tsq_flags(&self) -> Option<::cty::c_ulong> {
            unsafe { bpf_probe_read(&self.sk_tsq_flags) }.ok()
        }
        pub fn sk_wait_pending(&self) -> Option<::cty::c_int> {
            unsafe { bpf_probe_read(&self.sk_wait_pending) }.ok()
        }
        pub fn sk_max_ack_backlog(&self) -> Option<_cargo_bpf_u32> {
            unsafe { bpf_probe_read(&self.sk_max_ack_backlog) }.ok()
        }
        pub fn sk_txhash(&self) -> Option<__u32> {
            unsafe { bpf_probe_read(&self.sk_txhash) }.ok()
        }
        pub fn sk_pacing_status(&self) -> Option<_cargo_bpf_u32> {
            unsafe { bpf_probe_read(&self.sk_pacing_status) }.ok()
        }
        pub fn sk_tsflags(&self) -> Option<_cargo_bpf_u32> {
            unsafe { bpf_probe_read(&self.sk_tsflags) }.ok()
        }
        pub fn skc_node(&self) -> Option<hlist_node> {
            unsafe { bpf_probe_read(&self.__sk_common.__bindgen_anon_6.skc_node) }.ok()
        }
        pub fn sk_gso_max_segs(&self) -> Option<_cargo_bpf_u16> {
            unsafe { bpf_probe_read(&self.sk_gso_max_segs) }.ok()
        }
        pub fn sk_err_soft(&self) -> Option<::cty::c_int> {
            unsafe { bpf_probe_read(&self.sk_err_soft) }.ok()
        }
        pub fn skc_tw_dr(&self) -> Option<*mut inet_timewait_death_row> {
            let v = unsafe { bpf_probe_read(&self.__sk_common.__bindgen_anon_5.skc_tw_dr) }.ok()?;
            if v.is_null() {
                None
            } else {
                Some(v)
            }
        }
        pub fn sk_prefer_busy_poll(&self) -> Option<_cargo_bpf_u8> {
            unsafe { bpf_probe_read(&self.sk_prefer_busy_poll) }.ok()
        }
        pub fn sk_bpf_storage(&self) -> Option<*mut bpf_local_storage> {
            let v = unsafe { bpf_probe_read(&self.sk_bpf_storage) }.ok()?;
            if v.is_null() {
                None
            } else {
                Some(v)
            }
        }
        pub fn sk_backlog(&self) -> Option<sock__bindgen_ty_1> {
            unsafe { bpf_probe_read(&self.sk_backlog) }.ok()
        }
        pub fn sk_security(&self) -> Option<*mut ::cty::c_void> {
            let v = unsafe { bpf_probe_read(&self.sk_security) }.ok()?;
            if v.is_null() {
                None
            } else {
                Some(v)
            }
        }
        pub fn sk_uid(&self) -> Option<kuid_t> {
            unsafe { bpf_probe_read(&self.sk_uid) }.ok()
        }
        pub fn sk_prot_creator(&self) -> Option<*mut proto> {
            let v = unsafe { bpf_probe_read(&self.sk_prot_creator) }.ok()?;
            if v.is_null() {
                None
            } else {
                Some(v)
            }
        }
        pub fn skc_tx_queue_mapping(&self) -> Option<::cty::c_ushort> {
            unsafe { bpf_probe_read(&self.__sk_common.skc_tx_queue_mapping) }.ok()
        }
        pub fn skc_cookie(&self) -> Option<atomic64_t> {
            unsafe { bpf_probe_read(&self.__sk_common.skc_cookie) }.ok()
        }
        pub fn sk_priority(&self) -> Option<__u32> {
            unsafe { bpf_probe_read(&self.sk_priority) }.ok()
        }
        pub fn skc_prot(&self) -> Option<*mut proto> {
            let v = unsafe { bpf_probe_read(&self.__sk_common.skc_prot) }.ok()?;
            if v.is_null() {
                None
            } else {
                Some(v)
            }
        }
        pub fn sk_type(&self) -> Option<_cargo_bpf_u16> {
            unsafe { bpf_probe_read(&self.sk_type) }.ok()
        }
        pub fn sk_peer_cred(&self) -> Option<*const cred> {
            let v = unsafe { bpf_probe_read(&self.sk_peer_cred) }.ok()?;
            if v.is_null() {
                None
            } else {
                Some(v)
            }
        }
        pub fn skc_num(&self) -> Option<__u16> {
            unsafe { bpf_probe_read(&self.__sk_common.__bindgen_anon_3.__bindgen_anon_1.skc_num) }
                .ok()
        }
        pub fn sk_write_queue(&self) -> Option<sk_buff_head> {
            unsafe { bpf_probe_read(&self.sk_write_queue) }.ok()
        }
        pub fn sk_tskey(&self) -> Option<atomic_t> {
            unsafe { bpf_probe_read(&self.sk_tskey) }.ok()
        }
        pub fn sk_clockid(&self) -> Option<_cargo_bpf_u8> {
            unsafe { bpf_probe_read(&self.sk_clockid) }.ok()
        }
        pub fn sk_shutdown(&self) -> Option<_cargo_bpf_u8> {
            unsafe { bpf_probe_read(&self.sk_shutdown) }.ok()
        }
        pub fn sk_state_change(
            &self,
        ) -> Option<::core::option::Option<unsafe extern "C" fn(sk: *mut sock)>> {
            unsafe { bpf_probe_read(&self.sk_state_change) }.ok()
        }
        pub fn skc_v6_rcv_saddr(&self) -> Option<in6_addr> {
            unsafe { bpf_probe_read(&self.__sk_common.skc_v6_rcv_saddr) }.ok()
        }
        pub fn sk_rcu(&self) -> Option<callback_head> {
            unsafe { bpf_probe_read(&self.sk_rcu) }.ok()
        }
        pub fn sk_bind2_node(&self) -> Option<hlist_node> {
            unsafe { bpf_probe_read(&self.sk_bind2_node) }.ok()
        }
        pub fn sk_err(&self) -> Option<::cty::c_int> {
            unsafe { bpf_probe_read(&self.sk_err) }.ok()
        }
        pub fn sk_wq_raw(&self) -> Option<*mut socket_wq> {
            let v = unsafe { bpf_probe_read(&self.__bindgen_anon_1.sk_wq_raw) }.ok()?;
            if v.is_null() {
                None
            } else {
                Some(v)
            }
        }
        pub fn skc_family(&self) -> Option<::cty::c_ushort> {
            unsafe { bpf_probe_read(&self.__sk_common.skc_family) }.ok()
        }
        pub fn sk_sndbuf(&self) -> Option<::cty::c_int> {
            unsafe { bpf_probe_read(&self.sk_sndbuf) }.ok()
        }
        pub fn skc_rcv_saddr(&self) -> Option<__be32> {
            unsafe {
                bpf_probe_read(
                    &self
                        .__sk_common
                        .__bindgen_anon_1
                        .__bindgen_anon_1
                        .skc_rcv_saddr,
                )
            }
            .ok()
        }
        pub fn sk_max_pacing_rate(&self) -> Option<::cty::c_ulong> {
            unsafe { bpf_probe_read(&self.sk_max_pacing_rate) }.ok()
        }
        pub fn skc_hash(&self) -> Option<::cty::c_uint> {
            unsafe { bpf_probe_read(&self.__sk_common.__bindgen_anon_2.skc_hash) }.ok()
        }
        pub fn sk_zckey(&self) -> Option<atomic_t> {
            unsafe { bpf_probe_read(&self.sk_zckey) }.ok()
        }
        pub fn sk_reuseport_cb(&self) -> Option<*mut sock_reuseport> {
            let v = unsafe { bpf_probe_read(&self.sk_reuseport_cb) }.ok()?;
            if v.is_null() {
                None
            } else {
                Some(v)
            }
        }
        pub fn skc_listener(&self) -> Option<*mut sock> {
            let v =
                unsafe { bpf_probe_read(&self.__sk_common.__bindgen_anon_5.skc_listener) }.ok()?;
            if v.is_null() {
                None
            } else {
                Some(v)
            }
        }
        pub fn skc_incoming_cpu(&self) -> Option<::cty::c_int> {
            unsafe { bpf_probe_read(&self.__sk_common.__bindgen_anon_7.skc_incoming_cpu) }.ok()
        }
        pub fn skc_v6_daddr(&self) -> Option<in6_addr> {
            unsafe { bpf_probe_read(&self.__sk_common.skc_v6_daddr) }.ok()
        }
        pub fn sk_send_head(&self) -> Option<*mut sk_buff> {
            let v = unsafe { bpf_probe_read(&self.__bindgen_anon_2.sk_send_head) }.ok()?;
            if v.is_null() {
                None
            } else {
                Some(v)
            }
        }
        pub fn sk_forward_alloc(&self) -> Option<::cty::c_int> {
            unsafe { bpf_probe_read(&self.sk_forward_alloc) }.ok()
        }
        pub fn sk_pacing_shift(&self) -> Option<_cargo_bpf_u8> {
            unsafe { bpf_probe_read(&self.sk_pacing_shift) }.ok()
        }
        pub fn sk_rcvlowat(&self) -> Option<::cty::c_int> {
            unsafe { bpf_probe_read(&self.sk_rcvlowat) }.ok()
        }
        pub fn sk_rcvtimeo(&self) -> Option<::cty::c_long> {
            unsafe { bpf_probe_read(&self.sk_rcvtimeo) }.ok()
        }
        pub fn skc_tw_rcv_nxt(&self) -> Option<_cargo_bpf_u32> {
            unsafe { bpf_probe_read(&self.__sk_common.__bindgen_anon_7.skc_tw_rcv_nxt) }.ok()
        }
        pub fn sk_data_ready(
            &self,
        ) -> Option<::core::option::Option<unsafe extern "C" fn(sk: *mut sock)>> {
            unsafe { bpf_probe_read(&self.sk_data_ready) }.ok()
        }
        pub fn sk_napi_id(&self) -> Option<::cty::c_uint> {
            unsafe { bpf_probe_read(&self.sk_napi_id) }.ok()
        }
        pub fn skc_bind_node(&self) -> Option<hlist_node> {
            unsafe { bpf_probe_read(&self.__sk_common.__bindgen_anon_4.skc_bind_node) }.ok()
        }
        pub fn skc_flags(&self) -> Option<::cty::c_ulong> {
            unsafe { bpf_probe_read(&self.__sk_common.__bindgen_anon_5.skc_flags) }.ok()
        }
        pub fn skc_dontcopy_end(&self) -> Option<__IncompleteArrayField<::cty::c_int>> {
            unsafe { bpf_probe_read(&self.__sk_common.skc_dontcopy_end) }.ok()
        }
        pub fn sk_dst_pending_confirm(&self) -> Option<__u32> {
            unsafe { bpf_probe_read(&self.sk_dst_pending_confirm) }.ok()
        }
        pub fn sk_peer_lock(&self) -> Option<spinlock_t> {
            unsafe { bpf_probe_read(&self.sk_peer_lock) }.ok()
        }
        pub fn sk_stamp(&self) -> Option<ktime_t> {
            unsafe { bpf_probe_read(&self.sk_stamp) }.ok()
        }
        pub fn sk_omem_alloc(&self) -> Option<atomic_t> {
            unsafe { bpf_probe_read(&self.sk_omem_alloc) }.ok()
        }
        pub fn skc_rxhash(&self) -> Option<_cargo_bpf_u32> {
            unsafe { bpf_probe_read(&self.__sk_common.__bindgen_anon_8.skc_rxhash) }.ok()
        }
        pub fn skc_u16hashes(&self) -> Option<[__u16; 2usize]> {
            unsafe { bpf_probe_read(&self.__sk_common.__bindgen_anon_2.skc_u16hashes) }.ok()
        }
        pub fn sk_rx_dst(&self) -> Option<*mut dst_entry> {
            let v = unsafe { bpf_probe_read(&self.sk_rx_dst) }.ok()?;
            if v.is_null() {
                None
            } else {
                Some(v)
            }
        }
        pub fn sk_wmem_queued(&self) -> Option<::cty::c_int> {
            unsafe { bpf_probe_read(&self.sk_wmem_queued) }.ok()
        }
        pub fn sk_lingertime(&self) -> Option<::cty::c_ulong> {
            unsafe { bpf_probe_read(&self.sk_lingertime) }.ok()
        }
        pub fn sk_gso_max_size(&self) -> Option<::cty::c_uint> {
            unsafe { bpf_probe_read(&self.sk_gso_max_size) }.ok()
        }
        pub fn sk_use_task_frag(&self) -> Option<bool_> {
            unsafe { bpf_probe_read(&self.sk_use_task_frag) }.ok()
        }
        pub fn sk_peer_pid(&self) -> Option<*mut pid> {
            let v = unsafe { bpf_probe_read(&self.sk_peer_pid) }.ok()?;
            if v.is_null() {
                None
            } else {
                Some(v)
            }
        }
        pub fn sk_cgrp_data(&self) -> Option<sock_cgroup_data> {
            unsafe { bpf_probe_read(&self.sk_cgrp_data) }.ok()
        }
        pub fn sk_error_queue(&self) -> Option<sk_buff_head> {
            unsafe { bpf_probe_read(&self.sk_error_queue) }.ok()
        }
        pub fn sk_socket(&self) -> Option<*mut socket> {
            let v = unsafe { bpf_probe_read(&self.sk_socket) }.ok()?;
            if v.is_null() {
                None
            } else {
                Some(v)
            }
        }
        pub fn skc_rx_queue_mapping(&self) -> Option<::cty::c_ushort> {
            unsafe { bpf_probe_read(&self.__sk_common.skc_rx_queue_mapping) }.ok()
        }
        pub fn sk_error_report(
            &self,
        ) -> Option<::core::option::Option<unsafe extern "C" fn(sk: *mut sock)>> {
            unsafe { bpf_probe_read(&self.sk_error_report) }.ok()
        }
        pub fn sk_policy(&self) -> Option<[*mut xfrm_policy; 2usize]> {
            unsafe { bpf_probe_read(&self.sk_policy) }.ok()
        }
        pub fn sk_user_data(&self) -> Option<*mut ::cty::c_void> {
            let v = unsafe { bpf_probe_read(&self.sk_user_data) }.ok()?;
            if v.is_null() {
                None
            } else {
                Some(v)
            }
        }
        pub fn skc_daddr(&self) -> Option<__be32> {
            unsafe { bpf_probe_read(&self.__sk_common.__bindgen_anon_1.__bindgen_anon_1.skc_daddr) }
                .ok()
        }
        pub fn sk_reserved_mem(&self) -> Option<_cargo_bpf_u32> {
            unsafe { bpf_probe_read(&self.sk_reserved_mem) }.ok()
        }
        pub fn sk_bind_phc(&self) -> Option<::cty::c_int> {
            unsafe { bpf_probe_read(&self.sk_bind_phc) }.ok()
        }
        pub fn skc_dontcopy_begin(&self) -> Option<__IncompleteArrayField<::cty::c_int>> {
            unsafe { bpf_probe_read(&self.__sk_common.skc_dontcopy_begin) }.ok()
        }
        pub fn sk_gso_type(&self) -> Option<::cty::c_int> {
            unsafe { bpf_probe_read(&self.sk_gso_type) }.ok()
        }
        pub fn skc_portaddr_node(&self) -> Option<hlist_node> {
            unsafe { bpf_probe_read(&self.__sk_common.__bindgen_anon_4.skc_portaddr_node) }.ok()
        }
        pub fn sk_wq(&self) -> Option<*mut socket_wq> {
            let v = unsafe { bpf_probe_read(&self.__bindgen_anon_1.sk_wq) }.ok()?;
            if v.is_null() {
                None
            } else {
                Some(v)
            }
        }
        pub fn sk_sndtimeo(&self) -> Option<::cty::c_long> {
            unsafe { bpf_probe_read(&self.sk_sndtimeo) }.ok()
        }
        pub fn sk_write_space(
            &self,
        ) -> Option<::core::option::Option<unsafe extern "C" fn(sk: *mut sock)>> {
            unsafe { bpf_probe_read(&self.sk_write_space) }.ok()
        }
        pub fn skc_nulls_node(&self) -> Option<hlist_nulls_node> {
            unsafe { bpf_probe_read(&self.__sk_common.__bindgen_anon_6.skc_nulls_node) }.ok()
        }
        pub fn sk_rx_dst_ifindex(&self) -> Option<::cty::c_int> {
            unsafe { bpf_probe_read(&self.sk_rx_dst_ifindex) }.ok()
        }
        pub fn skc_addrpair(&self) -> Option<__addrpair> {
            unsafe { bpf_probe_read(&self.__sk_common.__bindgen_anon_1.skc_addrpair) }.ok()
        }
        pub fn sk_backlog_rcv(
            &self,
        ) -> Option<
            ::core::option::Option<
                unsafe extern "C" fn(sk: *mut sock, skb: *mut sk_buff) -> ::cty::c_int,
            >,
        > {
            unsafe { bpf_probe_read(&self.sk_backlog_rcv) }.ok()
        }
        pub fn skc_state(&self) -> Option<::cty::c_uchar> {
            unsafe { bpf_probe_read(&self.__sk_common.skc_state) }.ok()
        }
        pub fn skc_rcv_wnd(&self) -> Option<_cargo_bpf_u32> {
            unsafe { bpf_probe_read(&self.__sk_common.__bindgen_anon_7.skc_rcv_wnd) }.ok()
        }
        pub fn sk_timer(&self) -> Option<timer_list> {
            unsafe { bpf_probe_read(&self.sk_timer) }.ok()
        }
        pub fn sk_drops(&self) -> Option<atomic_t> {
            unsafe { bpf_probe_read(&self.sk_drops) }.ok()
        }
        pub fn sk_receive_queue(&self) -> Option<sk_buff_head> {
            unsafe { bpf_probe_read(&self.sk_receive_queue) }.ok()
        }
        pub fn sk_route_caps(&self) -> Option<netdev_features_t> {
            unsafe { bpf_probe_read(&self.sk_route_caps) }.ok()
        }
        pub fn sk_ack_backlog(&self) -> Option<_cargo_bpf_u32> {
            unsafe { bpf_probe_read(&self.sk_ack_backlog) }.ok()
        }
        pub fn skc_refcnt(&self) -> Option<refcount_t> {
            unsafe { bpf_probe_read(&self.__sk_common.skc_refcnt) }.ok()
        }
        pub fn ns_tracker(&self) -> Option<netns_tracker> {
            unsafe { bpf_probe_read(&self.ns_tracker) }.ok()
        }
        pub fn sk_ll_usec(&self) -> Option<::cty::c_uint> {
            unsafe { bpf_probe_read(&self.sk_ll_usec) }.ok()
        }
        pub fn sk_allocation(&self) -> Option<gfp_t> {
            unsafe { bpf_probe_read(&self.sk_allocation) }.ok()
        }
        pub fn sk_callback_lock(&self) -> Option<rwlock_t> {
            unsafe { bpf_probe_read(&self.sk_callback_lock) }.ok()
        }
        pub fn sk_validate_xmit_skb(
            &self,
        ) -> Option<
            ::core::option::Option<
                unsafe extern "C" fn(
                    sk: *mut sock,
                    dev: *mut net_device,
                    skb: *mut sk_buff,
                ) -> *mut sk_buff,
            >,
        > {
            unsafe { bpf_probe_read(&self.sk_validate_xmit_skb) }.ok()
        }
        pub fn skc_tw_snd_nxt(&self) -> Option<_cargo_bpf_u32> {
            unsafe { bpf_probe_read(&self.__sk_common.__bindgen_anon_8.skc_tw_snd_nxt) }.ok()
        }
    }
    #[doc = r" Auto-generated read-accessors by cargo_bpf::accessors::generate_read_accessors"]
    impl path {
        pub fn dentry(&self) -> Option<*mut dentry> {
            let v = unsafe { bpf_probe_read(&self.dentry) }.ok()?;
            if v.is_null() {
                None
            } else {
                Some(v)
            }
        }
        pub fn mnt(&self) -> Option<*mut vfsmount> {
            let v = unsafe { bpf_probe_read(&self.mnt) }.ok()?;
            if v.is_null() {
                None
            } else {
                Some(v)
            }
        }
    }
    #[doc = r" Auto-generated read-accessors by cargo_bpf::accessors::generate_read_accessors"]
    impl file {
        pub fn f_version(&self) -> Option<_cargo_bpf_u64> {
            unsafe { bpf_probe_read(&self.f_version) }.ok()
        }
        pub fn f_mode(&self) -> Option<fmode_t> {
            unsafe { bpf_probe_read(&self.f_mode) }.ok()
        }
        pub fn f_mapping(&self) -> Option<*mut address_space> {
            let v = unsafe { bpf_probe_read(&self.f_mapping) }.ok()?;
            if v.is_null() {
                None
            } else {
                Some(v)
            }
        }
        pub fn f_lock(&self) -> Option<spinlock_t> {
            unsafe { bpf_probe_read(&self.f_lock) }.ok()
        }
        pub fn f_op(&self) -> Option<*const file_operations> {
            let v = unsafe { bpf_probe_read(&self.f_op) }.ok()?;
            if v.is_null() {
                None
            } else {
                Some(v)
            }
        }
        pub fn f_sb_err(&self) -> Option<errseq_t> {
            unsafe { bpf_probe_read(&self.f_sb_err) }.ok()
        }
        pub fn f_ra(&self) -> Option<file_ra_state> {
            unsafe { bpf_probe_read(&self.f_ra) }.ok()
        }
        pub fn f_ep(&self) -> Option<*mut hlist_head> {
            let v = unsafe { bpf_probe_read(&self.f_ep) }.ok()?;
            if v.is_null() {
                None
            } else {
                Some(v)
            }
        }
        pub fn f_pos_lock(&self) -> Option<mutex> {
            unsafe { bpf_probe_read(&self.f_pos_lock) }.ok()
        }
        pub fn f_rcuhead(&self) -> Option<callback_head> {
            unsafe { bpf_probe_read(&self.__bindgen_anon_1.f_rcuhead) }.ok()
        }
        pub fn f_llist(&self) -> Option<llist_node> {
            unsafe { bpf_probe_read(&self.__bindgen_anon_1.f_llist) }.ok()
        }
        pub fn f_wb_err(&self) -> Option<errseq_t> {
            unsafe { bpf_probe_read(&self.f_wb_err) }.ok()
        }
        pub fn f_path(&self) -> Option<path> {
            unsafe { bpf_probe_read(&self.f_path) }.ok()
        }
        pub fn f_flags(&self) -> Option<::cty::c_uint> {
            unsafe { bpf_probe_read(&self.f_flags) }.ok()
        }
        pub fn f_cred(&self) -> Option<*const cred> {
            let v = unsafe { bpf_probe_read(&self.f_cred) }.ok()?;
            if v.is_null() {
                None
            } else {
                Some(v)
            }
        }
        pub fn f_inode(&self) -> Option<*mut inode> {
            let v = unsafe { bpf_probe_read(&self.f_inode) }.ok()?;
            if v.is_null() {
                None
            } else {
                Some(v)
            }
        }
        pub fn f_security(&self) -> Option<*mut ::cty::c_void> {
            let v = unsafe { bpf_probe_read(&self.f_security) }.ok()?;
            if v.is_null() {
                None
            } else {
                Some(v)
            }
        }
        pub fn f_owner(&self) -> Option<fown_struct> {
            unsafe { bpf_probe_read(&self.f_owner) }.ok()
        }
        pub fn f_iocb_flags(&self) -> Option<::cty::c_uint> {
            unsafe { bpf_probe_read(&self.__bindgen_anon_1.f_iocb_flags) }.ok()
        }
        pub fn f_pos(&self) -> Option<loff_t> {
            unsafe { bpf_probe_read(&self.f_pos) }.ok()
        }
        pub fn f_count(&self) -> Option<atomic_long_t> {
            unsafe { bpf_probe_read(&self.f_count) }.ok()
        }
        pub fn private_data(&self) -> Option<*mut ::cty::c_void> {
            let v = unsafe { bpf_probe_read(&self.private_data) }.ok()?;
            if v.is_null() {
                None
            } else {
                Some(v)
            }
        }
    }
    #[doc = r" Auto-generated read-accessors by cargo_bpf::accessors::generate_read_accessors"]
    impl sockaddr_in {
        pub fn sin_family(&self) -> Option<__kernel_sa_family_t> {
            unsafe { bpf_probe_read(&self.sin_family) }.ok()
        }
        pub fn sin_port(&self) -> Option<__be16> {
            unsafe { bpf_probe_read(&self.sin_port) }.ok()
        }
        pub fn __pad(&self) -> Option<[::cty::c_uchar; 8usize]> {
            unsafe { bpf_probe_read(&self.__pad) }.ok()
        }
        pub fn sin_addr(&self) -> Option<in_addr> {
            unsafe { bpf_probe_read(&self.sin_addr) }.ok()
        }
    }
    #[doc = r" Auto-generated read-accessors by cargo_bpf::accessors::generate_read_accessors"]
    impl qstr {
        pub fn hash_len(&self) -> Option<_cargo_bpf_u64> {
            unsafe { bpf_probe_read(&self.__bindgen_anon_1.hash_len) }.ok()
        }
        pub fn len(&self) -> Option<_cargo_bpf_u32> {
            unsafe { bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.len) }.ok()
        }
        pub fn hash(&self) -> Option<_cargo_bpf_u32> {
            unsafe { bpf_probe_read(&self.__bindgen_anon_1.__bindgen_anon_1.hash) }.ok()
        }
        pub fn name(&self) -> Option<*const ::cty::c_uchar> {
            let v = unsafe { bpf_probe_read(&self.name) }.ok()?;
            if v.is_null() {
                None
            } else {
                Some(v)
            }
        }
    }
    #[doc = r" Auto-generated read-accessors by cargo_bpf::accessors::generate_read_accessors"]
    impl in_addr {
        pub fn s_addr(&self) -> Option<__be32> {
            unsafe { bpf_probe_read(&self.s_addr) }.ok()
        }
    }
    #[doc = r" Auto-generated read-accessors by cargo_bpf::accessors::generate_read_accessors"]
    impl dentry {
        pub fn d_hash(&self) -> Option<hlist_bl_node> {
            unsafe { bpf_probe_read(&self.d_hash) }.ok()
        }
        pub fn d_name(&self) -> Option<qstr> {
            unsafe { bpf_probe_read(&self.d_name) }.ok()
        }
        pub fn d_lockref(&self) -> Option<lockref> {
            unsafe { bpf_probe_read(&self.d_lockref) }.ok()
        }
        pub fn d_child(&self) -> Option<list_head> {
            unsafe { bpf_probe_read(&self.d_child) }.ok()
        }
        pub fn d_inode(&self) -> Option<*mut inode> {
            let v = unsafe { bpf_probe_read(&self.d_inode) }.ok()?;
            if v.is_null() {
                None
            } else {
                Some(v)
            }
        }
        pub fn d_flags(&self) -> Option<::cty::c_uint> {
            unsafe { bpf_probe_read(&self.d_flags) }.ok()
        }
        pub fn d_fsdata(&self) -> Option<*mut ::cty::c_void> {
            let v = unsafe { bpf_probe_read(&self.d_fsdata) }.ok()?;
            if v.is_null() {
                None
            } else {
                Some(v)
            }
        }
        pub fn d_u(&self) -> Option<dentry__bindgen_ty_2> {
            unsafe { bpf_probe_read(&self.d_u) }.ok()
        }
        pub fn d_parent(&self) -> Option<*mut dentry> {
            let v = unsafe { bpf_probe_read(&self.d_parent) }.ok()?;
            if v.is_null() {
                None
            } else {
                Some(v)
            }
        }
        pub fn d_op(&self) -> Option<*const dentry_operations> {
            let v = unsafe { bpf_probe_read(&self.d_op) }.ok()?;
            if v.is_null() {
                None
            } else {
                Some(v)
            }
        }
        pub fn d_subdirs(&self) -> Option<list_head> {
            unsafe { bpf_probe_read(&self.d_subdirs) }.ok()
        }
        pub fn d_sb(&self) -> Option<*mut super_block> {
            let v = unsafe { bpf_probe_read(&self.d_sb) }.ok()?;
            if v.is_null() {
                None
            } else {
                Some(v)
            }
        }
        pub fn d_seq(&self) -> Option<seqcount_spinlock_t> {
            unsafe { bpf_probe_read(&self.d_seq) }.ok()
        }
        pub fn d_iname(&self) -> Option<[::cty::c_uchar; 32usize]> {
            unsafe { bpf_probe_read(&self.d_iname) }.ok()
        }
        pub fn d_wait(&self) -> Option<*mut wait_queue_head_t> {
            let v = unsafe { bpf_probe_read(&self.__bindgen_anon_1.d_wait) }.ok()?;
            if v.is_null() {
                None
            } else {
                Some(v)
            }
        }
        pub fn d_time(&self) -> Option<::cty::c_ulong> {
            unsafe { bpf_probe_read(&self.d_time) }.ok()
        }
        pub fn d_lru(&self) -> Option<list_head> {
            unsafe { bpf_probe_read(&self.__bindgen_anon_1.d_lru) }.ok()
        }
    }
}
pub use gen_bindings::*;
